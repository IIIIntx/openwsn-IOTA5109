diff --git a/1102.diff b/1102.diff
new file mode 100644
index 00000000..526e71ba
--- /dev/null
+++ b/1102.diff
@@ -0,0 +1,58296 @@
+diff --git a/bsp/boards/nrf52840_dk/uart.c b/bsp/boards/nrf52840_dk/uart.c
+index a80a3f20..3e63bece 100644
+--- a/bsp/boards/nrf52840_dk/uart.c
++++ b/bsp/boards/nrf52840_dk/uart.c
+@@ -12,7 +12,7 @@
+ #include "leds.h"
+ #include "debugpins.h"
+ #include "uart.h"
+-
++#include "stdio.h"
+ //=========================== defines =========================================
+ 
+ #define UART_RX_PIN       NRF_GPIO_PIN_MAP(0,8) // p0.08
+@@ -130,6 +130,20 @@ uint8_t uart_readByte(void) {
+     return NRF_UART0->RXD;
+ }
+ 
++void uart_writeFloatByte(float dataToWrite){
++    
++    char buffer[50];  // make sure the buffer is large enough!
++
++    int length = sprintf(buffer, "%f", dataToWrite);  // convert float to string and get length
++
++    // Now, send the string over UART
++    for(int i=0; i<length; i++)
++    {
++        uart_writeByte(buffer[i]);  // assuming UART_send() is your function to send a byte over UART
++    }
++
++}
++
+ //=========================== private =========================================
+ 
+ void UARTE0_UART0_IRQHandler(void) {
+diff --git a/bsp/boards/uart.h b/bsp/boards/uart.h
+index 745c42d6..a4d60eb9 100644
+--- a/bsp/boards/uart.h
++++ b/bsp/boards/uart.h
+@@ -47,6 +47,7 @@ void    uart_clearRxInterrupts(void);
+ void    uart_clearTxInterrupts(void);
+ void    uart_setCTS(bool state);
+ void    uart_writeByte(uint8_t byteToWrite);
++void    uart_writeFloatByte(float dataToWrite);
+ #if BOARD_FASTSIM_ENABLED
+ void    uart_writeCircularBuffer_FASTSIM(uint8_t* buffer, uint16_t* outputBufIdxR, uint16_t* outputBufIdxW);
+ #endif
+diff --git a/bsp/chips/bmx388/bmx388.c b/bsp/chips/bmx388/bmx388.c
+new file mode 100644
+index 00000000..e47fc9a3
+--- /dev/null
++++ b/bsp/chips/bmx388/bmx388.c
+@@ -0,0 +1,242 @@
++/**
++\brief bmx160 driver.
++
++\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
++*/
++
++#include "i2c.h"
++#include "bmx388.h"
++#include "math.h"
++
++//=========================== define ==========================================
++
++typedef struct{
++
++    //int16_t mag_x;
++    //int16_t mag_y;
++    //int16_t mag_z;
++
++    //int16_t rhall;
++
++    //int16_t gyr_x;
++    //int16_t gyr_y;
++    //int16_t gyr_z;
++
++    //int16_t acc_x;
++    //int16_t acc_y;
++    //int16_t acc_z;
++
++    uint8_t pres[3];
++    uint8_t temp[3];
++    
++}bmx388x_data_t;
++
++ //typedef struct bmp388_handle_s
++ //{                                                                  
++ //    uint16_t t1;                                                                        
++ //    uint16_t t2;                                                                        
++ //    int8_t t3;                                                                          
++ //    int16_t p1;                                                                         
++ //    int16_t p2;                                                                         
++ //    int8_t p3;                                                                          
++ //    int8_t p4;                                                                          
++ //    uint16_t p5;                                                                        
++ //    uint16_t p6;                                                                        
++ //    int8_t p7;                                                                          
++ //    int8_t p8;                                                                          
++ //    int16_t p9;                                                                         
++ //    int8_t p10;                                                                         
++ //    int8_t p11;                                                                         
++ //    int64_t t_fine;                                                                     
++ //} bmp388x_compensation_t;
++
++typedef struct {
++    
++    bmx388x_data_t bmx388x_data;
++        uint32_t fullpres;
++        uint32_t fulltemp;
++        uint32_t sen_time;
++        uint8_t res[21];
++        double  PAR_T[3];//3个温度修正系数
++	double  PAR_P[11];//11个气压修正系数
++        float   t_fine;
++
++}bmx388x_var_t;
++
++//=========================== variables =======================================
++
++bmx388x_var_t bmx388x_var;
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++// admin
++uint8_t bmx388_who_am_i(void) {
++
++    uint8_t chipid;
++    i2c_read_bytes(BMX160_REG_ADDR_CHIPID, &chipid, 1);
++    return chipid;
++}
++
++//void bmx160_config_wakeup(void) {
++    
++//}
++
++uint8_t bmx160_power_on(void) {
++    uint8_t pwr_cmd;
++    pwr_cmd = BMX160_CMD_PWR_CTRL;
++    i2c_write_bytes(BMX160_REG_ADDR_PWR_CTRL, &pwr_cmd,1);
++}
++
++uint8_t bmx160_get_pmu_status(void) {
++
++    uint8_t pmu_status;
++    i2c_read_bytes(BMX160_REG_ADDR_PMU_STATUS, &pmu_status, 1);
++    return pmu_status;
++}
++
++uint8_t bmx160_get_pwr_status(void) {
++
++    uint8_t pwr_status;
++    i2c_read_bytes(BMX160_REG_ADDR_PWR_CTRL, &pwr_status, 1);
++    return pwr_status;
++}
++
++
++void bmx160_set_cmd(uint8_t cmd) {
++    i2c_write_bytes(BMX160_REG_ADDR_PWR_CTRL, &cmd, 1);
++}
++
++//// configuration
++
++//void    bmx160_acc_config(uint8_t config) {
++//    i2c_write_bytes(BMX160_REG_ADDR_ACC_CONF, &config, 1);
++//}
++
++//void    bmx160_gyr_config(uint8_t config) {
++//    i2c_write_bytes(BMX160_REG_ADDR_GYR_CONF, &config, 1);
++//}
++
++//void    bmx160_mag_config(uint8_t config) {
++//    i2c_write_bytes(BMX160_REG_ADDR_MAG_CONF, &config, 1);
++//}
++
++//// range & interface
++
++//void    bmx160_acc_range(uint8_t range) {
++//    i2c_write_bytes(BMX160_REG_ADDR_ACC_RANGE, &range, 1);
++//}
++
++//void    bmx160_gyr_range(uint8_t range) {
++//    i2c_write_bytes(BMX160_REG_ADDR_GYR_RANGE, &range, 1);
++//}
++
++//void    bmx160_mag_if(uint8_t interface) {
++//    i2c_write_bytes(BMX160_REG_ADDR_MAG_IF, &interface, 1);
++//}
++
++
++// read
++void bmx160_read_9dof_data(void) {
++    i2c_read_bytes(BMX160_REG_ADDR_DATA, (uint8_t*)(&bmx388x_var.bmx388x_data), sizeof(bmx388x_data_t));
++    //i2c_read_bytes(BMX160_REG_ADDR_DATA, (uint8_t*)(&bmx388x_var.bmx388x_data), 1);
++    bmx388x_var.fulltemp = (bmx388x_var.bmx388x_data.temp[2] << 16) | (bmx388x_var.bmx388x_data.temp[1] << 8) | bmx388x_var.bmx388x_data.temp[0];
++    bmx388x_var.fullpres = (bmx388x_var.bmx388x_data.pres[2] << 16) | (bmx388x_var.bmx388x_data.pres[1] << 8) | bmx388x_var.bmx388x_data.pres[0];
++}
++
++float bmx388_read_t_fine(void){
++    
++    return bmx388x_var.t_fine;
++}
++
++
++//int16_t bmx160_read_acc_x(void) {
++
++//    return bmx160x_var.bmx160x_data.acc_x;
++//}
++//int16_t bmx160_read_acc_y(void) {
++    
++//    return bmx160x_var.bmx160x_data.acc_y;
++//}
++//int16_t bmx160_read_acc_z(void) {
++    
++//    return bmx160x_var.bmx160x_data.acc_z;
++//}
++
++//int16_t bmx160_read_mag_x(void) {
++    
++//    return bmx160x_var.bmx160x_data.mag_x;
++//}
++//int16_t bmx160_read_mag_y(void) {
++    
++//    return bmx160x_var.bmx160x_data.mag_y;
++//}
++//int16_t bmx160_read_mag_z(void) {
++    
++//    return bmx160x_var.bmx160x_data.mag_z;
++//}
++
++//int16_t bmx160_read_gyr_x(void) {
++    
++//    return bmx160x_var.bmx160x_data.gyr_x;
++//}
++//int16_t bmx160_read_gyr_y(void) {
++    
++//    return bmx160x_var.bmx160x_data.gyr_y;
++//}
++//int16_t bmx160_read_gyr_z(void) {
++    
++//    return bmx160x_var.bmx160x_data.gyr_z;
++//}
++
++ uint8_t bmp388_get_sensortime(void)
++ {
++     
++     i2c_read_bytes(BMX160_REG_ADDR_SENSORTIME, (uint8_t*)(&bmx388x_var.sen_time), sizeof(bmx388x_var.sen_time));
++
++     return 0;                                                                              /* success return 0 */
++ }
++ void bmp388_get_compensation(void)
++ {
++     i2c_read_bytes(BMX160_REG_ADDR_COMP,(uint8_t*)(&bmx388x_var.res[0]),sizeof(bmx388x_var.res));
++     bmx388x_var.PAR_T[0]=((bmx388x_var.res[1]<<8)|bmx388x_var.res[0])/pow(2,-8);
++     bmx388x_var.PAR_T[1]=((bmx388x_var.res[3]<<8)|bmx388x_var.res[2])/pow(2,30);
++     bmx388x_var.PAR_T[2]=(int8_t)bmx388x_var.res[4]/pow(2,48);//计算3个温度修正系数
++
++     bmx388x_var.PAR_P[0]=(((int16_t)((bmx388x_var.res[6]<<8)|bmx388x_var.res[5]))-pow(2,14))/pow(2,20);
++     bmx388x_var.PAR_P[1]=(((int16_t)((bmx388x_var.res[8]<<8)|bmx388x_var.res[7]))-pow(2,14))/pow(2,29);
++     bmx388x_var.PAR_P[2]=(int8_t)bmx388x_var.res[9]/pow(2,32);
++     bmx388x_var.PAR_P[3]=(int8_t)bmx388x_var.res[10]/pow(2,37);
++     bmx388x_var.PAR_P[4]=((bmx388x_var.res[12]<<8)|bmx388x_var.res[11])/pow(2,-3);
++     bmx388x_var.PAR_P[5]=((bmx388x_var.res[14]<<8)|bmx388x_var.res[13])/pow(2,6);
++     bmx388x_var.PAR_P[6]=(int8_t)bmx388x_var.res[15]/pow(2,8);
++     bmx388x_var.PAR_P[7]=(int8_t)bmx388x_var.res[16]/pow(2,15);
++     bmx388x_var.PAR_P[8]=(int16_t)((bmx388x_var.res[18]<<8)|bmx388x_var.res[17])/pow(2,48);
++     bmx388x_var.PAR_P[9]=(int8_t)bmx388x_var.res[19]/pow(2,48);
++     bmx388x_var.PAR_P[10]=(int8_t)bmx388x_var.res[20]/pow(2,65);//计算11个温度修正系数
++}
++
++void bmp388_compensation_temp(void)
++{
++    float partial_data1;
++    float partial_data2;
++
++    partial_data1 = (float)(bmx388x_var.fulltemp-bmx388x_var.PAR_T[0]);
++    partial_data2 = (float)(partial_data1*bmx388x_var.PAR_T[1]);
++
++    bmx388x_var.t_fine = partial_data2+(partial_data1*partial_data1)*bmx388x_var.PAR_T[2];
++
++}
++
++////=========================== helper ==========================================
++
++//float bmx160_from_lsb_to_celsius(int16_t lsb) {
++
++//}
++
++//float bmx160_from_fs8_lp1_to_mg(int16_t lsb) {
++
++//}
++
++////=========================== private =========================================
+\ No newline at end of file
+diff --git a/bsp/chips/bmx388/bmx388.h b/bsp/chips/bmx388/bmx388.h
+new file mode 100644
+index 00000000..e3a55bda
+--- /dev/null
++++ b/bsp/chips/bmx388/bmx388.h
+@@ -0,0 +1,96 @@
++/**
++\brief registers address mapping of bmx160 sensor.
++
++\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
++*/
++
++#include "stdint.h"
++
++//=========================== define ==========================================
++
++#define BMX388_ADDR 0x76
++
++//---- register addresses
++
++#define BMX160_REG_ADDR_CHIPID      0x00
++#define BMX160_REG_ADDR_ERR_REG     0x02
++#define BMX160_REG_ADDR_PMU_STATUS  0x03
++
++// sensor data
++
++#define BMX160_REG_ADDR_DATA        0x04
++#define BMX160_REG_ADDR_PRESURE     0x04
++#define BMX160_REG_ADDR_TEMPATURE   0x07
++#define BMX160_REG_ADDR_SENSORTIME  0x0C
++#define BMX160_REG_ADDR_EVENT       0x10
++#define BMX160_REG_ADDR_INT_STATUS  0x11
++#define BMX160_REG_ADDR_FIFO_LENGTH 0x12
++#define BMX160_REG_ADDR_FIFO_DATA   0x14
++#define BMX160_REG_ADDR_FIFO_WTM    0x15
++#define BMX160_REG_ADDR_FIFO_CONFIG1 0x17
++#define BMX160_REG_ADDR_FIFO_CONFIG2 0x18
++#define BMX160_REG_ADDR_INT_CTRL    0x19
++#define BMX160_REG_ADDR_INT_CONF    0x1A
++#define BMX160_REG_ADDR_PWR_CTRL    0x1B
++#define BMX160_REG_ADDR_OSR         0x1C
++#define BMX160_REG_ADDR_ODR         0x1D
++#define BMX160_REG_ADDR_COMP        0x31
++
++//---- register values
++
++//#define BMX160_CMD_PMU_ACC_SUSPEND        0x10
++//#define BMX160_CMD_PMU_ACC_NORMAL         0x11
++//#define BMX160_CMD_PMU_ACC_LOW_POWER      0x12
++
++//#define BMX160_CMD_PMU_GYR_SUSPEND        0x14
++//#define BMX160_CMD_PMU_GYR_NORMAL         0x15
++//#define BMX160_CMD_PMU_GYR_FSU            0x17
++
++//#define BMX160_CMD_PMU_MAG_IF_SUSPEND     0x18
++//#define BMX160_CMD_PMU_MAG_IF_NORMAL      0x19
++//#define BMX160_CMD_PMU_MAG_IF_LOW_POWER   0x1A
++#define BMX160_CMD_PWR_CTRL 0x33
++
++//=========================== variables =======================================
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++// admin
++uint8_t bmx388_who_am_i(void);
++uint8_t bmx160_power_on(void);
++uint8_t bmx160_get_pmu_status(void);
++uint8_t bmx160_get_pwr_status(void);
++uint8_t bmp388_get_sensortime(void);
++
++void    bmx160_set_cmd(uint8_t cmd);
++void    bmx160_acc_config(uint8_t config);
++void    bmx160_gyr_config(uint8_t config);
++void    bmx160_mag_config(uint8_t config);
++
++void    bmx160_acc_range(uint8_t range);
++void    bmx160_gyr_range(uint8_t range);
++void    bmx160_mag_if(uint8_t interface);
++
++// read
++int16_t bmx160_read_temperature(void);
++
++int16_t bmx160_read_acc_x(void);
++int16_t bmx160_read_acc_y(void);
++int16_t bmx160_read_acc_z(void);
++
++int16_t bmx160_read_mag_x(void);
++int16_t bmx160_read_mag_y(void);
++int16_t bmx160_read_mag_z(void);
++
++int16_t bmx160_read_gyr_x(void);
++int16_t bmx160_read_gyr_y(void);
++int16_t bmx160_read_gyr_z(void);
++
++void    bmx160_read_9dof_data(void);
++void    bmp388_get_compensation(void);
++
++void bmp388_compensation_temp(void);
++
++//=========================== private =========================================
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/01bsp_bmx160/01bsp_bmx160.c b/projects/common/01bsp_bmx160/01bsp_bmx160.c
+similarity index 95%
+rename from projects/nrf52840_dk/01bsp_bmx160/01bsp_bmx160.c
+rename to projects/common/01bsp_bmx160/01bsp_bmx160.c
+index 8dcc89be..2b38533a 100644
+--- a/projects/nrf52840_dk/01bsp_bmx160/01bsp_bmx160.c
++++ b/projects/common/01bsp_bmx160/01bsp_bmx160.c
+@@ -1,177 +1,177 @@
+-/**
+-\brief This program shows the use of the "bmx160" bsp module.
+-
+-Since the bsp modules for different platforms have the same declaration, you
+-can use this project with any platform.
+-
+-This project configure bmx160 and read the gyroscope values in 3 axises.
+-Then it sends out the gyro data through uart at interval of SAMPLE_PERIOD.
+-
+-\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
+-*/
+-
+-#include "stdio.h"
+-#include "stdint.h"
+-#include "string.h"
+-#include "board.h"
+-#include "leds.h"
+-#include "sctimer.h"
+-#include "i2c.h"
+-#include "uart.h"
+-#include "bmx160.h"
+-
+-//=========================== defines =========================================
+-
+-#define SAMPLE_PERIOD   (32768>>4)  // @32kHz = 1s
+-#define BUFFER_SIZE     0x08   //2B*3 axises value + 2B ending with '\r\n'
+-
+-//=========================== variables =======================================
+-
+-typedef struct {
+-   uint16_t num_compare;
+-   bool sampling_now;
+-   uint8_t axes[6];
+-   float axis_x;
+-   float axis_y;
+-   float axis_z;
+-
+-   uint8_t who_am_i;
+-   int16_t temp;
+-   float   temp_f;
+-
+-   // uart specific
+-              uint8_t uart_lastTxByteIndex;
+-   volatile   uint8_t uartDone;
+-   volatile   uint8_t uartSendNow;
+-   volatile   uint8_t uartToSend[BUFFER_SIZE];
+-} app_vars_t;
+-
+-app_vars_t app_vars;
+-
+-//=========================== prototypes ======================================
+-
+-void cb_compare(void);
+-void cb_uartTxDone(void);
+-uint8_t cb_uartRxCb(void);
+-
+-//=========================== main ============================================
+-
+-/**
+-\brief The program starts executing here.
+-*/
+-int mote_main(void) {
+-
+-    int16_t tmp;
+-    uint8_t i;
+-
+-    // initialize board. 
+-    board_init();
+-
+-    // setup UART
+-    uart_setCallbacks(cb_uartTxDone,cb_uartRxCb);
+-    uart_enableInterrupts();
+-   
+-    sctimer_set_callback(cb_compare);
+-    sctimer_setCompare(sctimer_readCounter()+SAMPLE_PERIOD);
+-         
+-    // alway set address first
+-    i2c_set_addr(BMX160_ADDR);
+-
+-    // should be 0xd8 for bmx160
+-    app_vars.who_am_i = bmx160_who_am_i();    
+-  
+-    // configure bmx160
+-
+-    // 0x8: 100Hz
+-    // 0xb: 800Hz
+-    // 0xc: 1600Hz
+-    bmx160_acc_config(0x0c); 
+-    // 0x8: 100Hz
+-    // 0xc: 1600Hz
+-    // 0xd: 3200Hz
+-    bmx160_gyr_config(0x0d);
+-    // 0x8: 100Hz
+-    // 0xb: 800Hz
+-    bmx160_mag_config(0x0b);
+-
+-    // 0x3: +/-2g 
+-    // 0x5: +/-4g
+-    // 0x8: +/-8g 
+-    // 0xc: +/-16g
+-    bmx160_acc_range(0x8);
+-    // 0x0: +/-2000°/s = 16.4LSB/°/s
+-    // 0x1: +/-1000°/s = 32.8LSB/°/s
+-    // 0x2: +/-500°/s  = 131.2LSB/°/s
+-    // 0x3: +/-250°/s  = 262.4LSB/°/s
+-    bmx160_gyr_range(0x1);
+-    // ToDo
+-    //bmx160_mag_if();
+-
+-    while (1) {
+-
+-        // wait for timer to elapse
+-        while (app_vars.uartSendNow==0);
+-        app_vars.uartSendNow = 0;
+-        bmx160_set_cmd(BMX160_CMD_PMU_GYR_NORMAL);
+-        bmx160_read_9dof_data();
+-
+-        i=0;
+-        tmp = bmx160_read_gyr_x();
+-        app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
+-        app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
+-        
+-        tmp = bmx160_read_gyr_y();
+-        app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
+-        app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
+-
+-        tmp = bmx160_read_gyr_z();
+-        app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
+-        app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
+-
+-        app_vars.uartToSend[i++] = '\r';
+-        app_vars.uartToSend[i++] = '\n';
+-
+-        // send string over UART
+-        app_vars.uartDone              = 0;
+-        app_vars.uart_lastTxByteIndex  = 0;
+-        uart_writeByte(app_vars.uartToSend[app_vars.uart_lastTxByteIndex]);
+-        while(app_vars.uartDone==0);
+-    }
+-}
+-
+-//=========================== callbacks =======================================
+-
+-void cb_compare(void) {
+-   
+-    // have main "task" send over UART
+-    app_vars.uartSendNow = 1;
+-
+-    // schedule again
+-    sctimer_setCompare(sctimer_readCounter()+SAMPLE_PERIOD);
+-}
+-
+-void cb_uartTxDone(void) {
+-
+-    app_vars.uart_lastTxByteIndex++;
+-    if (app_vars.uart_lastTxByteIndex<sizeof(app_vars.uartToSend)) {
+-        uart_writeByte(app_vars.uartToSend[app_vars.uart_lastTxByteIndex]);
+-    } else {
+-        app_vars.uartDone = 1;
+-    }
+-}
+-
+-uint8_t cb_uartRxCb(void) {
+-   
+-   uint8_t byte;
+-   
+-   // toggle LED
+-   leds_error_toggle();
+-   
+-   // read received byte
+-   byte = uart_readByte();
+-   
+-   // echo that byte over serial
+-   uart_writeByte(byte);
+-   
+-   return 0;
++/**
++\brief This program shows the use of the "bmx160" bsp module.
++
++Since the bsp modules for different platforms have the same declaration, you
++can use this project with any platform.
++
++This project configure bmx160 and read the gyroscope values in 3 axises.
++Then it sends out the gyro data through uart at interval of SAMPLE_PERIOD.
++
++\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
++*/
++
++#include "stdio.h"
++#include "stdint.h"
++#include "string.h"
++#include "board.h"
++#include "leds.h"
++#include "sctimer.h"
++#include "i2c.h"
++#include "uart.h"
++#include "bmx160.h"
++
++//=========================== defines =========================================
++
++#define SAMPLE_PERIOD   (32768>>6)  // @32kHz = 1s
++#define BUFFER_SIZE     0x08   //2B*3 axises value + 2B ending with '\r\n'
++
++//=========================== variables =======================================
++
++typedef struct {
++   uint16_t num_compare;
++   bool sampling_now;
++   uint8_t axes[6];
++   float axis_x;
++   float axis_y;
++   float axis_z;
++
++   uint8_t who_am_i;
++   int16_t temp;
++   float   temp_f;
++
++   // uart specific
++              uint8_t uart_lastTxByteIndex;
++   volatile   uint8_t uartDone;
++   volatile   uint8_t uartSendNow;
++   volatile   uint8_t uartToSend[BUFFER_SIZE];
++} app_vars_t;
++
++app_vars_t app_vars;
++
++//=========================== prototypes ======================================
++
++void cb_compare(void);
++void cb_uartTxDone(void);
++uint8_t cb_uartRxCb(void);
++
++//=========================== main ============================================
++
++/**
++\brief The program starts executing here.
++*/
++int mote_main(void) {
++
++    int16_t tmp;
++    uint8_t i;
++
++    // initialize board. 
++    board_init();
++
++    // setup UART
++    uart_setCallbacks(cb_uartTxDone,cb_uartRxCb);
++    uart_enableInterrupts();
++   
++    sctimer_set_callback(cb_compare);
++    sctimer_setCompare(sctimer_readCounter()+SAMPLE_PERIOD);
++         
++    // alway set address first
++    i2c_set_addr(BMX160_ADDR);
++
++    // should be 0xd8 for bmx160
++    app_vars.who_am_i = bmx160_who_am_i();    
++  
++    // configure bmx160
++
++    // 0x8: 100Hz
++    // 0xb: 800Hz
++    // 0xc: 1600Hz
++    bmx160_acc_config(0x0c); 
++    // 0x8: 100Hz
++    // 0xc: 1600Hz
++    // 0xd: 3200Hz
++    bmx160_gyr_config(0x0d);
++    // 0x8: 100Hz
++    // 0xb: 800Hz
++    bmx160_mag_config(0x0b);
++
++    // 0x3: +/-2g 
++    // 0x5: +/-4g
++    // 0x8: +/-8g 
++    // 0xc: +/-16g
++    bmx160_acc_range(0x8);
++    // 0x0: +/-2000°/s = 16.4LSB/°/s
++    // 0x1: +/-1000°/s = 32.8LSB/°/s
++    // 0x2: +/-500°/s  = 131.2LSB/°/s
++    // 0x3: +/-250°/s  = 262.4LSB/°/s
++    bmx160_gyr_range(0x1);
++    // ToDo
++    //bmx160_mag_if();
++
++    while (1) {
++
++        // wait for timer to elapse
++        while (app_vars.uartSendNow==0);
++        app_vars.uartSendNow = 0;
++        bmx160_set_cmd(BMX160_CMD_PMU_GYR_NORMAL);
++        bmx160_read_9dof_data();
++
++        i=0;
++        tmp = bmx160_read_gyr_x();
++        app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
++        app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
++        
++        tmp = bmx160_read_gyr_y();
++        app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
++        app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
++
++        tmp = bmx160_read_gyr_z();
++        app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
++        app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
++
++        app_vars.uartToSend[i++] = '\r';
++        app_vars.uartToSend[i++] = '\n';
++
++        // send string over UART
++        app_vars.uartDone              = 0;
++        app_vars.uart_lastTxByteIndex  = 0;
++        uart_writeByte(app_vars.uartToSend[app_vars.uart_lastTxByteIndex]);
++        while(app_vars.uartDone==0);
++    }
++}
++
++//=========================== callbacks =======================================
++
++void cb_compare(void) {
++   
++    // have main "task" send over UART
++    app_vars.uartSendNow = 1;
++
++    // schedule again
++    sctimer_setCompare(sctimer_readCounter()+SAMPLE_PERIOD);
++}
++
++void cb_uartTxDone(void) {
++
++    app_vars.uart_lastTxByteIndex++;
++    if (app_vars.uart_lastTxByteIndex<sizeof(app_vars.uartToSend)) {
++        uart_writeByte(app_vars.uartToSend[app_vars.uart_lastTxByteIndex]);
++    } else {
++        app_vars.uartDone = 1;
++    }
++}
++
++uint8_t cb_uartRxCb(void) {
++   
++   uint8_t byte;
++   
++   // toggle LED
++   leds_error_toggle();
++   
++   // read received byte
++   byte = uart_readByte();
++   
++   // echo that byte over serial
++   uart_writeByte(byte);
++   
++   return 0;
+ }
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/01bsp_bmx160/01bsp_bmx160.py b/projects/common/01bsp_bmx160/01bsp_bmx160.py
+similarity index 96%
+rename from projects/nrf52840_dk/01bsp_bmx160/01bsp_bmx160.py
+rename to projects/common/01bsp_bmx160/01bsp_bmx160.py
+index 14d92bb7..90c43b6e 100644
+--- a/projects/nrf52840_dk/01bsp_bmx160/01bsp_bmx160.py
++++ b/projects/common/01bsp_bmx160/01bsp_bmx160.py
+@@ -1,118 +1,118 @@
+-import pygame
+-import serial
+-import struct
+-from pygame.locals import *
+-from OpenGL.GL import *
+-from OpenGL.GLU import *
+-
+-long  = 1
+-width = 0.8
+-hight = 0.2
+-
+-# Cube vertices and faces
+-vertices = [
+-    [long, -width, -hight], [long, width, -hight], [-long, width, -hight], [-long, -width, -hight],
+-    [long, -width, hight], [long, width, hight], [-long, width, hight], [-long, -width, hight]
+-]
+-
+-face_edges = (
+-    (0, 1, 2, 3),
+-    (4, 5, 6, 7),
+-    (0, 4, 7, 3),
+-    (1, 5, 6, 2),
+-    (0, 1, 5, 4),
+-    (3, 2, 6, 7)
+-)
+-
+-line_edges = [
+-    [0, 1], [1, 2], [2, 3], [3, 0],
+-    [0, 4], [1, 5], [2, 6], [3, 7],
+-    [4, 5], [5, 6], [6, 7], [7, 4]
+-]
+-
+-blue_gray   = (0.68, 0.84, 1)
+-line_white  = (1,1,1)
+-
+-face_colors = [blue_gray for i in range(6)]
+-
+-def draw_cube():
+-    glBegin(GL_QUADS)
+-    for face in range(len(face_edges)):
+-        glColor3fv(face_colors[face])
+-        for vertex in face_edges[face]:
+-            glVertex3fv(vertices[vertex])
+-    glEnd()
+-    
+-    glColor3f(line_white[0], line_white[1], line_white[2])
+-    glBegin(GL_LINES)
+-    for edge in line_edges:
+-        for vertex in edge:
+-            glVertex3fv(vertices[vertex])
+-    glEnd()
+-
+-def main():
+-    pygame.init()
+-    display = (800, 600)
+-    pygame.display.set_mode(display, DOUBLEBUF | OPENGL)
+-
+-    gluPerspective(45, (display[0] / display[1]), 0.1, 50.0)
+-    glTranslatef(0.0, 0.0, -5)
+-
+-    # Connect to the serial port
+-    ser = serial.Serial('COM14', 115200)  # Replace 'COM3' with your serial port and baud rate
+-
+-    rawFrame = []
+-    while True:
+-        for event in pygame.event.get():
+-            if event.type == pygame.QUIT:
+-                pygame.quit()
+-                quit()
+-
+-        # Read gyroscope measurements from the serial port
+-
+-        byte  = ser.read(1)        
+-        rawFrame += byte
+-        
+-        if rawFrame[-2:]==[13, 10]:
+-                    
+-            if len(rawFrame) == 8:
+-                            
+-                (x_gyro, y_gyro, z_gyro) = struct.unpack('>hhh', bytes(rawFrame[:-2]))
+-                        
+-                # debug info
+-                output = 'gyr_x={0:<6} gyr_y={1:<6} gyr_z={2:<6}'.format(
+-                    x_gyro,
+-                    y_gyro,
+-                    z_gyro
+-                )
+-                
+-            rawFrame         = []
+-            
+-            # GYRO_RESOLUATION_0 = 16.4
+-            GYRO_RESOLUATION_1 = 32.8
+-            # GYRO_RESOLUATION_2 = 65.6
+-            # GYRO_RESOLUATION_3 = 131.2
+-            
+-            # GYRO_RESOLUATION_4 = 264.4
+-            gyro_reso = GYRO_RESOLUATION_1
+-            DATA_INTERVAL = 0.0625
+-            
+-            x_gyro = DATA_INTERVAL*float(x_gyro)/float(gyro_reso)
+-            y_gyro = DATA_INTERVAL*float(y_gyro)/float(gyro_reso)
+-            z_gyro = DATA_INTERVAL*float(z_gyro)/float(gyro_reso)
+-
+-            # Rotate the cube based on gyroscope measurements
+-            glRotatef(x_gyro, 1, 0, 0)
+-            glRotatef(y_gyro, 0, 1, 0)
+-            glRotatef(z_gyro, 0, 0, 1)
+-            
+-            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
+-            draw_cube()
+-            pygame.display.flip()
+-            pygame.time.wait(10)
+-
+-    # Close the serial port when finished
+-    ser.close()
+-
+-if __name__ == '__main__':
+-    main()
++import pygame
++import serial
++import struct
++from pygame.locals import *
++from OpenGL.GL import *
++from OpenGL.GLU import *
++
++long  = 1
++width = 0.8
++hight = 0.2
++
++# Cube vertices and faces
++vertices = [
++    [long, -width, -hight], [long, width, -hight], [-long, width, -hight], [-long, -width, -hight],
++    [long, -width, hight], [long, width, hight], [-long, width, hight], [-long, -width, hight]
++]
++
++face_edges = (
++    (0, 1, 2, 3),
++    (4, 5, 6, 7),
++    (0, 4, 7, 3),
++    (1, 5, 6, 2),
++    (0, 1, 5, 4),
++    (3, 2, 6, 7)
++)
++
++line_edges = [
++    [0, 1], [1, 2], [2, 3], [3, 0],
++    [0, 4], [1, 5], [2, 6], [3, 7],
++    [4, 5], [5, 6], [6, 7], [7, 4]
++]
++
++blue_gray   = (0.68, 0.84, 1)
++line_white  = (1,1,1)
++
++face_colors = [blue_gray for i in range(6)]
++
++def draw_cube():
++    glBegin(GL_QUADS)
++    for face in range(len(face_edges)):
++        glColor3fv(face_colors[face])
++        for vertex in face_edges[face]:
++            glVertex3fv(vertices[vertex])
++    glEnd()
++    
++    glColor3f(line_white[0], line_white[1], line_white[2])
++    glBegin(GL_LINES)
++    for edge in line_edges:
++        for vertex in edge:
++            glVertex3fv(vertices[vertex])
++    glEnd()
++
++def main():
++    pygame.init()
++    display = (800, 600)
++    pygame.display.set_mode(display, DOUBLEBUF | OPENGL)
++
++    gluPerspective(45, (display[0] / display[1]), 0.1, 50.0)
++    glTranslatef(0.0, 0.0, -5)
++
++    # Connect to the serial port
++    ser = serial.Serial('COM14', 115200)  # Replace 'COM3' with your serial port and baud rate
++
++    rawFrame = []
++    while True:
++        for event in pygame.event.get():
++            if event.type == pygame.QUIT:
++                pygame.quit()
++                quit()
++
++        # Read gyroscope measurements from the serial port
++
++        byte  = ser.read(1)        
++        rawFrame += byte
++        
++        if rawFrame[-2:]==[13, 10]:
++                    
++            if len(rawFrame) == 8:
++                            
++                (x_gyro, y_gyro, z_gyro) = struct.unpack('>hhh', bytes(rawFrame[:-2]))
++                        
++                # debug info
++                output = 'gyr_x={0:<6} gyr_y={1:<6} gyr_z={2:<6}'.format(
++                    x_gyro,
++                    y_gyro,
++                    z_gyro
++                )
++                
++            rawFrame         = []
++            
++            # GYRO_RESOLUATION_0 = 16.4
++            GYRO_RESOLUATION_1 = 32.8
++            # GYRO_RESOLUATION_2 = 65.6
++            # GYRO_RESOLUATION_3 = 131.2
++            
++            # GYRO_RESOLUATION_4 = 264.4
++            gyro_reso = GYRO_RESOLUATION_1
++            DATA_INTERVAL = 0.0625
++            
++            x_gyro = DATA_INTERVAL*float(x_gyro)/float(gyro_reso)
++            y_gyro = DATA_INTERVAL*float(y_gyro)/float(gyro_reso)
++            z_gyro = DATA_INTERVAL*float(z_gyro)/float(gyro_reso)
++
++            # Rotate the cube based on gyroscope measurements
++            glRotatef(x_gyro, 1, 0, 0)
++            glRotatef(y_gyro, 0, 1, 0)
++            glRotatef(z_gyro, 0, 0, 1)
++            
++            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
++            draw_cube()
++            pygame.display.flip()
++            pygame.time.wait(10)
++
++    # Close the serial port when finished
++    ser.close()
++
++if __name__ == '__main__':
++    main()
+diff --git a/projects/common/01bsp_bmx388/01bsp_bmx388.c b/projects/common/01bsp_bmx388/01bsp_bmx388.c
+new file mode 100644
+index 00000000..9adf2614
+--- /dev/null
++++ b/projects/common/01bsp_bmx388/01bsp_bmx388.c
+@@ -0,0 +1,165 @@
++/**
++\brief This program shows the use of the "bmx160" bsp module.
++
++Since the bsp modules for different platforms have the same declaration, you
++can use this project with any platform.
++
++This project configure bmx160 and read the gyroscope values in 3 axises.
++Then it sends out the gyro data through uart at interval of SAMPLE_PERIOD.
++
++\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
++*/
++
++#include "stdio.h"
++#include "stdint.h"
++#include "string.h"
++#include "board.h"
++#include "leds.h"
++#include "sctimer.h"
++#include "i2c.h"
++#include "uart.h"
++#include "bmx388.h"
++
++//=========================== defines =========================================
++
++#define SAMPLE_PERIOD   (32768>>6)  // @32kHz = 1s
++#define BUFFER_SIZE     0x08   //2B*3 axises value + 2B ending with '\r\n'
++
++//=========================== variables =======================================
++
++typedef struct {
++   uint16_t num_compare;
++   bool sampling_now;
++   uint8_t axes[6];
++   float axis_x;
++   float axis_y;
++   float axis_z;
++
++   uint8_t who_am_i;
++   uint8_t sensorTime;
++   int16_t temp;
++   float   temp_f;
++
++   // uart specific
++              uint8_t uart_lastTxByteIndex;
++   volatile   uint8_t uartDone;
++   volatile   uint8_t uartSendNow;
++   volatile   uint8_t uartToSend[BUFFER_SIZE];
++    uint8_t   pwr_status;
++} app_vars_t;
++
++app_vars_t app_vars;
++
++//=========================== prototypes ======================================
++
++void cb_compare(void);
++void cb_uartTxDone(void);
++uint8_t cb_uartRxCb(void);
++
++//=========================== main ============================================
++
++/**
++\brief The program starts executing here.
++*/
++int mote_main(void) {
++
++    int16_t tmp;
++    uint8_t i;
++
++    // initialize board. 
++    board_init();
++
++    // setup UART
++    uart_setCallbacks(cb_uartTxDone,cb_uartRxCb);
++    uart_enableInterrupts();
++   
++    sctimer_set_callback(cb_compare);
++    sctimer_setCompare(sctimer_readCounter()+SAMPLE_PERIOD);
++         
++    // alway set address first
++    i2c_set_addr(BMX388_ADDR);
++    bmx160_power_on();
++    app_vars.pwr_status = bmx160_get_pwr_status();
++
++    // should be 0x50 for bmx388
++    app_vars.who_am_i = bmx388_who_am_i();
++        
++
++    while (1) {
++
++        //// wait for timer to elapse
++        //while (app_vars.uartSendNow==0);
++        //app_vars.uartSendNow = 0;
++        ////bmx160_set_cmd(BMX160_CMD_PMU_GYR_NORMAL);
++
++        bmx160_read_9dof_data();
++        bmp388_get_sensortime();
++        uint8_t stasus;
++        stasus = bmx160_get_pmu_status();
++
++        bmp388_get_compensation();
++        bmp388_compensation_temp();
++
++
++        //i=0;
++        //tmp = bmx160_read_gyr_x();
++        //app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
++        //app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
++        
++        //tmp = bmx160_read_gyr_y();
++        //app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
++        //app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
++
++        //tmp = bmx160_read_gyr_z();
++        //app_vars.uartToSend[i++] = (uint8_t)((tmp>>8) & 0x00ff);
++        //app_vars.uartToSend[i++] = (uint8_t)((tmp>>0) & 0x00ff);
++
++        //app_vars.uartToSend[i++] = '\r';
++        //app_vars.uartToSend[i++] = '\n';
++
++        //// send string over UART
++        //app_vars.uartDone              = 0;
++        //app_vars.uart_lastTxByteIndex  = 0;
++        ////uart_writeByte(app_vars.uartToSend[app_vars.uart_lastTxByteIndex]);
++        //uart_writeFloatByte()
++        //while(app_vars.uartDone==0);
++        //app_vars.sensorTime = bmp388_get_sensortime();
++    }
++}
++
++//=========================== callbacks =======================================
++
++void cb_compare(void) {
++   
++    // have main "task" send over UART
++    app_vars.uartSendNow = 1;
++
++    // schedule again
++    sctimer_setCompare(sctimer_readCounter()+SAMPLE_PERIOD);
++}
++
++void cb_uartTxDone(void) {
++
++    app_vars.uart_lastTxByteIndex++;
++    if (app_vars.uart_lastTxByteIndex<sizeof(app_vars.uartToSend)) {
++        uart_writeByte(app_vars.uartToSend[app_vars.uart_lastTxByteIndex]);
++    } else {
++        app_vars.uartDone = 1;
++    }
++}
++
++uint8_t cb_uartRxCb(void) {
++   
++   uint8_t byte;
++   
++   // toggle LED
++   leds_error_toggle();
++   
++   // read received byte
++   byte = uart_readByte();
++   
++   // echo that byte over serial
++   uart_writeByte(byte);
++   
++   return 0;
++}
+\ No newline at end of file
+diff --git a/projects/common/01bsp_uart/01bsp_uart-Imon_hkustgz.c b/projects/common/01bsp_uart/01bsp_uart-Imon_hkustgz.c
+new file mode 100644
+index 00000000..d21400f0
+--- /dev/null
++++ b/projects/common/01bsp_uart/01bsp_uart-Imon_hkustgz.c
+@@ -0,0 +1,146 @@
++/**
++\brief This is a program which shows how to use the bsp modules for the board
++       and UART.
++
++\note: Since the bsp modules for different platforms have the same declaration,
++       you can use this project with any platform.
++
++Load this program on your board. Open a serial terminal client (e.g. PuTTY or
++TeraTerm):
++- You will read "Hello World!" printed over and over on your terminal client.
++- when you enter a character on the client, the board echoes it back (i.e. you
++  see the character on the terminal client) and the "ERROR" led blinks.
++
++\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012
++*/
++
++#include "stdint.h"
++#include "stdio.h"
++#include "string.h"
++// bsp modules required
++#include "board.h"
++#include "uart.h"
++#include "sctimer.h"
++#include "leds.h"
++
++//=========================== defines =========================================
++
++#define SCTIMER_PERIOD     0x4fff // 0xffff@32kHz = 2s
++uint8_t stringToSend[]       = "Hello, World!\r\n";
++
++//=========================== variables =======================================
++
++typedef struct {
++              uint8_t uart_lastTxByteIndex;
++              uint8_t uart_lastRxByteIndex;
++              uint8_t echoStartFlag;
++              uint8_t echoFinishFlag;
++   volatile   uint8_t uartDone;
++   volatile   uint8_t uartSendNow;
++} app_vars_t;
++
++app_vars_t app_vars;
++uint8_t stringToReceive[32];
++
++//=========================== prototypes ======================================
++
++void cb_compare(void);
++void cb_uartTxDone(void);
++uint8_t cb_uartRxCb(void);
++void some_delay(void);
++
++//=========================== main ============================================
++
++/**
++\brief The program starts executing here.
++*/
++int mote_main(void) {
++  
++   // clear local variable
++   memset(&app_vars,0,sizeof(app_vars_t));
++    
++   app_vars.uartSendNow = 1;
++   app_vars.uart_lastRxByteIndex = 0;
++   app_vars.echoStartFlag = 0;
++   app_vars.echoFinishFlag = 0;
++   
++   // initialize the board
++   board_init();
++   
++   // setup UART
++   uart_setCallbacks(cb_uartTxDone,cb_uartRxCb);
++   uart_enableInterrupts();
++   
++   // setup sctimer
++   sctimer_set_callback(cb_compare);
++   sctimer_setCompare(sctimer_readCounter()+SCTIMER_PERIOD);
++   
++   while(1) {
++      
++      // wait for timer to elapse
++      while (app_vars.uartSendNow==0);
++      app_vars.uartSendNow = 0;
++      uart_writeByte(0x66);
++      // send string over UART
++      app_vars.uartDone              = 0;
++      app_vars.uart_lastTxByteIndex  = 0;
++      //uart_writeByte(stringToSend[app_vars.uart_lastTxByteIndex]);
++      uart_writeByte(0x70);
++      while(app_vars.uartDone==0);
++   }
++}
++
++//=========================== callbacks =======================================
++
++void cb_compare(void) {
++   
++   // have main "task" send over UART
++   app_vars.uartSendNow = 1;
++   
++   // schedule again
++   sctimer_setCompare(sctimer_readCounter()+SCTIMER_PERIOD);
++}
++
++void cb_uartTxDone(void) {
++   if (app_vars.echoStartFlag == 1)
++   {
++   app_vars.echoStartFlag == 0;
++   //for(uint8_t i=0;i<=app_vars.uart_lastRxByteIndex;i=i+1){
++   //   uart_writeByte(stringToReceive[i]);
++   //   }
++   uart_writeByte(stringToReceive[app_vars.uart_lastRxByteIndex]);
++   uart_writeByte('\n');
++   if(stringToReceive[app_vars.uart_lastRxByteIndex]==0x0d) app_vars.uart_lastRxByteIndex = 0;
++   app_vars.echoFinishFlag = 1;
++   }
++   app_vars.uartDone = 1;
++   //else {
++   //  app_vars.uart_lastTxByteIndex++;
++   //  if (app_vars.uart_lastTxByteIndex<sizeof(app_vars.uart_lastRxByteIndex)) {
++   //     uart_writeByte(stringToSend[app_vars.uart_lastTxByteIndex]);
++   //     //uart_writeByte(stringToReceive);
++   //  } else {
++   //     app_vars.uartDone = 1;
++   //  }
++   // }
++}
++
++uint8_t cb_uartRxCb(void) {
++   uint8_t byte;
++   // toggle LED
++   leds_error_on();
++   // read received byte
++   byte = uart_readByte();
++   stringToReceive[app_vars.uart_lastRxByteIndex] = byte;
++   if(stringToReceive[app_vars.uart_lastRxByteIndex]==0x0d) 
++     {app_vars.echoStartFlag=1;}  
++   app_vars.uart_lastRxByteIndex ++;
++
++   // echo that byte over serial
++   return 0;
++}
++
++void some_delay(void) {
++   volatile uint32_t delay;
++   for (delay=0x00fffff;delay>0;delay--);
++}
+\ No newline at end of file
+diff --git a/projects/common/01bsp_uart/01bsp_uart.c b/projects/common/01bsp_uart/01bsp_uart.c
+index bc19dcd0..3e18372c 100644
+--- a/projects/common/01bsp_uart/01bsp_uart.c
++++ b/projects/common/01bsp_uart/01bsp_uart.c
+@@ -25,22 +25,18 @@ TeraTerm):
+ 
+ //=========================== defines =========================================
+ 
+-#define SCTIMER_PERIOD     0x4fff // 0xffff@32kHz = 2s
++#define SCTIMER_PERIOD     0xffff // 0xffff@32kHz = 2s
+ uint8_t stringToSend[]       = "Hello, World!\r\n";
+ 
+ //=========================== variables =======================================
+ 
+ typedef struct {
+               uint8_t uart_lastTxByteIndex;
+-              uint8_t uart_lastRxByteIndex;
+-              uint8_t echoStartFlag;
+-              uint8_t echoFinishFlag;
+    volatile   uint8_t uartDone;
+    volatile   uint8_t uartSendNow;
+ } app_vars_t;
+ 
+ app_vars_t app_vars;
+-uint8_t stringToReceive[32];
+ 
+ //=========================== prototypes ======================================
+ 
+@@ -55,14 +51,11 @@ void some_delay(void);
+ \brief The program starts executing here.
+ */
+ int mote_main(void) {
+-  
++   
+    // clear local variable
+    memset(&app_vars,0,sizeof(app_vars_t));
+     
+    app_vars.uartSendNow = 1;
+-   app_vars.uart_lastRxByteIndex = 0;
+-   app_vars.echoStartFlag = 0;
+-   app_vars.echoFinishFlag = 0;
+    
+    // initialize the board
+    board_init();
+@@ -80,12 +73,11 @@ int mote_main(void) {
+       // wait for timer to elapse
+       while (app_vars.uartSendNow==0);
+       app_vars.uartSendNow = 0;
+-      uart_writeByte(0x66);
++      
+       // send string over UART
+       app_vars.uartDone              = 0;
+       app_vars.uart_lastTxByteIndex  = 0;
+-      //uart_writeByte(stringToSend[app_vars.uart_lastTxByteIndex]);
+-      uart_writeByte(0x70);
++      uart_writeByte(stringToSend[app_vars.uart_lastTxByteIndex]);
+       while(app_vars.uartDone==0);
+    }
+ }
+@@ -102,45 +94,35 @@ void cb_compare(void) {
+ }
+ 
+ void cb_uartTxDone(void) {
+-   if (app_vars.echoStartFlag == 1)
+-   {
+-   app_vars.echoStartFlag == 0;
+-   //for(uint8_t i=0;i<=app_vars.uart_lastRxByteIndex;i=i+1){
+-   //   uart_writeByte(stringToReceive[i]);
+-   //   }
+-   uart_writeByte(stringToReceive[app_vars.uart_lastRxByteIndex]);
+-   uart_writeByte('\n');
+-   if(stringToReceive[app_vars.uart_lastRxByteIndex]==0x0d) app_vars.uart_lastRxByteIndex = 0;
+-   app_vars.echoFinishFlag = 1;
++   app_vars.uart_lastTxByteIndex++;
++   if (app_vars.uart_lastTxByteIndex<sizeof(stringToSend)) {
++      uart_writeByte(stringToSend[app_vars.uart_lastTxByteIndex]);
++   } else {
++      app_vars.uartDone = 1;
+    }
+-   app_vars.uartDone = 1;
+-   //else {
+-   //  app_vars.uart_lastTxByteIndex++;
+-   //  if (app_vars.uart_lastTxByteIndex<sizeof(app_vars.uart_lastRxByteIndex)) {
+-   //     uart_writeByte(stringToSend[app_vars.uart_lastTxByteIndex]);
+-   //     //uart_writeByte(stringToReceive);
+-   //  } else {
+-   //     app_vars.uartDone = 1;
+-   //  }
+-   // }
+ }
+ 
+ uint8_t cb_uartRxCb(void) {
+    uint8_t byte;
++   uint8_t i=0;
++   
+    // toggle LED
+    leds_error_on();
++   some_delay();
++   
+    // read received byte
+    byte = uart_readByte();
+-   stringToReceive[app_vars.uart_lastRxByteIndex] = byte;
+-   if(stringToReceive[app_vars.uart_lastRxByteIndex]==0x0d) 
+-     {app_vars.echoStartFlag=1;}  
+-   app_vars.uart_lastRxByteIndex ++;
+-
++   
+    // echo that byte over serial
++   for (i=0 ; i<=10; i++)
++     {
++     uart_writeByte(byte);
++     }
++   
+    return 0;
+ }
+ 
+ void some_delay(void) {
+    volatile uint32_t delay;
+    for (delay=0x00fffff;delay>0;delay--);
+-}
+\ No newline at end of file
++}
+diff --git a/projects/nrf52840_dk/01bsp_bmx388_Debug.jlink b/projects/nrf52840_dk/01bsp_bmx388_Debug.jlink
+new file mode 100644
+index 00000000..35ce3010
+--- /dev/null
++++ b/projects/nrf52840_dk/01bsp_bmx388_Debug.jlink
+@@ -0,0 +1,44 @@
++[BREAKPOINTS]
++ForceImpTypeAny = 0
++ShowInfoWin = 1
++EnableFlashBP = 2
++BPDuringExecution = 0
++[CFI]
++CFISize = 0x00
++CFIAddr = 0x00
++[CPU]
++MonModeVTableAddr = 0xFFFFFFFF
++MonModeDebug = 0
++MaxNumAPs = 0
++LowPowerHandlingMode = 0
++OverrideMemMap = 0
++AllowSimulation = 1
++ScriptFile=""
++[FLASH]
++RMWThreshold = 0x400
++Loaders=""
++EraseType = 0x00
++CacheExcludeSize = 0x00
++CacheExcludeAddr = 0x00
++MinNumBytesFlashDL = 0
++SkipProgOnCRCMatch = 1
++VerifyDownload = 1
++AllowCaching = 1
++EnableFlashDL = 2
++Override = 0
++Device="ARM7"
++[GENERAL]
++WorkRAMSize = 0x00
++WorkRAMAddr = 0x00
++RAMUsageLimit = 0x00
++[SWO]
++SWOLogFile=""
++[MEM]
++RdOverrideOrMask = 0x00
++RdOverrideAndMask = 0xFFFFFFFF
++RdOverrideAddr = 0xFFFFFFFF
++WrOverrideOrMask = 0x00
++WrOverrideAndMask = 0xFFFFFFFF
++WrOverrideAddr = 0xFFFFFFFF
++[RAM]
++VerifyDownload = 0x01
+diff --git a/projects/nrf52840_dk/01bsp_i2c.c b/projects/nrf52840_dk/01bsp_i2c.c
+new file mode 100644
+index 00000000..3f92e2cf
+--- /dev/null
++++ b/projects/nrf52840_dk/01bsp_i2c.c
+@@ -0,0 +1,60 @@
++/**
++\brief This is a program shows how to read data from i2c slave device.
++
++\note: Since the bsp modules for different platforms have the same declaration,
++       you can use this project with any platform.
++
++This project reads the chipid through i2c interface with the device.
++
++\author Tengfei Chang <tengfeichang@hkust-gz.edu.cn>, July 2023.
++*/
++
++#include "stdint.h"
++#include "stdio.h"
++// bsp modules required
++#include "board.h"
++#include "i2c.h"
++
++//=========================== defines =========================================
++
++#define I2C_DEV_ADDR                0x68
++#define I2C_DEV_REG_ADDR_CHIPID     0x00
++
++//=========================== variables =======================================
++
++typedef struct {
++   uint8_t    who_am_i;
++} app_vars_t;
++
++app_vars_t app_vars;
++
++//=========================== prototypes ======================================
++
++//=========================== main ============================================
++
++/**
++\brief The program starts executing here.
++*/
++int mote_main(void) {
++   
++    uint32_t  tmp;
++    uint32_t  i;
++
++    memset(&app_vars,0,sizeof(app_vars));
++   
++    // initialize
++   
++    board_init();
++
++    // alway set address first
++    i2c_set_addr(I2C_DEV_ADDR);
++   
++    // retrieve radio manufacturer ID over SPI
++    while(1) {
++
++        tmp = i2c_read_bytes(I2C_DEV_REG_ADDR_CHIPID, &app_vars.who_am_i, 1);
++        for (i=0;i<0xfffff;i++);
++   }
++}
++
++//=========================== callbacks =======================================
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/adc.c b/projects/nrf52840_dk/adc.c
+new file mode 100644
+index 00000000..4dcb1be0
+--- /dev/null
++++ b/projects/nrf52840_dk/adc.c
+@@ -0,0 +1,28 @@
++/**
++    \brief Definition of the nrf52480 ADC driver.
++    \author Frank Senf <frank.senf@imms.de>, July 2018.
++    \author Tengfei Chang <tengfeichang@hkust-gz.edu.cn>, April, 2023
++*/
++
++
++#include "adc.h"
++
++
++//=========================== defines =========================================
++
++//=========================== typedef =========================================
++
++//=========================== variables =======================================
++
++//=========================== prototype =======================================
++
++//=========================== public ==========================================
++
++void adc_init(void) {
++}
++
++uint16_t adc_read(void) {
++}
++
++
++//=========================== private =========================================
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/adc.h b/projects/nrf52840_dk/adc.h
+new file mode 100644
+index 00000000..5fd68f4c
+--- /dev/null
++++ b/projects/nrf52840_dk/adc.h
+@@ -0,0 +1,22 @@
++/**
++    \brief Declaration of the nrf52480 ADC driver.
++    \author Frank Senf <frank.senf@imms.de>, July 2018.
++*/
++
++#ifndef __ADC_H__
++#define __ADC_H__
++
++#include "board_info.h"
++
++//=========================== define ==========================================
++
++//=========================== typedef =========================================
++
++//=========================== module variables ================================
++
++//=========================== prototypes ======================================
++
++void adc_init(void);
++uint16_t adc_read(void);
++
++#endif // __ADC_SENSOR_H__
+diff --git a/projects/nrf52840_dk/af.h b/projects/nrf52840_dk/af.h
+new file mode 100644
+index 00000000..bd866468
+--- /dev/null
++++ b/projects/nrf52840_dk/af.h
+@@ -0,0 +1,24 @@
++#ifndef OPENWSN_AF_H
++#define OPENWSN_AF_H
++
++/**
++\brief Address families definitions
++*/
++
++enum {
++    AF_UNSPEC = 0,              /**< unspecified address family */
++#define AF_UNSPEC   AF_UNSPEC   /**< unspecified address family (as macro) */
++    AF_UNIX,                    /**< local to host (pipes, portals) address family. */
++#define AF_UNIX     AF_UNIX     /**< unspecified address family (as macro) */
++    AF_PACKET,                  /**< packet family */
++#define AF_PACKET   AF_PACKET   /**< packet family (as macro) */
++    AF_INET,                    /**< internetwork address family: UDP, TCP, etc. */
++#define AF_INET     AF_INET     /**< internetwork address family: UDP, TCP, etc. (as macro) */
++    AF_INET6,                   /**< internetwork address family with IPv6: UDP, TCP, etc. */
++#define AF_INET6    AF_INET6    /**< internetwork address family with IPv6: UDP, TCP, etc. (as macro) */
++    AF_NUMOF,                   /**< maximum number of address families on this system */
++#define AF_NUMOF    AF_NUMOF    /**< maximum number of address families on this system (as macro) */
++#define AF_MAX      AF_NUMOF    /**< alias for @ref AF_NUMOF */
++};
++
++#endif /* OPENWSN_AF_H */
+diff --git a/projects/nrf52840_dk/bmx160.c b/projects/nrf52840_dk/bmx160.c
+new file mode 100644
+index 00000000..445d82c3
+--- /dev/null
++++ b/projects/nrf52840_dk/bmx160.c
+@@ -0,0 +1,181 @@
++/**
++\brief bmx160 driver.
++
++\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
++*/
++
++#include "i2c.h"
++#include "bmx160.h"
++
++//=========================== define ==========================================
++
++typedef struct{
++
++    int16_t mag_x;
++    int16_t mag_y;
++    int16_t mag_z;
++
++    int16_t rhall;
++
++    int16_t gyr_x;
++    int16_t gyr_y;
++    int16_t gyr_z;
++
++    int16_t acc_x;
++    int16_t acc_y;
++    int16_t acc_z;
++
++}bmx160x_data_t;
++
++typedef struct {
++    
++    bmx160x_data_t bmx160x_data;
++
++}bmx160x_var_t;
++
++//=========================== variables =======================================
++
++bmx160x_var_t bmx160x_var;
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++// admin
++uint8_t bmx160_who_am_i(void) {
++
++    uint8_t chipid;
++    i2c_read_bytes(BMX160_REG_ADDR_CHIPID, &chipid, 1);
++    return chipid;
++}
++
++void bmx160_config_wakeup(void) {
++    
++}
++
++uint8_t bmx160_power_down(void) {
++
++}
++
++uint8_t bmx160_get_pmu_status(void) {
++
++    uint8_t pmu_status;
++    i2c_read_bytes(BMX160_REG_ADDR_PMU_STATUS, &pmu_status, 1);
++    return pmu_status;
++}
++
++
++void bmx160_set_cmd(uint8_t cmd) {
++    i2c_write_bytes(BMX160_REG_ADDR_CMD, &cmd, 1);
++}
++
++// configuration
++
++void    bmx160_acc_config(uint8_t config) {
++    i2c_write_bytes(BMX160_REG_ADDR_ACC_CONF, &config, 1);
++}
++
++void    bmx160_gyr_config(uint8_t config) {
++    i2c_write_bytes(BMX160_REG_ADDR_GYR_CONF, &config, 1);
++}
++
++void    bmx160_mag_config(uint8_t config) {
++    i2c_write_bytes(BMX160_REG_ADDR_MAG_CONF, &config, 1);
++}
++
++// range & interface
++
++void    bmx160_acc_range(uint8_t range) {
++    i2c_write_bytes(BMX160_REG_ADDR_ACC_RANGE, &range, 1);
++}
++
++void    bmx160_gyr_range(uint8_t range) {
++    i2c_write_bytes(BMX160_REG_ADDR_GYR_RANGE, &range, 1);
++}
++
++void    bmx160_mag_if(uint8_t interface) {
++    i2c_write_bytes(BMX160_REG_ADDR_MAG_IF, &interface, 1);
++}
++
++
++// read
++void bmx160_read_9dof_data(void) {
++
++    uint8_t pmu_status;
++
++    // enable  accelarometer
++    do {
++        bmx160_set_cmd(BMX160_CMD_PMU_ACC_NORMAL);
++        i2c_read_bytes(BMX160_REG_ADDR_PMU_STATUS, &pmu_status, 1);
++    } while ((pmu_status & 0x10) != 0x10); 
++
++    // enable gyroscope
++    do {
++        bmx160_set_cmd(BMX160_CMD_PMU_GYR_NORMAL);
++        i2c_read_bytes(BMX160_REG_ADDR_PMU_STATUS, &pmu_status, 1);
++    } while ((pmu_status & 0x04) != 0x04); 
++
++    // enabel mag
++    do {
++        bmx160_set_cmd(BMX160_CMD_PMU_MAG_IF_NORMAL);
++        i2c_read_bytes(BMX160_REG_ADDR_PMU_STATUS, &pmu_status, 1);
++    } while ((pmu_status & 0x01) != 0x01); 
++
++    // wait until pmu status are correct
++    //       acc_normal gyr_normal mag_if_normal
++    // 0xb10 01         01         01 = 0x95
++    
++    i2c_read_bytes(BMX160_REG_ADDR_DATA, (uint8_t*)(&bmx160x_var.bmx160x_data), sizeof(bmx160x_data_t));
++}
++
++
++int16_t bmx160_read_acc_x(void) {
++
++    return bmx160x_var.bmx160x_data.acc_x;
++}
++int16_t bmx160_read_acc_y(void) {
++    
++    return bmx160x_var.bmx160x_data.acc_y;
++}
++int16_t bmx160_read_acc_z(void) {
++    
++    return bmx160x_var.bmx160x_data.acc_z;
++}
++
++int16_t bmx160_read_mag_x(void) {
++    
++    return bmx160x_var.bmx160x_data.mag_x;
++}
++int16_t bmx160_read_mag_y(void) {
++    
++    return bmx160x_var.bmx160x_data.mag_y;
++}
++int16_t bmx160_read_mag_z(void) {
++    
++    return bmx160x_var.bmx160x_data.mag_z;
++}
++
++int16_t bmx160_read_gyr_x(void) {
++    
++    return bmx160x_var.bmx160x_data.gyr_x;
++}
++int16_t bmx160_read_gyr_y(void) {
++    
++    return bmx160x_var.bmx160x_data.gyr_y;
++}
++int16_t bmx160_read_gyr_z(void) {
++    
++    return bmx160x_var.bmx160x_data.gyr_z;
++}
++
++//=========================== helper ==========================================
++
++float bmx160_from_lsb_to_celsius(int16_t lsb) {
++
++}
++
++float bmx160_from_fs8_lp1_to_mg(int16_t lsb) {
++
++}
++
++//=========================== private =========================================
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/bmx160.h b/projects/nrf52840_dk/bmx160.h
+new file mode 100644
+index 00000000..e00d96dc
+--- /dev/null
++++ b/projects/nrf52840_dk/bmx160.h
+@@ -0,0 +1,112 @@
++/**
++\brief registers address mapping of bmx160 sensor.
++
++\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
++*/
++
++#include "stdint.h"
++
++//=========================== define ==========================================
++
++#define BMX160_ADDR 0x68
++
++//---- register addresses
++
++#define BMX160_REG_ADDR_CHIPID      0x00
++#define BMX160_REG_ADDR_ERR_REG     0x02
++#define BMX160_REG_ADDR_PMU_STATUS  0x03
++
++// sensor data
++
++#define BMX160_REG_ADDR_DATA        0x04
++
++#define BMX160_REG_ADDR_MAG_X_L     0x04
++#define BMX160_REG_ADDR_MAG_X_H     0x05
++#define BMX160_REG_ADDR_MAG_Y_L     0x06
++#define BMX160_REG_ADDR_MAG_Y_H     0x07
++#define BMX160_REG_ADDR_MAG_Z_L     0x08
++#define BMX160_REG_ADDR_MAG_Z_H     0x09
++#define BMX160_REG_ADDR_RHALL_L     0x0a
++#define BMX160_REG_ADDR_RHALL_H     0x0b
++#define BMX160_REG_ADDR_GYR_X_L     0x0c
++#define BMX160_REG_ADDR_GYR_X_H     0x0d
++#define BMX160_REG_ADDR_GYR_Y_L     0x0e
++#define BMX160_REG_ADDR_GYR_Y_H     0x0f
++#define BMX160_REG_ADDR_GYR_Z_L     0x10
++#define BMX160_REG_ADDR_GYR_Z_H     0x11
++#define BMX160_REG_ADDR_ACC_X_L     0x12
++#define BMX160_REG_ADDR_ACC_X_H     0x13
++#define BMX160_REG_ADDR_ACC_Y_L     0x14
++#define BMX160_REG_ADDR_ACC_Y_H     0x15 
++#define BMX160_REG_ADDR_ACC_Z_L     0x16
++#define BMX160_REG_ADDR_ACC_Z_H     0x17
++
++#define BMX160_REG_ADDR_SENSORTIME  0x18
++#define BMX160_REG_ADDR_STATUS      0x1B
++#define BMX160_REG_ADDR_INT_STATUS  0x1C
++#define BMX160_REG_ADDR_TEMPERATURE 0x20
++#define BMX160_REG_ADDR_FIFO_LENGTH 0x22
++#define BMX160_REG_ADDR_FIFO_DATA   0x24
++#define BMX160_REG_ADDR_ACC_CONF    0x40
++#define BMX160_REG_ADDR_ACC_RANGE   0x41
++#define BMX160_REG_ADDR_GYR_CONF    0x42
++#define BMX160_REG_ADDR_GYR_RANGE   0x43
++#define BMX160_REG_ADDR_MAG_CONF    0x44
++#define BMX160_REG_ADDR_FIFO_DOWNS  0x45
++#define BMX160_REG_ADDR_FIFO_CONFIG 0x46
++#define BMX160_REG_ADDR_MAG_IF      0x4C
++#define BMX160_REG_ADDR_INT_EN      0x50
++#define BMX160_REG_ADDR_CMD         0x7E
++
++//---- register values
++
++#define BMX160_CMD_PMU_ACC_SUSPEND        0x10
++#define BMX160_CMD_PMU_ACC_NORMAL         0x11
++#define BMX160_CMD_PMU_ACC_LOW_POWER      0x12
++
++#define BMX160_CMD_PMU_GYR_SUSPEND        0x14
++#define BMX160_CMD_PMU_GYR_NORMAL         0x15
++#define BMX160_CMD_PMU_GYR_FSU            0x17
++
++#define BMX160_CMD_PMU_MAG_IF_SUSPEND     0x18
++#define BMX160_CMD_PMU_MAG_IF_NORMAL      0x19
++#define BMX160_CMD_PMU_MAG_IF_LOW_POWER   0x1A
++
++//=========================== variables =======================================
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++// admin
++uint8_t bmx160_who_am_i(void);
++uint8_t bmx160_power_down(void);
++uint8_t bmx160_get_pmu_status(void);
++
++void    bmx160_set_cmd(uint8_t cmd);
++void    bmx160_acc_config(uint8_t config);
++void    bmx160_gyr_config(uint8_t config);
++void    bmx160_mag_config(uint8_t config);
++
++void    bmx160_acc_range(uint8_t range);
++void    bmx160_gyr_range(uint8_t range);
++void    bmx160_mag_if(uint8_t interface);
++
++// read
++int16_t bmx160_read_temperature(void);
++
++int16_t bmx160_read_acc_x(void);
++int16_t bmx160_read_acc_y(void);
++int16_t bmx160_read_acc_z(void);
++
++int16_t bmx160_read_mag_x(void);
++int16_t bmx160_read_mag_y(void);
++int16_t bmx160_read_mag_z(void);
++
++int16_t bmx160_read_gyr_x(void);
++int16_t bmx160_read_gyr_y(void);
++int16_t bmx160_read_gyr_z(void);
++
++void    bmx160_read_9dof_data(void);
++
++//=========================== private =========================================
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/board.c b/projects/nrf52840_dk/board.c
+new file mode 100644
+index 00000000..04e9807b
+--- /dev/null
++++ b/projects/nrf52840_dk/board.c
+@@ -0,0 +1,90 @@
++/**
++ * Author: Tamas Harczos (tamas.harczos@imms.de)
++ * Date:   Apr 2018
++ * Description: nRF52840-specific definition of the "board" bsp module.
++ */
++
++#include "nrf52840.h"
++#include "board.h"
++#include "leds.h"
++#include "sctimer.h"
++#include "debugpins.h"
++#include "uart.h"
++#include "radio.h"
++#include "spi.h"
++#include "radio.h"
++#include "sensors.h"
++#include "i2c.h"
++
++
++//=========================== variables =======================================
++
++//=========================== prototypes ======================================
++
++void enable_dcdc(void);
++
++//=========================== main ============================================
++
++extern int mote_main(void);
++
++int main(void) {
++    return mote_main();
++}
++
++
++//=========================== public ==========================================
++
++void board_init(void) {
++
++    // start hfclock
++    NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
++    NRF_CLOCK->TASKS_HFCLKSTART    = 1;
++    while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0); //wait for crystal
++
++    leds_init();
++    debugpins_init();
++    uart_init();
++    sctimer_init();
++    radio_init();
++
++    i2c_init();
++
++    // configure dcdc
++    enable_dcdc();
++}
++
++/**
++ * Puts the board to sleep
++ */
++void board_sleep(void) {
++
++    __WFE();
++    __WFE();
++}
++
++/**
++ * Resets the board
++ */
++void board_reset(void) {
++
++    NVIC_SystemReset();
++}
++
++//=========================== private =========================================
++
++void enable_dcdc(void) {
++
++    uint32_t status; 
++
++    status = NRF_POWER->MAINREGSTATUS;
++
++    if (status == 0) {
++
++        while (NRF_POWER->DCDCEN == 0){
++            // in normal voltage mode: PS1.2, page 59
++            NRF_POWER->DCDCEN = (uint32_t)1;
++        }
++    }
++}
++
++//=========================== interrupt handlers ==============================
+diff --git a/projects/nrf52840_dk/board_info.h b/projects/nrf52840_dk/board_info.h
+new file mode 100644
+index 00000000..9e4dc5de
+--- /dev/null
++++ b/projects/nrf52840_dk/board_info.h
+@@ -0,0 +1,165 @@
++/**
++ * Author: Tamas Harczos (tamas.harczos@imms.de)
++ * Date:   Apr 2018
++ * Description: nRF52840-specific board information bsp module.
++ */
++
++#ifndef __BOARD_INFO_H
++#define __BOARD_INFO_H
++
++#include <stdint.h>
++#include <string.h>
++#include "cmsis_gcc.h"
++
++//=========================== defines =========================================
++
++//===== interrupt state
++
++#define INTERRUPT_DECLARATION()
++#define DISABLE_INTERRUPTS()  __disable_irq()
++#define ENABLE_INTERRUPTS()   __enable_irq()
++
++//===== timer
++
++#define PORT_TIMER_WIDTH                    uint32_t      ///< actually, 24 bit, but we will virtualize the 32 bit timer
++#define PORT_RADIOTIMER_WIDTH               uint32_t
++
++#define PORT_SIGNED_INT_WIDTH               int32_t
++#define PORT_TICS_PER_MS                    33
++#define PORT_US_PER_TICK                    30  // number of us per 32kHz clock tick
++#define PORT_MAX_TICKS_IN_SINGLE_CLOCK      (uint32_t)(0x00ffffff)
++
++// on GINA, we use the comparatorA interrupt for the OS
++#define SCHEDULER_WAKEUP()
++#define SCHEDULER_ENABLE_INTERRUPT()
++
++// this is a workaround from the fact that the interrupt pin for the GINA radio
++// is not connected to a pin on the MSP which allows time capture.
++#define CAPTURE_TIME()
++
++
++// pin selection
++#define NRF_GPIO_PIN_MAP(port, pin) (((port) << 5) | ((pin) & 0x1F))
++
++// interrupt priority
++#define RTC_PRIORITY    0
++#define RADIO_PRIORITY  0
++#define UART_PRIORITY   2
++
++//===== IEEE802154E timing
++// 1 clock tick = 30.5 us
++
++#define SLOTDURATION 20 // in miliseconds
++
++#if SLOTDURATION==10
++    // time-slot related
++    #define PORT_TsSlotDuration                 328   // counter counts one extra count, see datasheet
++
++#if BOARD_PCA10056
++// nrf52840-DK
++    #define PORT_maxTxDataPrepare               13    // ~397us (measured 364us)
++    #define PORT_maxRxAckPrepare                13    // ~397us (measured 364us)
++    #define PORT_maxRxDataPrepare               13    // ~397us (measured 364us)
++    #define PORT_maxTxAckPrepare                13    // ~397us (measured 364us)
++
++    // radio speed related
++    #define PORT_delayTx                        10    //  305us (measured 282us; radio_txNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++    #define PORT_delayRx                         5    // ~153us (measured 147us; radio_rxNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++#endif
++#if BOARD_PCA10059
++// nrf52840-DONGLE
++    #define PORT_maxTxDataPrepare               13    // ~397us (measured 345us)
++    #define PORT_maxRxAckPrepare                13    // ~397us (measured 345us)
++    #define PORT_maxRxDataPrepare               13    // ~397us (measured 345us)
++    #define PORT_maxTxAckPrepare                13    // ~397us (measured 345us)
++
++    // radio speed related
++    #define PORT_delayTx                        10    //  305us (measured 282us; radio_txNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++    #define PORT_delayRx                         5    // ~153us (measured 136us; radio_rxNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++#endif
++
++#endif // SLOTDURATION==10
++
++#if SLOTDURATION==15
++    // time-slot related
++    #define PORT_TsSlotDuration                 492   // counter counts one extra count, see datasheet
++
++#if BOARD_PCA10056
++// nrf52840-DK
++    #define PORT_maxTxDataPrepare               13    // ~397us (measured 364us)
++    #define PORT_maxRxAckPrepare                13    // ~397us (measured 364us)
++    #define PORT_maxRxDataPrepare               13    // ~397us (measured 364us)
++    #define PORT_maxTxAckPrepare                13    // ~397us (measured 364us)
++
++    // radio speed related
++    #define PORT_delayTx                        10    //  305us (measured 282us; radio_txNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++    #define PORT_delayRx                         5    // ~153us (measured 147us; radio_rxNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++#endif
++#if BOARD_PCA10059
++// nrf52840-DONGLE
++    #define PORT_maxTxDataPrepare               13    // ~397us (measured 345us)
++    #define PORT_maxRxAckPrepare                13    // ~397us (measured 345us)
++    #define PORT_maxRxDataPrepare               13    // ~397us (measured 345us)
++    #define PORT_maxTxAckPrepare                13    // ~397us (measured 345us)
++
++    // radio speed related
++    #define PORT_delayTx                        10    //  305us (measured 282us; radio_txNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++    #define PORT_delayRx                         5    // ~153us (measured 136us; radio_rxNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++#endif
++
++#endif // SLOTDURATION==15
++
++
++#if SLOTDURATION==20
++    // time-slot related
++    #define PORT_TsSlotDuration                 656   // counter counts one extra count, see datasheet
++
++#if BOARD_PCA10056
++// nrf52840-DK
++    #define PORT_maxTxDataPrepare               13    // ~397us (measured 364us)
++    #define PORT_maxRxAckPrepare                13    // ~397us (measured 364us)
++    #define PORT_maxRxDataPrepare               13    // ~397us (measured 364us)
++    #define PORT_maxTxAckPrepare                13    // ~397us (measured 364us)
++
++    // radio speed related
++    #define PORT_delayTx                         8    //  305us (measured 282us; radio_txNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++    #define PORT_delayRx                         0    // ~153us (measured 147us; radio_rxNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++#endif
++#if BOARD_PCA10059
++// nrf52840-DONGLE
++    #define PORT_maxTxDataPrepare               13    // ~397us (measured 345us)
++    #define PORT_maxRxAckPrepare                13    // ~397us (measured 345us)
++    #define PORT_maxRxDataPrepare               13    // ~397us (measured 345us)
++    #define PORT_maxTxAckPrepare                13    // ~397us (measured 345us)
++
++    // radio speed related
++    #define PORT_delayTx                        10    //  305us (measured 282us; radio_txNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++    #define PORT_delayRx                         5    // ~153us (measured 136us; radio_rxNow() to RADIO_IRQHandler() / NRF_RADIO->EVENTS_READY)
++#endif
++
++#endif // SLOTDURATION==20
++
++//===== adaptive_sync accuracy
++
++#define SYNC_ACCURACY                            1     // ticks
++
++//===== per-board number of sensors
++
++#define NUMSENSORS 2
++
++//=========================== typedef  ========================================
++
++//=========================== variables =======================================
++
++static const uint8_t rreg_uriquery[]        = "h=ucb";
++static const uint8_t infoBoardname[]        = "nRF52840";
++static const uint8_t infouCName[]           = "nRF52840";
++static const uint8_t infoRadioName[]        = "nRF52840 SoC";
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++//=========================== private =========================================
++
++#endif
+diff --git a/projects/nrf52840_dk/check_config.h b/projects/nrf52840_dk/check_config.h
+new file mode 100644
+index 00000000..775eafb4
+--- /dev/null
++++ b/projects/nrf52840_dk/check_config.h
+@@ -0,0 +1,121 @@
++#ifndef OPENWSN_CHECK_CONFIG_H
++#define OPENWSN_CHECK_CONFIG_H
++
++#if !defined(PYTHON_BOARD) && \
++    !defined(TELOSB) && \
++    !defined(WSN430V13B) && \
++    !defined(WSN430V14) && \
++    !defined(GINA) && \
++    !defined(Z1) && \
++    !defined(OPENMOTESTM) && \
++    !defined(OPENMOTE_CC2538) && \
++    !defined(OPENMOTE_B) && \
++    !defined(OPENMOTE_B_24GHZ) && \
++    !defined(OPENMOTE_B_SUBGHZ) && \
++    !defined(AGILEFOX) && \
++    !defined(IOTLAB_M3) && \
++    !defined(IOTLAB_A8_M3) && \
++    !defined(SAMR21_XPRO) && \
++    !defined(NRF52840_DK)
++#error 'Board name must be specified to check for configuration errors'
++#endif
++
++#if (defined(OPENMOTE_CC2538) || \
++    defined(OPENMOTE_B) || \
++    defined(OPENMOTE_B_24GHZ) || \
++    defined(OPENMOTE_B_SUBGHZ) || \
++    defined(TELOSB) || \
++    defined(WSN430V13B) || \
++    defined(WSN430V14) || \
++    defined(OPENMOTESTM) || \
++    defined(GINA) || \
++    defined(NRF52840_DK) || \
++    defined(AGILEFOX) || \
++    defined(IOTLAB_M3) || \
++    defined(IOTLAB_A8_M3) || \
++    defined(SAMR21_XPRO) || \
++    defined(Z1)) && \
++    OPENWSN_IEEE802154E_SECURITY_C && \
++    !BOARD_CRYPTOENGINE_ENABLED
++#warning 'Software encryption might be too slow on certain hardware. It is recommend to use BOARD_CRYTPOENGINE_ENABLED where possible.'
++#endif
++
++#if BOARD_CRYPTOENGINE_ENABLED && (\
++    defined(WSN430V13B) || \
++    defined(WSN430V14) || \
++    defined(AGILEFOX) || \
++    defined(GINA) || \
++    defined(NRF52840_DK) || \
++    defined(SAMR21_XPRO) || \
++    defined(Z1) || \
++    defined(OPENMOTESTM))
++#error 'Hardware encryption not supported on this platform.'
++#endif
++
++#if OPENWSN_IEEE802154E_SECURITY_C && !OPENWSN_CJOIN_C
++#error 'Link-layer security requires CJOIN application.'
++#endif
++
++#if defined(PYTHON_BOARD) && BOARD_CRYPTOENGINE_ENABLED
++#error 'Python board does not support hardware acceleration.'
++#endif
++
++#if BOARD_FASTSIM_ENABLED && !defined(PYTHON_BOARD)
++#error 'FASTSIM is only supported in simulation mode.'
++
++#endif
++
++#if !BOARD_FASTSIM_ENABLED && defined(PYTHON_BOARD)
++#warning 'FASTSIM not enabled for UART communication in simulation mode.'
++
++#endif
++
++#if ((IEEE802154E_SINGLE_CHANNEL != 0) && \
++    ((IEEE802154E_SINGLE_CHANNEL < 11) || \
++    (IEEE802154E_SINGLE_CHANNEL > 26)))
++#error 'Illegal value for OPENWSN_IEEE802154E_SINGLE_CHANNEL'
++#endif
++
++#if !OPENWSN_COAP_C && (\
++    OPENWSN_C6T_C || \
++    OPENWSN_CEXAMPLE_C || \
++    OPENWSN_CINFO_C || \
++    OPENWSN_CINFRARED_C || \
++    OPENWSN_CLED_C || \
++    OPENWSN_CSENSORS_C || \
++    OPENWSN_CSTORM_C || \
++    OPENWSN_CWELLKNOWN || \
++    OPENWSN_RRT_C)
++
++#error "A CoAP dependent application is defined, but CoAP is not included in the build."
++#endif
++
++#if OPENWSN_CSENSORS_C && !BOARD_SENSORS_ENABLED
++#error "The CSENSORS app requires the sensor drivers."
++#endif
++
++#if !OPENWSN_UDP_C && (\
++    OPENWSN_UECHO_C || \
++    OPENWSN_UINJECT_C || \
++    OPENWSN_USERIALBRIDGE_C || \
++    OPENWSN_UEXPIRATION_C || \
++    OPENWSN_UEXP_MONITOR)
++
++#error "A UDP dependent application is defined, but UDP is not included in the build."
++#endif
++
++#if !OPENWSN_6LO_FRAGMENTATION_C && (\
++    MAX_PKTSIZE_SUPPORTED || \
++    MAX_NUM_BIGPKTS)
++#error "6LoWPAN fragmentation options specified, but 6LoWPAN fragmentation is not included in the build."
++#endif
++
++#if OPENWSN_CJOIN_C && !OPENWSN_COAP_C
++#error "CJOIN requires the CoAP protocol."
++#endif
++
++#if OPENWSN_COAP_C && !(OPENWSN_UDP_C || OPENWSN_TCP_C)
++#error "CoAP requires a transport layer, i.e. UDP or TCP."
++#endif
++
++#endif /* OPENWSN_CHECK_CONFIG_H */
+diff --git a/projects/nrf52840_dk/cmsis_compiler.h b/projects/nrf52840_dk/cmsis_compiler.h
+new file mode 100644
+index 00000000..adbf296f
+--- /dev/null
++++ b/projects/nrf52840_dk/cmsis_compiler.h
+@@ -0,0 +1,283 @@
++/**************************************************************************//**
++ * @file     cmsis_compiler.h
++ * @brief    CMSIS compiler generic header file
++ * @version  V5.1.0
++ * @date     09. October 2018
++ ******************************************************************************/
++/*
++ * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
++ *
++ * SPDX-License-Identifier: Apache-2.0
++ *
++ * Licensed under the Apache License, Version 2.0 (the License); you may
++ * not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an AS IS BASIS, WITHOUT
++ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#ifndef __CMSIS_COMPILER_H
++#define __CMSIS_COMPILER_H
++
++#include <stdint.h>
++
++/*
++ * Arm Compiler 4/5
++ */
++#if   defined ( __CC_ARM )
++  #include "cmsis_armcc.h"
++
++
++/*
++ * Arm Compiler 6.6 LTM (armclang)
++ */
++#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
++  #include "cmsis_armclang_ltm.h"
++
++  /*
++ * Arm Compiler above 6.10.1 (armclang)
++ */
++#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
++  #include "cmsis_armclang.h"
++
++
++/*
++ * GNU Compiler
++ */
++#elif defined ( __GNUC__ )
++  #include "cmsis_gcc.h"
++
++
++/*
++ * IAR Compiler
++ */
++#elif defined ( __ICCARM__ )
++  #include <cmsis_iccarm.h>
++
++
++/*
++ * TI Arm Compiler
++ */
++#elif defined ( __TI_ARM__ )
++  #include <cmsis_ccs.h>
++
++  #ifndef   __ASM
++    #define __ASM                                  __asm
++  #endif
++  #ifndef   __INLINE
++    #define __INLINE                               inline
++  #endif
++  #ifndef   __STATIC_INLINE
++    #define __STATIC_INLINE                        static inline
++  #endif
++  #ifndef   __STATIC_FORCEINLINE
++    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
++  #endif
++  #ifndef   __NO_RETURN
++    #define __NO_RETURN                            __attribute__((noreturn))
++  #endif
++  #ifndef   __USED
++    #define __USED                                 __attribute__((used))
++  #endif
++  #ifndef   __WEAK
++    #define __WEAK                                 __attribute__((weak))
++  #endif
++  #ifndef   __PACKED
++    #define __PACKED                               __attribute__((packed))
++  #endif
++  #ifndef   __PACKED_STRUCT
++    #define __PACKED_STRUCT                        struct __attribute__((packed))
++  #endif
++  #ifndef   __PACKED_UNION
++    #define __PACKED_UNION                         union __attribute__((packed))
++  #endif
++  #ifndef   __UNALIGNED_UINT32        /* deprecated */
++    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
++    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
++  #endif
++  #ifndef   __UNALIGNED_UINT16_WRITE
++    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
++    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
++  #endif
++  #ifndef   __UNALIGNED_UINT16_READ
++    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
++    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
++  #endif
++  #ifndef   __UNALIGNED_UINT32_WRITE
++    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
++    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
++  #endif
++  #ifndef   __UNALIGNED_UINT32_READ
++    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
++    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
++  #endif
++  #ifndef   __ALIGNED
++    #define __ALIGNED(x)                           __attribute__((aligned(x)))
++  #endif
++  #ifndef   __RESTRICT
++    #define __RESTRICT                             __restrict
++  #endif
++  #ifndef   __COMPILER_BARRIER
++    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
++    #define __COMPILER_BARRIER()                   (void)0
++  #endif
++
++
++/*
++ * TASKING Compiler
++ */
++#elif defined ( __TASKING__ )
++  /*
++   * The CMSIS functions have been implemented as intrinsics in the compiler.
++   * Please use "carm -?i" to get an up to date list of all intrinsics,
++   * Including the CMSIS ones.
++   */
++
++  #ifndef   __ASM
++    #define __ASM                                  __asm
++  #endif
++  #ifndef   __INLINE
++    #define __INLINE                               inline
++  #endif
++  #ifndef   __STATIC_INLINE
++    #define __STATIC_INLINE                        static inline
++  #endif
++  #ifndef   __STATIC_FORCEINLINE
++    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
++  #endif
++  #ifndef   __NO_RETURN
++    #define __NO_RETURN                            __attribute__((noreturn))
++  #endif
++  #ifndef   __USED
++    #define __USED                                 __attribute__((used))
++  #endif
++  #ifndef   __WEAK
++    #define __WEAK                                 __attribute__((weak))
++  #endif
++  #ifndef   __PACKED
++    #define __PACKED                               __packed__
++  #endif
++  #ifndef   __PACKED_STRUCT
++    #define __PACKED_STRUCT                        struct __packed__
++  #endif
++  #ifndef   __PACKED_UNION
++    #define __PACKED_UNION                         union __packed__
++  #endif
++  #ifndef   __UNALIGNED_UINT32        /* deprecated */
++    struct __packed__ T_UINT32 { uint32_t v; };
++    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
++  #endif
++  #ifndef   __UNALIGNED_UINT16_WRITE
++    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
++    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
++  #endif
++  #ifndef   __UNALIGNED_UINT16_READ
++    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
++    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
++  #endif
++  #ifndef   __UNALIGNED_UINT32_WRITE
++    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
++    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
++  #endif
++  #ifndef   __UNALIGNED_UINT32_READ
++    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
++    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
++  #endif
++  #ifndef   __ALIGNED
++    #define __ALIGNED(x)              __align(x)
++  #endif
++  #ifndef   __RESTRICT
++    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
++    #define __RESTRICT
++  #endif
++  #ifndef   __COMPILER_BARRIER
++    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
++    #define __COMPILER_BARRIER()                   (void)0
++  #endif
++
++
++/*
++ * COSMIC Compiler
++ */
++#elif defined ( __CSMC__ )
++   #include <cmsis_csm.h>
++
++ #ifndef   __ASM
++    #define __ASM                                  _asm
++  #endif
++  #ifndef   __INLINE
++    #define __INLINE                               inline
++  #endif
++  #ifndef   __STATIC_INLINE
++    #define __STATIC_INLINE                        static inline
++  #endif
++  #ifndef   __STATIC_FORCEINLINE
++    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
++  #endif
++  #ifndef   __NO_RETURN
++    // NO RETURN is automatically detected hence no warning here
++    #define __NO_RETURN
++  #endif
++  #ifndef   __USED
++    #warning No compiler specific solution for __USED. __USED is ignored.
++    #define __USED
++  #endif
++  #ifndef   __WEAK
++    #define __WEAK                                 __weak
++  #endif
++  #ifndef   __PACKED
++    #define __PACKED                               @packed
++  #endif
++  #ifndef   __PACKED_STRUCT
++    #define __PACKED_STRUCT                        @packed struct
++  #endif
++  #ifndef   __PACKED_UNION
++    #define __PACKED_UNION                         @packed union
++  #endif
++  #ifndef   __UNALIGNED_UINT32        /* deprecated */
++    @packed struct T_UINT32 { uint32_t v; };
++    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
++  #endif
++  #ifndef   __UNALIGNED_UINT16_WRITE
++    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
++    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
++  #endif
++  #ifndef   __UNALIGNED_UINT16_READ
++    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
++    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
++  #endif
++  #ifndef   __UNALIGNED_UINT32_WRITE
++    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
++    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
++  #endif
++  #ifndef   __UNALIGNED_UINT32_READ
++    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
++    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
++  #endif
++  #ifndef   __ALIGNED
++    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
++    #define __ALIGNED(x)
++  #endif
++  #ifndef   __RESTRICT
++    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
++    #define __RESTRICT
++  #endif
++  #ifndef   __COMPILER_BARRIER
++    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
++    #define __COMPILER_BARRIER()                   (void)0
++  #endif
++
++
++#else
++  #error Unknown compiler.
++#endif
++
++
++#endif /* __CMSIS_COMPILER_H */
++
+diff --git a/projects/nrf52840_dk/cmsis_gcc.h b/projects/nrf52840_dk/cmsis_gcc.h
+new file mode 100644
+index 00000000..3ddcc58b
+--- /dev/null
++++ b/projects/nrf52840_dk/cmsis_gcc.h
+@@ -0,0 +1,2168 @@
++/**************************************************************************//**
++ * @file     cmsis_gcc.h
++ * @brief    CMSIS compiler GCC header file
++ * @version  V5.2.0
++ * @date     08. May 2019
++ ******************************************************************************/
++/*
++ * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
++ *
++ * SPDX-License-Identifier: Apache-2.0
++ *
++ * Licensed under the Apache License, Version 2.0 (the License); you may
++ * not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an AS IS BASIS, WITHOUT
++ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#ifndef __CMSIS_GCC_H
++#define __CMSIS_GCC_H
++
++/* ignore some GCC warnings */
++#pragma GCC diagnostic push
++#pragma GCC diagnostic ignored "-Wsign-conversion"
++#pragma GCC diagnostic ignored "-Wconversion"
++#pragma GCC diagnostic ignored "-Wunused-parameter"
++
++/* Fallback for __has_builtin */
++#ifndef __has_builtin
++  #define __has_builtin(x) (0)
++#endif
++
++/* CMSIS compiler specific defines */
++#ifndef   __ASM
++  #define __ASM                                  __asm
++#endif
++#ifndef   __INLINE
++  #define __INLINE                               inline
++#endif
++#ifndef   __STATIC_INLINE
++  #define __STATIC_INLINE                        static inline
++#endif
++#ifndef   __STATIC_FORCEINLINE                 
++  #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
++#endif                                           
++#ifndef   __NO_RETURN
++  #define __NO_RETURN                            __attribute__((__noreturn__))
++#endif
++#ifndef   __USED
++  #define __USED                                 __attribute__((used))
++#endif
++#ifndef   __WEAK
++  #define __WEAK                                 __attribute__((weak))
++#endif
++#ifndef   __PACKED
++  #define __PACKED                               __attribute__((packed, aligned(1)))
++#endif
++#ifndef   __PACKED_STRUCT
++  #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
++#endif
++#ifndef   __PACKED_UNION
++  #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
++#endif
++#ifndef   __UNALIGNED_UINT32        /* deprecated */
++  #pragma GCC diagnostic push
++  #pragma GCC diagnostic ignored "-Wpacked"
++  #pragma GCC diagnostic ignored "-Wattributes"
++  struct __attribute__((packed)) T_UINT32 { uint32_t v; };
++  #pragma GCC diagnostic pop
++  #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
++#endif
++#ifndef   __UNALIGNED_UINT16_WRITE
++  #pragma GCC diagnostic push
++  #pragma GCC diagnostic ignored "-Wpacked"
++  #pragma GCC diagnostic ignored "-Wattributes"
++  __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
++  #pragma GCC diagnostic pop
++  #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
++#endif
++#ifndef   __UNALIGNED_UINT16_READ
++  #pragma GCC diagnostic push
++  #pragma GCC diagnostic ignored "-Wpacked"
++  #pragma GCC diagnostic ignored "-Wattributes"
++  __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
++  #pragma GCC diagnostic pop
++  #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
++#endif
++#ifndef   __UNALIGNED_UINT32_WRITE
++  #pragma GCC diagnostic push
++  #pragma GCC diagnostic ignored "-Wpacked"
++  #pragma GCC diagnostic ignored "-Wattributes"
++  __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
++  #pragma GCC diagnostic pop
++  #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
++#endif
++#ifndef   __UNALIGNED_UINT32_READ
++  #pragma GCC diagnostic push
++  #pragma GCC diagnostic ignored "-Wpacked"
++  #pragma GCC diagnostic ignored "-Wattributes"
++  __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
++  #pragma GCC diagnostic pop
++  #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
++#endif
++#ifndef   __ALIGNED
++  #define __ALIGNED(x)                           __attribute__((aligned(x)))
++#endif
++#ifndef   __RESTRICT
++  #define __RESTRICT                             __restrict
++#endif
++#ifndef   __COMPILER_BARRIER
++  #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
++#endif
++
++/* #########################  Startup and Lowlevel Init  ######################## */
++
++#ifndef __PROGRAM_START
++
++/**
++  \brief   Initializes data and bss sections
++  \details This default implementations initialized all data and additional bss
++           sections relying on .copy.table and .zero.table specified properly
++           in the used linker script.
++  
++ */
++__STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
++{
++  extern void _start(void) __NO_RETURN;
++  
++  typedef struct {
++    uint32_t const* src;
++    uint32_t* dest;
++    uint32_t  wlen;
++  } __copy_table_t;
++  
++  typedef struct {
++    uint32_t* dest;
++    uint32_t  wlen;
++  } __zero_table_t;
++  
++  extern const __copy_table_t __copy_table_start__;
++  extern const __copy_table_t __copy_table_end__;
++  extern const __zero_table_t __zero_table_start__;
++  extern const __zero_table_t __zero_table_end__;
++
++  for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable) {
++    for(uint32_t i=0u; i<pTable->wlen; ++i) {
++      pTable->dest[i] = pTable->src[i];
++    }
++  }
++ 
++  for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable) {
++    for(uint32_t i=0u; i<pTable->wlen; ++i) {
++      pTable->dest[i] = 0u;
++    }
++  }
++ 
++  _start();
++}
++  
++#define __PROGRAM_START           __cmsis_start
++#endif
++
++#ifndef __INITIAL_SP
++#define __INITIAL_SP              __StackTop
++#endif
++
++#ifndef __STACK_LIMIT
++#define __STACK_LIMIT             __StackLimit
++#endif
++
++#ifndef __VECTOR_TABLE
++#define __VECTOR_TABLE            __Vectors
++#endif
++
++#ifndef __VECTOR_TABLE_ATTRIBUTE
++#define __VECTOR_TABLE_ATTRIBUTE  __attribute((used, section(".vectors")))
++#endif
++
++/* ###########################  Core Function Access  ########################### */
++/** \ingroup  CMSIS_Core_FunctionInterface
++    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
++  @{
++ */
++
++/**
++  \brief   Enable IRQ Interrupts
++  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
++           Can only be executed in Privileged modes.
++ */
++__STATIC_FORCEINLINE void __enable_irq(void)
++{
++  __ASM volatile ("cpsie i" : : : "memory");
++}
++
++
++/**
++  \brief   Disable IRQ Interrupts
++  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
++           Can only be executed in Privileged modes.
++ */
++__STATIC_FORCEINLINE void __disable_irq(void)
++{
++  __ASM volatile ("cpsid i" : : : "memory");
++}
++
++
++/**
++  \brief   Get Control Register
++  \details Returns the content of the Control Register.
++  \return               Control Register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, control" : "=r" (result) );
++  return(result);
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Get Control Register (non-secure)
++  \details Returns the content of the non-secure Control Register when in secure mode.
++  \return               non-secure Control Register value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
++  return(result);
++}
++#endif
++
++
++/**
++  \brief   Set Control Register
++  \details Writes the given value to the Control Register.
++  \param [in]    control  Control Register value to set
++ */
++__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
++{
++  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Set Control Register (non-secure)
++  \details Writes the given value to the non-secure Control Register when in secure state.
++  \param [in]    control  Control Register value to set
++ */
++__STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
++{
++  __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
++}
++#endif
++
++
++/**
++  \brief   Get IPSR Register
++  \details Returns the content of the IPSR Register.
++  \return               IPSR Register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
++  return(result);
++}
++
++
++/**
++  \brief   Get APSR Register
++  \details Returns the content of the APSR Register.
++  \return               APSR Register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_APSR(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
++  return(result);
++}
++
++
++/**
++  \brief   Get xPSR Register
++  \details Returns the content of the xPSR Register.
++  \return               xPSR Register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_xPSR(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
++  return(result);
++}
++
++
++/**
++  \brief   Get Process Stack Pointer
++  \details Returns the current value of the Process Stack Pointer (PSP).
++  \return               PSP Register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_PSP(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
++  return(result);
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Get Process Stack Pointer (non-secure)
++  \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure state.
++  \return               PSP Register value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
++  return(result);
++}
++#endif
++
++
++/**
++  \brief   Set Process Stack Pointer
++  \details Assigns the given value to the Process Stack Pointer (PSP).
++  \param [in]    topOfProcStack  Process Stack Pointer value to set
++ */
++__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
++{
++  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Set Process Stack Pointer (non-secure)
++  \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure state.
++  \param [in]    topOfProcStack  Process Stack Pointer value to set
++ */
++__STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
++{
++  __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
++}
++#endif
++
++
++/**
++  \brief   Get Main Stack Pointer
++  \details Returns the current value of the Main Stack Pointer (MSP).
++  \return               MSP Register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_MSP(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, msp" : "=r" (result) );
++  return(result);
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Get Main Stack Pointer (non-secure)
++  \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure state.
++  \return               MSP Register value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
++  return(result);
++}
++#endif
++
++
++/**
++  \brief   Set Main Stack Pointer
++  \details Assigns the given value to the Main Stack Pointer (MSP).
++  \param [in]    topOfMainStack  Main Stack Pointer value to set
++ */
++__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
++{
++  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Set Main Stack Pointer (non-secure)
++  \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
++  \param [in]    topOfMainStack  Main Stack Pointer value to set
++ */
++__STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
++{
++  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
++}
++#endif
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Get Stack Pointer (non-secure)
++  \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
++  \return               SP Register value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
++  return(result);
++}
++
++
++/**
++  \brief   Set Stack Pointer (non-secure)
++  \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
++  \param [in]    topOfStack  Stack Pointer value to set
++ */
++__STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
++{
++  __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
++}
++#endif
++
++
++/**
++  \brief   Get Priority Mask
++  \details Returns the current state of the priority mask bit from the Priority Mask Register.
++  \return               Priority Mask value
++ */
++__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
++  return(result);
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Get Priority Mask (non-secure)
++  \details Returns the current state of the non-secure priority mask bit from the Priority Mask Register when in secure state.
++  \return               Priority Mask value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
++  return(result);
++}
++#endif
++
++
++/**
++  \brief   Set Priority Mask
++  \details Assigns the given value to the Priority Mask Register.
++  \param [in]    priMask  Priority Mask
++ */
++__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
++{
++  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Set Priority Mask (non-secure)
++  \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
++  \param [in]    priMask  Priority Mask
++ */
++__STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
++{
++  __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
++}
++#endif
++
++
++#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
++     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
++     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
++/**
++  \brief   Enable FIQ
++  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
++           Can only be executed in Privileged modes.
++ */
++__STATIC_FORCEINLINE void __enable_fault_irq(void)
++{
++  __ASM volatile ("cpsie f" : : : "memory");
++}
++
++
++/**
++  \brief   Disable FIQ
++  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
++           Can only be executed in Privileged modes.
++ */
++__STATIC_FORCEINLINE void __disable_fault_irq(void)
++{
++  __ASM volatile ("cpsid f" : : : "memory");
++}
++
++
++/**
++  \brief   Get Base Priority
++  \details Returns the current value of the Base Priority register.
++  \return               Base Priority register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
++  return(result);
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Get Base Priority (non-secure)
++  \details Returns the current value of the non-secure Base Priority register when in secure state.
++  \return               Base Priority register value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
++  return(result);
++}
++#endif
++
++
++/**
++  \brief   Set Base Priority
++  \details Assigns the given value to the Base Priority register.
++  \param [in]    basePri  Base Priority value to set
++ */
++__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
++{
++  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Set Base Priority (non-secure)
++  \details Assigns the given value to the non-secure Base Priority register when in secure state.
++  \param [in]    basePri  Base Priority value to set
++ */
++__STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
++{
++  __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
++}
++#endif
++
++
++/**
++  \brief   Set Base Priority with condition
++  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
++           or the new value increases the BASEPRI priority level.
++  \param [in]    basePri  Base Priority value to set
++ */
++__STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
++{
++  __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
++}
++
++
++/**
++  \brief   Get Fault Mask
++  \details Returns the current value of the Fault Mask register.
++  \return               Fault Mask register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
++  return(result);
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Get Fault Mask (non-secure)
++  \details Returns the current value of the non-secure Fault Mask register when in secure state.
++  \return               Fault Mask register value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
++{
++  uint32_t result;
++
++  __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
++  return(result);
++}
++#endif
++
++
++/**
++  \brief   Set Fault Mask
++  \details Assigns the given value to the Fault Mask register.
++  \param [in]    faultMask  Fault Mask value to set
++ */
++__STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
++{
++  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Set Fault Mask (non-secure)
++  \details Assigns the given value to the non-secure Fault Mask register when in secure state.
++  \param [in]    faultMask  Fault Mask value to set
++ */
++__STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
++{
++  __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
++}
++#endif
++
++#endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
++           (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
++           (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
++
++
++#if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
++     (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
++
++/**
++  \brief   Get Process Stack Pointer Limit
++  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
++  Stack Pointer Limit register hence zero is returned always in non-secure
++  mode.
++  
++  \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
++  \return               PSPLIM Register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
++{
++#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
++    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
++    // without main extensions, the non-secure PSPLIM is RAZ/WI
++  return 0U;
++#else
++  uint32_t result;
++  __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
++  return result;
++#endif
++}
++
++#if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
++/**
++  \brief   Get Process Stack Pointer Limit (non-secure)
++  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
++  Stack Pointer Limit register hence zero is returned always.
++
++  \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.
++  \return               PSPLIM Register value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
++{
++#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
++  // without main extensions, the non-secure PSPLIM is RAZ/WI
++  return 0U;
++#else
++  uint32_t result;
++  __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
++  return result;
++#endif
++}
++#endif
++
++
++/**
++  \brief   Set Process Stack Pointer Limit
++  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
++  Stack Pointer Limit register hence the write is silently ignored in non-secure
++  mode.
++  
++  \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
++  \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
++ */
++__STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
++{
++#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
++    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
++  // without main extensions, the non-secure PSPLIM is RAZ/WI
++  (void)ProcStackPtrLimit;
++#else
++  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
++#endif
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
++/**
++  \brief   Set Process Stack Pointer (non-secure)
++  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
++  Stack Pointer Limit register hence the write is silently ignored.
++
++  \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in secure state.
++  \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
++ */
++__STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
++{
++#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
++  // without main extensions, the non-secure PSPLIM is RAZ/WI
++  (void)ProcStackPtrLimit;
++#else
++  __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
++#endif
++}
++#endif
++
++
++/**
++  \brief   Get Main Stack Pointer Limit
++  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
++  Stack Pointer Limit register hence zero is returned always in non-secure
++  mode.
++
++  \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
++  \return               MSPLIM Register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
++{
++#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
++    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
++  // without main extensions, the non-secure MSPLIM is RAZ/WI
++  return 0U;
++#else
++  uint32_t result;
++  __ASM volatile ("MRS %0, msplim" : "=r" (result) );
++  return result;
++#endif
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
++/**
++  \brief   Get Main Stack Pointer Limit (non-secure)
++  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
++  Stack Pointer Limit register hence zero is returned always.
++
++  \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in secure state.
++  \return               MSPLIM Register value
++ */
++__STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
++{
++#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
++  // without main extensions, the non-secure MSPLIM is RAZ/WI
++  return 0U;
++#else
++  uint32_t result;
++  __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
++  return result;
++#endif
++}
++#endif
++
++
++/**
++  \brief   Set Main Stack Pointer Limit
++  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
++  Stack Pointer Limit register hence the write is silently ignored in non-secure
++  mode.
++
++  \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
++  \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
++ */
++__STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
++{
++#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
++    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
++  // without main extensions, the non-secure MSPLIM is RAZ/WI
++  (void)MainStackPtrLimit;
++#else
++  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
++#endif
++}
++
++
++#if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
++/**
++  \brief   Set Main Stack Pointer Limit (non-secure)
++  Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
++  Stack Pointer Limit register hence the write is silently ignored.
++
++  \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secure state.
++  \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
++ */
++__STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
++{
++#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
++  // without main extensions, the non-secure MSPLIM is RAZ/WI
++  (void)MainStackPtrLimit;
++#else
++  __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
++#endif
++}
++#endif
++
++#endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
++           (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
++
++
++/**
++  \brief   Get FPSCR
++  \details Returns the current value of the Floating Point Status/Control register.
++  \return               Floating Point Status/Control register value
++ */
++__STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
++{
++#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
++     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
++#if __has_builtin(__builtin_arm_get_fpscr) 
++// Re-enable using built-in when GCC has been fixed
++// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
++  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
++  return __builtin_arm_get_fpscr();
++#else
++  uint32_t result;
++
++  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
++  return(result);
++#endif
++#else
++  return(0U);
++#endif
++}
++
++
++/**
++  \brief   Set FPSCR
++  \details Assigns the given value to the Floating Point Status/Control register.
++  \param [in]    fpscr  Floating Point Status/Control value to set
++ */
++__STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
++{
++#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
++     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
++#if __has_builtin(__builtin_arm_set_fpscr)
++// Re-enable using built-in when GCC has been fixed
++// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
++  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
++  __builtin_arm_set_fpscr(fpscr);
++#else
++  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
++#endif
++#else
++  (void)fpscr;
++#endif
++}
++
++
++/*@} end of CMSIS_Core_RegAccFunctions */
++
++
++/* ##########################  Core Instruction Access  ######################### */
++/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
++  Access to dedicated instructions
++  @{
++*/
++
++/* Define macros for porting to both thumb1 and thumb2.
++ * For thumb1, use low register (r0-r7), specified by constraint "l"
++ * Otherwise, use general registers, specified by constraint "r" */
++#if defined (__thumb__) && !defined (__thumb2__)
++#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
++#define __CMSIS_GCC_RW_REG(r) "+l" (r)
++#define __CMSIS_GCC_USE_REG(r) "l" (r)
++#else
++#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
++#define __CMSIS_GCC_RW_REG(r) "+r" (r)
++#define __CMSIS_GCC_USE_REG(r) "r" (r)
++#endif
++
++/**
++  \brief   No Operation
++  \details No Operation does nothing. This instruction can be used for code alignment purposes.
++ */
++#define __NOP()                             __ASM volatile ("nop")
++
++/**
++  \brief   Wait For Interrupt
++  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
++ */
++#define __WFI()                             __ASM volatile ("wfi")
++
++
++/**
++  \brief   Wait For Event
++  \details Wait For Event is a hint instruction that permits the processor to enter
++           a low-power state until one of a number of events occurs.
++ */
++#define __WFE()                             __ASM volatile ("wfe")
++
++
++/**
++  \brief   Send Event
++  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
++ */
++#define __SEV()                             __ASM volatile ("sev")
++
++
++/**
++  \brief   Instruction Synchronization Barrier
++  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
++           so that all instructions following the ISB are fetched from cache or memory,
++           after the instruction has been completed.
++ */
++__STATIC_FORCEINLINE void __ISB(void)
++{
++  __ASM volatile ("isb 0xF":::"memory");
++}
++
++
++/**
++  \brief   Data Synchronization Barrier
++  \details Acts as a special kind of Data Memory Barrier.
++           It completes when all explicit memory accesses before this instruction complete.
++ */
++__STATIC_FORCEINLINE void __DSB(void)
++{
++  __ASM volatile ("dsb 0xF":::"memory");
++}
++
++
++/**
++  \brief   Data Memory Barrier
++  \details Ensures the apparent order of the explicit memory operations before
++           and after the instruction, without ensuring their completion.
++ */
++__STATIC_FORCEINLINE void __DMB(void)
++{
++  __ASM volatile ("dmb 0xF":::"memory");
++}
++
++
++/**
++  \brief   Reverse byte order (32 bit)
++  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
++  \param [in]    value  Value to reverse
++  \return               Reversed value
++ */
++__STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
++{
++#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
++  return __builtin_bswap32(value);
++#else
++  uint32_t result;
++
++  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
++  return result;
++#endif
++}
++
++
++/**
++  \brief   Reverse byte order (16 bit)
++  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
++  \param [in]    value  Value to reverse
++  \return               Reversed value
++ */
++__STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
++{
++  uint32_t result;
++
++  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
++  return result;
++}
++
++
++/**
++  \brief   Reverse byte order (16 bit)
++  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
++  \param [in]    value  Value to reverse
++  \return               Reversed value
++ */
++__STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
++{
++#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
++  return (int16_t)__builtin_bswap16(value);
++#else
++  int16_t result;
++
++  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
++  return result;
++#endif
++}
++
++
++/**
++  \brief   Rotate Right in unsigned value (32 bit)
++  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
++  \param [in]    op1  Value to rotate
++  \param [in]    op2  Number of Bits to rotate
++  \return               Rotated value
++ */
++__STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
++{
++  op2 %= 32U;
++  if (op2 == 0U)
++  {
++    return op1;
++  }
++  return (op1 >> op2) | (op1 << (32U - op2));
++}
++
++
++/**
++  \brief   Breakpoint
++  \details Causes the processor to enter Debug state.
++           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
++  \param [in]    value  is ignored by the processor.
++                 If required, a debugger can use it to store additional information about the breakpoint.
++ */
++#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
++
++
++/**
++  \brief   Reverse bit order of value
++  \details Reverses the bit order of the given value.
++  \param [in]    value  Value to reverse
++  \return               Reversed value
++ */
++__STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
++{
++  uint32_t result;
++
++#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
++     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
++     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
++   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
++#else
++  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
++
++  result = value;                      /* r will be reversed bits of v; first get LSB of v */
++  for (value >>= 1U; value != 0U; value >>= 1U)
++  {
++    result <<= 1U;
++    result |= value & 1U;
++    s--;
++  }
++  result <<= s;                        /* shift when v's highest bits are zero */
++#endif
++  return result;
++}
++
++
++/**
++  \brief   Count leading zeros
++  \details Counts the number of leading zeros of a data value.
++  \param [in]  value  Value to count the leading zeros
++  \return             number of leading zeros in value
++ */
++__STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)
++{
++  /* Even though __builtin_clz produces a CLZ instruction on ARM, formally
++     __builtin_clz(0) is undefined behaviour, so handle this case specially.
++     This guarantees ARM-compatible results if happening to compile on a non-ARM
++     target, and ensures the compiler doesn't decide to activate any
++     optimisations using the logic "value was passed to __builtin_clz, so it
++     is non-zero".
++     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
++     single CLZ instruction.
++   */
++  if (value == 0U)
++  {
++    return 32U;
++  }
++  return __builtin_clz(value);
++}
++
++
++#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
++     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
++     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
++     (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
++/**
++  \brief   LDR Exclusive (8 bit)
++  \details Executes a exclusive LDR instruction for 8 bit value.
++  \param [in]    ptr  Pointer to data
++  \return             value of type uint8_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
++{
++    uint32_t result;
++
++#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
++   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
++#else
++    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
++       accepted by assembler. So has to use following less efficient pattern.
++    */
++   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
++#endif
++   return ((uint8_t) result);    /* Add explicit type cast here */
++}
++
++
++/**
++  \brief   LDR Exclusive (16 bit)
++  \details Executes a exclusive LDR instruction for 16 bit values.
++  \param [in]    ptr  Pointer to data
++  \return        value of type uint16_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint16_t __LDREXH(volatile uint16_t *addr)
++{
++    uint32_t result;
++
++#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
++   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
++#else
++    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
++       accepted by assembler. So has to use following less efficient pattern.
++    */
++   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
++#endif
++   return ((uint16_t) result);    /* Add explicit type cast here */
++}
++
++
++/**
++  \brief   LDR Exclusive (32 bit)
++  \details Executes a exclusive LDR instruction for 32 bit values.
++  \param [in]    ptr  Pointer to data
++  \return        value of type uint32_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
++{
++    uint32_t result;
++
++   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
++   return(result);
++}
++
++
++/**
++  \brief   STR Exclusive (8 bit)
++  \details Executes a exclusive STR instruction for 8 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++  \return          0  Function succeeded
++  \return          1  Function failed
++ */
++__STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
++{
++   uint32_t result;
++
++   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
++   return(result);
++}
++
++
++/**
++  \brief   STR Exclusive (16 bit)
++  \details Executes a exclusive STR instruction for 16 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++  \return          0  Function succeeded
++  \return          1  Function failed
++ */
++__STATIC_FORCEINLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
++{
++   uint32_t result;
++
++   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
++   return(result);
++}
++
++
++/**
++  \brief   STR Exclusive (32 bit)
++  \details Executes a exclusive STR instruction for 32 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++  \return          0  Function succeeded
++  \return          1  Function failed
++ */
++__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
++{
++   uint32_t result;
++
++   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
++   return(result);
++}
++
++
++/**
++  \brief   Remove the exclusive lock
++  \details Removes the exclusive lock which is created by LDREX.
++ */
++__STATIC_FORCEINLINE void __CLREX(void)
++{
++  __ASM volatile ("clrex" ::: "memory");
++}
++
++#endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
++           (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
++           (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
++           (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
++
++
++#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
++     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
++     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
++/**
++  \brief   Signed Saturate
++  \details Saturates a signed value.
++  \param [in]  ARG1  Value to be saturated
++  \param [in]  ARG2  Bit position to saturate to (1..32)
++  \return             Saturated value
++ */
++#define __SSAT(ARG1,ARG2) \
++__extension__ \
++({                          \
++  int32_t __RES, __ARG1 = (ARG1); \
++  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
++  __RES; \
++ })
++
++
++/**
++  \brief   Unsigned Saturate
++  \details Saturates an unsigned value.
++  \param [in]  ARG1  Value to be saturated
++  \param [in]  ARG2  Bit position to saturate to (0..31)
++  \return             Saturated value
++ */
++#define __USAT(ARG1,ARG2) \
++ __extension__ \
++({                          \
++  uint32_t __RES, __ARG1 = (ARG1); \
++  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
++  __RES; \
++ })
++
++
++/**
++  \brief   Rotate Right with Extend (32 bit)
++  \details Moves each bit of a bitstring right by one bit.
++           The carry input is shifted in at the left end of the bitstring.
++  \param [in]    value  Value to rotate
++  \return               Rotated value
++ */
++__STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)
++{
++  uint32_t result;
++
++  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
++  return(result);
++}
++
++
++/**
++  \brief   LDRT Unprivileged (8 bit)
++  \details Executes a Unprivileged LDRT instruction for 8 bit value.
++  \param [in]    ptr  Pointer to data
++  \return             value of type uint8_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)
++{
++    uint32_t result;
++
++#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
++   __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*ptr) );
++#else
++    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
++       accepted by assembler. So has to use following less efficient pattern.
++    */
++   __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (ptr) : "memory" );
++#endif
++   return ((uint8_t) result);    /* Add explicit type cast here */
++}
++
++
++/**
++  \brief   LDRT Unprivileged (16 bit)
++  \details Executes a Unprivileged LDRT instruction for 16 bit values.
++  \param [in]    ptr  Pointer to data
++  \return        value of type uint16_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)
++{
++    uint32_t result;
++
++#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
++   __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*ptr) );
++#else
++    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
++       accepted by assembler. So has to use following less efficient pattern.
++    */
++   __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (ptr) : "memory" );
++#endif
++   return ((uint16_t) result);    /* Add explicit type cast here */
++}
++
++
++/**
++  \brief   LDRT Unprivileged (32 bit)
++  \details Executes a Unprivileged LDRT instruction for 32 bit values.
++  \param [in]    ptr  Pointer to data
++  \return        value of type uint32_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)
++{
++    uint32_t result;
++
++   __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*ptr) );
++   return(result);
++}
++
++
++/**
++  \brief   STRT Unprivileged (8 bit)
++  \details Executes a Unprivileged STRT instruction for 8 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++ */
++__STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)
++{
++   __ASM volatile ("strbt %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
++}
++
++
++/**
++  \brief   STRT Unprivileged (16 bit)
++  \details Executes a Unprivileged STRT instruction for 16 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++ */
++__STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)
++{
++   __ASM volatile ("strht %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
++}
++
++
++/**
++  \brief   STRT Unprivileged (32 bit)
++  \details Executes a Unprivileged STRT instruction for 32 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++ */
++__STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)
++{
++   __ASM volatile ("strt %1, %0" : "=Q" (*ptr) : "r" (value) );
++}
++
++#else  /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
++           (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
++           (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
++
++/**
++  \brief   Signed Saturate
++  \details Saturates a signed value.
++  \param [in]  value  Value to be saturated
++  \param [in]    sat  Bit position to saturate to (1..32)
++  \return             Saturated value
++ */
++__STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)
++{
++  if ((sat >= 1U) && (sat <= 32U))
++  {
++    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
++    const int32_t min = -1 - max ;
++    if (val > max)
++    {
++      return max;
++    }
++    else if (val < min)
++    {
++      return min;
++    }
++  }
++  return val;
++}
++
++/**
++  \brief   Unsigned Saturate
++  \details Saturates an unsigned value.
++  \param [in]  value  Value to be saturated
++  \param [in]    sat  Bit position to saturate to (0..31)
++  \return             Saturated value
++ */
++__STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)
++{
++  if (sat <= 31U)
++  {
++    const uint32_t max = ((1U << sat) - 1U);
++    if (val > (int32_t)max)
++    {
++      return max;
++    }
++    else if (val < 0)
++    {
++      return 0U;
++    }
++  }
++  return (uint32_t)val;
++}
++
++#endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
++           (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
++           (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
++
++
++#if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
++     (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
++/**
++  \brief   Load-Acquire (8 bit)
++  \details Executes a LDAB instruction for 8 bit value.
++  \param [in]    ptr  Pointer to data
++  \return             value of type uint8_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)
++{
++    uint32_t result;
++
++   __ASM volatile ("ldab %0, %1" : "=r" (result) : "Q" (*ptr) );
++   return ((uint8_t) result);
++}
++
++
++/**
++  \brief   Load-Acquire (16 bit)
++  \details Executes a LDAH instruction for 16 bit values.
++  \param [in]    ptr  Pointer to data
++  \return        value of type uint16_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)
++{
++    uint32_t result;
++
++   __ASM volatile ("ldah %0, %1" : "=r" (result) : "Q" (*ptr) );
++   return ((uint16_t) result);
++}
++
++
++/**
++  \brief   Load-Acquire (32 bit)
++  \details Executes a LDA instruction for 32 bit values.
++  \param [in]    ptr  Pointer to data
++  \return        value of type uint32_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)
++{
++    uint32_t result;
++
++   __ASM volatile ("lda %0, %1" : "=r" (result) : "Q" (*ptr) );
++   return(result);
++}
++
++
++/**
++  \brief   Store-Release (8 bit)
++  \details Executes a STLB instruction for 8 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++ */
++__STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)
++{
++   __ASM volatile ("stlb %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
++}
++
++
++/**
++  \brief   Store-Release (16 bit)
++  \details Executes a STLH instruction for 16 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++ */
++__STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)
++{
++   __ASM volatile ("stlh %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
++}
++
++
++/**
++  \brief   Store-Release (32 bit)
++  \details Executes a STL instruction for 32 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++ */
++__STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)
++{
++   __ASM volatile ("stl %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
++}
++
++
++/**
++  \brief   Load-Acquire Exclusive (8 bit)
++  \details Executes a LDAB exclusive instruction for 8 bit value.
++  \param [in]    ptr  Pointer to data
++  \return             value of type uint8_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint8_t __LDAEXB(volatile uint8_t *ptr)
++{
++    uint32_t result;
++
++   __ASM volatile ("ldaexb %0, %1" : "=r" (result) : "Q" (*ptr) );
++   return ((uint8_t) result);
++}
++
++
++/**
++  \brief   Load-Acquire Exclusive (16 bit)
++  \details Executes a LDAH exclusive instruction for 16 bit values.
++  \param [in]    ptr  Pointer to data
++  \return        value of type uint16_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint16_t __LDAEXH(volatile uint16_t *ptr)
++{
++    uint32_t result;
++
++   __ASM volatile ("ldaexh %0, %1" : "=r" (result) : "Q" (*ptr) );
++   return ((uint16_t) result);
++}
++
++
++/**
++  \brief   Load-Acquire Exclusive (32 bit)
++  \details Executes a LDA exclusive instruction for 32 bit values.
++  \param [in]    ptr  Pointer to data
++  \return        value of type uint32_t at (*ptr)
++ */
++__STATIC_FORCEINLINE uint32_t __LDAEX(volatile uint32_t *ptr)
++{
++    uint32_t result;
++
++   __ASM volatile ("ldaex %0, %1" : "=r" (result) : "Q" (*ptr) );
++   return(result);
++}
++
++
++/**
++  \brief   Store-Release Exclusive (8 bit)
++  \details Executes a STLB exclusive instruction for 8 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++  \return          0  Function succeeded
++  \return          1  Function failed
++ */
++__STATIC_FORCEINLINE uint32_t __STLEXB(uint8_t value, volatile uint8_t *ptr)
++{
++   uint32_t result;
++
++   __ASM volatile ("stlexb %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) );
++   return(result);
++}
++
++
++/**
++  \brief   Store-Release Exclusive (16 bit)
++  \details Executes a STLH exclusive instruction for 16 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++  \return          0  Function succeeded
++  \return          1  Function failed
++ */
++__STATIC_FORCEINLINE uint32_t __STLEXH(uint16_t value, volatile uint16_t *ptr)
++{
++   uint32_t result;
++
++   __ASM volatile ("stlexh %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) );
++   return(result);
++}
++
++
++/**
++  \brief   Store-Release Exclusive (32 bit)
++  \details Executes a STL exclusive instruction for 32 bit values.
++  \param [in]  value  Value to store
++  \param [in]    ptr  Pointer to location
++  \return          0  Function succeeded
++  \return          1  Function failed
++ */
++__STATIC_FORCEINLINE uint32_t __STLEX(uint32_t value, volatile uint32_t *ptr)
++{
++   uint32_t result;
++
++   __ASM volatile ("stlex %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) );
++   return(result);
++}
++
++#endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
++           (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
++
++/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
++
++
++/* ###################  Compiler specific Intrinsics  ########################### */
++/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
++  Access to dedicated SIMD instructions
++  @{
++*/
++
++#if (defined (__ARM_FEATURE_DSP) && (__ARM_FEATURE_DSP == 1))
++
++__STATIC_FORCEINLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++
++__STATIC_FORCEINLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++
++__STATIC_FORCEINLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
++{
++  uint32_t result;
++
++  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
++  return(result);
++}
++
++#define __SSAT16(ARG1,ARG2) \
++({                          \
++  int32_t __RES, __ARG1 = (ARG1); \
++  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
++  __RES; \
++ })
++
++#define __USAT16(ARG1,ARG2) \
++({                          \
++  uint32_t __RES, __ARG1 = (ARG1); \
++  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
++  __RES; \
++ })
++
++__STATIC_FORCEINLINE uint32_t __UXTB16(uint32_t op1)
++{
++  uint32_t result;
++
++  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SXTB16(uint32_t op1)
++{
++  uint32_t result;
++
++  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
++{
++  uint32_t result;
++
++  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
++{
++  uint32_t result;
++
++  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint64_t __SMLALD (uint32_t op1, uint32_t op2, uint64_t acc)
++{
++  union llreg_u{
++    uint32_t w32[2];
++    uint64_t w64;
++  } llr;
++  llr.w64 = acc;
++
++#ifndef __ARMEB__   /* Little endian */
++  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
++#else               /* Big endian */
++  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
++#endif
++
++  return(llr.w64);
++}
++
++__STATIC_FORCEINLINE uint64_t __SMLALDX (uint32_t op1, uint32_t op2, uint64_t acc)
++{
++  union llreg_u{
++    uint32_t w32[2];
++    uint64_t w64;
++  } llr;
++  llr.w64 = acc;
++
++#ifndef __ARMEB__   /* Little endian */
++  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
++#else               /* Big endian */
++  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
++#endif
++
++  return(llr.w64);
++}
++
++__STATIC_FORCEINLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
++{
++  uint32_t result;
++
++  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
++{
++  uint32_t result;
++
++  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE uint64_t __SMLSLD (uint32_t op1, uint32_t op2, uint64_t acc)
++{
++  union llreg_u{
++    uint32_t w32[2];
++    uint64_t w64;
++  } llr;
++  llr.w64 = acc;
++
++#ifndef __ARMEB__   /* Little endian */
++  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
++#else               /* Big endian */
++  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
++#endif
++
++  return(llr.w64);
++}
++
++__STATIC_FORCEINLINE uint64_t __SMLSLDX (uint32_t op1, uint32_t op2, uint64_t acc)
++{
++  union llreg_u{
++    uint32_t w32[2];
++    uint64_t w64;
++  } llr;
++  llr.w64 = acc;
++
++#ifndef __ARMEB__   /* Little endian */
++  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
++#else               /* Big endian */
++  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
++#endif
++
++  return(llr.w64);
++}
++
++__STATIC_FORCEINLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
++{
++  uint32_t result;
++
++  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE  int32_t __QADD( int32_t op1,  int32_t op2)
++{
++  int32_t result;
++
++  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++__STATIC_FORCEINLINE  int32_t __QSUB( int32_t op1,  int32_t op2)
++{
++  int32_t result;
++
++  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
++  return(result);
++}
++
++#if 0
++#define __PKHBT(ARG1,ARG2,ARG3) \
++({                          \
++  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
++  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
++  __RES; \
++ })
++
++#define __PKHTB(ARG1,ARG2,ARG3) \
++({                          \
++  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
++  if (ARG3 == 0) \
++    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
++  else \
++    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
++  __RES; \
++ })
++#endif
++
++#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
++                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
++
++#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
++                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
++
++__STATIC_FORCEINLINE int32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
++{
++ int32_t result;
++
++ __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
++ return(result);
++}
++
++#endif /* (__ARM_FEATURE_DSP == 1) */
++/*@} end of group CMSIS_SIMD_intrinsics */
++
++
++#pragma GCC diagnostic pop
++
++#endif /* __CMSIS_GCC_H */
+diff --git a/projects/nrf52840_dk/cmsis_version.h b/projects/nrf52840_dk/cmsis_version.h
+new file mode 100644
+index 00000000..f2e27466
+--- /dev/null
++++ b/projects/nrf52840_dk/cmsis_version.h
+@@ -0,0 +1,39 @@
++/**************************************************************************//**
++ * @file     cmsis_version.h
++ * @brief    CMSIS Core(M) Version definitions
++ * @version  V5.0.3
++ * @date     24. June 2019
++ ******************************************************************************/
++/*
++ * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
++ *
++ * SPDX-License-Identifier: Apache-2.0
++ *
++ * Licensed under the Apache License, Version 2.0 (the License); you may
++ * not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an AS IS BASIS, WITHOUT
++ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#if   defined ( __ICCARM__ )
++  #pragma system_include         /* treat file as system include file for MISRA check */
++#elif defined (__clang__)
++  #pragma clang system_header   /* treat file as system include file */
++#endif
++
++#ifndef __CMSIS_VERSION_H
++#define __CMSIS_VERSION_H
++
++/*  CMSIS Version definitions */
++#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
++#define __CM_CMSIS_VERSION_SUB   ( 3U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
++#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
++                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
++#endif
+diff --git a/projects/nrf52840_dk/compiler_abstraction.h b/projects/nrf52840_dk/compiler_abstraction.h
+new file mode 100644
+index 00000000..0ffec65a
+--- /dev/null
++++ b/projects/nrf52840_dk/compiler_abstraction.h
+@@ -0,0 +1,264 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#ifndef _COMPILER_ABSTRACTION_H
++#define _COMPILER_ABSTRACTION_H
++
++/*lint ++flb "Enter library region" */
++
++#ifndef NRF_STRING_CONCATENATE_IMPL
++    #define NRF_STRING_CONCATENATE_IMPL(lhs, rhs) lhs ## rhs
++#endif
++#ifndef NRF_STRING_CONCATENATE
++    #define NRF_STRING_CONCATENATE(lhs, rhs) NRF_STRING_CONCATENATE_IMPL(lhs, rhs)
++#endif
++
++#if defined ( __CC_ARM )
++
++    #ifndef __ASM
++        #define __ASM               __asm
++    #endif
++
++    #ifndef __INLINE
++        #define __INLINE            __inline
++    #endif
++
++    #ifndef __WEAK
++        #define __WEAK              __weak
++    #endif
++
++    #ifndef __ALIGN
++        #define __ALIGN(n)          __align(n)
++    #endif
++
++    #ifndef __PACKED
++        #define __PACKED            __packed
++    #endif
++
++    #ifndef __UNUSED
++        #define __UNUSED            __attribute__((unused))
++    #endif
++
++    #define GET_SP()                __current_sp()
++
++    #ifndef NRF_STATIC_ASSERT
++        #define NRF_STATIC_ASSERT(cond, msg) \
++            ;enum { NRF_STRING_CONCATENATE(static_assert_on_line_, __LINE__) = 1 / (!!(cond)) }
++    #endif
++    
++#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
++
++    #ifndef __ASM
++        #define __ASM               __asm
++    #endif
++
++    #ifndef __INLINE
++        #define __INLINE            __inline
++    #endif
++
++    #ifndef __WEAK
++        #define __WEAK              __attribute__((weak))
++    #endif
++
++    #ifndef __ALIGN
++        #define __ALIGN(n)          __attribute__((aligned(n)))
++    #endif
++
++    #ifndef __PACKED
++        #define __PACKED            __attribute__((packed, aligned(1)))
++    #endif
++
++    #ifndef __UNUSED
++        #define __UNUSED            __attribute__((unused))
++    #endif
++
++    #define GET_SP()                __current_sp()
++
++    #ifndef NRF_STATIC_ASSERT
++        #ifdef __cplusplus
++            #ifndef _Static_assert
++                #define _Static_assert static_assert
++            #endif
++        #endif
++        #define NRF_STATIC_ASSERT(cond, msg) _Static_assert(cond, msg)
++    #endif
++
++#elif defined ( __ICCARM__ )
++
++    #ifndef __ASM
++        #define __ASM               __asm
++    #endif
++
++    #ifndef __INLINE
++        #define __INLINE            inline
++    #endif
++
++    #ifndef __WEAK
++        #define __WEAK              __weak
++    #endif
++
++    #if (__VER__ >= 8000000)
++        #ifndef __ALIGN
++            #define __ALIGN(n) __attribute__((aligned(x)))
++        #endif
++
++        #ifndef   __PACKED
++            #define __PACKED __attribute__((packed, aligned(1)))
++        #endif
++    #else
++        #ifndef __ALIGN
++            #define STRING_PRAGMA(x) _Pragma(#x)
++            #define __ALIGN(n) STRING_PRAGMA(data_alignment = n)
++        #endif
++
++        #ifndef   __PACKED
++            #define __PACKED __packed
++        #endif
++    #endif
++
++    #ifndef __UNUSED
++        #define __UNUSED
++    #endif
++    
++    #define GET_SP()                __get_SP()
++
++    #ifndef NRF_STATIC_ASSERT
++        #define NRF_STATIC_ASSERT(cond, msg) static_assert(cond, msg)
++    #endif
++
++#elif defined   ( __GNUC__ ) ||  defined   ( __clang__ )
++
++    #ifndef __ASM
++        #define __ASM               __asm
++    #endif
++
++    #ifndef __INLINE
++        #define __INLINE            inline
++    #endif
++
++    #ifndef __WEAK
++        #define __WEAK              __attribute__((weak))
++    #endif
++
++    #ifndef __ALIGN
++        #define __ALIGN(n)          __attribute__((aligned(n)))
++    #endif
++
++    #ifndef __PACKED
++        #define __PACKED           __attribute__((packed)) 
++    #endif
++
++    #ifndef __UNUSED
++        #define __UNUSED            __attribute__((unused))
++    #endif
++
++    #define GET_SP()                gcc_current_sp()
++
++    static inline unsigned int gcc_current_sp(void)
++    {
++        unsigned int stack_pointer = 0;
++        __asm__ __volatile__ ("mov %0, sp" : "=r"(stack_pointer));
++        return stack_pointer;
++    }
++
++    #ifndef NRF_STATIC_ASSERT
++        #ifdef __cplusplus
++            #ifndef _Static_assert
++                #define _Static_assert static_assert
++            #endif
++        #endif
++        #define NRF_STATIC_ASSERT(cond, msg) _Static_assert(cond, msg)
++    #endif
++
++#elif defined   ( __TASKING__ )
++
++    #ifndef __ASM
++        #define __ASM               __asm
++    #endif
++
++    #ifndef __INLINE
++        #define __INLINE            inline
++    #endif
++
++    #ifndef __WEAK
++        #define __WEAK              __attribute__((weak))
++    #endif
++
++    #ifndef __ALIGN
++        #define __ALIGN(n)          __align(n)
++    #endif
++    
++    /* Not defined for TASKING. */
++    #ifndef __PACKED
++        #define __PACKED
++    #endif
++
++    #ifndef __UNUSED
++        #define __UNUSED            __attribute__((unused))
++    #endif
++
++    #define GET_SP()                __get_MSP()
++
++    #ifndef NRF_STATIC_ASSERT
++        #define NRF_STATIC_ASSERT(cond, msg) static_assert(cond, msg)
++    #endif
++
++#endif
++
++#define NRF_MDK_VERSION_ASSERT_AT_LEAST(major, minor, micro) \
++    NRF_STATIC_ASSERT( \
++        ( \
++            (major < MDK_MAJOR_VERSION) || \
++            (major == MDK_MAJOR_VERSION && minor < MDK_MINOR_VERSION) || \
++            (major == MDK_MAJOR_VERSION && minor == MDK_MINOR_VERSION && micro < MDK_MICRO_VERSION) \
++        ), "MDK version mismatch.")
++
++#define NRF_MDK_VERSION_ASSERT_EXACT(major, minor, micro) \
++    NRF_STATIC_ASSERT( \
++        ( \
++            (major != MDK_MAJOR_VERSION) || \
++            (major != MDK_MAJOR_VERSION) || \
++            (major != MDK_MAJOR_VERSION) \
++        ), "MDK version mismatch.")
++
++/*lint --flb "Leave library region" */
++
++#endif
+diff --git a/projects/nrf52840_dk/config.h b/projects/nrf52840_dk/config.h
+new file mode 100644
+index 00000000..20960d74
+--- /dev/null
++++ b/projects/nrf52840_dk/config.h
+@@ -0,0 +1,459 @@
++#ifndef OPENWSN_CONFIG_H
++#define OPENWSN_CONFIG_H
++
++// =========================== Debugging ============================
++
++/**
++ * \def OPENWSN_DEBUG_LEVEL
++ *
++ * Specifies the debugging level used in the OpenWSN stack.
++ * - level 0: no logging
++ * - level 1: only critical logs
++ * - level 2: critical and error logs
++ * - level 3: critical, error, and success
++ * - level 4: critical, error, success, and warning
++ * - level 5: critical, error, success, warning, and info
++ * - level 6: critical, error, success, warning, info, and verbose
++ *
++ */
++#ifndef OPENWSN_DEBUG_LEVEL
++#define OPENWSN_DEBUG_LEVEL         6
++#endif
++
++// ========================== Applications ==========================
++
++/**
++ * \def OPENWSN_C6T_C
++ *
++ * Application that allows direct manipulation of the 6top scheduling.
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_C6T_C
++#define OPENWSN_C6T_C (0)
++#endif
++
++/**
++ * \def OPENWSN_CEXAMPLE_C
++ *
++ * A CoAP example application. It periodically sends a random string of numbers.
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_CEXAMPLE_C
++#define OPENWSN_CEXAMPLE_C (0)
++#endif
++
++/**
++ * \def OPENWSN_CINFO_C
++ *
++ * CoAP application which responds with information about the OpenWSN version running on the board.
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_CINFO_C
++#define OPENWSN_CINFO_C (0)
++#endif
++
++/**
++ * \def OPENWSN_CINFRARED_C
++ *
++ * A CoAP infrared application.
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_CINFRARED_C
++#define OPENWSN_CINFRARED_C (0)
++#endif
++
++/**
++ * \def OPENWSN_CLED_C
++ *
++ * CoAP application that exposes the leds of the board as a CoAP resource.
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_CLED_C
++#define OPENWSN_CLED_C (0)
++#endif
++
++/**
++ * \def OPENWSN_CSENSORS_C
++ *
++ * A CoAP resource which allows an application to GET/SET the state of sensors.
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_CSENSORS_C
++#define OPENWSN_CSENSORS_C (0)
++#endif
++
++/**
++ * \def OPENWSN_CSTORM_C
++ *
++ *
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_CSTORM_C
++#define OPENWSN_CSTORM_C (0)
++#endif
++
++/**
++ * \def OPENWSN_CWELLKNOWN_C
++ *
++ * Implements the CoAP .wellknown endpoint on a mote.
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_CWELLKNOWN_C
++#define OPENWSN_CWELLKNOWN_C (0)
++#endif
++
++/**
++ * \def OPENWSN_RRT_C
++ *
++ * A CoAP application.
++ *
++ * Requires: OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_RRT_C
++#define OPENWSN_RRT_C (0)
++#endif
++
++/**
++ * \def OPENWSN_UECHO_C
++ *
++ * An echo application (server side) that sits directly on top of UDP.
++ *
++ * Requires: OPENWSN_UDP_C
++ *
++ */
++#ifndef OPENWSN_UECHO_C
++#define OPENWSN_UECHO_C (0)
++#endif
++
++/**
++ * \def OPENWSN_UEXPIRATION_C
++ *
++ *
++ *
++ * Requires: OPENWSN_UDP_C
++ *
++ */
++#ifndef OPENWSN_UEXPIRATION_C
++#define OPENWSN_UEXPIRATION_C (0)
++#endif
++
++/**
++ * \def OPENWSN_UEXP_MONITOR_C
++ *
++ *
++ *
++ * Requires: OPENWSN_UDP_C
++ *
++ */
++#ifndef OPENWSN_UEXP_MONITOR_C
++#define OPENWSN_UEXP_MONITOR_C (0)
++#endif
++
++/**
++ * \def OPENWSN_UINJECT_C
++ *
++ * Application that creates UDP traffic and injects it in the network.
++ *
++ * Requires: OPENWSN_UDP_C
++ *
++ */
++#ifndef OPENWSN_UINJECT_C
++#define OPENWSN_UINJECT_C (0)
++#endif
++
++/**
++ * \def OPENWSN_USERIALBRIDGE_C
++ *
++ * Requires: OPENWSN_UDP_C
++ *
++ */
++#ifndef OPENWSN_USERIALBRIDGE_C
++#define OPENWSN_USERIALBRIDGE_C (0)
++#endif
++
++/**
++ * \def OPENWSN_CJOIN_C
++ *
++ * The CJOIN protocol performs a secure joining and install link-layer keys
++ *
++ * Requires: OPENWSN_UDP_C, OPENWSN_COAP_C
++ *
++ */
++#ifndef OPENWSN_CJOIN_C
++#define OPENWSN_CJOIN_C (0)
++#endif
++
++// ======================= OpenWeb configuration =======================
++
++/**
++ * \def OPENWSN_COAP_C
++ *
++ * Implementation of the CoAP protocol.
++ *
++ * Requires: OPENWSN_UDP_C
++ *
++ */
++#ifndef OPENWSN_COAP_C
++#define OPENWSN_COAP_C (0)
++#endif
++
++/**
++ * \def OPENWSN_COAP_PORT_DEFAULT
++ *
++ * Defines the default port to use for COAP
++ *
++ */
++#ifndef OPENWSN_COAP_PORT_DEFAULT
++#define OPENWSN_COAP_PORT_DEFAULT   (5683)
++#endif
++
++// ========================== Stack modules ===========================
++
++/**
++ * \def OPENWSN_UDP_C
++ *
++ * Implementation of the UDP protocol.
++ *
++ */
++#ifndef OPENWSN_UDP_C
++#define OPENWSN_UDP_C (0)
++#endif
++
++/**
++ * \def OPENWSN_6LO_FRAGMENTATION_C
++ *
++ * Implements 6LoWPAN fragmentation.
++ *
++ * Configuration options:
++ *  - MAX_PKTSIZE_SUPPORTED: defines the maximum IPV6 packet size (header + payload) the mote supports. Default
++ *  value is 1320. This corresponds to a 40-byte IPv6 header + the minimal IPv6 MTU of 1280 bytes.
++ *  - MAX_NUM_BIGPKTS: defines how many static buffer space will be allocated for processing large packets.
++ *
++ */
++#ifndef OPENWSN_6LO_FRAGMENTATION_C
++#define OPENWSN_6LO_FRAGMENTATION_C (0)
++#endif
++
++#if OPENWSN_6LO_FRAGMENTATION_C
++#ifndef MAX_PKTSIZE_SUPPORTED
++#define MAX_PKTSIZE_SUPPORTED   1320
++#endif
++#ifndef MAX_NUM_BIGPKTS
++#define MAX_NUM_BIGPKTS         2
++#endif
++#endif
++
++/**
++ * \def OPENWSN_ICMPV6ECHO_C
++ *
++ * Enables the icmpv6 echo (ping) functionality
++ */
++#ifndef OPENWSN_ICMPV6ECHO_C
++#define OPENWSN_ICMPV6ECHO_C (0)
++#endif
++
++
++/**
++ * \def OPENWSN_IEEE802154E_SECURITY_C
++ *
++ * Enables link-layer security. When this is enabled you should also use BOARD_CRYPTOENGINE_ENABLED where possible.
++ *
++ * Requires: OPENWSN_CJOIN_C, OPENWSN_COAP_C, OPENWSN_UDP_C
++ */
++#ifndef OPENWSN_IEEE802154E_SECURITY_C
++#define OPENWSN_IEEE802154E_SECURITY_C (0)
++#endif
++
++
++/**
++ * \def OPENWSN_FORCETOPOLOGY_C
++ *
++ * Force the networks topology according the code in topology.c
++ *
++ */
++#ifndef OPENWSN_FORCETOPOLOGY_C
++#define OPENWSN_FORCETOPOLOGY_C (0)
++#endif
++
++
++/**
++ * \def OPENWSN_ADAPTIVESYNC_C
++ *
++ * Force the networks topology according the code in topology.c
++ *
++ */
++#ifndef OPENWSN_ADAPTIVE_SYNC_C
++#define OPENWSN_ADAPTIVE_SYNC_C (0)
++#endif
++
++
++// ========================== Stack configuration ===========================
++
++/**
++ * \def DEADLINE_OPTION
++ *
++ * Activates IPv6 DEADLINE OPTION.
++ *
++ */
++#ifndef DEADLINE_OPTION
++#define DEADLINE_OPTION (0)
++#endif
++
++/**
++ * \def ADAPTIVE_MSF
++ *
++ * Allow the MSF algorithm to dynamically remove and allocate slots, based on the traffic load in the network.
++ *
++ * Configuration options:
++ *  - MSF_MAX_NUMCELLS: cell usage is calculated every MSF_MAX_NUMCELLS elapsed cells.
++ *  - MSF_LIM_NUMCELLSUSED_HIGH: if cell usage is above this value, trigger 6P to add a single cell to the selected parent
++ *  - MSF_LIM_NUMCELLSUSED_LOW: if cell usage is below this value, trigger 6P to remove a single cell to the selected parent
++ */
++#ifndef ADAPTIVE_MSF
++#define ADAPTIVE_MSF (0)
++#endif
++
++#if ADAPTIVE_MSF
++#ifndef MSF_MAX_NUMCELLS
++#define MSF_MAX_NUMCELLS            32
++#endif
++#ifndef MSF_LIM_NUMCELLSUSED_HIGH
++#define MSF_LIM_NUMCELLSUSED_HIGH   24
++#endif
++#ifndef MSF_LIM_NUMCELLSUSED_HIGH
++#define MSF_LIM_NUMCELLSUSED_HIGH   8
++#endif
++#endif
++
++/**
++ * \def IEEE802154E_SINGLE_CHANNEL
++ *
++ * Sets channel to a fixed value (acceptable values are [11 - 26] and [0])
++ * When the channel is set to 0, frequency hopping is enabled, otherwise a single channel is used.
++ *
++ */
++#ifndef IEEE802154E_SINGLE_CHANNEL
++#define IEEE802154E_SINGLE_CHANNEL      0
++#endif
++
++/**
++ * \def PACKETQUEUE_LENGTH
++ *
++ * Specifies the size of the packet queue. Large queue sizes are required to support fragmentation but significantly
++ * increase RAM usage.
++ *
++ */
++#ifndef PACKETQUEUE_LENGTH
++#define PACKETQUEUE_LENGTH              20
++#endif
++
++/**
++ * \def DAGROOT
++ *
++ * Set this mote as the DODAG root.
++ *
++ */
++#ifndef DAGROOT
++#define DAGROOT (0)
++#endif
++
++/**
++ * \def DAGROOT
++ *
++ * Set this mote as the DODAG root.
++ *
++ */
++#ifndef PANID_DEFINED
++#define PANID_DEFINED   (0xcafe)
++#endif
++
++// ======================== Board configuration ========================
++
++/**
++ * \def BOARD_CRYPTOENGINE_ENABLED
++ *
++ * Enable AES hardware acceleration. This options is only available on boards that support hardware acceleration. It
++ * cannot be combined with the python board.
++ *
++ */
++#ifndef BOARD_CRYPTOENGINE_ENABLED
++#define BOARD_CRYPTOENGINE_ENABLED (0)
++#endif
++
++/**
++ * \def BOARD_OPENSERIAL_PRINTF
++ *
++ * Enable usage of openserial_printf function to print strings over the serial port.
++ * WARNING: this feature links in nano.specs and nosys.specs adding roughly 3Kb of Flash usage.
++ *
++ */
++#ifndef BOARD_OPENSERIAL_PRINTF
++#define BOARD_OPENSERIAL_PRINTF (0)
++#endif
++
++
++/**
++ * \def BOARD_OPENSERIAL_SNIFFER
++ *
++ * Prints sniffed packet over serial.
++ *
++ */
++#ifndef BOARD_OPENSERIAL_SNIFFER
++#define BOARD_OPENSERIAL_SNIFFER (0)
++#endif
++
++
++/**
++ * \def BOARD_SENSORS_ENABLED
++ *
++ * Includes the sensor driver
++ *
++ */
++#ifndef BOARD_SENSORS_ENABLED
++#define BOARD_SENSORS_ENABLED (0)
++#endif
++
++/**
++ * \def BOARD_FASTSIM_ENABLED
++ *
++ * Enables fast UART printing in simulation mode. Active by default.
++ *
++ */
++#if !defined(BOARD_FASTSIM_ENABLED) && defined(PYTHON_BOARD)
++#define BOARD_FASTSIM_ENABLED (1)
++#else
++#define BOARD_FASTSIM_ENABLED (0)
++#endif
++
++// ======================== Kernel configuration ========================
++
++/**
++ * \def SCHEDULER_DEBUG_ENABLE
++ *
++ * Enables storing of scheduler debug variables (scheduler_debug_vars)
++ *
++ */
++#ifndef SCHEDULER_DEBUG_ENABLE
++#define SCHEDULER_DEBUG_ENABLE (0)
++#endif
++
++#include "check_config.h"
++
++#endif /* OPENWSN_CONFIG_H */
+diff --git a/projects/nrf52840_dk/core_cm4.h b/projects/nrf52840_dk/core_cm4.h
+new file mode 100644
+index 00000000..12c023b8
+--- /dev/null
++++ b/projects/nrf52840_dk/core_cm4.h
+@@ -0,0 +1,2124 @@
++/**************************************************************************//**
++ * @file     core_cm4.h
++ * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
++ * @version  V5.1.0
++ * @date     13. March 2019
++ ******************************************************************************/
++/*
++ * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
++ *
++ * SPDX-License-Identifier: Apache-2.0
++ *
++ * Licensed under the Apache License, Version 2.0 (the License); you may
++ * not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an AS IS BASIS, WITHOUT
++ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#if   defined ( __ICCARM__ )
++  #pragma system_include         /* treat file as system include file for MISRA check */
++#elif defined (__clang__)
++  #pragma clang system_header   /* treat file as system include file */
++#endif
++
++#ifndef __CORE_CM4_H_GENERIC
++#define __CORE_CM4_H_GENERIC
++
++#include <stdint.h>
++
++#ifdef __cplusplus
++ extern "C" {
++#endif
++
++/**
++  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
++  CMSIS violates the following MISRA-C:2004 rules:
++
++   \li Required Rule 8.5, object/function definition in header file.<br>
++     Function definitions in header files are used to allow 'inlining'.
++
++   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
++     Unions are used for effective representation of core registers.
++
++   \li Advisory Rule 19.7, Function-like macro defined.<br>
++     Function-like macros are used to allow more efficient code.
++ */
++
++
++/*******************************************************************************
++ *                 CMSIS definitions
++ ******************************************************************************/
++/**
++  \ingroup Cortex_M4
++  @{
++ */
++
++#include "cmsis_version.h"
++
++/* CMSIS CM4 definitions */
++#define __CM4_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
++#define __CM4_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
++#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16U) | \
++                                    __CM4_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
++
++#define __CORTEX_M                (4U)                                   /*!< Cortex-M Core */
++
++/** __FPU_USED indicates whether an FPU is used or not.
++    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
++*/
++#if defined ( __CC_ARM )
++  #if defined __TARGET_FPU_VFP
++    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
++      #define __FPU_USED       1U
++    #else
++      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
++      #define __FPU_USED       0U
++    #endif
++  #else
++    #define __FPU_USED         0U
++  #endif
++
++#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
++  #if defined __ARM_FP
++    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
++      #define __FPU_USED       1U
++    #else
++      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
++      #define __FPU_USED       0U
++    #endif
++  #else
++    #define __FPU_USED         0U
++  #endif
++
++#elif defined ( __GNUC__ )
++  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
++    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
++      #define __FPU_USED       1U
++    #else
++      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
++      #define __FPU_USED       0U
++    #endif
++  #else
++    #define __FPU_USED         0U
++  #endif
++
++#elif defined ( __ICCARM__ )
++  #if defined __ARMVFP__
++    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
++      #define __FPU_USED       1U
++    #else
++      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
++      #define __FPU_USED       0U
++    #endif
++  #else
++    #define __FPU_USED         0U
++  #endif
++
++#elif defined ( __TI_ARM__ )
++  #if defined __TI_VFP_SUPPORT__
++    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
++      #define __FPU_USED       1U
++    #else
++      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
++      #define __FPU_USED       0U
++    #endif
++  #else
++    #define __FPU_USED         0U
++  #endif
++
++#elif defined ( __TASKING__ )
++  #if defined __FPU_VFP__
++    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
++      #define __FPU_USED       1U
++    #else
++      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
++      #define __FPU_USED       0U
++    #endif
++  #else
++    #define __FPU_USED         0U
++  #endif
++
++#elif defined ( __CSMC__ )
++  #if ( __CSMC__ & 0x400U)
++    #if defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)
++      #define __FPU_USED       1U
++    #else
++      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
++      #define __FPU_USED       0U
++    #endif
++  #else
++    #define __FPU_USED         0U
++  #endif
++
++#endif
++
++#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
++
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* __CORE_CM4_H_GENERIC */
++
++#ifndef __CMSIS_GENERIC
++
++#ifndef __CORE_CM4_H_DEPENDANT
++#define __CORE_CM4_H_DEPENDANT
++
++#ifdef __cplusplus
++ extern "C" {
++#endif
++
++/* check device defines and use defaults */
++#if defined __CHECK_DEVICE_DEFINES
++  #ifndef __CM4_REV
++    #define __CM4_REV               0x0000U
++    #warning "__CM4_REV not defined in device header file; using default!"
++  #endif
++
++  #ifndef __FPU_PRESENT
++    #define __FPU_PRESENT             0U
++    #warning "__FPU_PRESENT not defined in device header file; using default!"
++  #endif
++
++  #ifndef __MPU_PRESENT
++    #define __MPU_PRESENT             0U
++    #warning "__MPU_PRESENT not defined in device header file; using default!"
++  #endif
++
++  #ifndef __NVIC_PRIO_BITS
++    #define __NVIC_PRIO_BITS          3U
++    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
++  #endif
++
++  #ifndef __Vendor_SysTickConfig
++    #define __Vendor_SysTickConfig    0U
++    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
++  #endif
++#endif
++
++/* IO definitions (access restrictions to peripheral registers) */
++/**
++    \defgroup CMSIS_glob_defs CMSIS Global Defines
++
++    <strong>IO Type Qualifiers</strong> are used
++    \li to specify the access to peripheral variables.
++    \li for automatic generation of peripheral register debug information.
++*/
++#ifdef __cplusplus
++  #define   __I     volatile             /*!< Defines 'read only' permissions */
++#else
++  #define   __I     volatile const       /*!< Defines 'read only' permissions */
++#endif
++#define     __O     volatile             /*!< Defines 'write only' permissions */
++#define     __IO    volatile             /*!< Defines 'read / write' permissions */
++
++/* following defines should be used for structure members */
++#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
++#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
++#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
++
++/*@} end of group Cortex_M4 */
++
++
++
++/*******************************************************************************
++ *                 Register Abstraction
++  Core Register contain:
++  - Core Register
++  - Core NVIC Register
++  - Core SCB Register
++  - Core SysTick Register
++  - Core Debug Register
++  - Core MPU Register
++  - Core FPU Register
++ ******************************************************************************/
++/**
++  \defgroup CMSIS_core_register Defines and Type Definitions
++  \brief Type definitions and defines for Cortex-M processor based devices.
++*/
++
++/**
++  \ingroup    CMSIS_core_register
++  \defgroup   CMSIS_CORE  Status and Control Registers
++  \brief      Core Register type definitions.
++  @{
++ */
++
++/**
++  \brief  Union type to access the Application Program Status Register (APSR).
++ */
++typedef union
++{
++  struct
++  {
++    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved */
++    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
++    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved */
++    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
++    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
++    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
++    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
++    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
++  } b;                                   /*!< Structure used for bit  access */
++  uint32_t w;                            /*!< Type      used for word access */
++} APSR_Type;
++
++/* APSR Register Definitions */
++#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
++#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
++
++#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
++#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
++
++#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
++#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
++
++#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
++#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
++
++#define APSR_Q_Pos                         27U                                            /*!< APSR: Q Position */
++#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
++
++#define APSR_GE_Pos                        16U                                            /*!< APSR: GE Position */
++#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
++
++
++/**
++  \brief  Union type to access the Interrupt Program Status Register (IPSR).
++ */
++typedef union
++{
++  struct
++  {
++    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
++    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
++  } b;                                   /*!< Structure used for bit  access */
++  uint32_t w;                            /*!< Type      used for word access */
++} IPSR_Type;
++
++/* IPSR Register Definitions */
++#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
++#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
++
++
++/**
++  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
++ */
++typedef union
++{
++  struct
++  {
++    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
++    uint32_t _reserved0:1;               /*!< bit:      9  Reserved */
++    uint32_t ICI_IT_1:6;                 /*!< bit: 10..15  ICI/IT part 1 */
++    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags */
++    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved */
++    uint32_t T:1;                        /*!< bit:     24  Thumb bit */
++    uint32_t ICI_IT_2:2;                 /*!< bit: 25..26  ICI/IT part 2 */
++    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag */
++    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
++    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
++    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
++    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
++  } b;                                   /*!< Structure used for bit  access */
++  uint32_t w;                            /*!< Type      used for word access */
++} xPSR_Type;
++
++/* xPSR Register Definitions */
++#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
++#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
++
++#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
++#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
++
++#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
++#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
++
++#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
++#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
++
++#define xPSR_Q_Pos                         27U                                            /*!< xPSR: Q Position */
++#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
++
++#define xPSR_ICI_IT_2_Pos                  25U                                            /*!< xPSR: ICI/IT part 2 Position */
++#define xPSR_ICI_IT_2_Msk                  (3UL << xPSR_ICI_IT_2_Pos)                     /*!< xPSR: ICI/IT part 2 Mask */
++
++#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
++#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
++
++#define xPSR_GE_Pos                        16U                                            /*!< xPSR: GE Position */
++#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
++
++#define xPSR_ICI_IT_1_Pos                  10U                                            /*!< xPSR: ICI/IT part 1 Position */
++#define xPSR_ICI_IT_1_Msk                  (0x3FUL << xPSR_ICI_IT_1_Pos)                  /*!< xPSR: ICI/IT part 1 Mask */
++
++#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
++#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
++
++
++/**
++  \brief  Union type to access the Control Registers (CONTROL).
++ */
++typedef union
++{
++  struct
++  {
++    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
++    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
++    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag */
++    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved */
++  } b;                                   /*!< Structure used for bit  access */
++  uint32_t w;                            /*!< Type      used for word access */
++} CONTROL_Type;
++
++/* CONTROL Register Definitions */
++#define CONTROL_FPCA_Pos                    2U                                            /*!< CONTROL: FPCA Position */
++#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
++
++#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
++#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
++
++#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
++#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
++
++/*@} end of group CMSIS_CORE */
++
++
++/**
++  \ingroup    CMSIS_core_register
++  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
++  \brief      Type definitions for the NVIC Registers
++  @{
++ */
++
++/**
++  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
++ */
++typedef struct
++{
++  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
++        uint32_t RESERVED0[24U];
++  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
++        uint32_t RESERVED1[24U];
++  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
++        uint32_t RESERVED2[24U];
++  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
++        uint32_t RESERVED3[24U];
++  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
++        uint32_t RESERVED4[56U];
++  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
++        uint32_t RESERVED5[644U];
++  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
++}  NVIC_Type;
++
++/* Software Triggered Interrupt Register Definitions */
++#define NVIC_STIR_INTID_Pos                 0U                                         /*!< STIR: INTLINESNUM Position */
++#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
++
++/*@} end of group CMSIS_NVIC */
++
++
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_SCB     System Control Block (SCB)
++  \brief    Type definitions for the System Control Block Registers
++  @{
++ */
++
++/**
++  \brief  Structure type to access the System Control Block (SCB).
++ */
++typedef struct
++{
++  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
++  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
++  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
++  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
++  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
++  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
++  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
++  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
++  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
++  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
++  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
++  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
++  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
++  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
++  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
++  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
++  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
++  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
++  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
++        uint32_t RESERVED0[5U];
++  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
++} SCB_Type;
++
++/* SCB CPUID Register Definitions */
++#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
++#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
++
++#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
++#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
++
++#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
++#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
++
++#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
++#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
++
++#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
++#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
++
++/* SCB Interrupt Control State Register Definitions */
++#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
++#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
++
++#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
++#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
++
++#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
++#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
++
++#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
++#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
++
++#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
++#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
++
++#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
++#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
++
++#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
++#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
++
++#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
++#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
++
++#define SCB_ICSR_RETTOBASE_Pos             11U                                            /*!< SCB ICSR: RETTOBASE Position */
++#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
++
++#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
++#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
++
++/* SCB Vector Table Offset Register Definitions */
++#define SCB_VTOR_TBLOFF_Pos                 7U                                            /*!< SCB VTOR: TBLOFF Position */
++#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
++
++/* SCB Application Interrupt and Reset Control Register Definitions */
++#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
++#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
++
++#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
++#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
++
++#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
++#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
++
++#define SCB_AIRCR_PRIGROUP_Pos              8U                                            /*!< SCB AIRCR: PRIGROUP Position */
++#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
++
++#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
++#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
++
++#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
++#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
++
++#define SCB_AIRCR_VECTRESET_Pos             0U                                            /*!< SCB AIRCR: VECTRESET Position */
++#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
++
++/* SCB System Control Register Definitions */
++#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
++#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
++
++#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
++#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
++
++#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
++#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
++
++/* SCB Configuration Control Register Definitions */
++#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
++#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
++
++#define SCB_CCR_BFHFNMIGN_Pos               8U                                            /*!< SCB CCR: BFHFNMIGN Position */
++#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
++
++#define SCB_CCR_DIV_0_TRP_Pos               4U                                            /*!< SCB CCR: DIV_0_TRP Position */
++#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
++
++#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
++#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
++
++#define SCB_CCR_USERSETMPEND_Pos            1U                                            /*!< SCB CCR: USERSETMPEND Position */
++#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
++
++#define SCB_CCR_NONBASETHRDENA_Pos          0U                                            /*!< SCB CCR: NONBASETHRDENA Position */
++#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
++
++/* SCB System Handler Control and State Register Definitions */
++#define SCB_SHCSR_USGFAULTENA_Pos          18U                                            /*!< SCB SHCSR: USGFAULTENA Position */
++#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
++
++#define SCB_SHCSR_BUSFAULTENA_Pos          17U                                            /*!< SCB SHCSR: BUSFAULTENA Position */
++#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
++
++#define SCB_SHCSR_MEMFAULTENA_Pos          16U                                            /*!< SCB SHCSR: MEMFAULTENA Position */
++#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
++
++#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
++#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
++
++#define SCB_SHCSR_BUSFAULTPENDED_Pos       14U                                            /*!< SCB SHCSR: BUSFAULTPENDED Position */
++#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
++
++#define SCB_SHCSR_MEMFAULTPENDED_Pos       13U                                            /*!< SCB SHCSR: MEMFAULTPENDED Position */
++#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
++
++#define SCB_SHCSR_USGFAULTPENDED_Pos       12U                                            /*!< SCB SHCSR: USGFAULTPENDED Position */
++#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
++
++#define SCB_SHCSR_SYSTICKACT_Pos           11U                                            /*!< SCB SHCSR: SYSTICKACT Position */
++#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
++
++#define SCB_SHCSR_PENDSVACT_Pos            10U                                            /*!< SCB SHCSR: PENDSVACT Position */
++#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
++
++#define SCB_SHCSR_MONITORACT_Pos            8U                                            /*!< SCB SHCSR: MONITORACT Position */
++#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
++
++#define SCB_SHCSR_SVCALLACT_Pos             7U                                            /*!< SCB SHCSR: SVCALLACT Position */
++#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
++
++#define SCB_SHCSR_USGFAULTACT_Pos           3U                                            /*!< SCB SHCSR: USGFAULTACT Position */
++#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
++
++#define SCB_SHCSR_BUSFAULTACT_Pos           1U                                            /*!< SCB SHCSR: BUSFAULTACT Position */
++#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
++
++#define SCB_SHCSR_MEMFAULTACT_Pos           0U                                            /*!< SCB SHCSR: MEMFAULTACT Position */
++#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
++
++/* SCB Configurable Fault Status Register Definitions */
++#define SCB_CFSR_USGFAULTSR_Pos            16U                                            /*!< SCB CFSR: Usage Fault Status Register Position */
++#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
++
++#define SCB_CFSR_BUSFAULTSR_Pos             8U                                            /*!< SCB CFSR: Bus Fault Status Register Position */
++#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
++
++#define SCB_CFSR_MEMFAULTSR_Pos             0U                                            /*!< SCB CFSR: Memory Manage Fault Status Register Position */
++#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
++
++/* MemManage Fault Status Register (part of SCB Configurable Fault Status Register) */
++#define SCB_CFSR_MMARVALID_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 7U)               /*!< SCB CFSR (MMFSR): MMARVALID Position */
++#define SCB_CFSR_MMARVALID_Msk             (1UL << SCB_CFSR_MMARVALID_Pos)                /*!< SCB CFSR (MMFSR): MMARVALID Mask */
++
++#define SCB_CFSR_MLSPERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 5U)               /*!< SCB CFSR (MMFSR): MLSPERR Position */
++#define SCB_CFSR_MLSPERR_Msk               (1UL << SCB_CFSR_MLSPERR_Pos)                  /*!< SCB CFSR (MMFSR): MLSPERR Mask */
++
++#define SCB_CFSR_MSTKERR_Pos               (SCB_SHCSR_MEMFAULTACT_Pos + 4U)               /*!< SCB CFSR (MMFSR): MSTKERR Position */
++#define SCB_CFSR_MSTKERR_Msk               (1UL << SCB_CFSR_MSTKERR_Pos)                  /*!< SCB CFSR (MMFSR): MSTKERR Mask */
++
++#define SCB_CFSR_MUNSTKERR_Pos             (SCB_SHCSR_MEMFAULTACT_Pos + 3U)               /*!< SCB CFSR (MMFSR): MUNSTKERR Position */
++#define SCB_CFSR_MUNSTKERR_Msk             (1UL << SCB_CFSR_MUNSTKERR_Pos)                /*!< SCB CFSR (MMFSR): MUNSTKERR Mask */
++
++#define SCB_CFSR_DACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 1U)               /*!< SCB CFSR (MMFSR): DACCVIOL Position */
++#define SCB_CFSR_DACCVIOL_Msk              (1UL << SCB_CFSR_DACCVIOL_Pos)                 /*!< SCB CFSR (MMFSR): DACCVIOL Mask */
++
++#define SCB_CFSR_IACCVIOL_Pos              (SCB_SHCSR_MEMFAULTACT_Pos + 0U)               /*!< SCB CFSR (MMFSR): IACCVIOL Position */
++#define SCB_CFSR_IACCVIOL_Msk              (1UL /*<< SCB_CFSR_IACCVIOL_Pos*/)             /*!< SCB CFSR (MMFSR): IACCVIOL Mask */
++
++/* BusFault Status Register (part of SCB Configurable Fault Status Register) */
++#define SCB_CFSR_BFARVALID_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 7U)                  /*!< SCB CFSR (BFSR): BFARVALID Position */
++#define SCB_CFSR_BFARVALID_Msk            (1UL << SCB_CFSR_BFARVALID_Pos)                 /*!< SCB CFSR (BFSR): BFARVALID Mask */
++
++#define SCB_CFSR_LSPERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 5U)                  /*!< SCB CFSR (BFSR): LSPERR Position */
++#define SCB_CFSR_LSPERR_Msk               (1UL << SCB_CFSR_LSPERR_Pos)                    /*!< SCB CFSR (BFSR): LSPERR Mask */
++
++#define SCB_CFSR_STKERR_Pos               (SCB_CFSR_BUSFAULTSR_Pos + 4U)                  /*!< SCB CFSR (BFSR): STKERR Position */
++#define SCB_CFSR_STKERR_Msk               (1UL << SCB_CFSR_STKERR_Pos)                    /*!< SCB CFSR (BFSR): STKERR Mask */
++
++#define SCB_CFSR_UNSTKERR_Pos             (SCB_CFSR_BUSFAULTSR_Pos + 3U)                  /*!< SCB CFSR (BFSR): UNSTKERR Position */
++#define SCB_CFSR_UNSTKERR_Msk             (1UL << SCB_CFSR_UNSTKERR_Pos)                  /*!< SCB CFSR (BFSR): UNSTKERR Mask */
++
++#define SCB_CFSR_IMPRECISERR_Pos          (SCB_CFSR_BUSFAULTSR_Pos + 2U)                  /*!< SCB CFSR (BFSR): IMPRECISERR Position */
++#define SCB_CFSR_IMPRECISERR_Msk          (1UL << SCB_CFSR_IMPRECISERR_Pos)               /*!< SCB CFSR (BFSR): IMPRECISERR Mask */
++
++#define SCB_CFSR_PRECISERR_Pos            (SCB_CFSR_BUSFAULTSR_Pos + 1U)                  /*!< SCB CFSR (BFSR): PRECISERR Position */
++#define SCB_CFSR_PRECISERR_Msk            (1UL << SCB_CFSR_PRECISERR_Pos)                 /*!< SCB CFSR (BFSR): PRECISERR Mask */
++
++#define SCB_CFSR_IBUSERR_Pos              (SCB_CFSR_BUSFAULTSR_Pos + 0U)                  /*!< SCB CFSR (BFSR): IBUSERR Position */
++#define SCB_CFSR_IBUSERR_Msk              (1UL << SCB_CFSR_IBUSERR_Pos)                   /*!< SCB CFSR (BFSR): IBUSERR Mask */
++
++/* UsageFault Status Register (part of SCB Configurable Fault Status Register) */
++#define SCB_CFSR_DIVBYZERO_Pos            (SCB_CFSR_USGFAULTSR_Pos + 9U)                  /*!< SCB CFSR (UFSR): DIVBYZERO Position */
++#define SCB_CFSR_DIVBYZERO_Msk            (1UL << SCB_CFSR_DIVBYZERO_Pos)                 /*!< SCB CFSR (UFSR): DIVBYZERO Mask */
++
++#define SCB_CFSR_UNALIGNED_Pos            (SCB_CFSR_USGFAULTSR_Pos + 8U)                  /*!< SCB CFSR (UFSR): UNALIGNED Position */
++#define SCB_CFSR_UNALIGNED_Msk            (1UL << SCB_CFSR_UNALIGNED_Pos)                 /*!< SCB CFSR (UFSR): UNALIGNED Mask */
++
++#define SCB_CFSR_NOCP_Pos                 (SCB_CFSR_USGFAULTSR_Pos + 3U)                  /*!< SCB CFSR (UFSR): NOCP Position */
++#define SCB_CFSR_NOCP_Msk                 (1UL << SCB_CFSR_NOCP_Pos)                      /*!< SCB CFSR (UFSR): NOCP Mask */
++
++#define SCB_CFSR_INVPC_Pos                (SCB_CFSR_USGFAULTSR_Pos + 2U)                  /*!< SCB CFSR (UFSR): INVPC Position */
++#define SCB_CFSR_INVPC_Msk                (1UL << SCB_CFSR_INVPC_Pos)                     /*!< SCB CFSR (UFSR): INVPC Mask */
++
++#define SCB_CFSR_INVSTATE_Pos             (SCB_CFSR_USGFAULTSR_Pos + 1U)                  /*!< SCB CFSR (UFSR): INVSTATE Position */
++#define SCB_CFSR_INVSTATE_Msk             (1UL << SCB_CFSR_INVSTATE_Pos)                  /*!< SCB CFSR (UFSR): INVSTATE Mask */
++
++#define SCB_CFSR_UNDEFINSTR_Pos           (SCB_CFSR_USGFAULTSR_Pos + 0U)                  /*!< SCB CFSR (UFSR): UNDEFINSTR Position */
++#define SCB_CFSR_UNDEFINSTR_Msk           (1UL << SCB_CFSR_UNDEFINSTR_Pos)                /*!< SCB CFSR (UFSR): UNDEFINSTR Mask */
++
++/* SCB Hard Fault Status Register Definitions */
++#define SCB_HFSR_DEBUGEVT_Pos              31U                                            /*!< SCB HFSR: DEBUGEVT Position */
++#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
++
++#define SCB_HFSR_FORCED_Pos                30U                                            /*!< SCB HFSR: FORCED Position */
++#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
++
++#define SCB_HFSR_VECTTBL_Pos                1U                                            /*!< SCB HFSR: VECTTBL Position */
++#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
++
++/* SCB Debug Fault Status Register Definitions */
++#define SCB_DFSR_EXTERNAL_Pos               4U                                            /*!< SCB DFSR: EXTERNAL Position */
++#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
++
++#define SCB_DFSR_VCATCH_Pos                 3U                                            /*!< SCB DFSR: VCATCH Position */
++#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
++
++#define SCB_DFSR_DWTTRAP_Pos                2U                                            /*!< SCB DFSR: DWTTRAP Position */
++#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
++
++#define SCB_DFSR_BKPT_Pos                   1U                                            /*!< SCB DFSR: BKPT Position */
++#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
++
++#define SCB_DFSR_HALTED_Pos                 0U                                            /*!< SCB DFSR: HALTED Position */
++#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
++
++/*@} end of group CMSIS_SCB */
++
++
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
++  \brief    Type definitions for the System Control and ID Register not in the SCB
++  @{
++ */
++
++/**
++  \brief  Structure type to access the System Control and ID Register not in the SCB.
++ */
++typedef struct
++{
++        uint32_t RESERVED0[1U];
++  __IM  uint32_t ICTR;                   /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register */
++  __IOM uint32_t ACTLR;                  /*!< Offset: 0x008 (R/W)  Auxiliary Control Register */
++} SCnSCB_Type;
++
++/* Interrupt Controller Type Register Definitions */
++#define SCnSCB_ICTR_INTLINESNUM_Pos         0U                                         /*!< ICTR: INTLINESNUM Position */
++#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
++
++/* Auxiliary Control Register Definitions */
++#define SCnSCB_ACTLR_DISOOFP_Pos            9U                                         /*!< ACTLR: DISOOFP Position */
++#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
++
++#define SCnSCB_ACTLR_DISFPCA_Pos            8U                                         /*!< ACTLR: DISFPCA Position */
++#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
++
++#define SCnSCB_ACTLR_DISFOLD_Pos            2U                                         /*!< ACTLR: DISFOLD Position */
++#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
++
++#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1U                                         /*!< ACTLR: DISDEFWBUF Position */
++#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
++
++#define SCnSCB_ACTLR_DISMCYCINT_Pos         0U                                         /*!< ACTLR: DISMCYCINT Position */
++#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
++
++/*@} end of group CMSIS_SCnotSCB */
++
++
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
++  \brief    Type definitions for the System Timer Registers.
++  @{
++ */
++
++/**
++  \brief  Structure type to access the System Timer (SysTick).
++ */
++typedef struct
++{
++  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
++  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
++  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
++  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
++} SysTick_Type;
++
++/* SysTick Control / Status Register Definitions */
++#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
++#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
++
++#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
++#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
++
++#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
++#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
++
++#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
++#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
++
++/* SysTick Reload Register Definitions */
++#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
++#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
++
++/* SysTick Current Register Definitions */
++#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
++#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
++
++/* SysTick Calibration Register Definitions */
++#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
++#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
++
++#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
++#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
++
++#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
++#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
++
++/*@} end of group CMSIS_SysTick */
++
++
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
++  \brief    Type definitions for the Instrumentation Trace Macrocell (ITM)
++  @{
++ */
++
++/**
++  \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
++ */
++typedef struct
++{
++  __OM  union
++  {
++    __OM  uint8_t    u8;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit */
++    __OM  uint16_t   u16;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit */
++    __OM  uint32_t   u32;                /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit */
++  }  PORT [32U];                         /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers */
++        uint32_t RESERVED0[864U];
++  __IOM uint32_t TER;                    /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register */
++        uint32_t RESERVED1[15U];
++  __IOM uint32_t TPR;                    /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register */
++        uint32_t RESERVED2[15U];
++  __IOM uint32_t TCR;                    /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register */
++        uint32_t RESERVED3[32U];
++        uint32_t RESERVED4[43U];
++  __OM  uint32_t LAR;                    /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register */
++  __IM  uint32_t LSR;                    /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register */
++        uint32_t RESERVED5[6U];
++  __IM  uint32_t PID4;                   /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
++  __IM  uint32_t PID5;                   /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
++  __IM  uint32_t PID6;                   /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
++  __IM  uint32_t PID7;                   /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
++  __IM  uint32_t PID0;                   /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
++  __IM  uint32_t PID1;                   /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
++  __IM  uint32_t PID2;                   /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
++  __IM  uint32_t PID3;                   /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
++  __IM  uint32_t CID0;                   /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
++  __IM  uint32_t CID1;                   /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
++  __IM  uint32_t CID2;                   /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
++  __IM  uint32_t CID3;                   /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
++} ITM_Type;
++
++/* ITM Trace Privilege Register Definitions */
++#define ITM_TPR_PRIVMASK_Pos                0U                                            /*!< ITM TPR: PRIVMASK Position */
++#define ITM_TPR_PRIVMASK_Msk               (0xFFFFFFFFUL /*<< ITM_TPR_PRIVMASK_Pos*/)     /*!< ITM TPR: PRIVMASK Mask */
++
++/* ITM Trace Control Register Definitions */
++#define ITM_TCR_BUSY_Pos                   23U                                            /*!< ITM TCR: BUSY Position */
++#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
++
++#define ITM_TCR_TraceBusID_Pos             16U                                            /*!< ITM TCR: ATBID Position */
++#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
++
++#define ITM_TCR_GTSFREQ_Pos                10U                                            /*!< ITM TCR: Global timestamp frequency Position */
++#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
++
++#define ITM_TCR_TSPrescale_Pos              8U                                            /*!< ITM TCR: TSPrescale Position */
++#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
++
++#define ITM_TCR_SWOENA_Pos                  4U                                            /*!< ITM TCR: SWOENA Position */
++#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
++
++#define ITM_TCR_DWTENA_Pos                  3U                                            /*!< ITM TCR: DWTENA Position */
++#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
++
++#define ITM_TCR_SYNCENA_Pos                 2U                                            /*!< ITM TCR: SYNCENA Position */
++#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
++
++#define ITM_TCR_TSENA_Pos                   1U                                            /*!< ITM TCR: TSENA Position */
++#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
++
++#define ITM_TCR_ITMENA_Pos                  0U                                            /*!< ITM TCR: ITM Enable bit Position */
++#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
++
++/* ITM Lock Status Register Definitions */
++#define ITM_LSR_ByteAcc_Pos                 2U                                            /*!< ITM LSR: ByteAcc Position */
++#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
++
++#define ITM_LSR_Access_Pos                  1U                                            /*!< ITM LSR: Access Position */
++#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
++
++#define ITM_LSR_Present_Pos                 0U                                            /*!< ITM LSR: Present Position */
++#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
++
++/*@}*/ /* end of group CMSIS_ITM */
++
++
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
++  \brief    Type definitions for the Data Watchpoint and Trace (DWT)
++  @{
++ */
++
++/**
++  \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
++ */
++typedef struct
++{
++  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  Control Register */
++  __IOM uint32_t CYCCNT;                 /*!< Offset: 0x004 (R/W)  Cycle Count Register */
++  __IOM uint32_t CPICNT;                 /*!< Offset: 0x008 (R/W)  CPI Count Register */
++  __IOM uint32_t EXCCNT;                 /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register */
++  __IOM uint32_t SLEEPCNT;               /*!< Offset: 0x010 (R/W)  Sleep Count Register */
++  __IOM uint32_t LSUCNT;                 /*!< Offset: 0x014 (R/W)  LSU Count Register */
++  __IOM uint32_t FOLDCNT;                /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register */
++  __IM  uint32_t PCSR;                   /*!< Offset: 0x01C (R/ )  Program Counter Sample Register */
++  __IOM uint32_t COMP0;                  /*!< Offset: 0x020 (R/W)  Comparator Register 0 */
++  __IOM uint32_t MASK0;                  /*!< Offset: 0x024 (R/W)  Mask Register 0 */
++  __IOM uint32_t FUNCTION0;              /*!< Offset: 0x028 (R/W)  Function Register 0 */
++        uint32_t RESERVED0[1U];
++  __IOM uint32_t COMP1;                  /*!< Offset: 0x030 (R/W)  Comparator Register 1 */
++  __IOM uint32_t MASK1;                  /*!< Offset: 0x034 (R/W)  Mask Register 1 */
++  __IOM uint32_t FUNCTION1;              /*!< Offset: 0x038 (R/W)  Function Register 1 */
++        uint32_t RESERVED1[1U];
++  __IOM uint32_t COMP2;                  /*!< Offset: 0x040 (R/W)  Comparator Register 2 */
++  __IOM uint32_t MASK2;                  /*!< Offset: 0x044 (R/W)  Mask Register 2 */
++  __IOM uint32_t FUNCTION2;              /*!< Offset: 0x048 (R/W)  Function Register 2 */
++        uint32_t RESERVED2[1U];
++  __IOM uint32_t COMP3;                  /*!< Offset: 0x050 (R/W)  Comparator Register 3 */
++  __IOM uint32_t MASK3;                  /*!< Offset: 0x054 (R/W)  Mask Register 3 */
++  __IOM uint32_t FUNCTION3;              /*!< Offset: 0x058 (R/W)  Function Register 3 */
++} DWT_Type;
++
++/* DWT Control Register Definitions */
++#define DWT_CTRL_NUMCOMP_Pos               28U                                         /*!< DWT CTRL: NUMCOMP Position */
++#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
++
++#define DWT_CTRL_NOTRCPKT_Pos              27U                                         /*!< DWT CTRL: NOTRCPKT Position */
++#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
++
++#define DWT_CTRL_NOEXTTRIG_Pos             26U                                         /*!< DWT CTRL: NOEXTTRIG Position */
++#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
++
++#define DWT_CTRL_NOCYCCNT_Pos              25U                                         /*!< DWT CTRL: NOCYCCNT Position */
++#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
++
++#define DWT_CTRL_NOPRFCNT_Pos              24U                                         /*!< DWT CTRL: NOPRFCNT Position */
++#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
++
++#define DWT_CTRL_CYCEVTENA_Pos             22U                                         /*!< DWT CTRL: CYCEVTENA Position */
++#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
++
++#define DWT_CTRL_FOLDEVTENA_Pos            21U                                         /*!< DWT CTRL: FOLDEVTENA Position */
++#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
++
++#define DWT_CTRL_LSUEVTENA_Pos             20U                                         /*!< DWT CTRL: LSUEVTENA Position */
++#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
++
++#define DWT_CTRL_SLEEPEVTENA_Pos           19U                                         /*!< DWT CTRL: SLEEPEVTENA Position */
++#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
++
++#define DWT_CTRL_EXCEVTENA_Pos             18U                                         /*!< DWT CTRL: EXCEVTENA Position */
++#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
++
++#define DWT_CTRL_CPIEVTENA_Pos             17U                                         /*!< DWT CTRL: CPIEVTENA Position */
++#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
++
++#define DWT_CTRL_EXCTRCENA_Pos             16U                                         /*!< DWT CTRL: EXCTRCENA Position */
++#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
++
++#define DWT_CTRL_PCSAMPLENA_Pos            12U                                         /*!< DWT CTRL: PCSAMPLENA Position */
++#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
++
++#define DWT_CTRL_SYNCTAP_Pos               10U                                         /*!< DWT CTRL: SYNCTAP Position */
++#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
++
++#define DWT_CTRL_CYCTAP_Pos                 9U                                         /*!< DWT CTRL: CYCTAP Position */
++#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
++
++#define DWT_CTRL_POSTINIT_Pos               5U                                         /*!< DWT CTRL: POSTINIT Position */
++#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
++
++#define DWT_CTRL_POSTPRESET_Pos             1U                                         /*!< DWT CTRL: POSTPRESET Position */
++#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
++
++#define DWT_CTRL_CYCCNTENA_Pos              0U                                         /*!< DWT CTRL: CYCCNTENA Position */
++#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
++
++/* DWT CPI Count Register Definitions */
++#define DWT_CPICNT_CPICNT_Pos               0U                                         /*!< DWT CPICNT: CPICNT Position */
++#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
++
++/* DWT Exception Overhead Count Register Definitions */
++#define DWT_EXCCNT_EXCCNT_Pos               0U                                         /*!< DWT EXCCNT: EXCCNT Position */
++#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
++
++/* DWT Sleep Count Register Definitions */
++#define DWT_SLEEPCNT_SLEEPCNT_Pos           0U                                         /*!< DWT SLEEPCNT: SLEEPCNT Position */
++#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
++
++/* DWT LSU Count Register Definitions */
++#define DWT_LSUCNT_LSUCNT_Pos               0U                                         /*!< DWT LSUCNT: LSUCNT Position */
++#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
++
++/* DWT Folded-instruction Count Register Definitions */
++#define DWT_FOLDCNT_FOLDCNT_Pos             0U                                         /*!< DWT FOLDCNT: FOLDCNT Position */
++#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
++
++/* DWT Comparator Mask Register Definitions */
++#define DWT_MASK_MASK_Pos                   0U                                         /*!< DWT MASK: MASK Position */
++#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
++
++/* DWT Comparator Function Register Definitions */
++#define DWT_FUNCTION_MATCHED_Pos           24U                                         /*!< DWT FUNCTION: MATCHED Position */
++#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
++
++#define DWT_FUNCTION_DATAVADDR1_Pos        16U                                         /*!< DWT FUNCTION: DATAVADDR1 Position */
++#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
++
++#define DWT_FUNCTION_DATAVADDR0_Pos        12U                                         /*!< DWT FUNCTION: DATAVADDR0 Position */
++#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
++
++#define DWT_FUNCTION_DATAVSIZE_Pos         10U                                         /*!< DWT FUNCTION: DATAVSIZE Position */
++#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
++
++#define DWT_FUNCTION_LNK1ENA_Pos            9U                                         /*!< DWT FUNCTION: LNK1ENA Position */
++#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
++
++#define DWT_FUNCTION_DATAVMATCH_Pos         8U                                         /*!< DWT FUNCTION: DATAVMATCH Position */
++#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
++
++#define DWT_FUNCTION_CYCMATCH_Pos           7U                                         /*!< DWT FUNCTION: CYCMATCH Position */
++#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
++
++#define DWT_FUNCTION_EMITRANGE_Pos          5U                                         /*!< DWT FUNCTION: EMITRANGE Position */
++#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
++
++#define DWT_FUNCTION_FUNCTION_Pos           0U                                         /*!< DWT FUNCTION: FUNCTION Position */
++#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
++
++/*@}*/ /* end of group CMSIS_DWT */
++
++
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_TPI     Trace Port Interface (TPI)
++  \brief    Type definitions for the Trace Port Interface (TPI)
++  @{
++ */
++
++/**
++  \brief  Structure type to access the Trace Port Interface Register (TPI).
++ */
++typedef struct
++{
++  __IM  uint32_t SSPSR;                  /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register */
++  __IOM uint32_t CSPSR;                  /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
++        uint32_t RESERVED0[2U];
++  __IOM uint32_t ACPR;                   /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
++        uint32_t RESERVED1[55U];
++  __IOM uint32_t SPPR;                   /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
++        uint32_t RESERVED2[131U];
++  __IM  uint32_t FFSR;                   /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
++  __IOM uint32_t FFCR;                   /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
++  __IM  uint32_t FSCR;                   /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
++        uint32_t RESERVED3[759U];
++  __IM  uint32_t TRIGGER;                /*!< Offset: 0xEE8 (R/ )  TRIGGER Register */
++  __IM  uint32_t FIFO0;                  /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
++  __IM  uint32_t ITATBCTR2;              /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
++        uint32_t RESERVED4[1U];
++  __IM  uint32_t ITATBCTR0;              /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
++  __IM  uint32_t FIFO1;                  /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
++  __IOM uint32_t ITCTRL;                 /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
++        uint32_t RESERVED5[39U];
++  __IOM uint32_t CLAIMSET;               /*!< Offset: 0xFA0 (R/W)  Claim tag set */
++  __IOM uint32_t CLAIMCLR;               /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
++        uint32_t RESERVED7[8U];
++  __IM  uint32_t DEVID;                  /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
++  __IM  uint32_t DEVTYPE;                /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
++} TPI_Type;
++
++/* TPI Asynchronous Clock Prescaler Register Definitions */
++#define TPI_ACPR_PRESCALER_Pos              0U                                         /*!< TPI ACPR: PRESCALER Position */
++#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
++
++/* TPI Selected Pin Protocol Register Definitions */
++#define TPI_SPPR_TXMODE_Pos                 0U                                         /*!< TPI SPPR: TXMODE Position */
++#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
++
++/* TPI Formatter and Flush Status Register Definitions */
++#define TPI_FFSR_FtNonStop_Pos              3U                                         /*!< TPI FFSR: FtNonStop Position */
++#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
++
++#define TPI_FFSR_TCPresent_Pos              2U                                         /*!< TPI FFSR: TCPresent Position */
++#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
++
++#define TPI_FFSR_FtStopped_Pos              1U                                         /*!< TPI FFSR: FtStopped Position */
++#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
++
++#define TPI_FFSR_FlInProg_Pos               0U                                         /*!< TPI FFSR: FlInProg Position */
++#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
++
++/* TPI Formatter and Flush Control Register Definitions */
++#define TPI_FFCR_TrigIn_Pos                 8U                                         /*!< TPI FFCR: TrigIn Position */
++#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
++
++#define TPI_FFCR_EnFCont_Pos                1U                                         /*!< TPI FFCR: EnFCont Position */
++#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
++
++/* TPI TRIGGER Register Definitions */
++#define TPI_TRIGGER_TRIGGER_Pos             0U                                         /*!< TPI TRIGGER: TRIGGER Position */
++#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
++
++/* TPI Integration ETM Data Register Definitions (FIFO0) */
++#define TPI_FIFO0_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO0: ITM_ATVALID Position */
++#define TPI_FIFO0_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
++
++#define TPI_FIFO0_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO0: ITM_bytecount Position */
++#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
++
++#define TPI_FIFO0_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO0: ETM_ATVALID Position */
++#define TPI_FIFO0_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
++
++#define TPI_FIFO0_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO0: ETM_bytecount Position */
++#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
++
++#define TPI_FIFO0_ETM2_Pos                 16U                                         /*!< TPI FIFO0: ETM2 Position */
++#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
++
++#define TPI_FIFO0_ETM1_Pos                  8U                                         /*!< TPI FIFO0: ETM1 Position */
++#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
++
++#define TPI_FIFO0_ETM0_Pos                  0U                                         /*!< TPI FIFO0: ETM0 Position */
++#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
++
++/* TPI ITATBCTR2 Register Definitions */
++#define TPI_ITATBCTR2_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY2 Position */
++#define TPI_ITATBCTR2_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY2_Pos*/)   /*!< TPI ITATBCTR2: ATREADY2 Mask */
++
++#define TPI_ITATBCTR2_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR2: ATREADY1 Position */
++#define TPI_ITATBCTR2_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR2_ATREADY1_Pos*/)   /*!< TPI ITATBCTR2: ATREADY1 Mask */
++
++/* TPI Integration ITM Data Register Definitions (FIFO1) */
++#define TPI_FIFO1_ITM_ATVALID_Pos          29U                                         /*!< TPI FIFO1: ITM_ATVALID Position */
++#define TPI_FIFO1_ITM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
++
++#define TPI_FIFO1_ITM_bytecount_Pos        27U                                         /*!< TPI FIFO1: ITM_bytecount Position */
++#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
++
++#define TPI_FIFO1_ETM_ATVALID_Pos          26U                                         /*!< TPI FIFO1: ETM_ATVALID Position */
++#define TPI_FIFO1_ETM_ATVALID_Msk          (0x1UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
++
++#define TPI_FIFO1_ETM_bytecount_Pos        24U                                         /*!< TPI FIFO1: ETM_bytecount Position */
++#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
++
++#define TPI_FIFO1_ITM2_Pos                 16U                                         /*!< TPI FIFO1: ITM2 Position */
++#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
++
++#define TPI_FIFO1_ITM1_Pos                  8U                                         /*!< TPI FIFO1: ITM1 Position */
++#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
++
++#define TPI_FIFO1_ITM0_Pos                  0U                                         /*!< TPI FIFO1: ITM0 Position */
++#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
++
++/* TPI ITATBCTR0 Register Definitions */
++#define TPI_ITATBCTR0_ATREADY2_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY2 Position */
++#define TPI_ITATBCTR0_ATREADY2_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY2_Pos*/)   /*!< TPI ITATBCTR0: ATREADY2 Mask */
++
++#define TPI_ITATBCTR0_ATREADY1_Pos          0U                                         /*!< TPI ITATBCTR0: ATREADY1 Position */
++#define TPI_ITATBCTR0_ATREADY1_Msk         (0x1UL /*<< TPI_ITATBCTR0_ATREADY1_Pos*/)   /*!< TPI ITATBCTR0: ATREADY1 Mask */
++
++/* TPI Integration Mode Control Register Definitions */
++#define TPI_ITCTRL_Mode_Pos                 0U                                         /*!< TPI ITCTRL: Mode Position */
++#define TPI_ITCTRL_Mode_Msk                (0x3UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
++
++/* TPI DEVID Register Definitions */
++#define TPI_DEVID_NRZVALID_Pos             11U                                         /*!< TPI DEVID: NRZVALID Position */
++#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
++
++#define TPI_DEVID_MANCVALID_Pos            10U                                         /*!< TPI DEVID: MANCVALID Position */
++#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
++
++#define TPI_DEVID_PTINVALID_Pos             9U                                         /*!< TPI DEVID: PTINVALID Position */
++#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
++
++#define TPI_DEVID_MinBufSz_Pos              6U                                         /*!< TPI DEVID: MinBufSz Position */
++#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
++
++#define TPI_DEVID_AsynClkIn_Pos             5U                                         /*!< TPI DEVID: AsynClkIn Position */
++#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
++
++#define TPI_DEVID_NrTraceInput_Pos          0U                                         /*!< TPI DEVID: NrTraceInput Position */
++#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
++
++/* TPI DEVTYPE Register Definitions */
++#define TPI_DEVTYPE_SubType_Pos             4U                                         /*!< TPI DEVTYPE: SubType Position */
++#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
++
++#define TPI_DEVTYPE_MajorType_Pos           0U                                         /*!< TPI DEVTYPE: MajorType Position */
++#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
++
++/*@}*/ /* end of group CMSIS_TPI */
++
++
++#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
++  \brief    Type definitions for the Memory Protection Unit (MPU)
++  @{
++ */
++
++/**
++  \brief  Structure type to access the Memory Protection Unit (MPU).
++ */
++typedef struct
++{
++  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
++  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
++  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
++  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
++  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
++  __IOM uint32_t RBAR_A1;                /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register */
++  __IOM uint32_t RASR_A1;                /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
++  __IOM uint32_t RBAR_A2;                /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register */
++  __IOM uint32_t RASR_A2;                /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
++  __IOM uint32_t RBAR_A3;                /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register */
++  __IOM uint32_t RASR_A3;                /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
++} MPU_Type;
++
++#define MPU_TYPE_RALIASES                  4U
++
++/* MPU Type Register Definitions */
++#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
++#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
++
++#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
++#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
++
++#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
++#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
++
++/* MPU Control Register Definitions */
++#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
++#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
++
++#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
++#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
++
++#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
++#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
++
++/* MPU Region Number Register Definitions */
++#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
++#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
++
++/* MPU Region Base Address Register Definitions */
++#define MPU_RBAR_ADDR_Pos                   5U                                            /*!< MPU RBAR: ADDR Position */
++#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
++
++#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
++#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
++
++#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
++#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
++
++/* MPU Region Attribute and Size Register Definitions */
++#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
++#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
++
++#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
++#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
++
++#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
++#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
++
++#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
++#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
++
++#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
++#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
++
++#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
++#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
++
++#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
++#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
++
++#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
++#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
++
++#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
++#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
++
++#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
++#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
++
++/*@} end of group CMSIS_MPU */
++#endif /* defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U) */
++
++
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_FPU     Floating Point Unit (FPU)
++  \brief    Type definitions for the Floating Point Unit (FPU)
++  @{
++ */
++
++/**
++  \brief  Structure type to access the Floating Point Unit (FPU).
++ */
++typedef struct
++{
++        uint32_t RESERVED0[1U];
++  __IOM uint32_t FPCCR;                  /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register */
++  __IOM uint32_t FPCAR;                  /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register */
++  __IOM uint32_t FPDSCR;                 /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register */
++  __IM  uint32_t MVFR0;                  /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0 */
++  __IM  uint32_t MVFR1;                  /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1 */
++  __IM  uint32_t MVFR2;                  /*!< Offset: 0x018 (R/ )  Media and FP Feature Register 2 */
++} FPU_Type;
++
++/* Floating-Point Context Control Register Definitions */
++#define FPU_FPCCR_ASPEN_Pos                31U                                            /*!< FPCCR: ASPEN bit Position */
++#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
++
++#define FPU_FPCCR_LSPEN_Pos                30U                                            /*!< FPCCR: LSPEN Position */
++#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
++
++#define FPU_FPCCR_MONRDY_Pos                8U                                            /*!< FPCCR: MONRDY Position */
++#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
++
++#define FPU_FPCCR_BFRDY_Pos                 6U                                            /*!< FPCCR: BFRDY Position */
++#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
++
++#define FPU_FPCCR_MMRDY_Pos                 5U                                            /*!< FPCCR: MMRDY Position */
++#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
++
++#define FPU_FPCCR_HFRDY_Pos                 4U                                            /*!< FPCCR: HFRDY Position */
++#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
++
++#define FPU_FPCCR_THREAD_Pos                3U                                            /*!< FPCCR: processor mode bit Position */
++#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
++
++#define FPU_FPCCR_USER_Pos                  1U                                            /*!< FPCCR: privilege level bit Position */
++#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
++
++#define FPU_FPCCR_LSPACT_Pos                0U                                            /*!< FPCCR: Lazy state preservation active bit Position */
++#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
++
++/* Floating-Point Context Address Register Definitions */
++#define FPU_FPCAR_ADDRESS_Pos               3U                                            /*!< FPCAR: ADDRESS bit Position */
++#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
++
++/* Floating-Point Default Status Control Register Definitions */
++#define FPU_FPDSCR_AHP_Pos                 26U                                            /*!< FPDSCR: AHP bit Position */
++#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
++
++#define FPU_FPDSCR_DN_Pos                  25U                                            /*!< FPDSCR: DN bit Position */
++#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
++
++#define FPU_FPDSCR_FZ_Pos                  24U                                            /*!< FPDSCR: FZ bit Position */
++#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
++
++#define FPU_FPDSCR_RMode_Pos               22U                                            /*!< FPDSCR: RMode bit Position */
++#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
++
++/* Media and FP Feature Register 0 Definitions */
++#define FPU_MVFR0_FP_rounding_modes_Pos    28U                                            /*!< MVFR0: FP rounding modes bits Position */
++#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
++
++#define FPU_MVFR0_Short_vectors_Pos        24U                                            /*!< MVFR0: Short vectors bits Position */
++#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
++
++#define FPU_MVFR0_Square_root_Pos          20U                                            /*!< MVFR0: Square root bits Position */
++#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
++
++#define FPU_MVFR0_Divide_Pos               16U                                            /*!< MVFR0: Divide bits Position */
++#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
++
++#define FPU_MVFR0_FP_excep_trapping_Pos    12U                                            /*!< MVFR0: FP exception trapping bits Position */
++#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
++
++#define FPU_MVFR0_Double_precision_Pos      8U                                            /*!< MVFR0: Double-precision bits Position */
++#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
++
++#define FPU_MVFR0_Single_precision_Pos      4U                                            /*!< MVFR0: Single-precision bits Position */
++#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
++
++#define FPU_MVFR0_A_SIMD_registers_Pos      0U                                            /*!< MVFR0: A_SIMD registers bits Position */
++#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
++
++/* Media and FP Feature Register 1 Definitions */
++#define FPU_MVFR1_FP_fused_MAC_Pos         28U                                            /*!< MVFR1: FP fused MAC bits Position */
++#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
++
++#define FPU_MVFR1_FP_HPFP_Pos              24U                                            /*!< MVFR1: FP HPFP bits Position */
++#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
++
++#define FPU_MVFR1_D_NaN_mode_Pos            4U                                            /*!< MVFR1: D_NaN mode bits Position */
++#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
++
++#define FPU_MVFR1_FtZ_mode_Pos              0U                                            /*!< MVFR1: FtZ mode bits Position */
++#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
++
++/* Media and FP Feature Register 2 Definitions */
++
++#define FPU_MVFR2_VFP_Misc_Pos              4U                                            /*!< MVFR2: VFP Misc bits Position */
++#define FPU_MVFR2_VFP_Misc_Msk             (0xFUL << FPU_MVFR2_VFP_Misc_Pos)              /*!< MVFR2: VFP Misc bits Mask */
++
++/*@} end of group CMSIS_FPU */
++
++
++/**
++  \ingroup  CMSIS_core_register
++  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
++  \brief    Type definitions for the Core Debug Registers
++  @{
++ */
++
++/**
++  \brief  Structure type to access the Core Debug Register (CoreDebug).
++ */
++typedef struct
++{
++  __IOM uint32_t DHCSR;                  /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register */
++  __OM  uint32_t DCRSR;                  /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register */
++  __IOM uint32_t DCRDR;                  /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register */
++  __IOM uint32_t DEMCR;                  /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
++} CoreDebug_Type;
++
++/* Debug Halting Control and Status Register Definitions */
++#define CoreDebug_DHCSR_DBGKEY_Pos         16U                                            /*!< CoreDebug DHCSR: DBGKEY Position */
++#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
++
++#define CoreDebug_DHCSR_S_RESET_ST_Pos     25U                                            /*!< CoreDebug DHCSR: S_RESET_ST Position */
++#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
++
++#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24U                                            /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
++#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
++
++#define CoreDebug_DHCSR_S_LOCKUP_Pos       19U                                            /*!< CoreDebug DHCSR: S_LOCKUP Position */
++#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
++
++#define CoreDebug_DHCSR_S_SLEEP_Pos        18U                                            /*!< CoreDebug DHCSR: S_SLEEP Position */
++#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
++
++#define CoreDebug_DHCSR_S_HALT_Pos         17U                                            /*!< CoreDebug DHCSR: S_HALT Position */
++#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
++
++#define CoreDebug_DHCSR_S_REGRDY_Pos       16U                                            /*!< CoreDebug DHCSR: S_REGRDY Position */
++#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
++
++#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5U                                            /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
++#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
++
++#define CoreDebug_DHCSR_C_MASKINTS_Pos      3U                                            /*!< CoreDebug DHCSR: C_MASKINTS Position */
++#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
++
++#define CoreDebug_DHCSR_C_STEP_Pos          2U                                            /*!< CoreDebug DHCSR: C_STEP Position */
++#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
++
++#define CoreDebug_DHCSR_C_HALT_Pos          1U                                            /*!< CoreDebug DHCSR: C_HALT Position */
++#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
++
++#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0U                                            /*!< CoreDebug DHCSR: C_DEBUGEN Position */
++#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
++
++/* Debug Core Register Selector Register Definitions */
++#define CoreDebug_DCRSR_REGWnR_Pos         16U                                            /*!< CoreDebug DCRSR: REGWnR Position */
++#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
++
++#define CoreDebug_DCRSR_REGSEL_Pos          0U                                            /*!< CoreDebug DCRSR: REGSEL Position */
++#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
++
++/* Debug Exception and Monitor Control Register Definitions */
++#define CoreDebug_DEMCR_TRCENA_Pos         24U                                            /*!< CoreDebug DEMCR: TRCENA Position */
++#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
++
++#define CoreDebug_DEMCR_MON_REQ_Pos        19U                                            /*!< CoreDebug DEMCR: MON_REQ Position */
++#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
++
++#define CoreDebug_DEMCR_MON_STEP_Pos       18U                                            /*!< CoreDebug DEMCR: MON_STEP Position */
++#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
++
++#define CoreDebug_DEMCR_MON_PEND_Pos       17U                                            /*!< CoreDebug DEMCR: MON_PEND Position */
++#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
++
++#define CoreDebug_DEMCR_MON_EN_Pos         16U                                            /*!< CoreDebug DEMCR: MON_EN Position */
++#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
++
++#define CoreDebug_DEMCR_VC_HARDERR_Pos     10U                                            /*!< CoreDebug DEMCR: VC_HARDERR Position */
++#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
++
++#define CoreDebug_DEMCR_VC_INTERR_Pos       9U                                            /*!< CoreDebug DEMCR: VC_INTERR Position */
++#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
++
++#define CoreDebug_DEMCR_VC_BUSERR_Pos       8U                                            /*!< CoreDebug DEMCR: VC_BUSERR Position */
++#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
++
++#define CoreDebug_DEMCR_VC_STATERR_Pos      7U                                            /*!< CoreDebug DEMCR: VC_STATERR Position */
++#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
++
++#define CoreDebug_DEMCR_VC_CHKERR_Pos       6U                                            /*!< CoreDebug DEMCR: VC_CHKERR Position */
++#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
++
++#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5U                                            /*!< CoreDebug DEMCR: VC_NOCPERR Position */
++#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
++
++#define CoreDebug_DEMCR_VC_MMERR_Pos        4U                                            /*!< CoreDebug DEMCR: VC_MMERR Position */
++#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
++
++#define CoreDebug_DEMCR_VC_CORERESET_Pos    0U                                            /*!< CoreDebug DEMCR: VC_CORERESET Position */
++#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
++
++/*@} end of group CMSIS_CoreDebug */
++
++
++/**
++  \ingroup    CMSIS_core_register
++  \defgroup   CMSIS_core_bitfield     Core register bit field macros
++  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
++  @{
++ */
++
++/**
++  \brief   Mask and shift a bit field value for use in a register bit range.
++  \param[in] field  Name of the register bit field.
++  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
++  \return           Masked and shifted value.
++*/
++#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
++
++/**
++  \brief     Mask and shift a register value to extract a bit filed value.
++  \param[in] field  Name of the register bit field.
++  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
++  \return           Masked and shifted bit field value.
++*/
++#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
++
++/*@} end of group CMSIS_core_bitfield */
++
++
++/**
++  \ingroup    CMSIS_core_register
++  \defgroup   CMSIS_core_base     Core Definitions
++  \brief      Definitions for base addresses, unions, and structures.
++  @{
++ */
++
++/* Memory mapping of Core Hardware */
++#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
++#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address */
++#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address */
++#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address */
++#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address */
++#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
++#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
++#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
++
++#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
++#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
++#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
++#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
++#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct */
++#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct */
++#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct */
++#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct */
++
++#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
++  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
++  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
++#endif
++
++#define FPU_BASE            (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit */
++#define FPU                 ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit */
++
++/*@} */
++
++
++
++/*******************************************************************************
++ *                Hardware Abstraction Layer
++  Core Function Interface contains:
++  - Core NVIC Functions
++  - Core SysTick Functions
++  - Core Debug Functions
++  - Core Register Access Functions
++ ******************************************************************************/
++/**
++  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
++*/
++
++
++
++/* ##########################   NVIC functions  #################################### */
++/**
++  \ingroup  CMSIS_Core_FunctionInterface
++  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
++  \brief    Functions that manage interrupts and exceptions via the NVIC.
++  @{
++ */
++
++#ifdef CMSIS_NVIC_VIRTUAL
++  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
++    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
++  #endif
++  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
++#else
++  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
++  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
++  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
++  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
++  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
++  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
++  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
++  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
++  #define NVIC_GetActive              __NVIC_GetActive
++  #define NVIC_SetPriority            __NVIC_SetPriority
++  #define NVIC_GetPriority            __NVIC_GetPriority
++  #define NVIC_SystemReset            __NVIC_SystemReset
++#endif /* CMSIS_NVIC_VIRTUAL */
++
++#ifdef CMSIS_VECTAB_VIRTUAL
++  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
++    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
++  #endif
++  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
++#else
++  #define NVIC_SetVector              __NVIC_SetVector
++  #define NVIC_GetVector              __NVIC_GetVector
++#endif  /* (CMSIS_VECTAB_VIRTUAL) */
++
++#define NVIC_USER_IRQ_OFFSET          16
++
++
++/* The following EXC_RETURN values are saved the LR on exception entry */
++#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
++#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
++#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
++#define EXC_RETURN_HANDLER_FPU     (0xFFFFFFE1UL)     /* return to Handler mode, uses MSP after return, restore floating-point state */
++#define EXC_RETURN_THREAD_MSP_FPU  (0xFFFFFFE9UL)     /* return to Thread mode, uses MSP after return, restore floating-point state  */
++#define EXC_RETURN_THREAD_PSP_FPU  (0xFFFFFFEDUL)     /* return to Thread mode, uses PSP after return, restore floating-point state  */
++
++
++/**
++  \brief   Set Priority Grouping
++  \details Sets the priority grouping field using the required unlock sequence.
++           The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
++           Only values from 0..7 are used.
++           In case of a conflict between priority grouping and available
++           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
++  \param [in]      PriorityGroup  Priority grouping field.
++ */
++__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
++{
++  uint32_t reg_value;
++  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
++
++  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
++  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
++  reg_value  =  (reg_value                                   |
++                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
++                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
++  SCB->AIRCR =  reg_value;
++}
++
++
++/**
++  \brief   Get Priority Grouping
++  \details Reads the priority grouping field from the NVIC Interrupt Controller.
++  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
++ */
++__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
++{
++  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
++}
++
++
++/**
++  \brief   Enable Interrupt
++  \details Enables a device specific interrupt in the NVIC interrupt controller.
++  \param [in]      IRQn  Device specific interrupt number.
++  \note    IRQn must not be negative.
++ */
++__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
++{
++  if ((int32_t)(IRQn) >= 0)
++  {
++    __COMPILER_BARRIER();
++    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
++    __COMPILER_BARRIER();
++  }
++}
++
++
++/**
++  \brief   Get Interrupt Enable status
++  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
++  \param [in]      IRQn  Device specific interrupt number.
++  \return             0  Interrupt is not enabled.
++  \return             1  Interrupt is enabled.
++  \note    IRQn must not be negative.
++ */
++__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
++{
++  if ((int32_t)(IRQn) >= 0)
++  {
++    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
++  }
++  else
++  {
++    return(0U);
++  }
++}
++
++
++/**
++  \brief   Disable Interrupt
++  \details Disables a device specific interrupt in the NVIC interrupt controller.
++  \param [in]      IRQn  Device specific interrupt number.
++  \note    IRQn must not be negative.
++ */
++__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
++{
++  if ((int32_t)(IRQn) >= 0)
++  {
++    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
++    __DSB();
++    __ISB();
++  }
++}
++
++
++/**
++  \brief   Get Pending Interrupt
++  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
++  \param [in]      IRQn  Device specific interrupt number.
++  \return             0  Interrupt status is not pending.
++  \return             1  Interrupt status is pending.
++  \note    IRQn must not be negative.
++ */
++__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
++{
++  if ((int32_t)(IRQn) >= 0)
++  {
++    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
++  }
++  else
++  {
++    return(0U);
++  }
++}
++
++
++/**
++  \brief   Set Pending Interrupt
++  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
++  \param [in]      IRQn  Device specific interrupt number.
++  \note    IRQn must not be negative.
++ */
++__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
++{
++  if ((int32_t)(IRQn) >= 0)
++  {
++    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
++  }
++}
++
++
++/**
++  \brief   Clear Pending Interrupt
++  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
++  \param [in]      IRQn  Device specific interrupt number.
++  \note    IRQn must not be negative.
++ */
++__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
++{
++  if ((int32_t)(IRQn) >= 0)
++  {
++    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
++  }
++}
++
++
++/**
++  \brief   Get Active Interrupt
++  \details Reads the active register in the NVIC and returns the active bit for the device specific interrupt.
++  \param [in]      IRQn  Device specific interrupt number.
++  \return             0  Interrupt status is not active.
++  \return             1  Interrupt status is active.
++  \note    IRQn must not be negative.
++ */
++__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
++{
++  if ((int32_t)(IRQn) >= 0)
++  {
++    return((uint32_t)(((NVIC->IABR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
++  }
++  else
++  {
++    return(0U);
++  }
++}
++
++
++/**
++  \brief   Set Interrupt Priority
++  \details Sets the priority of a device specific interrupt or a processor exception.
++           The interrupt number can be positive to specify a device specific interrupt,
++           or negative to specify a processor exception.
++  \param [in]      IRQn  Interrupt number.
++  \param [in]  priority  Priority to set.
++  \note    The priority cannot be set for every processor exception.
++ */
++__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
++{
++  if ((int32_t)(IRQn) >= 0)
++  {
++    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
++  }
++  else
++  {
++    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
++  }
++}
++
++
++/**
++  \brief   Get Interrupt Priority
++  \details Reads the priority of a device specific interrupt or a processor exception.
++           The interrupt number can be positive to specify a device specific interrupt,
++           or negative to specify a processor exception.
++  \param [in]   IRQn  Interrupt number.
++  \return             Interrupt Priority.
++                      Value is aligned automatically to the implemented priority bits of the microcontroller.
++ */
++__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
++{
++
++  if ((int32_t)(IRQn) >= 0)
++  {
++    return(((uint32_t)NVIC->IP[((uint32_t)IRQn)]               >> (8U - __NVIC_PRIO_BITS)));
++  }
++  else
++  {
++    return(((uint32_t)SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] >> (8U - __NVIC_PRIO_BITS)));
++  }
++}
++
++
++/**
++  \brief   Encode Priority
++  \details Encodes the priority for an interrupt with the given priority group,
++           preemptive priority value, and subpriority value.
++           In case of a conflict between priority grouping and available
++           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
++  \param [in]     PriorityGroup  Used priority group.
++  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
++  \param [in]       SubPriority  Subpriority value (starting from 0).
++  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
++ */
++__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
++{
++  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
++  uint32_t PreemptPriorityBits;
++  uint32_t SubPriorityBits;
++
++  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
++  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
++
++  return (
++           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
++           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
++         );
++}
++
++
++/**
++  \brief   Decode Priority
++  \details Decodes an interrupt priority value with a given priority group to
++           preemptive priority value and subpriority value.
++           In case of a conflict between priority grouping and available
++           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
++  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
++  \param [in]     PriorityGroup  Used priority group.
++  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
++  \param [out]     pSubPriority  Subpriority value (starting from 0).
++ */
++__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
++{
++  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
++  uint32_t PreemptPriorityBits;
++  uint32_t SubPriorityBits;
++
++  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
++  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
++
++  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
++  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
++}
++
++
++/**
++  \brief   Set Interrupt Vector
++  \details Sets an interrupt vector in SRAM based interrupt vector table.
++           The interrupt number can be positive to specify a device specific interrupt,
++           or negative to specify a processor exception.
++           VTOR must been relocated to SRAM before.
++  \param [in]   IRQn      Interrupt number
++  \param [in]   vector    Address of interrupt handler function
++ */
++__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
++{
++  uint32_t vectors = (uint32_t )SCB->VTOR;
++  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
++  /* ARM Application Note 321 states that the M4 does not require the architectural barrier */
++}
++
++
++/**
++  \brief   Get Interrupt Vector
++  \details Reads an interrupt vector from interrupt vector table.
++           The interrupt number can be positive to specify a device specific interrupt,
++           or negative to specify a processor exception.
++  \param [in]   IRQn      Interrupt number.
++  \return                 Address of interrupt handler function
++ */
++__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
++{
++  uint32_t vectors = (uint32_t )SCB->VTOR;
++  return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4));
++}
++
++
++/**
++  \brief   System Reset
++  \details Initiates a system reset request to reset the MCU.
++ */
++__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
++{
++  __DSB();                                                          /* Ensure all outstanding memory accesses included
++                                                                       buffered write are completed before reset */
++  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
++                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
++                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
++  __DSB();                                                          /* Ensure completion of memory access */
++
++  for(;;)                                                           /* wait until reset */
++  {
++    __NOP();
++  }
++}
++
++/*@} end of CMSIS_Core_NVICFunctions */
++
++
++/* ##########################  MPU functions  #################################### */
++
++#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
++
++#include "mpu_armv7.h"
++
++#endif
++
++
++/* ##########################  FPU functions  #################################### */
++/**
++  \ingroup  CMSIS_Core_FunctionInterface
++  \defgroup CMSIS_Core_FpuFunctions FPU Functions
++  \brief    Function that provides FPU type.
++  @{
++ */
++
++/**
++  \brief   get FPU type
++  \details returns the FPU type
++  \returns
++   - \b  0: No FPU
++   - \b  1: Single precision FPU
++   - \b  2: Double + Single precision FPU
++ */
++__STATIC_INLINE uint32_t SCB_GetFPUType(void)
++{
++  uint32_t mvfr0;
++
++  mvfr0 = FPU->MVFR0;
++  if      ((mvfr0 & (FPU_MVFR0_Single_precision_Msk | FPU_MVFR0_Double_precision_Msk)) == 0x020U)
++  {
++    return 1U;           /* Single precision FPU */
++  }
++  else
++  {
++    return 0U;           /* No FPU */
++  }
++}
++
++
++/*@} end of CMSIS_Core_FpuFunctions */
++
++
++
++/* ##################################    SysTick function  ############################################ */
++/**
++  \ingroup  CMSIS_Core_FunctionInterface
++  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
++  \brief    Functions that configure the System.
++  @{
++ */
++
++#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
++
++/**
++  \brief   System Tick Configuration
++  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
++           Counter is in free running mode to generate periodic interrupts.
++  \param [in]  ticks  Number of ticks between two interrupts.
++  \return          0  Function succeeded.
++  \return          1  Function failed.
++  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
++           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
++           must contain a vendor-specific implementation of this function.
++ */
++__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
++{
++  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
++  {
++    return (1UL);                                                   /* Reload value impossible */
++  }
++
++  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
++  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
++  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
++  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
++                   SysTick_CTRL_TICKINT_Msk   |
++                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
++  return (0UL);                                                     /* Function successful */
++}
++
++#endif
++
++/*@} end of CMSIS_Core_SysTickFunctions */
++
++
++
++/* ##################################### Debug In/Output function ########################################### */
++/**
++  \ingroup  CMSIS_Core_FunctionInterface
++  \defgroup CMSIS_core_DebugFunctions ITM Functions
++  \brief    Functions that access the ITM debug interface.
++  @{
++ */
++
++extern volatile int32_t ITM_RxBuffer;                              /*!< External variable to receive characters. */
++#define                 ITM_RXBUFFER_EMPTY  ((int32_t)0x5AA55AA5U) /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
++
++
++/**
++  \brief   ITM Send Character
++  \details Transmits a character via the ITM channel 0, and
++           \li Just returns when no debugger is connected that has booked the output.
++           \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
++  \param [in]     ch  Character to transmit.
++  \returns            Character to transmit.
++ */
++__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
++{
++  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
++      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
++  {
++    while (ITM->PORT[0U].u32 == 0UL)
++    {
++      __NOP();
++    }
++    ITM->PORT[0U].u8 = (uint8_t)ch;
++  }
++  return (ch);
++}
++
++
++/**
++  \brief   ITM Receive Character
++  \details Inputs a character via the external variable \ref ITM_RxBuffer.
++  \return             Received character.
++  \return         -1  No character pending.
++ */
++__STATIC_INLINE int32_t ITM_ReceiveChar (void)
++{
++  int32_t ch = -1;                           /* no character available */
++
++  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY)
++  {
++    ch = ITM_RxBuffer;
++    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
++  }
++
++  return (ch);
++}
++
++
++/**
++  \brief   ITM Check Character
++  \details Checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
++  \return          0  No character available.
++  \return          1  Character available.
++ */
++__STATIC_INLINE int32_t ITM_CheckChar (void)
++{
++
++  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY)
++  {
++    return (0);                              /* no character available */
++  }
++  else
++  {
++    return (1);                              /*    character available */
++  }
++}
++
++/*@} end of CMSIS_core_DebugFunctions */
++
++
++
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* __CORE_CM4_H_DEPENDANT */
++
++#endif /* __CMSIS_GENERIC */
+diff --git a/projects/nrf52840_dk/cryptoengine.c b/projects/nrf52840_dk/cryptoengine.c
+new file mode 100644
+index 00000000..68dd3247
+--- /dev/null
++++ b/projects/nrf52840_dk/cryptoengine.c
+@@ -0,0 +1,40 @@
++/**
++\brief Dummy implementation of cryptoengine.
++*/
++
++#include <stdint.h>
++#include <string.h>
++#include "cryptoengine.h"
++
++owerror_t cryptoengine_aes_ccms_enc(uint8_t* a,
++         uint8_t len_a,
++         uint8_t* m,
++         uint8_t* len_m,
++         uint8_t* nonce,
++         uint8_t l,
++         uint8_t key[16],
++         uint8_t len_mac) {
++   
++   return E_FAIL;
++}
++
++owerror_t cryptoengine_aes_ccms_dec(uint8_t* a,
++         uint8_t len_a,
++         uint8_t* m,
++         uint8_t* len_m,
++         uint8_t* nonce,
++         uint8_t l,
++         uint8_t key[16],
++         uint8_t len_mac) {
++   
++   return E_FAIL;
++}
++
++owerror_t cryptoengine_aes_ecb_enc(uint8_t* buffer, uint8_t* key) {
++   return E_FAIL;
++}
++
++owerror_t cryptoengine_init(void) {
++   return E_SUCCESS;
++}
++
+diff --git a/projects/nrf52840_dk/debugpins.c b/projects/nrf52840_dk/debugpins.c
+new file mode 100644
+index 00000000..0a725318
+--- /dev/null
++++ b/projects/nrf52840_dk/debugpins.c
+@@ -0,0 +1,153 @@
++/**
++\brief nRF52840-specific definition of the "debugpins" bsp module.
++
++\author Tamas Harczos <tamas.harczos@imms.de>, April 2018.
++\author Tengfei Chang <tengfeichang@hkust-gz.edu.cn>, April 2023.
++*/
++
++#include "nrf52840.h"
++#include "board_info.h"
++#include "debugpins.h"
++
++//=========================== defines =========================================
++
++// board debug PINS defines
++
++#define DEBUGPIN_FRAME  NRF_GPIO_PIN_MAP(0,26)
++#define DEBUGPIN_SLOT   NRF_GPIO_PIN_MAP(0,27)
++#define DEBUGPIN_FSM    NRF_GPIO_PIN_MAP(0,28)
++#define DEBUGPIN_TASK   NRF_GPIO_PIN_MAP(0,29)
++#define DEBUGPIN_ISR    NRF_GPIO_PIN_MAP(0,30)
++#define DEBUGPIN_RADIO  NRF_GPIO_PIN_MAP(0,31)
++
++//=========================== variables =======================================
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++void debugpins_init(void) {
++
++    NRF_P0->DIRSET = 1<<DEBUGPIN_FRAME;
++    NRF_P0->DIRSET = 1<<DEBUGPIN_SLOT;
++    NRF_P0->DIRSET = 1<<DEBUGPIN_FSM;
++    NRF_P0->DIRSET = 1<<DEBUGPIN_TASK;
++    NRF_P0->DIRSET = 1<<DEBUGPIN_ISR;
++    NRF_P0->DIRSET = 1<<DEBUGPIN_RADIO;
++
++}
++
++void debugpins_frame_set(void) {
++
++    NRF_P0->OUTSET = 1<<DEBUGPIN_FRAME;
++}
++
++void debugpins_frame_clr(void) {
++
++    NRF_P0->OUTCLR = 1<<DEBUGPIN_FRAME;
++}
++
++void debugpins_frame_toggle(void) {
++
++    if ((NRF_P0->OUT & (1<<DEBUGPIN_FRAME))!=0) {        
++        NRF_P0->OUTCLR = 1<<DEBUGPIN_FRAME;
++    } else {
++        NRF_P0->OUTSET = 1<<DEBUGPIN_FRAME;
++    }
++}
++
++void debugpins_slot_set(void) {
++
++    NRF_P0->OUTSET = 1<<DEBUGPIN_SLOT;
++}
++
++void debugpins_slot_clr(void) {
++    
++    NRF_P0->OUTCLR = 1<<DEBUGPIN_SLOT;
++}
++
++void debugpins_slot_toggle(void) {
++
++    if ((NRF_P0->OUT & (1<<DEBUGPIN_SLOT))!=0) {        
++        NRF_P0->OUTCLR = 1<<DEBUGPIN_SLOT;
++    } else {
++        NRF_P0->OUTSET = 1<<DEBUGPIN_SLOT;
++    }
++}
++
++
++void debugpins_fsm_set(void) {
++
++    NRF_P0->OUTSET = 1<<DEBUGPIN_FSM;
++}
++
++void debugpins_fsm_clr(void) {
++    
++    NRF_P0->OUTCLR = 1<<DEBUGPIN_FSM;
++}
++
++void debugpins_fsm_toggle(void) {
++
++    if ((NRF_P0->OUT & (1<<DEBUGPIN_FSM))!=0) {        
++        NRF_P0->OUTCLR = 1<<DEBUGPIN_FSM;
++    } else {
++        NRF_P0->OUTSET = 1<<DEBUGPIN_FSM;
++    }
++}
++
++void debugpins_task_set(void) {
++
++    NRF_P0->OUTSET = 1<<DEBUGPIN_TASK;
++}
++
++void debugpins_task_clr(void) {
++
++    NRF_P0->OUTCLR = 1<<DEBUGPIN_TASK;
++}
++
++void debugpins_task_toggle(void) {
++
++    if ((NRF_P0->OUT & (1<<DEBUGPIN_TASK))!=0) {        
++        NRF_P0->OUTCLR = 1<<DEBUGPIN_TASK;
++    } else {
++        NRF_P0->OUTSET = 1<<DEBUGPIN_TASK;
++    }
++}
++
++void debugpins_isr_set(void) {
++    
++    NRF_P0->OUTSET = 1<<DEBUGPIN_ISR;
++}
++
++void debugpins_isr_clr(void) {
++
++    NRF_P0->OUTCLR = 1<<DEBUGPIN_ISR;
++}
++
++void debugpins_isr_toggle(void) {
++
++    if ((NRF_P0->OUT & (1<<DEBUGPIN_ISR))!=0) {        
++        NRF_P0->OUTCLR = 1<<DEBUGPIN_ISR;
++    } else {
++        NRF_P0->OUTSET = 1<<DEBUGPIN_ISR;
++    }
++}
++
++void debugpins_radio_set(void) {
++    
++    NRF_P0->OUTSET = 1<<DEBUGPIN_RADIO;
++}
++
++void debugpins_radio_clr(void) {
++    
++    NRF_P0->OUTCLR = 1<<DEBUGPIN_RADIO;
++}
++
++void debugpins_radio_toggle(void) {
++    
++    if ((NRF_P0->OUT & (1<<DEBUGPIN_RADIO))!=0) {        
++        NRF_P0->OUTCLR = 1<<DEBUGPIN_RADIO;
++    } else {
++        NRF_P0->OUTSET = 1<<DEBUGPIN_RADIO;
++    }
++}
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/eui64.c b/projects/nrf52840_dk/eui64.c
+new file mode 100644
+index 00000000..3510553b
+--- /dev/null
++++ b/projects/nrf52840_dk/eui64.c
+@@ -0,0 +1,41 @@
++/**
++ * brief nrf52840-specific definition of the "eui64" bsp module.
++ *
++ * Authors: Tamas Harczos (1, tamas.harczos@imms.de) and Adam Sedmak (2, adam.sedmak@gmail.com)
++ * Company: (1) Institut fuer Mikroelektronik- und Mechatronik-Systeme gemeinnuetzige GmbH (IMMS GmbH)
++ *          (2) Faculty of Electronics and Computing, Zagreb, Croatia
++ * Date:   May 2018
++*/
++
++#include "nrf52840.h"
++#include "nrf52840_bitfields.h"
++#include "string.h"
++#include "eui64.h"
++
++//=========================== defines =========================================
++
++//=========================== variables =======================================
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++void eui64_get(uint8_t* addressToWrite) {
++    
++    uint32_t tmp;
++    uint8_t i;
++
++    i = 0;
++
++    // get ID from Nordic chip
++    tmp = NRF_FICR->DEVICEID[0];
++    for (i=0;i<4;i++) {
++        addressToWrite[i] = (uint8_t)((tmp >> (i*8)) & 0x000000ff);
++    }
++    tmp = NRF_FICR->DEVICEID[1];
++    for (i=0;i<4;i++) {
++        addressToWrite[i+4] = (uint8_t)((tmp >> (i*8)) & 0x000000ff);
++    }
++}
++
++//=========================== private =========================================
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/i2c.c b/projects/nrf52840_dk/i2c.c
+new file mode 100644
+index 00000000..8de6b04e
+--- /dev/null
++++ b/projects/nrf52840_dk/i2c.c
+@@ -0,0 +1,183 @@
++/**
++\brief nRF52840-specific definition of the "i2c" bsp module.
++
++\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
++*/
++
++
++#include "nrf52840.h"
++#include "nrf52840_bitfields.h"
++#include "opendefs.h"
++#include "i2c.h"
++
++//=========================== define ==========================================
++
++#define NRF_GPIO_PIN_MAP(port, pin) (((port) << 5) | ((pin) & 0x1F))
++
++#define DOF10_SCL_PIN   NRF_GPIO_PIN_MAP(1,0)   // SCL signal pin P1.00
++#define DOF10_SDA_PIN   NRF_GPIO_PIN_MAP(0,24)  // SDA signal pin P0.24
++#define DOF10_FREQ      0x06400000              // frequency 6400000->400kbps
++
++#define TWIM_INTENSET_STOPPED_POS    1
++#define TWIM_INTENSET_ERROR_POS      9
++#define TWIM_INTENSET_SUSPENDED_POS  18
++#define TWIM_INTENSET_RXSTARTED_POS  19
++#define TWIM_INTENSET_TXSTARTED_POS  20
++#define TWIM_INTENSET_LASTRX_POS     23
++#define TWIM_INTENSET_LASTTX_POS     24
++
++#define TWI_INT_ENABLED       0
++
++//=========================== variables =======================================
++
++typedef struct {
++    uint8_t   i2c_addr;
++
++} i2c_vars_t; 
++
++//=========================== prototypes ======================================
++
++void nrf_gpio_cfg_input(uint32_t pin_number);
++
++//=========================== public ==========================================
++
++void i2c_init(void) {
++
++    nrf_gpio_cfg_input(DOF10_SCL_PIN);
++    nrf_gpio_cfg_input(DOF10_SDA_PIN);
++
++    // make sure TWIM0 is disabled before configuring the GPIO pins
++    NRF_TWIM0->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
++
++    NRF_TWIM0->PSEL.SCL   = DOF10_SCL_PIN;
++    NRF_TWIM0->PSEL.SDA   = DOF10_SDA_PIN;
++
++    NRF_TWIM0->FREQUENCY  = DOF10_FREQ;
++
++    NRF_TWIM0->SHORTS       = \
++        TWIM_SHORTS_LASTTX_STOP_Msk | TWIM_SHORTS_LASTRX_STOP_Msk;
++
++#if TWI_INT_ENABLED == 1
++
++    NRF_TWIM0->INTENSET =
++           (((uint32_t)0)   << TWIM_INTENSET_STOPPED_POS)
++         | (((uint32_t)0)   << TWIM_INTENSET_ERROR_POS)
++         | (((uint32_t)0)   << TWIM_INTENSET_SUSPENDED_POS)
++         | (((uint32_t)0)   << TWIM_INTENSET_RXSTARTED_POS)
++         | (((uint32_t)0)   << TWIM_INTENSET_TXSTARTED_POS)
++         | (((uint32_t)0)   << TWIM_INTENSET_LASTRX_POS)
++         | (((uint32_t)0)   << TWIM_INTENSET_LASTTX_POS);
++
++    // set priority and enable interrupt in NVIC
++    NVIC->IP[((uint32_t)SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn)] = 
++        (uint8_t)(
++            (
++                I2C_PRIORITY << (8 - __NVIC_PRIO_BITS)
++            ) & (uint32_t)0xff
++        );
++    NVIC->ISER[((uint32_t)SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn)>>5] = 
++       ((uint32_t)1) << ( ((uint32_t)SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn) & 0x1f);
++
++#endif
++
++    NRF_TWIM0->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
++}
++
++void i2c_set_addr(uint8_t address) {
++
++    NRF_TWIM0->ADDRESS    = address;
++}
++
++
++uint32_t i2c_read_bytes(uint8_t address, uint8_t* buffer, uint32_t length) {
++
++    uint8_t tx_buffer[1];
++
++    // ---- write first
++
++    // clear events
++    NRF_TWIM0->EVENTS_LASTTX    = 0;
++    NRF_TWIM0->EVENTS_STOPPED   = 0;
++    
++    // set tx buffer
++    NRF_TWIM0->TXD.PTR      = (uint32_t)(&tx_buffer[0]);
++    NRF_TWIM0->TXD.MAXCNT   = 1;
++    tx_buffer[0]            = address;
++
++    // start to write
++    NRF_TWIM0->TASKS_STARTTX  = 1;
++    while( NRF_TWIM0->EVENTS_LASTTX==0);
++    while( NRF_TWIM0->EVENTS_STOPPED==0);
++    NRF_TWIM0->EVENTS_LASTTX  = 0;
++    NRF_TWIM0->EVENTS_STOPPED = 0;
++
++    // ---- reading data
++
++    // clear events 
++    NRF_TWIM0->EVENTS_LASTRX  = 0;
++    NRF_TWIM0->EVENTS_STOPPED = 0;
++    
++    // set rx buffer
++    NRF_TWIM0->RXD.PTR        = (uint32_t)(buffer);
++    NRF_TWIM0->RXD.MAXCNT     = length;
++
++    // start to read
++    NRF_TWIM0->TASKS_STARTRX  = 1;
++    while( NRF_TWIM0->EVENTS_LASTRX==0);
++    while( NRF_TWIM0->EVENTS_STOPPED==0);
++    NRF_TWIM0->EVENTS_LASTRX  = 0;
++    NRF_TWIM0->EVENTS_STOPPED = 0;
++
++    // only for compatible purpose, return value has no meaning.
++    return 0xffffffff;
++}
++
++uint32_t i2c_write_bytes(uint8_t address, uint8_t* buffer, uint32_t length) {
++    
++    uint8_t tx_buffer[1+length];
++
++    // clear events
++    NRF_TWIM0->EVENTS_LASTTX    = 0;
++    NRF_TWIM0->EVENTS_STOPPED   = 0;
++    
++    // set tx buffer
++    NRF_TWIM0->TXD.PTR      = (uint32_t)(&tx_buffer[0]);
++    NRF_TWIM0->TXD.MAXCNT   = 1+length;
++    tx_buffer[0]            = address;
++    memcpy(&tx_buffer[1], buffer, length);
++
++    // start to write
++    NRF_TWIM0->TASKS_STARTTX = 1;
++    while( NRF_TWIM0->EVENTS_LASTTX==0);
++    while( NRF_TWIM0->EVENTS_STOPPED==0);
++    NRF_TWIM0->EVENTS_LASTTX = 0;
++    NRF_TWIM0->EVENTS_STOPPED = 0;
++
++    // only for compatible purpose, return value has no meaning.
++    return 0xffffffff;
++}
++
++//=========================== private =========================================
++
++void nrf_gpio_cfg_input(uint32_t pin_number) {
++
++    NRF_GPIO_Type* NRF_Px_port;
++    uint32_t       nrf_pin_number;
++
++    if (pin_number < 32) {
++
++        NRF_Px_port     = NRF_P0;
++        nrf_pin_number  = pin_number;
++    } else {
++
++        NRF_Px_port = NRF_P1;
++        nrf_pin_number  = pin_number & 0x1f;
++    }
++    
++    NRF_Px_port->PIN_CNF[nrf_pin_number]  = \
++            ((uint32_t)GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos)
++        | ((uint32_t)GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
++        | ((uint32_t)GPIO_PIN_CNF_PULL_Pullup << GPIO_PIN_CNF_PULL_Pos)
++        | ((uint32_t)GPIO_PIN_CNF_DRIVE_S0D1 << GPIO_PIN_CNF_DRIVE_Pos)
++        | ((uint32_t)GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos);
++}
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/leds.c b/projects/nrf52840_dk/leds.c
+new file mode 100644
+index 00000000..6a4a147a
+--- /dev/null
++++ b/projects/nrf52840_dk/leds.c
+@@ -0,0 +1,193 @@
++/**
++ * Author: Tamas Harczos (tamas.harczos@imms.de)
++ * Date:   Apr 2018
++ * Description: nRF52840-specific definition of the "leds" bsp module.
++ */
++
++ #include "stdbool.h"
++#include "nrf52840.h"
++#include "board_info.h"
++#include "leds.h"
++
++
++//=========================== defines =========================================
++
++// nrf52840-DK
++#define LED_1           NRF_GPIO_PIN_MAP(0,13)
++#define LED_2           NRF_GPIO_PIN_MAP(0,14)
++#define LED_3           NRF_GPIO_PIN_MAP(0,15)
++#define LED_4           NRF_GPIO_PIN_MAP(0,16)
++
++//=========================== variables =======================================
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++void leds_init() {
++
++    NRF_P0->DIRSET = 1<<LED_1;
++    NRF_P0->DIRSET = 1<<LED_2;
++    NRF_P0->DIRSET = 1<<LED_3;
++    NRF_P0->DIRSET = 1<<LED_4;
++
++    leds_all_off();
++}
++
++//==== error led
++
++void leds_error_off(void) {
++    NRF_P0->OUTSET = 1<<LED_1;
++}
++
++void leds_error_on(void) {
++    NRF_P0->OUTCLR = 1<<LED_1;
++}
++
++void leds_error_toggle(void) {
++    if ((NRF_P0->OUT & (1<<LED_1))!=0) {        
++        NRF_P0->OUTCLR = 1<<LED_1;
++    } else {
++        NRF_P0->OUTSET = 1<<LED_1;
++    }
++}
++
++uint8_t leds_error_isOn(void) {
++    if (NRF_P0->OUT & (1<<LED_1)) {
++        return 0;
++    } else {
++        return 1;
++    }
++}
++
++//==== sync led
++
++void leds_sync_off(void) {
++    NRF_P0->OUTSET = 1<<LED_2;
++}
++
++void leds_sync_on(void) {
++    NRF_P0->OUTCLR = 1<<LED_2;
++}
++
++void leds_sync_toggle(void) {
++    if ((NRF_P0->OUT & (1<<LED_2))!=0) {        
++        NRF_P0->OUTCLR = 1<<LED_2;
++    } else {
++        NRF_P0->OUTSET = 1<<LED_2;
++    }
++}
++
++uint8_t leds_sync_isOn(void) {
++    return (uint8_t)(NRF_P0->OUT & (1<<LED_2));
++}
++
++//==== radio led
++
++
++void leds_radio_off(void) {
++    NRF_P0->OUTSET = 1<<LED_3;
++}
++
++void leds_radio_on(void) {
++    NRF_P0->OUTCLR = 1<<LED_3;
++}
++
++void leds_radio_toggle(void) {
++    if ((NRF_P0->OUT & (1<<LED_3))!=0) {        
++        NRF_P0->OUTCLR = 1<<LED_3;
++    } else {
++        NRF_P0->OUTSET = 1<<LED_3;
++    }
++}
++
++uint8_t leds_radio_isOn(void) {
++    return (uint8_t)(NRF_P0->OUT & (1<<LED_3));
++}
++
++//==== debug led
++
++
++void leds_debug_off(void) {
++    NRF_P0->OUTSET = 1<<LED_4;
++}
++
++void leds_debug_on(void) {
++    NRF_P0->OUTCLR = 1<<LED_4;
++}
++
++void leds_debug_toggle(void) {
++    if ((NRF_P0->OUT & (1<<LED_4))!=0) {        
++        NRF_P0->OUTCLR = 1<<LED_4;
++    } else {
++        NRF_P0->OUTSET = 1<<LED_4;
++    }
++}
++
++uint8_t leds_debug_isOn(void) {
++    return (uint8_t)(NRF_P0->OUT & (1<<LED_4));
++}
++
++//==== all leds
++
++void leds_all_on(void) {
++    leds_radio_on();
++    leds_sync_on();
++    leds_debug_on();
++    leds_error_on();
++}
++
++void leds_all_off(void) {
++    leds_radio_off();
++    leds_sync_off();
++    leds_debug_off();
++    leds_error_off();
++}
++
++void leds_all_toggle(void) {
++    leds_radio_toggle();
++    leds_sync_toggle();
++    leds_debug_toggle();
++    leds_error_toggle();
++}
++
++void leds_error_blink(void) {
++    
++    uint8_t i;
++    uint32_t j;
++
++    // turn all LEDs off
++    leds_all_off();
++
++    // blink error LED for ~10s
++    for (i = 0; i < 100; i++) {
++        leds_error_toggle();
++        for(j=0;j<0x1ffff;j++);
++    }
++}
++
++void leds_circular_shift(void) {
++
++    uint32_t led_new_value;
++    uint32_t led_read;
++    uint32_t shift_bit;
++
++    led_read = NRF_P0->OUT & 0x0001e000;
++    shift_bit = (NRF_P0->OUT & 0x00010000)>>3;
++    led_new_value = ((led_read<<1) & 0x0001e000) | shift_bit; 
++    
++    NRF_P0->OUTSET = led_new_value;
++}
++
++void leds_increment(void) {
++    
++    uint32_t led_new_value;
++    uint32_t led_read;
++
++    led_read = (NRF_P0->OUT & 0x0001e000)>>13;
++    led_new_value = ((led_read+1) & 0x0000000f)<<13;
++
++    NRF_P0->OUTSET = led_new_value;
++}
++
++//=========================== private =========================================
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/mpu_armv7.h b/projects/nrf52840_dk/mpu_armv7.h
+new file mode 100644
+index 00000000..66ef59b4
+--- /dev/null
++++ b/projects/nrf52840_dk/mpu_armv7.h
+@@ -0,0 +1,272 @@
++/******************************************************************************
++ * @file     mpu_armv7.h
++ * @brief    CMSIS MPU API for Armv7-M MPU
++ * @version  V5.1.0
++ * @date     08. March 2019
++ ******************************************************************************/
++/*
++ * Copyright (c) 2017-2019 Arm Limited. All rights reserved.
++ *
++ * SPDX-License-Identifier: Apache-2.0
++ *
++ * Licensed under the Apache License, Version 2.0 (the License); you may
++ * not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ * www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an AS IS BASIS, WITHOUT
++ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++ 
++#if   defined ( __ICCARM__ )
++  #pragma system_include         /* treat file as system include file for MISRA check */
++#elif defined (__clang__)
++  #pragma clang system_header    /* treat file as system include file */
++#endif
++ 
++#ifndef ARM_MPU_ARMV7_H
++#define ARM_MPU_ARMV7_H
++
++#define ARM_MPU_REGION_SIZE_32B      ((uint8_t)0x04U) ///!< MPU Region Size 32 Bytes
++#define ARM_MPU_REGION_SIZE_64B      ((uint8_t)0x05U) ///!< MPU Region Size 64 Bytes
++#define ARM_MPU_REGION_SIZE_128B     ((uint8_t)0x06U) ///!< MPU Region Size 128 Bytes
++#define ARM_MPU_REGION_SIZE_256B     ((uint8_t)0x07U) ///!< MPU Region Size 256 Bytes
++#define ARM_MPU_REGION_SIZE_512B     ((uint8_t)0x08U) ///!< MPU Region Size 512 Bytes
++#define ARM_MPU_REGION_SIZE_1KB      ((uint8_t)0x09U) ///!< MPU Region Size 1 KByte
++#define ARM_MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU) ///!< MPU Region Size 2 KBytes
++#define ARM_MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU) ///!< MPU Region Size 4 KBytes
++#define ARM_MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU) ///!< MPU Region Size 8 KBytes
++#define ARM_MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU) ///!< MPU Region Size 16 KBytes
++#define ARM_MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU) ///!< MPU Region Size 32 KBytes
++#define ARM_MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU) ///!< MPU Region Size 64 KBytes
++#define ARM_MPU_REGION_SIZE_128KB    ((uint8_t)0x10U) ///!< MPU Region Size 128 KBytes
++#define ARM_MPU_REGION_SIZE_256KB    ((uint8_t)0x11U) ///!< MPU Region Size 256 KBytes
++#define ARM_MPU_REGION_SIZE_512KB    ((uint8_t)0x12U) ///!< MPU Region Size 512 KBytes
++#define ARM_MPU_REGION_SIZE_1MB      ((uint8_t)0x13U) ///!< MPU Region Size 1 MByte
++#define ARM_MPU_REGION_SIZE_2MB      ((uint8_t)0x14U) ///!< MPU Region Size 2 MBytes
++#define ARM_MPU_REGION_SIZE_4MB      ((uint8_t)0x15U) ///!< MPU Region Size 4 MBytes
++#define ARM_MPU_REGION_SIZE_8MB      ((uint8_t)0x16U) ///!< MPU Region Size 8 MBytes
++#define ARM_MPU_REGION_SIZE_16MB     ((uint8_t)0x17U) ///!< MPU Region Size 16 MBytes
++#define ARM_MPU_REGION_SIZE_32MB     ((uint8_t)0x18U) ///!< MPU Region Size 32 MBytes
++#define ARM_MPU_REGION_SIZE_64MB     ((uint8_t)0x19U) ///!< MPU Region Size 64 MBytes
++#define ARM_MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU) ///!< MPU Region Size 128 MBytes
++#define ARM_MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU) ///!< MPU Region Size 256 MBytes
++#define ARM_MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU) ///!< MPU Region Size 512 MBytes
++#define ARM_MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU) ///!< MPU Region Size 1 GByte
++#define ARM_MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU) ///!< MPU Region Size 2 GBytes
++#define ARM_MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU) ///!< MPU Region Size 4 GBytes
++
++#define ARM_MPU_AP_NONE 0U ///!< MPU Access Permission no access
++#define ARM_MPU_AP_PRIV 1U ///!< MPU Access Permission privileged access only
++#define ARM_MPU_AP_URO  2U ///!< MPU Access Permission unprivileged access read-only
++#define ARM_MPU_AP_FULL 3U ///!< MPU Access Permission full access
++#define ARM_MPU_AP_PRO  5U ///!< MPU Access Permission privileged access read-only
++#define ARM_MPU_AP_RO   6U ///!< MPU Access Permission read-only access
++
++/** MPU Region Base Address Register Value
++*
++* \param Region The region to be configured, number 0 to 15.
++* \param BaseAddress The base address for the region.
++*/
++#define ARM_MPU_RBAR(Region, BaseAddress) \
++  (((BaseAddress) & MPU_RBAR_ADDR_Msk) |  \
++   ((Region) & MPU_RBAR_REGION_Msk)    |  \
++   (MPU_RBAR_VALID_Msk))
++
++/**
++* MPU Memory Access Attributes
++* 
++* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
++* \param IsShareable       Region is shareable between multiple bus masters.
++* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
++* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
++*/  
++#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)   \
++  ((((TypeExtField) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                  | \
++   (((IsShareable)  << MPU_RASR_S_Pos)   & MPU_RASR_S_Msk)                    | \
++   (((IsCacheable)  << MPU_RASR_C_Pos)   & MPU_RASR_C_Msk)                    | \
++   (((IsBufferable) << MPU_RASR_B_Pos)   & MPU_RASR_B_Msk))
++
++/**
++* MPU Region Attribute and Size Register Value
++* 
++* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
++* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
++* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
++* \param SubRegionDisable  Sub-region disable field.
++* \param Size              Region size of the region to be configured, for example 4K, 8K.
++*/
++#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)    \
++  ((((DisableExec)      << MPU_RASR_XN_Pos)   & MPU_RASR_XN_Msk)                                  | \
++   (((AccessPermission) << MPU_RASR_AP_Pos)   & MPU_RASR_AP_Msk)                                  | \
++   (((AccessAttributes) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk))) | \
++   (((SubRegionDisable) << MPU_RASR_SRD_Pos)  & MPU_RASR_SRD_Msk)                                 | \
++   (((Size)             << MPU_RASR_SIZE_Pos) & MPU_RASR_SIZE_Msk)                                | \
++   (((MPU_RASR_ENABLE_Msk))))
++
++/**
++* MPU Region Attribute and Size Register Value
++* 
++* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
++* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
++* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
++* \param IsShareable       Region is shareable between multiple bus masters.
++* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
++* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
++* \param SubRegionDisable  Sub-region disable field.
++* \param Size              Region size of the region to be configured, for example 4K, 8K.
++*/                         
++#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size) \
++  ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
++
++/**
++* MPU Memory Access Attribute for strongly ordered memory.
++*  - TEX: 000b
++*  - Shareable
++*  - Non-cacheable
++*  - Non-bufferable
++*/ 
++#define ARM_MPU_ACCESS_ORDERED ARM_MPU_ACCESS_(0U, 1U, 0U, 0U)
++
++/**
++* MPU Memory Access Attribute for device memory.
++*  - TEX: 000b (if shareable) or 010b (if non-shareable)
++*  - Shareable or non-shareable
++*  - Non-cacheable
++*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
++*
++* \param IsShareable Configures the device memory as shareable or non-shareable.
++*/ 
++#define ARM_MPU_ACCESS_DEVICE(IsShareable) ((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))
++
++/**
++* MPU Memory Access Attribute for normal memory.
++*  - TEX: 1BBb (reflecting outer cacheability rules)
++*  - Shareable or non-shareable
++*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
++*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
++*
++* \param OuterCp Configures the outer cache policy.
++* \param InnerCp Configures the inner cache policy.
++* \param IsShareable Configures the memory as shareable or non-shareable.
++*/ 
++#define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) & 2U), ((InnerCp) & 1U))
++
++/**
++* MPU Memory Access Attribute non-cacheable policy.
++*/
++#define ARM_MPU_CACHEP_NOCACHE 0U
++
++/**
++* MPU Memory Access Attribute write-back, write and read allocate policy.
++*/
++#define ARM_MPU_CACHEP_WB_WRA 1U
++
++/**
++* MPU Memory Access Attribute write-through, no write allocate policy.
++*/
++#define ARM_MPU_CACHEP_WT_NWA 2U
++
++/**
++* MPU Memory Access Attribute write-back, no write allocate policy.
++*/
++#define ARM_MPU_CACHEP_WB_NWA 3U
++
++
++/**
++* Struct for a single MPU Region
++*/
++typedef struct {
++  uint32_t RBAR; //!< The region base address register value (RBAR)
++  uint32_t RASR; //!< The region attribute and size register value (RASR) \ref MPU_RASR
++} ARM_MPU_Region_t;
++    
++/** Enable the MPU.
++* \param MPU_Control Default access permissions for unconfigured regions.
++*/
++__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)
++{
++  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
++#ifdef SCB_SHCSR_MEMFAULTENA_Msk
++  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
++#endif
++  __DSB();
++  __ISB();
++}
++
++/** Disable the MPU.
++*/
++__STATIC_INLINE void ARM_MPU_Disable(void)
++{
++  __DMB();
++#ifdef SCB_SHCSR_MEMFAULTENA_Msk
++  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
++#endif
++  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
++}
++
++/** Clear and disable the given MPU region.
++* \param rnr Region number to be cleared.
++*/
++__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
++{
++  MPU->RNR = rnr;
++  MPU->RASR = 0U;
++}
++
++/** Configure an MPU region.
++* \param rbar Value for RBAR register.
++* \param rsar Value for RSAR register.
++*/   
++__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
++{
++  MPU->RBAR = rbar;
++  MPU->RASR = rasr;
++}
++
++/** Configure the given MPU region.
++* \param rnr Region number to be configured.
++* \param rbar Value for RBAR register.
++* \param rsar Value for RSAR register.
++*/   
++__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
++{
++  MPU->RNR = rnr;
++  MPU->RBAR = rbar;
++  MPU->RASR = rasr;
++}
++
++/** Memcopy with strictly ordered memory access, e.g. for register targets.
++* \param dst Destination data is copied to.
++* \param src Source data is copied from.
++* \param len Amount of data words to be copied.
++*/
++__STATIC_INLINE void ARM_MPU_OrderedMemcpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)
++{
++  uint32_t i;
++  for (i = 0U; i < len; ++i) 
++  {
++    dst[i] = src[i];
++  }
++}
++
++/** Load the given number of MPU regions from a table.
++* \param table Pointer to the MPU configuration table.
++* \param cnt Amount of regions to be configured.
++*/
++__STATIC_INLINE void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
++{
++  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;
++  while (cnt > MPU_TYPE_RALIASES) {
++    ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), MPU_TYPE_RALIASES*rowWordSize);
++    table += MPU_TYPE_RALIASES;
++    cnt -= MPU_TYPE_RALIASES;
++  }
++  ARM_MPU_OrderedMemcpy(&(MPU->RBAR), &(table->RBAR), cnt*rowWordSize);
++}
++
++#endif
+diff --git a/projects/nrf52840_dk/nrf.h b/projects/nrf52840_dk/nrf.h
+new file mode 100644
+index 00000000..58553e42
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf.h
+@@ -0,0 +1,198 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#ifndef NRF_H
++#define NRF_H
++
++/* MDK version */
++#define MDK_MAJOR_VERSION   8 
++#define MDK_MINOR_VERSION   40 
++#define MDK_MICRO_VERSION   3 
++
++   
++/* Define coprocessor domains */
++#if defined (NRF5340_XXAA_APPLICATION) || defined (NRF5340_XXAA_NETWORK)
++    #ifndef NRF5340_XXAA
++        #define NRF5340_XXAA
++    #endif
++#endif
++#if defined (NRF5340_XXAA_APPLICATION)
++    #ifndef NRF_APPLICATION
++        #define NRF_APPLICATION
++    #endif
++#endif
++#if defined (NRF5340_XXAA_NETWORK)
++    #ifndef NRF_NETWORK
++        #define NRF_NETWORK
++    #endif
++#endif
++
++/* Apply compatibility macros for old nRF5340 macros */
++#if defined(NRF5340_XXAA)
++    #if defined (NRF_APPLICATION)
++        #ifndef NRF5340_XXAA_APPLICATION
++            #define NRF5340_XXAA_APPLICATION
++        #endif
++    #endif
++    #if defined (NRF_NETWORK)
++        #ifndef NRF5340_XXAA_NETWORK
++            #define NRF5340_XXAA_NETWORK
++        #endif
++    #endif
++#endif
++
++/* Define NRF51_SERIES for common use in nRF51 series devices. Only if not previously defined. */
++#if defined (NRF51) ||\
++    defined (NRF51422_XXAA) ||\
++    defined (NRF51422_XXAB) ||\
++    defined (NRF51422_XXAC) ||\
++    defined (NRF51801_XXAB) ||\
++    defined (NRF51802_XXAA) ||\
++    defined (NRF51822_XXAA) ||\
++    defined (NRF51822_XXAB) ||\
++    defined (NRF51822_XXAC) ||\
++    defined (NRF51824_XXAA)
++    #ifndef NRF51_SERIES
++        #define NRF51_SERIES
++    #endif
++    #ifndef NRF51
++        #define NRF51
++    #endif
++#endif
++
++/* Redefine "old" too-generic name NRF52 to NRF52832_XXAA to keep backwards compatibility. */
++#if defined (NRF52)
++    #ifndef NRF52832_XXAA
++        #define NRF52832_XXAA
++    #endif
++#endif
++
++/* Define NRF52_SERIES for common use in nRF52 series devices. Only if not previously defined. */
++#if defined (NRF52805_XXAA) || defined (NRF52810_XXAA) || defined (NRF52811_XXAA) || defined (NRF52820_XXAA) || defined (NRF52832_XXAA) || defined (NRF52832_XXAB) || defined (NRF52833_XXAA) || defined (NRF52840_XXAA)
++    #ifndef NRF52_SERIES
++        #define NRF52_SERIES
++    #endif
++#endif
++
++/* Define NRF53_SERIES for common use in nRF53 series devices. */
++#if defined (NRF5340_XXAA)
++    #ifndef NRF53_SERIES
++        #define NRF53_SERIES
++    #endif
++#endif
++
++/* Define NRF91_SERIES for common use in nRF91 series devices. */
++#if defined (NRF9160_XXAA)
++    #ifndef NRF91_SERIES    
++        #define NRF91_SERIES
++    #endif
++#endif
++
++/* Device selection for device includes. */
++#if defined (NRF51)
++    #include "nrf51.h"
++    #include "nrf51_bitfields.h"
++    #include "nrf51_deprecated.h"
++
++#elif defined (NRF52805_XXAA)
++    #include "nrf52805.h"
++    #include "nrf52805_bitfields.h"
++    #include "nrf51_to_nrf52810.h"
++    #include "nrf52_to_nrf52810.h"
++    #include "nrf52810_to_nrf52811.h"
++#elif defined (NRF52810_XXAA)
++    #include "nrf52810.h"
++    #include "nrf52810_bitfields.h"
++    #include "nrf51_to_nrf52810.h"
++    #include "nrf52_to_nrf52810.h"
++    #include "nrf52810_name_change.h"
++#elif defined (NRF52811_XXAA)
++    #include "nrf52811.h"
++    #include "nrf52811_bitfields.h"
++    #include "nrf51_to_nrf52810.h"
++    #include "nrf52_to_nrf52810.h"
++    #include "nrf52810_to_nrf52811.h"
++#elif defined (NRF52820_XXAA)
++    #include "nrf52820.h"
++    #include "nrf52820_bitfields.h"
++    #include "nrf51_to_nrf52.h"
++    #include "nrf52_to_nrf52833.h"
++    #include "nrf52833_to_nrf52820.h"
++#elif defined (NRF52832_XXAA) || defined (NRF52832_XXAB)
++    #include "nrf52.h"
++    #include "nrf52_bitfields.h"
++    #include "nrf51_to_nrf52.h"
++    #include "nrf52_name_change.h"
++#elif defined (NRF52833_XXAA)
++    #include "nrf52833.h"
++    #include "nrf52833_bitfields.h"
++    #include "nrf52_to_nrf52833.h"
++    #include "nrf51_to_nrf52.h"
++#elif defined (NRF52840_XXAA)
++    #include "nrf52840.h"
++    #include "nrf52840_bitfields.h"
++    #include "nrf51_to_nrf52840.h"
++    #include "nrf52_to_nrf52840.h"
++
++#elif defined (NRF5340_XXAA)
++    #if defined(NRF_APPLICATION)
++        #include "nrf5340_application.h"
++        #include "nrf5340_application_bitfields.h"
++        #include "nrf5340_application_name_change.h"
++    #elif defined (NRF_NETWORK)
++        #include "nrf5340_network.h"
++        #include "nrf5340_network_bitfields.h"
++        #include "nrf5340_network_name_change.h"
++    #endif
++
++#elif defined (NRF9160_XXAA)
++    #include "nrf9160.h"
++    #include "nrf9160_bitfields.h"
++    #include "nrf9160_name_change.h"
++
++#else
++    #error "Device must be defined. See nrf.h."
++#endif /* NRF51, NRF52805_XXAA, NRF52810_XXAA, NRF52811_XXAA, NRF52820_XXAA, NRF52832_XXAA, NRF52832_XXAB, NRF52833_XXAA, NRF52840_XXAA, NRF5340_XXAA_APPLICATION, NRF5340_XXAA_NETWORK, NRF9160_XXAA */
++
++#include "compiler_abstraction.h"
++
++#endif /* NRF_H */
++
+diff --git a/projects/nrf52840_dk/nrf51_erratas.h b/projects/nrf52840_dk/nrf51_erratas.h
+new file mode 100644
+index 00000000..8320b1ec
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf51_erratas.h
+@@ -0,0 +1,4736 @@
++#ifndef NRF51_ERRATAS_H
++#define NRF51_ERRATAS_H
++
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#include <stdint.h>
++#include <stdbool.h>
++#include "compiler_abstraction.h"
++
++static bool nrf51_errata_1(void) __UNUSED;
++static bool nrf51_errata_2(void) __UNUSED;
++static bool nrf51_errata_3(void) __UNUSED;
++static bool nrf51_errata_4(void) __UNUSED;
++static bool nrf51_errata_5(void) __UNUSED;
++static bool nrf51_errata_6(void) __UNUSED;
++static bool nrf51_errata_7(void) __UNUSED;
++static bool nrf51_errata_8(void) __UNUSED;
++static bool nrf51_errata_9(void) __UNUSED;
++static bool nrf51_errata_10(void) __UNUSED;
++static bool nrf51_errata_11(void) __UNUSED;
++static bool nrf51_errata_12(void) __UNUSED;
++static bool nrf51_errata_13(void) __UNUSED;
++static bool nrf51_errata_14(void) __UNUSED;
++static bool nrf51_errata_15(void) __UNUSED;
++static bool nrf51_errata_16(void) __UNUSED;
++static bool nrf51_errata_17(void) __UNUSED;
++static bool nrf51_errata_18(void) __UNUSED;
++static bool nrf51_errata_19(void) __UNUSED;
++static bool nrf51_errata_20(void) __UNUSED;
++static bool nrf51_errata_21(void) __UNUSED;
++static bool nrf51_errata_22(void) __UNUSED;
++static bool nrf51_errata_23(void) __UNUSED;
++static bool nrf51_errata_24(void) __UNUSED;
++static bool nrf51_errata_25(void) __UNUSED;
++static bool nrf51_errata_26(void) __UNUSED;
++static bool nrf51_errata_27(void) __UNUSED;
++static bool nrf51_errata_28(void) __UNUSED;
++static bool nrf51_errata_29(void) __UNUSED;
++static bool nrf51_errata_30(void) __UNUSED;
++static bool nrf51_errata_31(void) __UNUSED;
++static bool nrf51_errata_32(void) __UNUSED;
++static bool nrf51_errata_33(void) __UNUSED;
++static bool nrf51_errata_34(void) __UNUSED;
++static bool nrf51_errata_35(void) __UNUSED;
++static bool nrf51_errata_36(void) __UNUSED;
++static bool nrf51_errata_37(void) __UNUSED;
++static bool nrf51_errata_38(void) __UNUSED;
++static bool nrf51_errata_39(void) __UNUSED;
++static bool nrf51_errata_40(void) __UNUSED;
++static bool nrf51_errata_41(void) __UNUSED;
++static bool nrf51_errata_42(void) __UNUSED;
++static bool nrf51_errata_43(void) __UNUSED;
++static bool nrf51_errata_44(void) __UNUSED;
++static bool nrf51_errata_45(void) __UNUSED;
++static bool nrf51_errata_46(void) __UNUSED;
++static bool nrf51_errata_47(void) __UNUSED;
++static bool nrf51_errata_48(void) __UNUSED;
++static bool nrf51_errata_49(void) __UNUSED;
++static bool nrf51_errata_50(void) __UNUSED;
++static bool nrf51_errata_51(void) __UNUSED;
++static bool nrf51_errata_52(void) __UNUSED;
++static bool nrf51_errata_53(void) __UNUSED;
++static bool nrf51_errata_54(void) __UNUSED;
++static bool nrf51_errata_55(void) __UNUSED;
++static bool nrf51_errata_56(void) __UNUSED;
++static bool nrf51_errata_57(void) __UNUSED;
++static bool nrf51_errata_58(void) __UNUSED;
++static bool nrf51_errata_59(void) __UNUSED;
++static bool nrf51_errata_60(void) __UNUSED;
++static bool nrf51_errata_61(void) __UNUSED;
++static bool nrf51_errata_62(void) __UNUSED;
++static bool nrf51_errata_63(void) __UNUSED;
++static bool nrf51_errata_64(void) __UNUSED;
++static bool nrf51_errata_65(void) __UNUSED;
++static bool nrf51_errata_66(void) __UNUSED;
++static bool nrf51_errata_67(void) __UNUSED;
++static bool nrf51_errata_68(void) __UNUSED;
++static bool nrf51_errata_69(void) __UNUSED;
++static bool nrf51_errata_70(void) __UNUSED;
++static bool nrf51_errata_71(void) __UNUSED;
++static bool nrf51_errata_72(void) __UNUSED;
++static bool nrf51_errata_73(void) __UNUSED;
++static bool nrf51_errata_74(void) __UNUSED;
++static bool nrf51_errata_75(void) __UNUSED;
++static bool nrf51_errata_76(void) __UNUSED;
++static bool nrf51_errata_77(void) __UNUSED;
++static bool nrf51_errata_78(void) __UNUSED;
++
++/* ========= Errata 1 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_1_PRESENT 1
++#else
++    #define NRF51_ERRATA_1_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_1_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_1_ENABLE_WORKAROUND NRF51_ERRATA_1_PRESENT
++#endif
++
++static bool nrf51_errata_1(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 2 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_2_PRESENT 1
++#else
++    #define NRF51_ERRATA_2_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_2_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_2_ENABLE_WORKAROUND NRF51_ERRATA_2_PRESENT
++#endif
++
++static bool nrf51_errata_2(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 3 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_3_PRESENT 1
++#else
++    #define NRF51_ERRATA_3_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_3_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_3_ENABLE_WORKAROUND NRF51_ERRATA_3_PRESENT
++#endif
++
++static bool nrf51_errata_3(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 4 ========= */
++#define NRF51_ERRATA_4_PRESENT 0
++
++#ifndef NRF51_ERRATA_4_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_4_ENABLE_WORKAROUND NRF51_ERRATA_4_PRESENT
++#endif
++
++static bool nrf51_errata_4(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 5 ========= */
++#define NRF51_ERRATA_5_PRESENT 0
++
++#ifndef NRF51_ERRATA_5_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_5_ENABLE_WORKAROUND NRF51_ERRATA_5_PRESENT
++#endif
++
++static bool nrf51_errata_5(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 6 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_6_PRESENT 1
++#else
++    #define NRF51_ERRATA_6_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_6_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_6_ENABLE_WORKAROUND NRF51_ERRATA_6_PRESENT
++#endif
++
++static bool nrf51_errata_6(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 7 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_7_PRESENT 1
++#else
++    #define NRF51_ERRATA_7_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_7_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_7_ENABLE_WORKAROUND NRF51_ERRATA_7_PRESENT
++#endif
++
++static bool nrf51_errata_7(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 8 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_8_PRESENT 1
++#else
++    #define NRF51_ERRATA_8_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_8_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_8_ENABLE_WORKAROUND NRF51_ERRATA_8_PRESENT
++#endif
++
++static bool nrf51_errata_8(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 9 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_9_PRESENT 1
++#else
++    #define NRF51_ERRATA_9_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_9_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_9_ENABLE_WORKAROUND NRF51_ERRATA_9_PRESENT
++#endif
++
++static bool nrf51_errata_9(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 10 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_10_PRESENT 1
++#else
++    #define NRF51_ERRATA_10_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_10_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_10_ENABLE_WORKAROUND NRF51_ERRATA_10_PRESENT
++#endif
++
++static bool nrf51_errata_10(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 11 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_11_PRESENT 1
++#else
++    #define NRF51_ERRATA_11_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_11_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_11_ENABLE_WORKAROUND NRF51_ERRATA_11_PRESENT
++#endif
++
++static bool nrf51_errata_11(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 12 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_12_PRESENT 1
++#else
++    #define NRF51_ERRATA_12_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_12_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_12_ENABLE_WORKAROUND NRF51_ERRATA_12_PRESENT
++#endif
++
++static bool nrf51_errata_12(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 13 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_13_PRESENT 1
++#else
++    #define NRF51_ERRATA_13_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_13_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_13_ENABLE_WORKAROUND NRF51_ERRATA_13_PRESENT
++#endif
++
++static bool nrf51_errata_13(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 14 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_14_PRESENT 1
++#else
++    #define NRF51_ERRATA_14_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_14_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_14_ENABLE_WORKAROUND NRF51_ERRATA_14_PRESENT
++#endif
++
++static bool nrf51_errata_14(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 15 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_15_PRESENT 1
++#else
++    #define NRF51_ERRATA_15_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_15_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_15_ENABLE_WORKAROUND NRF51_ERRATA_15_PRESENT
++#endif
++
++static bool nrf51_errata_15(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 16 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_16_PRESENT 1
++#else
++    #define NRF51_ERRATA_16_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_16_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_16_ENABLE_WORKAROUND NRF51_ERRATA_16_PRESENT
++#endif
++
++static bool nrf51_errata_16(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 17 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_17_PRESENT 1
++#else
++    #define NRF51_ERRATA_17_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_17_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_17_ENABLE_WORKAROUND NRF51_ERRATA_17_PRESENT
++#endif
++
++static bool nrf51_errata_17(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 18 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_18_PRESENT 1
++#else
++    #define NRF51_ERRATA_18_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_18_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_18_ENABLE_WORKAROUND NRF51_ERRATA_18_PRESENT
++#endif
++
++static bool nrf51_errata_18(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 19 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_19_PRESENT 1
++#else
++    #define NRF51_ERRATA_19_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_19_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_19_ENABLE_WORKAROUND NRF51_ERRATA_19_PRESENT
++#endif
++
++static bool nrf51_errata_19(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 20 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_20_PRESENT 1
++#else
++    #define NRF51_ERRATA_20_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_20_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_20_ENABLE_WORKAROUND NRF51_ERRATA_20_PRESENT
++#endif
++
++static bool nrf51_errata_20(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 21 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_21_PRESENT 1
++#else
++    #define NRF51_ERRATA_21_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_21_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_21_ENABLE_WORKAROUND NRF51_ERRATA_21_PRESENT
++#endif
++
++static bool nrf51_errata_21(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 22 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_22_PRESENT 1
++#else
++    #define NRF51_ERRATA_22_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_22_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_22_ENABLE_WORKAROUND NRF51_ERRATA_22_PRESENT
++#endif
++
++static bool nrf51_errata_22(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 23 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_23_PRESENT 1
++#else
++    #define NRF51_ERRATA_23_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_23_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_23_ENABLE_WORKAROUND NRF51_ERRATA_23_PRESENT
++#endif
++
++static bool nrf51_errata_23(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 24 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_24_PRESENT 1
++#else
++    #define NRF51_ERRATA_24_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_24_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_24_ENABLE_WORKAROUND NRF51_ERRATA_24_PRESENT
++#endif
++
++static bool nrf51_errata_24(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 25 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_25_PRESENT 1
++#else
++    #define NRF51_ERRATA_25_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_25_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_25_ENABLE_WORKAROUND NRF51_ERRATA_25_PRESENT
++#endif
++
++static bool nrf51_errata_25(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 26 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_26_PRESENT 1
++#else
++    #define NRF51_ERRATA_26_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_26_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_26_ENABLE_WORKAROUND NRF51_ERRATA_26_PRESENT
++#endif
++
++static bool nrf51_errata_26(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 27 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_27_PRESENT 1
++#else
++    #define NRF51_ERRATA_27_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_27_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_27_ENABLE_WORKAROUND NRF51_ERRATA_27_PRESENT
++#endif
++
++static bool nrf51_errata_27(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 28 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_28_PRESENT 1
++#else
++    #define NRF51_ERRATA_28_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_28_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_28_ENABLE_WORKAROUND NRF51_ERRATA_28_PRESENT
++#endif
++
++static bool nrf51_errata_28(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 29 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_29_PRESENT 1
++#else
++    #define NRF51_ERRATA_29_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_29_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_29_ENABLE_WORKAROUND NRF51_ERRATA_29_PRESENT
++#endif
++
++static bool nrf51_errata_29(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 30 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_30_PRESENT 1
++#else
++    #define NRF51_ERRATA_30_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_30_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_30_ENABLE_WORKAROUND NRF51_ERRATA_30_PRESENT
++#endif
++
++static bool nrf51_errata_30(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 31 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_31_PRESENT 1
++#else
++    #define NRF51_ERRATA_31_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_31_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_31_ENABLE_WORKAROUND NRF51_ERRATA_31_PRESENT
++#endif
++
++static bool nrf51_errata_31(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 32 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_32_PRESENT 1
++#else
++    #define NRF51_ERRATA_32_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_32_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_32_ENABLE_WORKAROUND NRF51_ERRATA_32_PRESENT
++#endif
++
++static bool nrf51_errata_32(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 33 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_33_PRESENT 1
++#else
++    #define NRF51_ERRATA_33_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_33_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_33_ENABLE_WORKAROUND NRF51_ERRATA_33_PRESENT
++#endif
++
++static bool nrf51_errata_33(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 34 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_34_PRESENT 1
++#else
++    #define NRF51_ERRATA_34_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_34_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_34_ENABLE_WORKAROUND NRF51_ERRATA_34_PRESENT
++#endif
++
++static bool nrf51_errata_34(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 35 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_35_PRESENT 1
++#else
++    #define NRF51_ERRATA_35_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_35_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_35_ENABLE_WORKAROUND NRF51_ERRATA_35_PRESENT
++#endif
++
++static bool nrf51_errata_35(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 36 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_36_PRESENT 1
++#else
++    #define NRF51_ERRATA_36_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_36_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_36_ENABLE_WORKAROUND NRF51_ERRATA_36_PRESENT
++#endif
++
++static bool nrf51_errata_36(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 37 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_37_PRESENT 1
++#else
++    #define NRF51_ERRATA_37_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_37_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_37_ENABLE_WORKAROUND NRF51_ERRATA_37_PRESENT
++#endif
++
++static bool nrf51_errata_37(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 38 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_38_PRESENT 1
++#else
++    #define NRF51_ERRATA_38_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_38_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_38_ENABLE_WORKAROUND NRF51_ERRATA_38_PRESENT
++#endif
++
++static bool nrf51_errata_38(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return true;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 39 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_39_PRESENT 1
++#else
++    #define NRF51_ERRATA_39_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_39_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_39_ENABLE_WORKAROUND NRF51_ERRATA_39_PRESENT
++#endif
++
++static bool nrf51_errata_39(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 40 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_40_PRESENT 1
++#else
++    #define NRF51_ERRATA_40_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_40_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_40_ENABLE_WORKAROUND NRF51_ERRATA_40_PRESENT
++#endif
++
++static bool nrf51_errata_40(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 41 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_41_PRESENT 1
++#else
++    #define NRF51_ERRATA_41_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_41_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_41_ENABLE_WORKAROUND NRF51_ERRATA_41_PRESENT
++#endif
++
++static bool nrf51_errata_41(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 42 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_42_PRESENT 1
++#else
++    #define NRF51_ERRATA_42_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_42_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_42_ENABLE_WORKAROUND NRF51_ERRATA_42_PRESENT
++#endif
++
++static bool nrf51_errata_42(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 43 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_43_PRESENT 1
++#else
++    #define NRF51_ERRATA_43_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_43_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_43_ENABLE_WORKAROUND NRF51_ERRATA_43_PRESENT
++#endif
++
++static bool nrf51_errata_43(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 44 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_44_PRESENT 1
++#else
++    #define NRF51_ERRATA_44_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_44_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_44_ENABLE_WORKAROUND NRF51_ERRATA_44_PRESENT
++#endif
++
++static bool nrf51_errata_44(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 45 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_45_PRESENT 1
++#else
++    #define NRF51_ERRATA_45_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_45_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_45_ENABLE_WORKAROUND NRF51_ERRATA_45_PRESENT
++#endif
++
++static bool nrf51_errata_45(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 46 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_46_PRESENT 1
++#else
++    #define NRF51_ERRATA_46_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_46_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_46_ENABLE_WORKAROUND NRF51_ERRATA_46_PRESENT
++#endif
++
++static bool nrf51_errata_46(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 47 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_47_PRESENT 1
++#else
++    #define NRF51_ERRATA_47_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_47_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_47_ENABLE_WORKAROUND NRF51_ERRATA_47_PRESENT
++#endif
++
++static bool nrf51_errata_47(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 48 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_48_PRESENT 1
++#else
++    #define NRF51_ERRATA_48_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_48_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_48_ENABLE_WORKAROUND NRF51_ERRATA_48_PRESENT
++#endif
++
++static bool nrf51_errata_48(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 49 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_49_PRESENT 1
++#else
++    #define NRF51_ERRATA_49_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_49_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_49_ENABLE_WORKAROUND NRF51_ERRATA_49_PRESENT
++#endif
++
++static bool nrf51_errata_49(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 50 ========= */
++#define NRF51_ERRATA_50_PRESENT 0
++
++#ifndef NRF51_ERRATA_50_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_50_ENABLE_WORKAROUND NRF51_ERRATA_50_PRESENT
++#endif
++
++static bool nrf51_errata_50(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 51 ========= */
++#define NRF51_ERRATA_51_PRESENT 0
++
++#ifndef NRF51_ERRATA_51_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_51_ENABLE_WORKAROUND NRF51_ERRATA_51_PRESENT
++#endif
++
++static bool nrf51_errata_51(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 52 ========= */
++#define NRF51_ERRATA_52_PRESENT 0
++
++#ifndef NRF51_ERRATA_52_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_52_ENABLE_WORKAROUND NRF51_ERRATA_52_PRESENT
++#endif
++
++static bool nrf51_errata_52(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 53 ========= */
++#define NRF51_ERRATA_53_PRESENT 0
++
++#ifndef NRF51_ERRATA_53_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_53_ENABLE_WORKAROUND NRF51_ERRATA_53_PRESENT
++#endif
++
++static bool nrf51_errata_53(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 54 ========= */
++#define NRF51_ERRATA_54_PRESENT 0
++
++#ifndef NRF51_ERRATA_54_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_54_ENABLE_WORKAROUND NRF51_ERRATA_54_PRESENT
++#endif
++
++static bool nrf51_errata_54(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 55 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_55_PRESENT 1
++#else
++    #define NRF51_ERRATA_55_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_55_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_55_ENABLE_WORKAROUND NRF51_ERRATA_55_PRESENT
++#endif
++
++static bool nrf51_errata_55(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 56 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_56_PRESENT 1
++#else
++    #define NRF51_ERRATA_56_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_56_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_56_ENABLE_WORKAROUND NRF51_ERRATA_56_PRESENT
++#endif
++
++static bool nrf51_errata_56(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 57 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_57_PRESENT 1
++#else
++    #define NRF51_ERRATA_57_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_57_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_57_ENABLE_WORKAROUND NRF51_ERRATA_57_PRESENT
++#endif
++
++static bool nrf51_errata_57(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 58 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_58_PRESENT 1
++#else
++    #define NRF51_ERRATA_58_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_58_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_58_ENABLE_WORKAROUND NRF51_ERRATA_58_PRESENT
++#endif
++
++static bool nrf51_errata_58(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 59 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_59_PRESENT 1
++#else
++    #define NRF51_ERRATA_59_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_59_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_59_ENABLE_WORKAROUND NRF51_ERRATA_59_PRESENT
++#endif
++
++static bool nrf51_errata_59(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 60 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_60_PRESENT 1
++#else
++    #define NRF51_ERRATA_60_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_60_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_60_ENABLE_WORKAROUND NRF51_ERRATA_60_PRESENT
++#endif
++
++static bool nrf51_errata_60(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 61 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_61_PRESENT 1
++#else
++    #define NRF51_ERRATA_61_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_61_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_61_ENABLE_WORKAROUND NRF51_ERRATA_61_PRESENT
++#endif
++
++static bool nrf51_errata_61(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return true;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 62 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_62_PRESENT 1
++#else
++    #define NRF51_ERRATA_62_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_62_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_62_ENABLE_WORKAROUND NRF51_ERRATA_62_PRESENT
++#endif
++
++static bool nrf51_errata_62(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 63 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_63_PRESENT 1
++#else
++    #define NRF51_ERRATA_63_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_63_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_63_ENABLE_WORKAROUND NRF51_ERRATA_63_PRESENT
++#endif
++
++static bool nrf51_errata_63(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 64 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_64_PRESENT 1
++#else
++    #define NRF51_ERRATA_64_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_64_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_64_ENABLE_WORKAROUND NRF51_ERRATA_64_PRESENT
++#endif
++
++static bool nrf51_errata_64(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 65 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_65_PRESENT 1
++#else
++    #define NRF51_ERRATA_65_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_65_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_65_ENABLE_WORKAROUND NRF51_ERRATA_65_PRESENT
++#endif
++
++static bool nrf51_errata_65(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 66 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_66_PRESENT 1
++#else
++    #define NRF51_ERRATA_66_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_66_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_66_ENABLE_WORKAROUND NRF51_ERRATA_66_PRESENT
++#endif
++
++static bool nrf51_errata_66(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 67 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_67_PRESENT 1
++#else
++    #define NRF51_ERRATA_67_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_67_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_67_ENABLE_WORKAROUND NRF51_ERRATA_67_PRESENT
++#endif
++
++static bool nrf51_errata_67(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return true;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 68 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_68_PRESENT 1
++#else
++    #define NRF51_ERRATA_68_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_68_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_68_ENABLE_WORKAROUND NRF51_ERRATA_68_PRESENT
++#endif
++
++static bool nrf51_errata_68(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 69 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_69_PRESENT 1
++#else
++    #define NRF51_ERRATA_69_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_69_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_69_ENABLE_WORKAROUND NRF51_ERRATA_69_PRESENT
++#endif
++
++static bool nrf51_errata_69(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 70 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_70_PRESENT 1
++#else
++    #define NRF51_ERRATA_70_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_70_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_70_ENABLE_WORKAROUND NRF51_ERRATA_70_PRESENT
++#endif
++
++static bool nrf51_errata_70(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return true;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 71 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_71_PRESENT 1
++#else
++    #define NRF51_ERRATA_71_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_71_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_71_ENABLE_WORKAROUND NRF51_ERRATA_71_PRESENT
++#endif
++
++static bool nrf51_errata_71(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 72 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_72_PRESENT 1
++#else
++    #define NRF51_ERRATA_72_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_72_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_72_ENABLE_WORKAROUND NRF51_ERRATA_72_PRESENT
++#endif
++
++static bool nrf51_errata_72(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return true;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 73 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_73_PRESENT 1
++#else
++    #define NRF51_ERRATA_73_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_73_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_73_ENABLE_WORKAROUND NRF51_ERRATA_73_PRESENT
++#endif
++
++static bool nrf51_errata_73(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 74 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_74_PRESENT 1
++#else
++    #define NRF51_ERRATA_74_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_74_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_74_ENABLE_WORKAROUND NRF51_ERRATA_74_PRESENT
++#endif
++
++static bool nrf51_errata_74(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 75 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_75_PRESENT 1
++#else
++    #define NRF51_ERRATA_75_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_75_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_75_ENABLE_WORKAROUND NRF51_ERRATA_75_PRESENT
++#endif
++
++static bool nrf51_errata_75(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return true;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 76 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_76_PRESENT 1
++#else
++    #define NRF51_ERRATA_76_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_76_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_76_ENABLE_WORKAROUND NRF51_ERRATA_76_PRESENT
++#endif
++
++static bool nrf51_errata_76(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    case 0x08ul:
++                        return false;
++                    case 0x09ul:
++                        return false;
++                    case 0x0Aul:
++                        return true;
++                    case 0x0Bul:
++                        return false;
++                    case 0x0Cul:
++                        return false;
++                    case 0x0Dul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 77 ========= */
++#define NRF51_ERRATA_77_PRESENT 0
++
++#ifndef NRF51_ERRATA_77_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_77_ENABLE_WORKAROUND NRF51_ERRATA_77_PRESENT
++#endif
++
++static bool nrf51_errata_77(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 78 ========= */
++#if    defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422) \
++    || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++    #define NRF51_ERRATA_78_PRESENT 1
++#else
++    #define NRF51_ERRATA_78_PRESENT 0
++#endif
++
++#ifndef NRF51_ERRATA_78_ENABLE_WORKAROUND
++    #define NRF51_ERRATA_78_ENABLE_WORKAROUND NRF51_ERRATA_78_PRESENT
++#endif
++
++static bool nrf51_errata_78(void)
++{
++    #ifndef NRF51_SERIES
++        return false;
++    #else
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF51422_XXAA) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAB) || defined (DEVELOP_IN_NRF51422)\
++         || defined (NRF51422_XXAC) || defined (DEVELOP_IN_NRF51422)
++            if (var1 == 0x01)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    case 0x08ul:
++                        return true;
++                    case 0x09ul:
++                        return true;
++                    case 0x0Aul:
++                        return false;
++                    case 0x0Bul:
++                        return true;
++                    case 0x0Cul:
++                        return true;
++                    case 0x0Dul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++#endif /* NRF51_ERRATAS_H */
+diff --git a/projects/nrf52840_dk/nrf51_to_nrf52840.h b/projects/nrf52840_dk/nrf51_to_nrf52840.h
+new file mode 100644
+index 00000000..161aeb69
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf51_to_nrf52840.h
+@@ -0,0 +1,1342 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#ifndef NRF51_TO_NRF52840_H
++#define NRF51_TO_NRF52840_H
++
++/*lint ++flb "Enter library region */
++
++/* This file is given to prevent your SW from not compiling with the name changes between nRF51 and nRF52840 devices.
++ * It redefines the old nRF51 names into the new ones as long as the functionality is still supported. If the
++ * functionality is gone, there old names are not defined, so compilation will fail. Note that also includes macros
++ * from the nrf51_deprecated.h file. */
++
++
++/* IRQ */
++/* Several peripherals have been added to several indexes. Names of IRQ handlers and IRQ numbers have changed. */
++#ifndef UART0_IRQHandler
++    #define UART0_IRQHandler        UARTE0_UART0_IRQHandler
++#endif
++#ifndef SPI0_TWI0_IRQHandler
++    #define SPI0_TWI0_IRQHandler    SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
++#endif
++#ifndef SPI1_TWI1_IRQHandler
++    #define SPI1_TWI1_IRQHandler    SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
++#endif
++#ifndef ADC_IRQHandler
++    #define ADC_IRQHandler          SAADC_IRQHandler
++#endif
++#ifndef LPCOMP_IRQHandler
++    #define LPCOMP_IRQHandler       COMP_LPCOMP_IRQHandler
++#endif
++#ifndef SWI0_IRQHandler
++    #define SWI0_IRQHandler         SWI0_EGU0_IRQHandler
++#endif
++#ifndef SWI1_IRQHandler
++    #define SWI1_IRQHandler         SWI1_EGU1_IRQHandler
++#endif
++#ifndef SWI2_IRQHandler
++    #define SWI2_IRQHandler         SWI2_EGU2_IRQHandler
++#endif
++#ifndef SWI3_IRQHandler
++    #define SWI3_IRQHandler         SWI3_EGU3_IRQHandler
++#endif
++#ifndef SWI4_IRQHandler
++    #define SWI4_IRQHandler         SWI4_EGU4_IRQHandler
++#endif
++#ifndef SWI5_IRQHandler
++    #define SWI5_IRQHandler         SWI5_EGU5_IRQHandler
++#endif
++
++#ifndef UART0_IRQn
++    #define UART0_IRQn              UARTE0_UART0_IRQn
++#endif
++#ifndef SPI0_TWI0_IRQn
++    #define SPI0_TWI0_IRQn          SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn
++#endif
++#ifndef SPI1_TWI1_IRQn
++    #define SPI1_TWI1_IRQn          SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQn
++#endif
++#ifndef ADC_IRQn
++    #define ADC_IRQn                SAADC_IRQn
++#endif
++#ifndef LPCOMP_IRQn
++    #define LPCOMP_IRQn             COMP_LPCOMP_IRQn
++#endif
++#ifndef SWI0_IRQn
++    #define SWI0_IRQn               SWI0_EGU0_IRQn
++#endif
++#ifndef SWI1_IRQn
++    #define SWI1_IRQn               SWI1_EGU1_IRQn
++#endif
++#ifndef SWI2_IRQn
++    #define SWI2_IRQn               SWI2_EGU2_IRQn
++#endif
++#ifndef SWI3_IRQn
++    #define SWI3_IRQn               SWI3_EGU3_IRQn
++#endif    
++#ifndef SWI4_IRQn
++    #define SWI4_IRQn               SWI4_EGU4_IRQn
++#endif    
++#ifndef SWI5_IRQn
++    #define SWI5_IRQn               SWI5_EGU5_IRQn
++#endif
++
++
++/* UICR */
++/* Register RBPCONF was renamed to APPROTECT. */
++#ifndef RBPCONF
++    #define RBPCONF     APPROTECT
++#endif
++
++#ifndef UICR_RBPCONF_PALL_Pos
++    #define UICR_RBPCONF_PALL_Pos           UICR_APPROTECT_PALL_Pos
++#endif
++#ifndef UICR_RBPCONF_PALL_Msk
++    #define UICR_RBPCONF_PALL_Msk           UICR_APPROTECT_PALL_Msk
++#endif
++#ifndef UICR_RBPCONF_PALL_Enabled
++    #define UICR_RBPCONF_PALL_Enabled       UICR_APPROTECT_PALL_Enabled
++#endif
++#ifndef UICR_RBPCONF_PALL_Disabled
++    #define UICR_RBPCONF_PALL_Disabled      UICR_APPROTECT_PALL_Disabled
++#endif
++
++
++/* GPIO */
++/* GPIO port was renamed to P0. */
++#ifndef NRF_GPIO
++    #define NRF_GPIO        NRF_P0
++#endif
++#ifndef NRF_GPIO_BASE
++    #define NRF_GPIO_BASE   NRF_P0_BASE
++#endif
++
++
++/* QDEC */
++/* The registers PSELA, PSELB and PSELLED were restructured into a struct. */
++#ifndef PSELLED
++    #define PSELLED     PSEL.LED
++#endif
++#ifndef PSELA
++    #define PSELA       PSEL.A
++#endif
++#ifndef PSELB
++    #define PSELB       PSEL.B
++#endif
++
++
++/* SPIS */
++/* The registers PSELSCK, PSELMISO, PSELMOSI, PSELCSN were restructured into a struct. */
++#ifndef PSELSCK
++    #define PSELSCK       PSEL.SCK
++#endif
++#ifndef PSELMISO
++    #define PSELMISO      PSEL.MISO
++#endif
++#ifndef PSELMOSI
++    #define PSELMOSI      PSEL.MOSI
++#endif
++#ifndef PSELCSN
++    #define PSELCSN       PSEL.CSN
++#endif    
++
++/* The registers RXDPTR, MAXRX, AMOUNTRX were restructured into a struct */
++#ifndef RXDPTR
++    #define RXDPTR        RXD.PTR
++#endif
++#ifndef MAXRX
++    #define MAXRX         RXD.MAXCNT
++#endif
++#ifndef AMOUNTRX
++    #define AMOUNTRX      RXD.AMOUNT
++#endif
++
++#ifndef SPIS_MAXRX_MAXRX_Pos
++    #define SPIS_MAXRX_MAXRX_Pos        SPIS_RXD_MAXCNT_MAXCNT_Pos
++#endif
++#ifndef SPIS_MAXRX_MAXRX_Msk
++    #define SPIS_MAXRX_MAXRX_Msk        SPIS_RXD_MAXCNT_MAXCNT_Msk
++#endif
++
++#ifndef SPIS_AMOUNTRX_AMOUNTRX_Pos
++    #define SPIS_AMOUNTRX_AMOUNTRX_Pos  SPIS_RXD_AMOUNT_AMOUNT_Pos
++#endif
++#ifndef SPIS_AMOUNTRX_AMOUNTRX_Msk
++    #define SPIS_AMOUNTRX_AMOUNTRX_Msk  SPIS_RXD_AMOUNT_AMOUNT_Msk
++#endif
++
++/* The registers TXDPTR, MAXTX, AMOUNTTX were restructured into a struct */
++#ifndef TXDPTR
++    #define TXDPTR        TXD.PTR
++#endif
++#ifndef MAXTX
++    #define MAXTX         TXD.MAXCNT
++#endif
++#ifndef AMOUNTTX
++    #define AMOUNTTX      TXD.AMOUNT
++#endif
++
++#ifndef SPIS_MAXTX_MAXTX_Pos
++    #define SPIS_MAXTX_MAXTX_Pos        SPIS_TXD_MAXCNT_MAXCNT_Pos
++#endif
++#ifndef SPIS_MAXTX_MAXTX_Msk
++    #define SPIS_MAXTX_MAXTX_Msk        SPIS_TXD_MAXCNT_MAXCNT_Msk
++#endif
++
++#ifndef SPIS_AMOUNTTX_AMOUNTTX_Pos
++    #define SPIS_AMOUNTTX_AMOUNTTX_Pos  SPIS_TXD_AMOUNT_AMOUNT_Pos
++#endif
++#ifndef SPIS_AMOUNTTX_AMOUNTTX_Msk
++    #define SPIS_AMOUNTTX_AMOUNTTX_Msk  SPIS_TXD_AMOUNT_AMOUNT_Msk
++#endif
++
++
++/* UART */
++/* The registers PSELRTS, PSELTXD, PSELCTS, PSELRXD were restructured into a struct. */
++#ifndef PSELRTS
++    #define PSELRTS       PSEL.RTS
++#endif
++#ifndef PSELTXD
++    #define PSELTXD       PSEL.TXD
++#endif
++#ifndef PSELCTS
++    #define PSELCTS       PSEL.CTS
++#endif
++#ifndef PSELRXD
++    #define PSELRXD       PSEL.RXD
++#endif
++
++/* TWI */
++/* The registers PSELSCL, PSELSDA were restructured into a struct. */
++#ifndef PSELSCL
++    #define PSELSCL       PSEL.SCL
++#endif
++#ifndef PSELSDA
++    #define PSELSDA       PSEL.SDA
++#endif
++
++
++/* From nrf51_deprecated.h */
++
++/* NVMC */
++/* The register ERASEPROTECTEDPAGE changed name to ERASEPCR0 in the documentation. */
++#ifndef ERASEPROTECTEDPAGE
++    #define ERASEPROTECTEDPAGE      ERASEPCR0
++#endif 
++
++
++/* IRQ */
++/* COMP module was eliminated. Adapted to nrf52840 headers. */
++#ifndef LPCOMP_COMP_IRQHandler
++    #define LPCOMP_COMP_IRQHandler  COMP_LPCOMP_IRQHandler
++#endif
++#ifndef LPCOMP_COMP_IRQn
++    #define LPCOMP_COMP_IRQn        COMP_LPCOMP_IRQn
++#endif
++
++
++/* REFSEL register redefined enumerated values and added some more. */
++#ifndef LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling
++    #define LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling          LPCOMP_REFSEL_REFSEL_Ref1_8Vdd
++#endif
++#ifndef LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling
++    #define LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling         LPCOMP_REFSEL_REFSEL_Ref2_8Vdd
++#endif
++#ifndef LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling
++    #define LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling       LPCOMP_REFSEL_REFSEL_Ref3_8Vdd
++#endif
++#ifndef LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling
++    #define LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling        LPCOMP_REFSEL_REFSEL_Ref4_8Vdd
++#endif
++#ifndef LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling
++    #define LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling        LPCOMP_REFSEL_REFSEL_Ref5_8Vdd
++#endif
++#ifndef LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling
++    #define LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling         LPCOMP_REFSEL_REFSEL_Ref6_8Vdd
++#endif
++#ifndef LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling
++    #define LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling       LPCOMP_REFSEL_REFSEL_Ref7_8Vdd
++#endif
++
++
++/* RADIO */
++/* The name of the field SKIPADDR was corrected. Old macros added for compatibility. */
++#ifndef RADIO_CRCCNF_SKIP_ADDR_Pos
++    #define RADIO_CRCCNF_SKIP_ADDR_Pos      RADIO_CRCCNF_SKIPADDR_Pos
++#endif
++#ifndef RADIO_CRCCNF_SKIP_ADDR_Msk
++    #define RADIO_CRCCNF_SKIP_ADDR_Msk      RADIO_CRCCNF_SKIPADDR_Msk
++#endif
++#ifndef RADIO_CRCCNF_SKIP_ADDR_Include
++    #define RADIO_CRCCNF_SKIP_ADDR_Include  RADIO_CRCCNF_SKIPADDR_Include
++#endif
++#ifndef RADIO_CRCCNF_SKIP_ADDR_Skip
++    #define RADIO_CRCCNF_SKIP_ADDR_Skip     RADIO_CRCCNF_SKIPADDR_Skip
++#endif
++
++
++/* FICR */
++/* The registers FICR.DEVICEID0 and FICR.DEVICEID1 were renamed into an array. */
++#ifndef DEVICEID0
++    #define DEVICEID0       DEVICEID[0]
++#endif
++#ifndef DEVICEID1
++    #define DEVICEID1       DEVICEID[1]
++#endif
++
++/* The registers FICR.ER0, FICR.ER1, FICR.ER2 and FICR.ER3 were renamed into an array. */
++#ifndef ER0
++    #define ER0             ER[0]
++#endif
++#ifndef ER1
++    #define ER1             ER[1]
++#endif
++#ifndef ER2
++    #define ER2             ER[2]
++#endif
++#ifndef ER3
++    #define ER3             ER[3]
++#endif
++
++/* The registers FICR.IR0, FICR.IR1, FICR.IR2 and FICR.IR3 were renamed into an array. */
++#ifndef IR0
++    #define IR0             IR[0]
++#endif
++#ifndef IR1
++    #define IR1             IR[1]
++#endif
++#ifndef IR2
++    #define IR2             IR[2]
++#endif
++#ifndef IR3
++    #define IR3             IR[3]
++#endif
++
++/* The registers FICR.DEVICEADDR0 and FICR.DEVICEADDR1 were renamed into an array. */
++#ifndef DEVICEADDR0
++    #define DEVICEADDR0     DEVICEADDR[0]
++#endif
++#ifndef DEVICEADDR1
++    #define DEVICEADDR1     DEVICEADDR[1]
++#endif
++
++
++/* PPI */
++/* The tasks PPI.TASKS_CHGxEN and PPI.TASKS_CHGxDIS were renamed into an array of structs. */
++#ifndef TASKS_CHG0EN
++    #define TASKS_CHG0EN     TASKS_CHG[0].EN
++#endif
++#ifndef TASKS_CHG0DIS
++    #define TASKS_CHG0DIS    TASKS_CHG[0].DIS
++#endif
++#ifndef TASKS_CHG1EN
++    #define TASKS_CHG1EN     TASKS_CHG[1].EN
++#endif
++#ifndef TASKS_CHG1DIS
++    #define TASKS_CHG1DIS    TASKS_CHG[1].DIS
++#endif
++#ifndef TASKS_CHG2EN
++    #define TASKS_CHG2EN     TASKS_CHG[2].EN
++#endif
++#ifndef TASKS_CHG2DIS
++    #define TASKS_CHG2DIS    TASKS_CHG[2].DIS
++#endif
++#ifndef TASKS_CHG3EN
++    #define TASKS_CHG3EN     TASKS_CHG[3].EN
++#endif
++#ifndef TASKS_CHG3DIS
++    #define TASKS_CHG3DIS    TASKS_CHG[3].DIS
++#endif
++
++/* The registers PPI.CHx_EEP and PPI.CHx_TEP were renamed into an array of structs. */
++#ifndef CH0_EEP
++    #define CH0_EEP          CH[0].EEP
++#endif
++#ifndef CH0_TEP
++    #define CH0_TEP          CH[0].TEP
++#endif
++#ifndef CH1_EEP
++    #define CH1_EEP          CH[1].EEP
++#endif
++#ifndef CH1_TEP
++    #define CH1_TEP          CH[1].TEP
++#endif
++#ifndef CH2_EEP
++    #define CH2_EEP          CH[2].EEP
++#endif
++#ifndef CH2_TEP
++    #define CH2_TEP          CH[2].TEP
++#endif
++#ifndef CH3_EEP
++    #define CH3_EEP          CH[3].EEP
++#endif
++#ifndef CH3_TEP
++    #define CH3_TEP          CH[3].TEP
++#endif
++#ifndef CH4_EEP
++    #define CH4_EEP          CH[4].EEP
++#endif
++#ifndef CH4_TEP
++    #define CH4_TEP          CH[4].TEP
++#endif
++#ifndef CH5_EEP
++    #define CH5_EEP          CH[5].EEP
++#endif
++#ifndef CH5_TEP
++    #define CH5_TEP          CH[5].TEP
++#endif
++#ifndef CH6_EEP
++    #define CH6_EEP          CH[6].EEP
++#endif
++#ifndef CH6_TEP
++    #define CH6_TEP          CH[6].TEP
++#endif 
++#ifndef CH7_EEP
++    #define CH7_EEP          CH[7].EEP
++#endif
++#ifndef CH7_TEP
++    #define CH7_TEP          CH[7].TEP
++#endif
++#ifndef CH8_EEP
++    #define CH8_EEP          CH[8].EEP
++#endif
++#ifndef CH8_TEP
++    #define CH8_TEP          CH[8].TEP
++#endif
++#ifndef CH9_EEP
++    #define CH9_EEP          CH[9].EEP
++#endif
++#ifndef CH9_TEP
++    #define CH9_TEP          CH[9].TEP
++#endif
++#ifndef CH10_EEP
++    #define CH10_EEP         CH[10].EEP
++#endif
++#ifndef CH10_TEP
++    #define CH10_TEP         CH[10].TEP
++#endif
++#ifndef CH11_EEP
++    #define CH11_EEP         CH[11].EEP
++#endif
++#ifndef CH11_TEP
++    #define CH11_TEP         CH[11].TEP
++#endif
++#ifndef CH12_EEP
++    #define CH12_EEP         CH[12].EEP
++#endif
++#ifndef CH12_TEP
++    #define CH12_TEP         CH[12].TEP
++#endif
++#ifndef CH13_EEP
++    #define CH13_EEP         CH[13].EEP
++#endif
++#ifndef CH13_TEP
++    #define CH13_TEP         CH[13].TEP
++#endif
++#ifndef CH14_EEP
++    #define CH14_EEP         CH[14].EEP
++#endif
++#ifndef CH14_TEP 
++    #define CH14_TEP         CH[14].TEP
++#endif
++#ifndef CH15_EEP
++    #define CH15_EEP         CH[15].EEP
++#endif
++#ifndef CH15_TEP
++    #define CH15_TEP         CH[15].TEP
++#endif
++
++/* The registers PPI.CHG0, PPI.CHG1, PPI.CHG2 and PPI.CHG3 were renamed into an array. */
++#ifndef CHG0
++    #define CHG0             CHG[0]
++#endif
++#ifndef CHG1
++    #define CHG1             CHG[1]
++#endif
++#ifndef CHG2
++    #define CHG2             CHG[2]
++#endif
++#ifndef CHG3
++    #define CHG3             CHG[3]
++#endif
++
++/* All bitfield macros for the CHGx registers therefore changed name. */
++#ifndef PPI_CHG0_CH15_Pos
++    #define PPI_CHG0_CH15_Pos       PPI_CHG_CH15_Pos
++#endif 
++#ifndef PPI_CHG0_CH15_Msk
++    #define PPI_CHG0_CH15_Msk       PPI_CHG_CH15_Msk
++#endif
++#ifndef PPI_CHG0_CH15_Excluded
++    #define PPI_CHG0_CH15_Excluded  PPI_CHG_CH15_Excluded
++#endif
++#ifndef PPI_CHG0_CH15_Included
++    #define PPI_CHG0_CH15_Included  PPI_CHG_CH15_Included
++#endif
++
++#ifndef PPI_CHG0_CH14_Pos
++    #define PPI_CHG0_CH14_Pos       PPI_CHG_CH14_Pos
++#endif
++#ifndef PPI_CHG0_CH14_Msk
++    #define PPI_CHG0_CH14_Msk       PPI_CHG_CH14_Msk
++#endif
++#ifndef PPI_CHG0_CH14_Excluded
++    #define PPI_CHG0_CH14_Excluded  PPI_CHG_CH14_Excluded
++#endif
++#ifndef PPI_CHG0_CH14_Included
++    #define PPI_CHG0_CH14_Included  PPI_CHG_CH14_Included
++#endif
++
++#ifndef PPI_CHG0_CH13_Pos
++    #define PPI_CHG0_CH13_Pos       PPI_CHG_CH13_Pos
++#endif
++#ifndef PPI_CHG0_CH13_Msk
++    #define PPI_CHG0_CH13_Msk       PPI_CHG_CH13_Msk
++#endif
++#ifndef PPI_CHG0_CH13_Excluded
++    #define PPI_CHG0_CH13_Excluded  PPI_CHG_CH13_Excluded
++#endif
++#ifndef PPI_CHG0_CH13_Included
++    #define PPI_CHG0_CH13_Included  PPI_CHG_CH13_Included
++#endif
++
++#ifndef PPI_CHG0_CH12_Pos
++    #define PPI_CHG0_CH12_Pos       PPI_CHG_CH12_Pos
++#endif
++#ifndef PPI_CHG0_CH12_Msk
++    #define PPI_CHG0_CH12_Msk       PPI_CHG_CH12_Msk
++#endif
++#ifndef PPI_CHG0_CH12_Excluded
++    #define PPI_CHG0_CH12_Excluded  PPI_CHG_CH12_Excluded
++#endif
++#ifndef PPI_CHG0_CH12_Included
++    #define PPI_CHG0_CH12_Included  PPI_CHG_CH12_Included
++#endif
++
++#ifndef PPI_CHG0_CH11_Pos
++    #define PPI_CHG0_CH11_Pos       PPI_CHG_CH11_Pos
++#endif
++#ifndef PPI_CHG0_CH11_Msk
++    #define PPI_CHG0_CH11_Msk       PPI_CHG_CH11_Msk
++#endif
++#ifndef PPI_CHG0_CH11_Excluded
++    #define PPI_CHG0_CH11_Excluded  PPI_CHG_CH11_Excluded
++#endif
++#ifndef PPI_CHG0_CH11_Included
++    #define PPI_CHG0_CH11_Included  PPI_CHG_CH11_Included
++#endif
++
++#ifndef PPI_CHG0_CH10_Pos
++    #define PPI_CHG0_CH10_Pos       PPI_CHG_CH10_Pos
++#endif
++#ifndef PPI_CHG0_CH10_Msk
++    #define PPI_CHG0_CH10_Msk       PPI_CHG_CH10_Msk
++#endif
++#ifndef PPI_CHG0_CH10_Excluded
++    #define PPI_CHG0_CH10_Excluded  PPI_CHG_CH10_Excluded
++#endif
++#ifndef PPI_CHG0_CH10_Included
++    #define PPI_CHG0_CH10_Included  PPI_CHG_CH10_Included
++#endif
++
++#ifndef PPI_CHG0_CH9_Pos
++    #define PPI_CHG0_CH9_Pos        PPI_CHG_CH9_Pos
++#endif
++#ifndef PPI_CHG0_CH9_Msk
++    #define PPI_CHG0_CH9_Msk        PPI_CHG_CH9_Msk
++#endif
++#ifndef PPI_CHG0_CH9_Excluded
++    #define PPI_CHG0_CH9_Excluded   PPI_CHG_CH9_Excluded
++#endif
++#ifndef PPI_CHG0_CH9_Included
++    #define PPI_CHG0_CH9_Included   PPI_CHG_CH9_Included
++#endif
++
++#ifndef PPI_CHG0_CH8_Pos
++    #define PPI_CHG0_CH8_Pos        PPI_CHG_CH8_Pos
++#endif
++#ifndef PPI_CHG0_CH8_Msk
++    #define PPI_CHG0_CH8_Msk        PPI_CHG_CH8_Msk
++#endif
++#ifndef PPI_CHG0_CH8_Excluded
++    #define PPI_CHG0_CH8_Excluded   PPI_CHG_CH8_Excluded
++#endif
++#ifndef PPI_CHG0_CH8_Included
++    #define PPI_CHG0_CH8_Included   PPI_CHG_CH8_Included
++#endif
++
++#ifndef PPI_CHG0_CH7_Pos
++    #define PPI_CHG0_CH7_Pos        PPI_CHG_CH7_Pos
++#endif
++#ifndef PPI_CHG0_CH7_Msk
++    #define PPI_CHG0_CH7_Msk        PPI_CHG_CH7_Msk
++#endif
++#ifndef PPI_CHG0_CH7_Excluded
++    #define PPI_CHG0_CH7_Excluded   PPI_CHG_CH7_Excluded
++#endif
++#ifndef PPI_CHG0_CH7_Included
++    #define PPI_CHG0_CH7_Included   PPI_CHG_CH7_Included
++#endif
++
++#ifndef PPI_CHG0_CH6_Pos
++    #define PPI_CHG0_CH6_Pos        PPI_CHG_CH6_Pos
++#endif
++#ifndef PPI_CHG0_CH6_Msk
++    #define PPI_CHG0_CH6_Msk        PPI_CHG_CH6_Msk
++#endif
++#ifndef PPI_CHG0_CH6_Excluded
++    #define PPI_CHG0_CH6_Excluded   PPI_CHG_CH6_Excluded
++#endif
++#ifndef PPI_CHG0_CH6_Included
++    #define PPI_CHG0_CH6_Included   PPI_CHG_CH6_Included
++#endif
++
++#ifndef PPI_CHG0_CH5_Pos
++    #define PPI_CHG0_CH5_Pos        PPI_CHG_CH5_Pos
++#endif
++#ifndef PPI_CHG0_CH5_Msk
++    #define PPI_CHG0_CH5_Msk        PPI_CHG_CH5_Msk
++#endif
++#ifndef PPI_CHG0_CH5_Excluded
++    #define PPI_CHG0_CH5_Excluded   PPI_CHG_CH5_Excluded
++#endif
++#ifndef PPI_CHG0_CH5_Included
++    #define PPI_CHG0_CH5_Included   PPI_CHG_CH5_Included
++#endif
++
++#ifndef PPI_CHG0_CH4_Pos
++    #define PPI_CHG0_CH4_Pos        PPI_CHG_CH4_Pos
++#endif
++#ifndef PPI_CHG0_CH4_Msk
++    #define PPI_CHG0_CH4_Msk        PPI_CHG_CH4_Msk
++#endif
++#ifndef PPI_CHG0_CH4_Excluded
++    #define PPI_CHG0_CH4_Excluded   PPI_CHG_CH4_Excluded
++#endif
++#ifndef PPI_CHG0_CH4_Included
++    #define PPI_CHG0_CH4_Included   PPI_CHG_CH4_Included
++#endif
++
++#ifndef PPI_CHG0_CH3_Pos
++    #define PPI_CHG0_CH3_Pos        PPI_CHG_CH3_Pos
++#endif
++#ifndef PPI_CHG0_CH3_Msk
++    #define PPI_CHG0_CH3_Msk        PPI_CHG_CH3_Msk
++#endif
++#ifndef PPI_CHG0_CH3_Excluded
++    #define PPI_CHG0_CH3_Excluded   PPI_CHG_CH3_Excluded
++#endif
++#ifndef PPI_CHG0_CH3_Included
++    #define PPI_CHG0_CH3_Included   PPI_CHG_CH3_Included
++#endif
++
++#ifndef PPI_CHG0_CH2_Pos
++    #define PPI_CHG0_CH2_Pos        PPI_CHG_CH2_Pos
++#endif
++#ifndef PPI_CHG0_CH2_Msk
++    #define PPI_CHG0_CH2_Msk        PPI_CHG_CH2_Msk
++#endif
++#ifndef PPI_CHG0_CH2_Excluded
++    #define PPI_CHG0_CH2_Excluded   PPI_CHG_CH2_Excluded
++#endif
++#ifndef PPI_CHG0_CH2_Included
++    #define PPI_CHG0_CH2_Included   PPI_CHG_CH2_Included
++#endif
++
++#ifndef PPI_CHG0_CH1_Pos
++    #define PPI_CHG0_CH1_Pos        PPI_CHG_CH1_Pos
++#endif
++#ifndef PPI_CHG0_CH1_Msk
++    #define PPI_CHG0_CH1_Msk        PPI_CHG_CH1_Msk
++#endif
++#ifndef PPI_CHG0_CH1_Excluded
++    #define PPI_CHG0_CH1_Excluded   PPI_CHG_CH1_Excluded
++#endif
++#ifndef PPI_CHG0_CH1_Included
++    #define PPI_CHG0_CH1_Included   PPI_CHG_CH1_Included
++#endif
++
++#ifndef PPI_CHG0_CH0_Pos
++    #define PPI_CHG0_CH0_Pos        PPI_CHG_CH0_Pos
++#endif
++#ifndef PPI_CHG0_CH0_Msk
++    #define PPI_CHG0_CH0_Msk        PPI_CHG_CH0_Msk
++#endif
++#ifndef PPI_CHG0_CH0_Excluded
++    #define PPI_CHG0_CH0_Excluded   PPI_CHG_CH0_Excluded
++#endif
++#ifndef PPI_CHG0_CH0_Included
++    #define PPI_CHG0_CH0_Included   PPI_CHG_CH0_Included
++#endif
++
++#ifndef PPI_CHG1_CH15_Pos
++    #define PPI_CHG1_CH15_Pos       PPI_CHG_CH15_Pos
++#endif
++#ifndef PPI_CHG1_CH15_Msk
++    #define PPI_CHG1_CH15_Msk       PPI_CHG_CH15_Msk
++#endif
++#ifndef PPI_CHG1_CH15_Excluded
++    #define PPI_CHG1_CH15_Excluded  PPI_CHG_CH15_Excluded
++#endif
++#ifndef PPI_CHG1_CH15_Included
++    #define PPI_CHG1_CH15_Included  PPI_CHG_CH15_Included
++#endif
++
++#ifndef PPI_CHG1_CH14_Pos
++    #define PPI_CHG1_CH14_Pos       PPI_CHG_CH14_Pos
++#endif
++#ifndef PPI_CHG1_CH14_Msk
++    #define PPI_CHG1_CH14_Msk       PPI_CHG_CH14_Msk
++#endif
++#ifndef PPI_CHG1_CH14_Excluded
++    #define PPI_CHG1_CH14_Excluded  PPI_CHG_CH14_Excluded
++#endif
++#ifndef PPI_CHG1_CH14_Included
++    #define PPI_CHG1_CH14_Included  PPI_CHG_CH14_Included
++#endif
++
++#ifndef PPI_CHG1_CH13_Pos
++    #define PPI_CHG1_CH13_Pos       PPI_CHG_CH13_Pos
++#endif
++#ifndef PPI_CHG1_CH13_Msk
++    #define PPI_CHG1_CH13_Msk       PPI_CHG_CH13_Msk
++#endif
++#ifndef PPI_CHG1_CH13_Excluded
++    #define PPI_CHG1_CH13_Excluded  PPI_CHG_CH13_Excluded
++#endif
++#ifndef PPI_CHG1_CH13_Included
++    #define PPI_CHG1_CH13_Included  PPI_CHG_CH13_Included
++#endif
++
++#ifndef PPI_CHG1_CH12_Pos
++    #define PPI_CHG1_CH12_Pos       PPI_CHG_CH12_Pos
++#endif
++#ifndef PPI_CHG1_CH12_Msk
++    #define PPI_CHG1_CH12_Msk       PPI_CHG_CH12_Msk
++#endif
++#ifndef PPI_CHG1_CH12_Excluded
++    #define PPI_CHG1_CH12_Excluded  PPI_CHG_CH12_Excluded
++#endif
++#ifndef PPI_CHG1_CH12_Included
++    #define PPI_CHG1_CH12_Included  PPI_CHG_CH12_Included
++#endif
++
++#ifndef PPI_CHG1_CH11_Pos
++    #define PPI_CHG1_CH11_Pos       PPI_CHG_CH11_Pos
++#endif
++#ifndef PPI_CHG1_CH11_Msk
++    #define PPI_CHG1_CH11_Msk       PPI_CHG_CH11_Msk
++#endif
++#ifndef PPI_CHG1_CH11_Excluded
++    #define PPI_CHG1_CH11_Excluded  PPI_CHG_CH11_Excluded
++#endif
++#ifndef PPI_CHG1_CH11_Included
++    #define PPI_CHG1_CH11_Included  PPI_CHG_CH11_Included
++#endif
++
++#ifndef PPI_CHG1_CH10_Pos
++    #define PPI_CHG1_CH10_Pos       PPI_CHG_CH10_Pos
++#endif
++#ifndef PPI_CHG1_CH10_Msk
++    #define PPI_CHG1_CH10_Msk       PPI_CHG_CH10_Msk
++#endif
++#ifndef PPI_CHG1_CH10_Excluded
++    #define PPI_CHG1_CH10_Excluded  PPI_CHG_CH10_Excluded
++#endif
++#ifndef PPI_CHG1_CH10_Included
++    #define PPI_CHG1_CH10_Included  PPI_CHG_CH10_Included
++#endif
++
++#ifndef PPI_CHG1_CH9_Pos
++    #define PPI_CHG1_CH9_Pos        PPI_CHG_CH9_Pos
++#endif
++#ifndef PPI_CHG1_CH9_Msk
++    #define PPI_CHG1_CH9_Msk        PPI_CHG_CH9_Msk
++#endif
++#ifndef PPI_CHG1_CH9_Excluded
++    #define PPI_CHG1_CH9_Excluded   PPI_CHG_CH9_Excluded
++#endif
++#ifndef PPI_CHG1_CH9_Included
++    #define PPI_CHG1_CH9_Included   PPI_CHG_CH9_Included
++#endif
++
++#ifndef PPI_CHG1_CH8_Pos
++    #define PPI_CHG1_CH8_Pos        PPI_CHG_CH8_Pos
++#endif
++#ifndef PPI_CHG1_CH8_Msk 
++    #define PPI_CHG1_CH8_Msk        PPI_CHG_CH8_Msk
++#endif
++#ifndef PPI_CHG1_CH8_Excluded
++    #define PPI_CHG1_CH8_Excluded   PPI_CHG_CH8_Excluded
++#endif
++#ifndef PPI_CHG1_CH8_Included 
++    #define PPI_CHG1_CH8_Included   PPI_CHG_CH8_Included
++#endif
++
++#ifndef PPI_CHG1_CH7_Pos
++    #define PPI_CHG1_CH7_Pos        PPI_CHG_CH7_Pos
++#endif
++#ifndef PPI_CHG1_CH7_Msk
++    #define PPI_CHG1_CH7_Msk        PPI_CHG_CH7_Msk
++#endif
++#ifndef PPI_CHG1_CH7_Excluded
++    #define PPI_CHG1_CH7_Excluded   PPI_CHG_CH7_Excluded
++#endif
++#ifndef PPI_CHG1_CH7_Included
++    #define PPI_CHG1_CH7_Included   PPI_CHG_CH7_Included
++#endif
++
++#ifndef PPI_CHG1_CH6_Pos
++    #define PPI_CHG1_CH6_Pos        PPI_CHG_CH6_Pos
++#endif
++#ifndef PPI_CHG1_CH6_Msk
++    #define PPI_CHG1_CH6_Msk        PPI_CHG_CH6_Msk
++#endif
++#ifndef PPI_CHG1_CH6_Excluded
++    #define PPI_CHG1_CH6_Excluded   PPI_CHG_CH6_Excluded
++#endif
++#ifndef PPI_CHG1_CH6_Included
++    #define PPI_CHG1_CH6_Included   PPI_CHG_CH6_Included
++#endif
++
++#ifndef PPI_CHG1_CH5_Pos
++    #define PPI_CHG1_CH5_Pos        PPI_CHG_CH5_Pos
++#endif
++#ifndef PPI_CHG1_CH5_Msk
++    #define PPI_CHG1_CH5_Msk        PPI_CHG_CH5_Msk
++#endif
++#ifndef PPI_CHG1_CH5_Excluded
++    #define PPI_CHG1_CH5_Excluded   PPI_CHG_CH5_Excluded
++#endif
++#ifndef PPI_CHG1_CH5_Included
++    #define PPI_CHG1_CH5_Included   PPI_CHG_CH5_Included
++#endif
++
++#ifndef PPI_CHG1_CH4_Pos
++    #define PPI_CHG1_CH4_Pos        PPI_CHG_CH4_Pos
++#endif
++#ifndef PPI_CHG1_CH4_Msk
++    #define PPI_CHG1_CH4_Msk        PPI_CHG_CH4_Msk
++#endif
++#ifndef PPI_CHG1_CH4_Excluded
++    #define PPI_CHG1_CH4_Excluded   PPI_CHG_CH4_Excluded
++#endif
++#ifndef PPI_CHG1_CH4_Included
++    #define PPI_CHG1_CH4_Included   PPI_CHG_CH4_Included
++#endif
++
++#ifndef PPI_CHG1_CH3_Pos
++    #define PPI_CHG1_CH3_Pos        PPI_CHG_CH3_Pos
++#endif
++#ifndef PPI_CHG1_CH3_Msk
++    #define PPI_CHG1_CH3_Msk        PPI_CHG_CH3_Msk
++#endif
++#ifndef PPI_CHG1_CH3_Excluded
++    #define PPI_CHG1_CH3_Excluded   PPI_CHG_CH3_Excluded
++#endif
++#ifndef PPI_CHG1_CH3_Included
++    #define PPI_CHG1_CH3_Included   PPI_CHG_CH3_Included
++#endif
++
++#ifndef PPI_CHG1_CH2_Pos
++    #define PPI_CHG1_CH2_Pos        PPI_CHG_CH2_Pos
++#endif
++#ifndef PPI_CHG1_CH2_Msk
++    #define PPI_CHG1_CH2_Msk        PPI_CHG_CH2_Msk
++#endif
++#ifndef PPI_CHG1_CH2_Excluded
++    #define PPI_CHG1_CH2_Excluded   PPI_CHG_CH2_Excluded
++#endif
++#ifndef PPI_CHG1_CH2_Included
++    #define PPI_CHG1_CH2_Included   PPI_CHG_CH2_Included
++#endif
++
++#ifndef PPI_CHG1_CH1_Pos
++    #define PPI_CHG1_CH1_Pos        PPI_CHG_CH1_Pos
++#endif
++#ifndef PPI_CHG1_CH1_Msk
++    #define PPI_CHG1_CH1_Msk        PPI_CHG_CH1_Msk
++#endif
++#ifndef PPI_CHG1_CH1_Excluded
++    #define PPI_CHG1_CH1_Excluded   PPI_CHG_CH1_Excluded
++#endif
++#ifndef PPI_CHG1_CH1_Included
++    #define PPI_CHG1_CH1_Included   PPI_CHG_CH1_Included
++#endif
++
++#ifndef PPI_CHG1_CH0_Pos
++    #define PPI_CHG1_CH0_Pos        PPI_CHG_CH0_Pos
++#endif
++#ifndef PPI_CHG1_CH0_Msk
++    #define PPI_CHG1_CH0_Msk        PPI_CHG_CH0_Msk
++#endif
++#ifndef PPI_CHG1_CH0_Excluded
++    #define PPI_CHG1_CH0_Excluded   PPI_CHG_CH0_Excluded
++#endif
++#ifndef PPI_CHG1_CH0_Included
++    #define PPI_CHG1_CH0_Included   PPI_CHG_CH0_Included
++#endif
++
++#ifndef PPI_CHG2_CH15_Pos
++    #define PPI_CHG2_CH15_Pos       PPI_CHG_CH15_Pos
++#endif
++#ifndef PPI_CHG2_CH15_Msk
++    #define PPI_CHG2_CH15_Msk       PPI_CHG_CH15_Msk
++#endif
++#ifndef PPI_CHG2_CH15_Excluded
++    #define PPI_CHG2_CH15_Excluded  PPI_CHG_CH15_Excluded
++#endif
++#ifndef PPI_CHG2_CH15_Included
++    #define PPI_CHG2_CH15_Included  PPI_CHG_CH15_Included
++#endif
++
++#ifndef PPI_CHG2_CH14_Pos
++    #define PPI_CHG2_CH14_Pos       PPI_CHG_CH14_Pos
++#endif
++#ifndef PPI_CHG2_CH14_Msk
++    #define PPI_CHG2_CH14_Msk       PPI_CHG_CH14_Msk
++#endif
++#ifndef PPI_CHG2_CH14_Excluded
++    #define PPI_CHG2_CH14_Excluded  PPI_CHG_CH14_Excluded
++#endif
++#ifndef PPI_CHG2_CH14_Included
++    #define PPI_CHG2_CH14_Included  PPI_CHG_CH14_Included
++#endif
++
++#ifndef PPI_CHG2_CH13_Pos
++    #define PPI_CHG2_CH13_Pos       PPI_CHG_CH13_Pos
++#endif
++#ifndef PPI_CHG2_CH13_Msk
++    #define PPI_CHG2_CH13_Msk       PPI_CHG_CH13_Msk
++#endif
++#ifndef PPI_CHG2_CH13_Excluded
++    #define PPI_CHG2_CH13_Excluded  PPI_CHG_CH13_Excluded
++#endif
++#ifndef PPI_CHG2_CH13_Included
++    #define PPI_CHG2_CH13_Included  PPI_CHG_CH13_Included
++#endif
++
++#ifndef PPI_CHG2_CH12_Pos
++    #define PPI_CHG2_CH12_Pos       PPI_CHG_CH12_Pos
++#endif
++#ifndef PPI_CHG2_CH12_Msk
++    #define PPI_CHG2_CH12_Msk       PPI_CHG_CH12_Msk
++#endif
++#ifndef PPI_CHG2_CH12_Excluded
++    #define PPI_CHG2_CH12_Excluded  PPI_CHG_CH12_Excluded
++#endif
++#ifndef PPI_CHG2_CH12_Included
++    #define PPI_CHG2_CH12_Included  PPI_CHG_CH12_Included
++#endif
++
++#ifndef PPI_CHG2_CH11_Pos
++    #define PPI_CHG2_CH11_Pos       PPI_CHG_CH11_Pos
++#endif
++#ifndef PPI_CHG2_CH11_Msk
++    #define PPI_CHG2_CH11_Msk       PPI_CHG_CH11_Msk
++#endif
++#ifndef PPI_CHG2_CH11_Excluded
++    #define PPI_CHG2_CH11_Excluded  PPI_CHG_CH11_Excluded
++#endif
++#ifndef PPI_CHG2_CH11_Included
++    #define PPI_CHG2_CH11_Included  PPI_CHG_CH11_Included
++#endif
++
++#ifndef PPI_CHG2_CH10_Pos
++    #define PPI_CHG2_CH10_Pos       PPI_CHG_CH10_Pos
++#endif
++#ifndef PPI_CHG2_CH10_Msk
++    #define PPI_CHG2_CH10_Msk       PPI_CHG_CH10_Msk
++#endif
++#ifndef PPI_CHG2_CH10_Excluded
++    #define PPI_CHG2_CH10_Excluded  PPI_CHG_CH10_Excluded
++#endif
++#ifndef PPI_CHG2_CH10_Included
++    #define PPI_CHG2_CH10_Included  PPI_CHG_CH10_Included
++#endif
++
++#ifndef PPI_CHG2_CH9_Pos
++    #define PPI_CHG2_CH9_Pos        PPI_CHG_CH9_Pos
++#endif
++#ifndef PPI_CHG2_CH9_Msk
++    #define PPI_CHG2_CH9_Msk        PPI_CHG_CH9_Msk
++#endif
++#ifndef PPI_CHG2_CH9_Excluded
++    #define PPI_CHG2_CH9_Excluded   PPI_CHG_CH9_Excluded
++#endif
++#ifndef PPI_CHG2_CH9_Included
++    #define PPI_CHG2_CH9_Included   PPI_CHG_CH9_Included
++#endif
++
++#ifndef PPI_CHG2_CH8_Pos
++    #define PPI_CHG2_CH8_Pos        PPI_CHG_CH8_Pos
++#endif
++#ifndef PPI_CHG2_CH8_Msk
++    #define PPI_CHG2_CH8_Msk        PPI_CHG_CH8_Msk
++#endif
++#ifndef PPI_CHG2_CH8_Excluded
++    #define PPI_CHG2_CH8_Excluded   PPI_CHG_CH8_Excluded
++#endif
++#ifndef PPI_CHG2_CH8_Included
++    #define PPI_CHG2_CH8_Included   PPI_CHG_CH8_Included
++#endif
++
++#ifndef PPI_CHG2_CH7_Pos
++    #define PPI_CHG2_CH7_Pos        PPI_CHG_CH7_Pos
++#endif
++#ifndef PPI_CHG2_CH7_Msk
++    #define PPI_CHG2_CH7_Msk        PPI_CHG_CH7_Msk
++#endif
++#ifndef PPI_CHG2_CH7_Excluded
++    #define PPI_CHG2_CH7_Excluded   PPI_CHG_CH7_Excluded
++#endif
++#ifndef PPI_CHG2_CH7_Included
++    #define PPI_CHG2_CH7_Included   PPI_CHG_CH7_Included
++#endif
++
++#ifndef PPI_CHG2_CH6_Pos
++    #define PPI_CHG2_CH6_Pos        PPI_CHG_CH6_Pos
++#endif
++#ifndef PPI_CHG2_CH6_Msk
++    #define PPI_CHG2_CH6_Msk        PPI_CHG_CH6_Msk
++#endif
++#ifndef PPI_CHG2_CH6_Excluded
++    #define PPI_CHG2_CH6_Excluded   PPI_CHG_CH6_Excluded
++#endif
++#ifndef PPI_CHG2_CH6_Included
++    #define PPI_CHG2_CH6_Included   PPI_CHG_CH6_Included
++#endif
++
++#ifndef PPI_CHG2_CH5_Pos
++    #define PPI_CHG2_CH5_Pos        PPI_CHG_CH5_Pos
++#endif
++#ifndef PPI_CHG2_CH5_Msk
++    #define PPI_CHG2_CH5_Msk        PPI_CHG_CH5_Msk
++#endif
++#ifndef PPI_CHG2_CH5_Excluded
++    #define PPI_CHG2_CH5_Excluded   PPI_CHG_CH5_Excluded
++#endif
++#ifndef PPI_CHG2_CH5_Included
++    #define PPI_CHG2_CH5_Included   PPI_CHG_CH5_Included
++#endif
++
++#ifndef PPI_CHG2_CH4_Pos
++    #define PPI_CHG2_CH4_Pos        PPI_CHG_CH4_Pos
++#endif
++#ifndef PPI_CHG2_CH4_Msk
++    #define PPI_CHG2_CH4_Msk        PPI_CHG_CH4_Msk
++#endif
++#ifndef PPI_CHG2_CH4_Excluded
++    #define PPI_CHG2_CH4_Excluded   PPI_CHG_CH4_Excluded
++#endif
++#ifndef PPI_CHG2_CH4_Included
++    #define PPI_CHG2_CH4_Included   PPI_CHG_CH4_Included
++#endif
++
++#ifndef PPI_CHG2_CH3_Pos
++    #define PPI_CHG2_CH3_Pos        PPI_CHG_CH3_Pos
++#endif
++#ifndef PPI_CHG2_CH3_Msk
++    #define PPI_CHG2_CH3_Msk        PPI_CHG_CH3_Msk
++#endif
++#ifndef PPI_CHG2_CH3_Excluded
++    #define PPI_CHG2_CH3_Excluded   PPI_CHG_CH3_Excluded
++#endif
++#ifndef PPI_CHG2_CH3_Included
++    #define PPI_CHG2_CH3_Included   PPI_CHG_CH3_Included
++#endif
++
++#ifndef PPI_CHG2_CH2_Pos
++    #define PPI_CHG2_CH2_Pos        PPI_CHG_CH2_Pos
++#endif
++#ifndef PPI_CHG2_CH2_Msk
++    #define PPI_CHG2_CH2_Msk        PPI_CHG_CH2_Msk
++#endif
++#ifndef PPI_CHG2_CH2_Excluded
++    #define PPI_CHG2_CH2_Excluded   PPI_CHG_CH2_Excluded
++#endif 
++#ifndef PPI_CHG2_CH2_Included
++    #define PPI_CHG2_CH2_Included   PPI_CHG_CH2_Included
++#endif
++
++#ifndef PPI_CHG2_CH1_Pos
++    #define PPI_CHG2_CH1_Pos        PPI_CHG_CH1_Pos
++#endif
++#ifndef PPI_CHG2_CH1_Msk
++    #define PPI_CHG2_CH1_Msk        PPI_CHG_CH1_Msk
++#endif
++#ifndef PPI_CHG2_CH1_Excluded
++    #define PPI_CHG2_CH1_Excluded   PPI_CHG_CH1_Excluded
++#endif
++#ifndef PPI_CHG2_CH1_Included
++    #define PPI_CHG2_CH1_Included   PPI_CHG_CH1_Included
++#endif
++
++#ifndef PPI_CHG2_CH0_Pos
++    #define PPI_CHG2_CH0_Pos        PPI_CHG_CH0_Pos
++#endif
++#ifndef PPI_CHG2_CH0_Msk
++    #define PPI_CHG2_CH0_Msk        PPI_CHG_CH0_Msk
++#endif
++#ifndef PPI_CHG2_CH0_Excluded
++    #define PPI_CHG2_CH0_Excluded   PPI_CHG_CH0_Excluded
++#endif
++#ifndef PPI_CHG2_CH0_Included
++    #define PPI_CHG2_CH0_Included   PPI_CHG_CH0_Included
++#endif
++
++#ifndef PPI_CHG3_CH15_Pos
++    #define PPI_CHG3_CH15_Pos       PPI_CHG_CH15_Pos
++#endif
++#ifndef PPI_CHG3_CH15_Msk
++    #define PPI_CHG3_CH15_Msk       PPI_CHG_CH15_Msk
++#endif
++#ifndef PPI_CHG3_CH15_Excluded
++    #define PPI_CHG3_CH15_Excluded  PPI_CHG_CH15_Excluded
++#endif
++#ifndef PPI_CHG3_CH15_Included
++    #define PPI_CHG3_CH15_Included  PPI_CHG_CH15_Included
++#endif
++
++#ifndef PPI_CHG3_CH14_Pos
++    #define PPI_CHG3_CH14_Pos       PPI_CHG_CH14_Pos
++#endif
++#ifndef PPI_CHG3_CH14_Msk
++    #define PPI_CHG3_CH14_Msk       PPI_CHG_CH14_Msk
++#endif
++#ifndef PPI_CHG3_CH14_Excluded
++    #define PPI_CHG3_CH14_Excluded  PPI_CHG_CH14_Excluded
++#endif
++#ifndef PPI_CHG3_CH14_Included
++    #define PPI_CHG3_CH14_Included  PPI_CHG_CH14_Included
++#endif
++
++#ifndef PPI_CHG3_CH13_Pos
++    #define PPI_CHG3_CH13_Pos       PPI_CHG_CH13_Pos
++#endif
++#ifndef PPI_CHG3_CH13_Msk
++    #define PPI_CHG3_CH13_Msk       PPI_CHG_CH13_Msk
++#endif
++#ifndef PPI_CHG3_CH13_Excluded
++    #define PPI_CHG3_CH13_Excluded  PPI_CHG_CH13_Excluded
++#endif
++#ifndef PPI_CHG3_CH13_Included
++    #define PPI_CHG3_CH13_Included  PPI_CHG_CH13_Included
++#endif
++
++#ifndef PPI_CHG3_CH12_Pos
++    #define PPI_CHG3_CH12_Pos       PPI_CHG_CH12_Pos
++#endif
++#ifndef PPI_CHG3_CH12_Msk
++    #define PPI_CHG3_CH12_Msk       PPI_CHG_CH12_Msk
++#endif
++#ifndef PPI_CHG3_CH12_Excluded
++    #define PPI_CHG3_CH12_Excluded  PPI_CHG_CH12_Excluded
++#endif
++#ifndef PPI_CHG3_CH12_Included
++    #define PPI_CHG3_CH12_Included  PPI_CHG_CH12_Included
++#endif
++
++#ifndef PPI_CHG3_CH11_Pos
++    #define PPI_CHG3_CH11_Pos       PPI_CHG_CH11_Pos
++#endif
++#ifndef PPI_CHG3_CH11_Msk
++    #define PPI_CHG3_CH11_Msk       PPI_CHG_CH11_Msk
++#endif
++#ifndef PPI_CHG3_CH11_Excluded
++    #define PPI_CHG3_CH11_Excluded  PPI_CHG_CH11_Excluded
++#endif
++#ifndef PPI_CHG3_CH11_Included
++    #define PPI_CHG3_CH11_Included  PPI_CHG_CH11_Included
++#endif
++
++#ifndef PPI_CHG3_CH10_Pos
++    #define PPI_CHG3_CH10_Pos       PPI_CHG_CH10_Pos
++#endif
++#ifndef PPI_CHG3_CH10_Msk
++    #define PPI_CHG3_CH10_Msk       PPI_CHG_CH10_Msk
++#endif
++#ifndef PPI_CHG3_CH10_Excluded
++    #define PPI_CHG3_CH10_Excluded  PPI_CHG_CH10_Excluded
++#endif
++#ifndef PPI_CHG3_CH10_Included
++    #define PPI_CHG3_CH10_Included  PPI_CHG_CH10_Included
++#endif
++
++#ifndef PPI_CHG3_CH9_Pos
++    #define PPI_CHG3_CH9_Pos        PPI_CHG_CH9_Pos
++#endif
++#ifndef PPI_CHG3_CH9_Msk
++    #define PPI_CHG3_CH9_Msk        PPI_CHG_CH9_Msk
++#endif
++#ifndef PPI_CHG3_CH9_Excluded
++    #define PPI_CHG3_CH9_Excluded   PPI_CHG_CH9_Excluded
++#endif
++#ifndef PPI_CHG3_CH9_Included
++    #define PPI_CHG3_CH9_Included   PPI_CHG_CH9_Included
++#endif
++
++#ifndef PPI_CHG3_CH8_Pos
++    #define PPI_CHG3_CH8_Pos        PPI_CHG_CH8_Pos
++#endif
++#ifndef PPI_CHG3_CH8_Msk
++    #define PPI_CHG3_CH8_Msk        PPI_CHG_CH8_Msk
++#endif
++#ifndef PPI_CHG3_CH8_Excluded
++    #define PPI_CHG3_CH8_Excluded   PPI_CHG_CH8_Excluded
++#endif
++#ifndef PPI_CHG3_CH8_Included
++    #define PPI_CHG3_CH8_Included   PPI_CHG_CH8_Included
++#endif
++
++#ifndef PPI_CHG3_CH7_Pos
++    #define PPI_CHG3_CH7_Pos        PPI_CHG_CH7_Pos
++#endif
++#ifndef PPI_CHG3_CH7_Msk
++    #define PPI_CHG3_CH7_Msk        PPI_CHG_CH7_Msk
++#endif
++#ifndef PPI_CHG3_CH7_Excluded
++    #define PPI_CHG3_CH7_Excluded   PPI_CHG_CH7_Excluded
++#endif
++#ifndef PPI_CHG3_CH7_Included
++    #define PPI_CHG3_CH7_Included   PPI_CHG_CH7_Included
++#endif
++
++#ifndef PPI_CHG3_CH6_Pos
++    #define PPI_CHG3_CH6_Pos        PPI_CHG_CH6_Pos
++#endif
++#ifndef PPI_CHG3_CH6_Msk
++    #define PPI_CHG3_CH6_Msk        PPI_CHG_CH6_Msk
++#endif
++#ifndef PPI_CHG3_CH6_Excluded
++    #define PPI_CHG3_CH6_Excluded   PPI_CHG_CH6_Excluded
++#endif
++#ifndef PPI_CHG3_CH6_Included
++    #define PPI_CHG3_CH6_Included   PPI_CHG_CH6_Included
++#endif
++
++#ifndef PPI_CHG3_CH5_Pos
++    #define PPI_CHG3_CH5_Pos        PPI_CHG_CH5_Pos
++#endif
++#ifndef PPI_CHG3_CH5_Msk
++    #define PPI_CHG3_CH5_Msk        PPI_CHG_CH5_Msk
++#endif
++#ifndef PPI_CHG3_CH5_Excluded
++    #define PPI_CHG3_CH5_Excluded   PPI_CHG_CH5_Excluded
++#endif
++#ifndef PPI_CHG3_CH5_Included
++    #define PPI_CHG3_CH5_Included   PPI_CHG_CH5_Included
++#endif
++
++#ifndef PPI_CHG3_CH4_Pos
++    #define PPI_CHG3_CH4_Pos        PPI_CHG_CH4_Pos
++#endif
++#ifndef PPI_CHG3_CH4_Msk
++    #define PPI_CHG3_CH4_Msk        PPI_CHG_CH4_Msk
++#endif
++#ifndef PPI_CHG3_CH4_Excluded
++    #define PPI_CHG3_CH4_Excluded   PPI_CHG_CH4_Excluded
++#endif
++#ifndef PPI_CHG3_CH4_Included
++    #define PPI_CHG3_CH4_Included   PPI_CHG_CH4_Included
++#endif
++
++#ifndef PPI_CHG3_CH3_Pos
++    #define PPI_CHG3_CH3_Pos        PPI_CHG_CH3_Pos
++#endif
++#ifndef PPI_CHG3_CH3_Msk
++    #define PPI_CHG3_CH3_Msk        PPI_CHG_CH3_Msk
++#endif
++#ifndef PPI_CHG3_CH3_Excluded
++    #define PPI_CHG3_CH3_Excluded   PPI_CHG_CH3_Excluded
++#endif
++#ifndef PPI_CHG3_CH3_Included
++    #define PPI_CHG3_CH3_Included   PPI_CHG_CH3_Included
++#endif
++
++#ifndef PPI_CHG3_CH2_Pos
++    #define PPI_CHG3_CH2_Pos        PPI_CHG_CH2_Pos
++#endif
++#ifndef PPI_CHG3_CH2_Msk
++    #define PPI_CHG3_CH2_Msk        PPI_CHG_CH2_Msk
++#endif
++#ifndef PPI_CHG3_CH2_Excluded
++    #define PPI_CHG3_CH2_Excluded   PPI_CHG_CH2_Excluded
++#endif
++#ifndef PPI_CHG3_CH2_Included
++    #define PPI_CHG3_CH2_Included   PPI_CHG_CH2_Included
++#endif
++
++#ifndef PPI_CHG3_CH1_Pos
++    #define PPI_CHG3_CH1_Pos        PPI_CHG_CH1_Pos
++#endif
++#ifndef PPI_CHG3_CH1_Msk
++    #define PPI_CHG3_CH1_Msk        PPI_CHG_CH1_Msk
++#endif
++#ifndef PPI_CHG3_CH1_Excluded
++    #define PPI_CHG3_CH1_Excluded   PPI_CHG_CH1_Excluded
++#endif
++#ifndef PPI_CHG3_CH1_Included
++    #define PPI_CHG3_CH1_Included   PPI_CHG_CH1_Included
++#endif
++
++#ifndef PPI_CHG3_CH0_Pos
++    #define PPI_CHG3_CH0_Pos        PPI_CHG_CH0_Pos
++#endif
++#ifndef PPI_CHG3_CH0_Msk
++    #define PPI_CHG3_CH0_Msk        PPI_CHG_CH0_Msk
++#endif
++#ifndef PPI_CHG3_CH0_Excluded
++    #define PPI_CHG3_CH0_Excluded   PPI_CHG_CH0_Excluded
++#endif
++#ifndef PPI_CHG3_CH0_Included
++    #define PPI_CHG3_CH0_Included   PPI_CHG_CH0_Included
++#endif
++
++
++
++
++
++/*lint --flb "Leave library region" */
++
++#endif /* NRF51_TO_NRF52840_H */
++
+diff --git a/projects/nrf52840_dk/nrf52840.h b/projects/nrf52840_dk/nrf52840.h
+new file mode 100644
+index 00000000..44c700d3
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf52840.h
+@@ -0,0 +1,2958 @@
++/*
++ * Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++ * 
++ * All rights reserved.
++ * 
++ * Redistribution and use in source and binary forms, with or without modification,
++ * are permitted provided that the following conditions are met:
++ * 
++ * 1. Redistributions of source code must retain the above copyright notice, this
++ * list of conditions and the following disclaimer.
++ * 
++ * 2. Redistributions in binary form, except as embedded into a Nordic
++ * Semiconductor ASA integrated circuit in a product or a software update for
++ * such product, must reproduce the above copyright notice, this list of
++ * conditions and the following disclaimer in the documentation and/or other
++ * materials provided with the distribution.
++ * 
++ * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
++ * contributors may be used to endorse or promote products derived from this
++ * software without specific prior written permission.
++ * 
++ * 4. This software, with or without modification, must only be used with a
++ * Nordic Semiconductor ASA integrated circuit.
++ * 
++ * 5. Any software provided in binary form under this license must not be reverse
++ * engineered, decompiled, modified and/or disassembled.
++ * 
++ * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++ * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++ * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++ *
++ * @file     nrf52840.h
++ * @brief    CMSIS HeaderFile
++ * @version  1
++ * @date     14. May 2021
++ * @note     Generated by SVDConv V3.3.35 on Friday, 14.05.2021 15:32:44
++ *           from File 'nrf52840.svd',
++ *           last modified on Friday, 14.05.2021 13:32:37
++ */
++
++
++
++/** @addtogroup Nordic Semiconductor
++  * @{
++  */
++
++
++/** @addtogroup nrf52840
++  * @{
++  */
++
++
++#ifndef NRF52840_H
++#define NRF52840_H
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++
++/** @addtogroup Configuration_of_CMSIS
++  * @{
++  */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                Interrupt Number Definition                                ================ */
++/* =========================================================================================================================== */
++
++typedef enum {
++/* =======================================  ARM Cortex-M4 Specific Interrupt Numbers  ======================================== */
++  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
++  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
++  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
++  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
++                                                     and No Match                                                              */
++  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
++                                                     related Fault                                                             */
++  UsageFault_IRQn           = -10,              /*!< -10  Usage Fault, i.e. Undef Instruction, Illegal State Transition        */
++  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
++  DebugMonitor_IRQn         =  -4,              /*!< -4 Debug Monitor                                                          */
++  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
++  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
++/* ==========================================  nrf52840 Specific Interrupt Numbers  ========================================== */
++  POWER_CLOCK_IRQn          =   0,              /*!< 0  POWER_CLOCK                                                            */
++  RADIO_IRQn                =   1,              /*!< 1  RADIO                                                                  */
++  UARTE0_UART0_IRQn         =   2,              /*!< 2  UARTE0_UART0                                                           */
++  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQn=   3,  /*!< 3  SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0                                      */
++  SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQn=   4,  /*!< 4  SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1                                      */
++  NFCT_IRQn                 =   5,              /*!< 5  NFCT                                                                   */
++  GPIOTE_IRQn               =   6,              /*!< 6  GPIOTE                                                                 */
++  SAADC_IRQn                =   7,              /*!< 7  SAADC                                                                  */
++  TIMER0_IRQn               =   8,              /*!< 8  TIMER0                                                                 */
++  TIMER1_IRQn               =   9,              /*!< 9  TIMER1                                                                 */
++  TIMER2_IRQn               =  10,              /*!< 10 TIMER2                                                                 */
++  RTC0_IRQn                 =  11,              /*!< 11 RTC0                                                                   */
++  TEMP_IRQn                 =  12,              /*!< 12 TEMP                                                                   */
++  RNG_IRQn                  =  13,              /*!< 13 RNG                                                                    */
++  ECB_IRQn                  =  14,              /*!< 14 ECB                                                                    */
++  CCM_AAR_IRQn              =  15,              /*!< 15 CCM_AAR                                                                */
++  WDT_IRQn                  =  16,              /*!< 16 WDT                                                                    */
++  RTC1_IRQn                 =  17,              /*!< 17 RTC1                                                                   */
++  QDEC_IRQn                 =  18,              /*!< 18 QDEC                                                                   */
++  COMP_LPCOMP_IRQn          =  19,              /*!< 19 COMP_LPCOMP                                                            */
++  SWI0_EGU0_IRQn            =  20,              /*!< 20 SWI0_EGU0                                                              */
++  SWI1_EGU1_IRQn            =  21,              /*!< 21 SWI1_EGU1                                                              */
++  SWI2_EGU2_IRQn            =  22,              /*!< 22 SWI2_EGU2                                                              */
++  SWI3_EGU3_IRQn            =  23,              /*!< 23 SWI3_EGU3                                                              */
++  SWI4_EGU4_IRQn            =  24,              /*!< 24 SWI4_EGU4                                                              */
++  SWI5_EGU5_IRQn            =  25,              /*!< 25 SWI5_EGU5                                                              */
++  TIMER3_IRQn               =  26,              /*!< 26 TIMER3                                                                 */
++  TIMER4_IRQn               =  27,              /*!< 27 TIMER4                                                                 */
++  PWM0_IRQn                 =  28,              /*!< 28 PWM0                                                                   */
++  PDM_IRQn                  =  29,              /*!< 29 PDM                                                                    */
++  MWU_IRQn                  =  32,              /*!< 32 MWU                                                                    */
++  PWM1_IRQn                 =  33,              /*!< 33 PWM1                                                                   */
++  PWM2_IRQn                 =  34,              /*!< 34 PWM2                                                                   */
++  SPIM2_SPIS2_SPI2_IRQn     =  35,              /*!< 35 SPIM2_SPIS2_SPI2                                                       */
++  RTC2_IRQn                 =  36,              /*!< 36 RTC2                                                                   */
++  I2S_IRQn                  =  37,              /*!< 37 I2S                                                                    */
++  FPU_IRQn                  =  38,              /*!< 38 FPU                                                                    */
++  USBD_IRQn                 =  39,              /*!< 39 USBD                                                                   */
++  UARTE1_IRQn               =  40,              /*!< 40 UARTE1                                                                 */
++  QSPI_IRQn                 =  41,              /*!< 41 QSPI                                                                   */
++  CRYPTOCELL_IRQn           =  42,              /*!< 42 CRYPTOCELL                                                             */
++  PWM3_IRQn                 =  45,              /*!< 45 PWM3                                                                   */
++  SPIM3_IRQn                =  47               /*!< 47 SPIM3                                                                  */
++} IRQn_Type;
++
++
++
++/* =========================================================================================================================== */
++/* ================                           Processor and Core Peripheral Section                           ================ */
++/* =========================================================================================================================== */
++
++/* ===========================  Configuration of the ARM Cortex-M4 Processor and Core Peripherals  =========================== */
++#define __CM4_REV                 0x0001U       /*!< CM4 Core Revision                                                         */
++#define __DSP_PRESENT                  1        /*!< DSP present or not                                                        */
++#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
++#define __NVIC_PRIO_BITS               3        /*!< Number of Bits used for Priority Levels                                   */
++#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
++#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
++#define __FPU_PRESENT                  1        /*!< FPU present                                                               */
++
++
++/** @} */ /* End of group Configuration_of_CMSIS */
++
++#include "core_cm4.h"                           /*!< ARM Cortex-M4 processor and core peripherals                              */
++#include "system_nrf52840.h"                    /*!< nrf52840 System                                                           */
++
++#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
++  #define __IM   __I
++#endif
++#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
++  #define __OM   __O
++#endif
++#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
++  #define __IOM  __IO
++#endif
++
++
++/* ========================================  Start of section using anonymous unions  ======================================== */
++#if defined (__CC_ARM)
++  #pragma push
++  #pragma anon_unions
++#elif defined (__ICCARM__)
++  #pragma language=extended
++#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
++  #pragma clang diagnostic push
++  #pragma clang diagnostic ignored "-Wc11-extensions"
++  #pragma clang diagnostic ignored "-Wreserved-id-macro"
++  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
++  #pragma clang diagnostic ignored "-Wnested-anon-types"
++#elif defined (__GNUC__)
++  /* anonymous unions are enabled by default */
++#elif defined (__TMS470__)
++  /* anonymous unions are enabled by default */
++#elif defined (__TASKING__)
++  #pragma warning 586
++#elif defined (__CSMC__)
++  /* anonymous unions are enabled by default */
++#else
++  #warning Not supported compiler type
++#endif
++
++
++/* =========================================================================================================================== */
++/* ================                              Device Specific Cluster Section                              ================ */
++/* =========================================================================================================================== */
++
++
++/** @addtogroup Device_Peripheral_clusters
++  * @{
++  */
++
++
++/**
++  * @brief FICR_INFO [INFO] (Device info)
++  */
++typedef struct {
++  __IM  uint32_t  PART;                         /*!< (@ 0x00000000) Part code                                                  */
++  __IM  uint32_t  VARIANT;                      /*!< (@ 0x00000004) Build code (hardware version and production configuration) */
++  __IM  uint32_t  PACKAGE;                      /*!< (@ 0x00000008) Package option                                             */
++  __IM  uint32_t  RAM;                          /*!< (@ 0x0000000C) RAM variant                                                */
++  __IM  uint32_t  FLASH;                        /*!< (@ 0x00000010) Flash variant                                              */
++} FICR_INFO_Type;                               /*!< Size = 20 (0x14)                                                          */
++
++
++/**
++  * @brief FICR_TEMP [TEMP] (Registers storing factory TEMP module linearization coefficients)
++  */
++typedef struct {
++  __IM  uint32_t  A0;                           /*!< (@ 0x00000000) Slope definition A0                                        */
++  __IM  uint32_t  A1;                           /*!< (@ 0x00000004) Slope definition A1                                        */
++  __IM  uint32_t  A2;                           /*!< (@ 0x00000008) Slope definition A2                                        */
++  __IM  uint32_t  A3;                           /*!< (@ 0x0000000C) Slope definition A3                                        */
++  __IM  uint32_t  A4;                           /*!< (@ 0x00000010) Slope definition A4                                        */
++  __IM  uint32_t  A5;                           /*!< (@ 0x00000014) Slope definition A5                                        */
++  __IM  uint32_t  B0;                           /*!< (@ 0x00000018) Y-intercept B0                                             */
++  __IM  uint32_t  B1;                           /*!< (@ 0x0000001C) Y-intercept B1                                             */
++  __IM  uint32_t  B2;                           /*!< (@ 0x00000020) Y-intercept B2                                             */
++  __IM  uint32_t  B3;                           /*!< (@ 0x00000024) Y-intercept B3                                             */
++  __IM  uint32_t  B4;                           /*!< (@ 0x00000028) Y-intercept B4                                             */
++  __IM  uint32_t  B5;                           /*!< (@ 0x0000002C) Y-intercept B5                                             */
++  __IM  uint32_t  T0;                           /*!< (@ 0x00000030) Segment end T0                                             */
++  __IM  uint32_t  T1;                           /*!< (@ 0x00000034) Segment end T1                                             */
++  __IM  uint32_t  T2;                           /*!< (@ 0x00000038) Segment end T2                                             */
++  __IM  uint32_t  T3;                           /*!< (@ 0x0000003C) Segment end T3                                             */
++  __IM  uint32_t  T4;                           /*!< (@ 0x00000040) Segment end T4                                             */
++} FICR_TEMP_Type;                               /*!< Size = 68 (0x44)                                                          */
++
++
++/**
++  * @brief FICR_NFC [NFC] (Unspecified)
++  */
++typedef struct {
++  __IM  uint32_t  TAGHEADER0;                   /*!< (@ 0x00000000) Default header for NFC tag. Software can read
++                                                                    these values to populate NFCID1_3RD_LAST,
++                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
++  __IM  uint32_t  TAGHEADER1;                   /*!< (@ 0x00000004) Default header for NFC tag. Software can read
++                                                                    these values to populate NFCID1_3RD_LAST,
++                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
++  __IM  uint32_t  TAGHEADER2;                   /*!< (@ 0x00000008) Default header for NFC tag. Software can read
++                                                                    these values to populate NFCID1_3RD_LAST,
++                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
++  __IM  uint32_t  TAGHEADER3;                   /*!< (@ 0x0000000C) Default header for NFC tag. Software can read
++                                                                    these values to populate NFCID1_3RD_LAST,
++                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
++} FICR_NFC_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief FICR_TRNG90B [TRNG90B] (NIST800-90B RNG calibration data)
++  */
++typedef struct {
++  __IM  uint32_t  BYTES;                        /*!< (@ 0x00000000) Amount of bytes for the required entropy bits              */
++  __IM  uint32_t  RCCUTOFF;                     /*!< (@ 0x00000004) Repetition counter cutoff                                  */
++  __IM  uint32_t  APCUTOFF;                     /*!< (@ 0x00000008) Adaptive proportion cutoff                                 */
++  __IM  uint32_t  STARTUP;                      /*!< (@ 0x0000000C) Amount of bytes for the startup tests                      */
++  __IM  uint32_t  ROSC1;                        /*!< (@ 0x00000010) Sample count for ring oscillator 1                         */
++  __IM  uint32_t  ROSC2;                        /*!< (@ 0x00000014) Sample count for ring oscillator 2                         */
++  __IM  uint32_t  ROSC3;                        /*!< (@ 0x00000018) Sample count for ring oscillator 3                         */
++  __IM  uint32_t  ROSC4;                        /*!< (@ 0x0000001C) Sample count for ring oscillator 4                         */
++} FICR_TRNG90B_Type;                            /*!< Size = 32 (0x20)                                                          */
++
++
++/**
++  * @brief POWER_RAM [RAM] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  POWER;                        /*!< (@ 0x00000000) Description cluster: RAMn power control register           */
++  __OM  uint32_t  POWERSET;                     /*!< (@ 0x00000004) Description cluster: RAMn power control set register       */
++  __OM  uint32_t  POWERCLR;                     /*!< (@ 0x00000008) Description cluster: RAMn power control clear
++                                                                    register                                                   */
++  __IM  uint32_t  RESERVED;
++} POWER_RAM_Type;                               /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief UART_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  RTS;                          /*!< (@ 0x00000000) Pin select for RTS                                         */
++  __IOM uint32_t  TXD;                          /*!< (@ 0x00000004) Pin select for TXD                                         */
++  __IOM uint32_t  CTS;                          /*!< (@ 0x00000008) Pin select for CTS                                         */
++  __IOM uint32_t  RXD;                          /*!< (@ 0x0000000C) Pin select for RXD                                         */
++} UART_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief UARTE_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  RTS;                          /*!< (@ 0x00000000) Pin select for RTS signal                                  */
++  __IOM uint32_t  TXD;                          /*!< (@ 0x00000004) Pin select for TXD signal                                  */
++  __IOM uint32_t  CTS;                          /*!< (@ 0x00000008) Pin select for CTS signal                                  */
++  __IOM uint32_t  RXD;                          /*!< (@ 0x0000000C) Pin select for RXD signal                                  */
++} UARTE_PSEL_Type;                              /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief UARTE_RXD [RXD] (RXD EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
++} UARTE_RXD_Type;                               /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief UARTE_TXD [TXD] (TXD EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
++} UARTE_TXD_Type;                               /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief SPI_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
++  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000004) Pin select for MOSI signal                                 */
++  __IOM uint32_t  MISO;                         /*!< (@ 0x00000008) Pin select for MISO signal                                 */
++} SPI_PSEL_Type;                                /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief SPIM_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
++  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000004) Pin select for MOSI signal                                 */
++  __IOM uint32_t  MISO;                         /*!< (@ 0x00000008) Pin select for MISO signal                                 */
++  __IOM uint32_t  CSN;                          /*!< (@ 0x0000000C) Pin select for CSN                                         */
++} SPIM_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief SPIM_RXD [RXD] (RXD EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
++  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
++} SPIM_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief SPIM_TXD [TXD] (TXD EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of bytes in transmit buffer                         */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
++  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
++} SPIM_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief SPIM_IFTIMING [IFTIMING] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  RXDELAY;                      /*!< (@ 0x00000000) Sample delay for input serial data on MISO                 */
++  __IOM uint32_t  CSNDUR;                       /*!< (@ 0x00000004) Minimum duration between edge of CSN and edge
++                                                                    of SCK and minimum duration CSN must stay
++                                                                    high between transactions                                  */
++} SPIM_IFTIMING_Type;                           /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief SPIS_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for SCK                                         */
++  __IOM uint32_t  MISO;                         /*!< (@ 0x00000004) Pin select for MISO signal                                 */
++  __IOM uint32_t  MOSI;                         /*!< (@ 0x00000008) Pin select for MOSI signal                                 */
++  __IOM uint32_t  CSN;                          /*!< (@ 0x0000000C) Pin select for CSN signal                                  */
++} SPIS_PSEL_Type;                               /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief SPIS_RXD [RXD] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RXD data pointer                                           */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes received in last granted transaction       */
++  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
++} SPIS_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief SPIS_TXD [TXD] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) TXD data pointer                                           */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transmitted in last granted transaction    */
++  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
++} SPIS_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief TWI_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL                                         */
++  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA                                         */
++} TWI_PSEL_Type;                                /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief TWIM_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL signal                                  */
++  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA signal                                  */
++} TWIM_PSEL_Type;                               /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief TWIM_RXD [RXD] (RXD EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in receive buffer                  */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
++  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
++} TWIM_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief TWIM_TXD [TXD] (TXD EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in transmit buffer                 */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
++  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
++} TWIM_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief TWIS_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SCL;                          /*!< (@ 0x00000000) Pin select for SCL signal                                  */
++  __IOM uint32_t  SDA;                          /*!< (@ 0x00000004) Pin select for SDA signal                                  */
++} TWIS_PSEL_Type;                               /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief TWIS_RXD [RXD] (RXD EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RXD Data pointer                                           */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in RXD buffer                      */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last RXD transaction    */
++  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
++} TWIS_RXD_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief TWIS_TXD [TXD] (TXD EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) TXD Data pointer                                           */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes in TXD buffer                      */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last TXD transaction    */
++  __IOM uint32_t  LIST;                         /*!< (@ 0x0000000C) EasyDMA list type                                          */
++} TWIS_TXD_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief NFCT_FRAMESTATUS [FRAMESTATUS] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  RX;                           /*!< (@ 0x00000000) Result of last incoming frame                              */
++} NFCT_FRAMESTATUS_Type;                        /*!< Size = 4 (0x4)                                                            */
++
++
++/**
++  * @brief NFCT_TXD [TXD] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  FRAMECONFIG;                  /*!< (@ 0x00000000) Configuration of outgoing frames                           */
++  __IOM uint32_t  AMOUNT;                       /*!< (@ 0x00000004) Size of outgoing frame                                     */
++} NFCT_TXD_Type;                                /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief NFCT_RXD [RXD] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  FRAMECONFIG;                  /*!< (@ 0x00000000) Configuration of incoming frames                           */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000004) Size of last incoming frame                                */
++} NFCT_RXD_Type;                                /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief SAADC_EVENTS_CH [EVENTS_CH] (Peripheral events.)
++  */
++typedef struct {
++  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Last result is equal or
++                                                                    above CH[n].LIMIT.HIGH                                     */
++  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Last result is equal or
++                                                                    below CH[n].LIMIT.LOW                                      */
++} SAADC_EVENTS_CH_Type;                         /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief SAADC_CH [CH] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PSELP;                        /*!< (@ 0x00000000) Description cluster: Input positive pin selection
++                                                                    for CH[n]                                                  */
++  __IOM uint32_t  PSELN;                        /*!< (@ 0x00000004) Description cluster: Input negative pin selection
++                                                                    for CH[n]                                                  */
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000008) Description cluster: Input configuration for
++                                                                    CH[n]                                                      */
++  __IOM uint32_t  LIMIT;                        /*!< (@ 0x0000000C) Description cluster: High/low limits for event
++                                                                    monitoring of a channel                                    */
++} SAADC_CH_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief SAADC_RESULT [RESULT] (RESULT EasyDMA channel)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of 16-bit samples to be written
++                                                                    to output RAM buffer                                       */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of 16-bit samples written to output RAM
++                                                                    buffer since the previous START task                       */
++} SAADC_RESULT_Type;                            /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief QDEC_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  LED;                          /*!< (@ 0x00000000) Pin select for LED signal                                  */
++  __IOM uint32_t  A;                            /*!< (@ 0x00000004) Pin select for A signal                                    */
++  __IOM uint32_t  B;                            /*!< (@ 0x00000008) Pin select for B signal                                    */
++} QDEC_PSEL_Type;                               /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief PWM_SEQ [SEQ] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Beginning address in RAM
++                                                                    of this sequence                                           */
++  __IOM uint32_t  CNT;                          /*!< (@ 0x00000004) Description cluster: Number of values (duty cycles)
++                                                                    in this sequence                                           */
++  __IOM uint32_t  REFRESH;                      /*!< (@ 0x00000008) Description cluster: Number of additional PWM
++                                                                    periods between samples loaded into compare
++                                                                    register                                                   */
++  __IOM uint32_t  ENDDELAY;                     /*!< (@ 0x0000000C) Description cluster: Time added after the sequence         */
++  __IM  uint32_t  RESERVED[4];
++} PWM_SEQ_Type;                                 /*!< Size = 32 (0x20)                                                          */
++
++
++/**
++  * @brief PWM_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  OUT[4];                       /*!< (@ 0x00000000) Description collection: Output pin select for
++                                                                    PWM channel n                                              */
++} PWM_PSEL_Type;                                /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief PDM_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  CLK;                          /*!< (@ 0x00000000) Pin number configuration for PDM CLK signal                */
++  __IOM uint32_t  DIN;                          /*!< (@ 0x00000004) Pin number configuration for PDM DIN signal                */
++} PDM_PSEL_Type;                                /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief PDM_SAMPLE [SAMPLE] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RAM address pointer to write samples to with
++                                                                    EasyDMA                                                    */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of samples to allocate memory for in EasyDMA
++                                                                    mode                                                       */
++} PDM_SAMPLE_Type;                              /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief ACL_ACL [ACL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  ADDR;                         /*!< (@ 0x00000000) Description cluster: Start address of region
++                                                                    to protect. The start address must be word-aligned.        */
++  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Size of region to protect
++                                                                    counting from address ACL[n].ADDR. Write
++                                                                    '0' as no effect.                                          */
++  __IOM uint32_t  PERM;                         /*!< (@ 0x00000008) Description cluster: Access permissions for region
++                                                                    n as defined by start address ACL[n].ADDR
++                                                                    and size ACL[n].SIZE                                       */
++  __IM  uint32_t  RESERVED;
++} ACL_ACL_Type;                                 /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief PPI_TASKS_CHG [TASKS_CHG] (Channel group tasks)
++  */
++typedef struct {
++  __OM  uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster: Enable channel group n                */
++  __OM  uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster: Disable channel group n               */
++} PPI_TASKS_CHG_Type;                           /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief PPI_CH [CH] (PPI Channel)
++  */
++typedef struct {
++  __IOM uint32_t  EEP;                          /*!< (@ 0x00000000) Description cluster: Channel n event endpoint              */
++  __IOM uint32_t  TEP;                          /*!< (@ 0x00000004) Description cluster: Channel n task endpoint               */
++} PPI_CH_Type;                                  /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief PPI_FORK [FORK] (Fork)
++  */
++typedef struct {
++  __IOM uint32_t  TEP;                          /*!< (@ 0x00000000) Description cluster: Channel n task endpoint               */
++} PPI_FORK_Type;                                /*!< Size = 4 (0x4)                                                            */
++
++
++/**
++  * @brief MWU_EVENTS_REGION [EVENTS_REGION] (Peripheral events.)
++  */
++typedef struct {
++  __IOM uint32_t  WA;                           /*!< (@ 0x00000000) Description cluster: Write access to region n
++                                                                    detected                                                   */
++  __IOM uint32_t  RA;                           /*!< (@ 0x00000004) Description cluster: Read access to region n
++                                                                    detected                                                   */
++} MWU_EVENTS_REGION_Type;                       /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief MWU_EVENTS_PREGION [EVENTS_PREGION] (Peripheral events.)
++  */
++typedef struct {
++  __IOM uint32_t  WA;                           /*!< (@ 0x00000000) Description cluster: Write access to peripheral
++                                                                    region n detected                                          */
++  __IOM uint32_t  RA;                           /*!< (@ 0x00000004) Description cluster: Read access to peripheral
++                                                                    region n detected                                          */
++} MWU_EVENTS_PREGION_Type;                      /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief MWU_PERREGION [PERREGION] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SUBSTATWA;                    /*!< (@ 0x00000000) Description cluster: Source of event/interrupt
++                                                                    in region n, write access detected while
++                                                                    corresponding subregion was enabled for
++                                                                    watching                                                   */
++  __IOM uint32_t  SUBSTATRA;                    /*!< (@ 0x00000004) Description cluster: Source of event/interrupt
++                                                                    in region n, read access detected while
++                                                                    corresponding subregion was enabled for
++                                                                    watching                                                   */
++} MWU_PERREGION_Type;                           /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief MWU_REGION [REGION] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  START;                        /*!< (@ 0x00000000) Description cluster: Start address for region
++                                                                    n                                                          */
++  __IOM uint32_t  END;                          /*!< (@ 0x00000004) Description cluster: End address of region n               */
++  __IM  uint32_t  RESERVED[2];
++} MWU_REGION_Type;                              /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief MWU_PREGION [PREGION] (Unspecified)
++  */
++typedef struct {
++  __IM  uint32_t  START;                        /*!< (@ 0x00000000) Description cluster: Reserved for future use               */
++  __IM  uint32_t  END;                          /*!< (@ 0x00000004) Description cluster: Reserved for future use               */
++  __IOM uint32_t  SUBS;                         /*!< (@ 0x00000008) Description cluster: Subregions of region n                */
++  __IM  uint32_t  RESERVED;
++} MWU_PREGION_Type;                             /*!< Size = 16 (0x10)                                                          */
++
++
++/**
++  * @brief I2S_CONFIG [CONFIG] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  MODE;                         /*!< (@ 0x00000000) I2S mode.                                                  */
++  __IOM uint32_t  RXEN;                         /*!< (@ 0x00000004) Reception (RX) enable.                                     */
++  __IOM uint32_t  TXEN;                         /*!< (@ 0x00000008) Transmission (TX) enable.                                  */
++  __IOM uint32_t  MCKEN;                        /*!< (@ 0x0000000C) Master clock generator enable.                             */
++  __IOM uint32_t  MCKFREQ;                      /*!< (@ 0x00000010) Master clock generator frequency.                          */
++  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000014) MCK / LRCK ratio.                                          */
++  __IOM uint32_t  SWIDTH;                       /*!< (@ 0x00000018) Sample width.                                              */
++  __IOM uint32_t  ALIGN;                        /*!< (@ 0x0000001C) Alignment of sample within a frame.                        */
++  __IOM uint32_t  FORMAT;                       /*!< (@ 0x00000020) Frame format.                                              */
++  __IOM uint32_t  CHANNELS;                     /*!< (@ 0x00000024) Enable channels.                                           */
++} I2S_CONFIG_Type;                              /*!< Size = 40 (0x28)                                                          */
++
++
++/**
++  * @brief I2S_RXD [RXD] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Receive buffer RAM start address.                          */
++} I2S_RXD_Type;                                 /*!< Size = 4 (0x4)                                                            */
++
++
++/**
++  * @brief I2S_TXD [TXD] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Transmit buffer RAM start address.                         */
++} I2S_TXD_Type;                                 /*!< Size = 4 (0x4)                                                            */
++
++
++/**
++  * @brief I2S_RXTXD [RXTXD] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000000) Size of RXD and TXD buffers.                               */
++} I2S_RXTXD_Type;                               /*!< Size = 4 (0x4)                                                            */
++
++
++/**
++  * @brief I2S_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  MCK;                          /*!< (@ 0x00000000) Pin select for MCK signal.                                 */
++  __IOM uint32_t  SCK;                          /*!< (@ 0x00000004) Pin select for SCK signal.                                 */
++  __IOM uint32_t  LRCK;                         /*!< (@ 0x00000008) Pin select for LRCK signal.                                */
++  __IOM uint32_t  SDIN;                         /*!< (@ 0x0000000C) Pin select for SDIN signal.                                */
++  __IOM uint32_t  SDOUT;                        /*!< (@ 0x00000010) Pin select for SDOUT signal.                               */
++} I2S_PSEL_Type;                                /*!< Size = 20 (0x14)                                                          */
++
++
++/**
++  * @brief USBD_HALTED [HALTED] (Unspecified)
++  */
++typedef struct {
++  __IM  uint32_t  EPIN[8];                      /*!< (@ 0x00000000) Description collection: IN endpoint halted status.
++                                                                    Can be used as is as response to a GetStatus()
++                                                                    request to endpoint.                                       */
++  __IM  uint32_t  RESERVED;
++  __IM  uint32_t  EPOUT[8];                     /*!< (@ 0x00000024) Description collection: OUT endpoint halted status.
++                                                                    Can be used as is as response to a GetStatus()
++                                                                    request to endpoint.                                       */
++} USBD_HALTED_Type;                             /*!< Size = 68 (0x44)                                                          */
++
++
++/**
++  * @brief USBD_SIZE [SIZE] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  EPOUT[8];                     /*!< (@ 0x00000000) Description collection: Number of bytes received
++                                                                    last in the data stage of this OUT endpoint                */
++  __IM  uint32_t  ISOOUT;                       /*!< (@ 0x00000020) Number of bytes received last on this ISO OUT
++                                                                    data endpoint                                              */
++} USBD_SIZE_Type;                               /*!< Size = 36 (0x24)                                                          */
++
++
++/**
++  * @brief USBD_EPIN [EPIN] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Data pointer                          */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
++                                                                    to transfer                                                */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
++                                                                    in the last transaction                                    */
++  __IM  uint32_t  RESERVED[2];
++} USBD_EPIN_Type;                               /*!< Size = 20 (0x14)                                                          */
++
++
++/**
++  * @brief USBD_ISOIN [ISOIN] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes to transfer                        */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
++} USBD_ISOIN_Type;                              /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief USBD_EPOUT [EPOUT] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Data pointer                          */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
++                                                                    to transfer                                                */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
++                                                                    in the last transaction                                    */
++  __IM  uint32_t  RESERVED[2];
++} USBD_EPOUT_Type;                              /*!< Size = 20 (0x14)                                                          */
++
++
++/**
++  * @brief USBD_ISOOUT [ISOOUT] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Data pointer                                               */
++  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of bytes to transfer                        */
++  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of bytes transferred in the last transaction        */
++} USBD_ISOOUT_Type;                             /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief QSPI_READ [READ] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SRC;                          /*!< (@ 0x00000000) Flash memory source address                                */
++  __IOM uint32_t  DST;                          /*!< (@ 0x00000004) RAM destination address                                    */
++  __IOM uint32_t  CNT;                          /*!< (@ 0x00000008) Read transfer length                                       */
++} QSPI_READ_Type;                               /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief QSPI_WRITE [WRITE] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  DST;                          /*!< (@ 0x00000000) Flash destination address                                  */
++  __IOM uint32_t  SRC;                          /*!< (@ 0x00000004) RAM source address                                         */
++  __IOM uint32_t  CNT;                          /*!< (@ 0x00000008) Write transfer length                                      */
++} QSPI_WRITE_Type;                              /*!< Size = 12 (0xc)                                                           */
++
++
++/**
++  * @brief QSPI_ERASE [ERASE] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Start address of flash block to be erased                  */
++  __IOM uint32_t  LEN;                          /*!< (@ 0x00000004) Size of block to be erased.                                */
++} QSPI_ERASE_Type;                              /*!< Size = 8 (0x8)                                                            */
++
++
++/**
++  * @brief QSPI_PSEL [PSEL] (Unspecified)
++  */
++typedef struct {
++  __IOM uint32_t  SCK;                          /*!< (@ 0x00000000) Pin select for serial clock SCK                            */
++  __IOM uint32_t  CSN;                          /*!< (@ 0x00000004) Pin select for chip select signal CSN.                     */
++  __IM  uint32_t  RESERVED;
++  __IOM uint32_t  IO0;                          /*!< (@ 0x0000000C) Pin select for serial data MOSI/IO0.                       */
++  __IOM uint32_t  IO1;                          /*!< (@ 0x00000010) Pin select for serial data MISO/IO1.                       */
++  __IOM uint32_t  IO2;                          /*!< (@ 0x00000014) Pin select for serial data IO2.                            */
++  __IOM uint32_t  IO3;                          /*!< (@ 0x00000018) Pin select for serial data IO3.                            */
++} QSPI_PSEL_Type;                               /*!< Size = 28 (0x1c)                                                          */
++
++
++/** @} */ /* End of group Device_Peripheral_clusters */
++
++
++/* =========================================================================================================================== */
++/* ================                            Device Specific Peripheral Section                             ================ */
++/* =========================================================================================================================== */
++
++
++/** @addtogroup Device_Peripheral_peripherals
++  * @{
++  */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           FICR                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Factory information configuration registers (FICR)
++  */
++
++typedef struct {                                /*!< (@ 0x10000000) FICR Structure                                             */
++  __IM  uint32_t  RESERVED[4];
++  __IM  uint32_t  CODEPAGESIZE;                 /*!< (@ 0x00000010) Code memory page size                                      */
++  __IM  uint32_t  CODESIZE;                     /*!< (@ 0x00000014) Code memory size                                           */
++  __IM  uint32_t  RESERVED1[18];
++  __IM  uint32_t  DEVICEID[2];                  /*!< (@ 0x00000060) Description collection: Device identifier                  */
++  __IM  uint32_t  RESERVED2[6];
++  __IM  uint32_t  ER[4];                        /*!< (@ 0x00000080) Description collection: Encryption root, word
++                                                                    n                                                          */
++  __IM  uint32_t  IR[4];                        /*!< (@ 0x00000090) Description collection: Identity Root, word n              */
++  __IM  uint32_t  DEVICEADDRTYPE;               /*!< (@ 0x000000A0) Device address type                                        */
++  __IM  uint32_t  DEVICEADDR[2];                /*!< (@ 0x000000A4) Description collection: Device address n                   */
++  __IM  uint32_t  RESERVED3[21];
++  __IM  FICR_INFO_Type INFO;                    /*!< (@ 0x00000100) Device info                                                */
++  __IM  uint32_t  RESERVED4[143];
++  __IM  uint32_t  PRODTEST[3];                  /*!< (@ 0x00000350) Description collection: Production test signature
++                                                                    n                                                          */
++  __IM  uint32_t  RESERVED5[42];
++  __IM  FICR_TEMP_Type TEMP;                    /*!< (@ 0x00000404) Registers storing factory TEMP module linearization
++                                                                    coefficients                                               */
++  __IM  uint32_t  RESERVED6[2];
++  __IOM FICR_NFC_Type NFC;                      /*!< (@ 0x00000450) Unspecified                                                */
++  __IM  uint32_t  RESERVED7[488];
++  __IOM FICR_TRNG90B_Type TRNG90B;              /*!< (@ 0x00000C00) NIST800-90B RNG calibration data                           */
++} NRF_FICR_Type;                                /*!< Size = 3104 (0xc20)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           UICR                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief User information configuration registers (UICR)
++  */
++
++typedef struct {                                /*!< (@ 0x10001000) UICR Structure                                             */
++  __IM  uint32_t  RESERVED[5];
++  __IOM uint32_t  NRFFW[13];                    /*!< (@ 0x00000014) Description collection: Reserved for Nordic firmware
++                                                                    design                                                     */
++  __IM  uint32_t  RESERVED1[2];
++  __IOM uint32_t  NRFHW[12];                    /*!< (@ 0x00000050) Description collection: Reserved for Nordic hardware
++                                                                    design                                                     */
++  __IOM uint32_t  CUSTOMER[32];                 /*!< (@ 0x00000080) Description collection: Reserved for customer              */
++  __IM  uint32_t  RESERVED2[64];
++  __IOM uint32_t  PSELRESET[2];                 /*!< (@ 0x00000200) Description collection: Mapping of the nRESET
++                                                                    function (see POWER chapter for details)                   */
++  __IOM uint32_t  APPROTECT;                    /*!< (@ 0x00000208) Access port protection                                     */
++  __IOM uint32_t  NFCPINS;                      /*!< (@ 0x0000020C) Setting of pins dedicated to NFC functionality:
++                                                                    NFC antenna or GPIO                                        */
++  __IOM uint32_t  DEBUGCTRL;                    /*!< (@ 0x00000210) Processor debug control                                    */
++  __IM  uint32_t  RESERVED3[60];
++  __IOM uint32_t  REGOUT0;                      /*!< (@ 0x00000304) Output voltage from REG0 regulator stage. The
++                                                                    maximum output voltage from this stage is
++                                                                    given as VDDH - V_VDDH-VDD.                                */
++} NRF_UICR_Type;                                /*!< Size = 776 (0x308)                                                        */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                         APPROTECT                                         ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Access Port Protection (APPROTECT)
++  */
++
++typedef struct {                                /*!< (@ 0x40000000) APPROTECT Structure                                        */
++  __IM  uint32_t  RESERVED[340];
++  __IOM uint32_t  FORCEPROTECT;                 /*!< (@ 0x00000550) Software force enable APPROTECT mechanism until
++                                                                    next reset.                                                */
++  __IM  uint32_t  RESERVED1;
++  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000558) Software disable APPROTECT mechanism                       */
++} NRF_APPROTECT_Type;                           /*!< Size = 1372 (0x55c)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           CLOCK                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Clock control (CLOCK)
++  */
++
++typedef struct {                                /*!< (@ 0x40000000) CLOCK Structure                                            */
++  __OM  uint32_t  TASKS_HFCLKSTART;             /*!< (@ 0x00000000) Start HFXO crystal oscillator                              */
++  __OM  uint32_t  TASKS_HFCLKSTOP;              /*!< (@ 0x00000004) Stop HFXO crystal oscillator                               */
++  __OM  uint32_t  TASKS_LFCLKSTART;             /*!< (@ 0x00000008) Start LFCLK                                                */
++  __OM  uint32_t  TASKS_LFCLKSTOP;              /*!< (@ 0x0000000C) Stop LFCLK                                                 */
++  __OM  uint32_t  TASKS_CAL;                    /*!< (@ 0x00000010) Start calibration of LFRC                                  */
++  __OM  uint32_t  TASKS_CTSTART;                /*!< (@ 0x00000014) Start calibration timer                                    */
++  __OM  uint32_t  TASKS_CTSTOP;                 /*!< (@ 0x00000018) Stop calibration timer                                     */
++  __IM  uint32_t  RESERVED[57];
++  __IOM uint32_t  EVENTS_HFCLKSTARTED;          /*!< (@ 0x00000100) HFXO crystal oscillator started                            */
++  __IOM uint32_t  EVENTS_LFCLKSTARTED;          /*!< (@ 0x00000104) LFCLK started                                              */
++  __IM  uint32_t  RESERVED1;
++  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x0000010C) Calibration of LFRC completed                              */
++  __IOM uint32_t  EVENTS_CTTO;                  /*!< (@ 0x00000110) Calibration timer timeout                                  */
++  __IM  uint32_t  RESERVED2[5];
++  __IOM uint32_t  EVENTS_CTSTARTED;             /*!< (@ 0x00000128) Calibration timer has been started and is ready
++                                                                    to process new tasks                                       */
++  __IOM uint32_t  EVENTS_CTSTOPPED;             /*!< (@ 0x0000012C) Calibration timer has been stopped and is ready
++                                                                    to process new tasks                                       */
++  __IM  uint32_t  RESERVED3[117];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED4[63];
++  __IM  uint32_t  HFCLKRUN;                     /*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
++                                                                    triggered                                                  */
++  __IM  uint32_t  HFCLKSTAT;                    /*!< (@ 0x0000040C) HFCLK status                                               */
++  __IM  uint32_t  RESERVED5;
++  __IM  uint32_t  LFCLKRUN;                     /*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
++                                                                    triggered                                                  */
++  __IM  uint32_t  LFCLKSTAT;                    /*!< (@ 0x00000418) LFCLK status                                               */
++  __IM  uint32_t  LFCLKSRCCOPY;                 /*!< (@ 0x0000041C) Copy of LFCLKSRC register, set when LFCLKSTART
++                                                                    task was triggered                                         */
++  __IM  uint32_t  RESERVED6[62];
++  __IOM uint32_t  LFCLKSRC;                     /*!< (@ 0x00000518) Clock source for the LFCLK                                 */
++  __IM  uint32_t  RESERVED7[3];
++  __IOM uint32_t  HFXODEBOUNCE;                 /*!< (@ 0x00000528) HFXO debounce time. The HFXO is started by triggering
++                                                                    the TASKS_HFCLKSTART task.                                 */
++  __IM  uint32_t  RESERVED8[3];
++  __IOM uint32_t  CTIV;                         /*!< (@ 0x00000538) Calibration timer interval                                 */
++  __IM  uint32_t  RESERVED9[8];
++  __IOM uint32_t  TRACECONFIG;                  /*!< (@ 0x0000055C) Clocking options for the trace port debug interface        */
++  __IM  uint32_t  RESERVED10[21];
++  __IOM uint32_t  LFRCMODE;                     /*!< (@ 0x000005B4) LFRC mode configuration                                    */
++} NRF_CLOCK_Type;                               /*!< Size = 1464 (0x5b8)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           POWER                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Power control (POWER)
++  */
++
++typedef struct {                                /*!< (@ 0x40000000) POWER Structure                                            */
++  __IM  uint32_t  RESERVED[30];
++  __OM  uint32_t  TASKS_CONSTLAT;               /*!< (@ 0x00000078) Enable Constant Latency mode                               */
++  __OM  uint32_t  TASKS_LOWPWR;                 /*!< (@ 0x0000007C) Enable Low-power mode (variable latency)                   */
++  __IM  uint32_t  RESERVED1[34];
++  __IOM uint32_t  EVENTS_POFWARN;               /*!< (@ 0x00000108) Power failure warning                                      */
++  __IM  uint32_t  RESERVED2[2];
++  __IOM uint32_t  EVENTS_SLEEPENTER;            /*!< (@ 0x00000114) CPU entered WFI/WFE sleep                                  */
++  __IOM uint32_t  EVENTS_SLEEPEXIT;             /*!< (@ 0x00000118) CPU exited WFI/WFE sleep                                   */
++  __IOM uint32_t  EVENTS_USBDETECTED;           /*!< (@ 0x0000011C) Voltage supply detected on VBUS                            */
++  __IOM uint32_t  EVENTS_USBREMOVED;            /*!< (@ 0x00000120) Voltage supply removed from VBUS                           */
++  __IOM uint32_t  EVENTS_USBPWRRDY;             /*!< (@ 0x00000124) USB 3.3 V supply ready                                     */
++  __IM  uint32_t  RESERVED3[119];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED4[61];
++  __IOM uint32_t  RESETREAS;                    /*!< (@ 0x00000400) Reset reason                                               */
++  __IM  uint32_t  RESERVED5[9];
++  __IM  uint32_t  RAMSTATUS;                    /*!< (@ 0x00000428) Deprecated register - RAM status register                  */
++  __IM  uint32_t  RESERVED6[3];
++  __IM  uint32_t  USBREGSTATUS;                 /*!< (@ 0x00000438) USB supply status                                          */
++  __IM  uint32_t  RESERVED7[49];
++  __OM  uint32_t  SYSTEMOFF;                    /*!< (@ 0x00000500) System OFF register                                        */
++  __IM  uint32_t  RESERVED8[3];
++  __IOM uint32_t  POFCON;                       /*!< (@ 0x00000510) Power-fail comparator configuration                        */
++  __IM  uint32_t  RESERVED9[2];
++  __IOM uint32_t  GPREGRET;                     /*!< (@ 0x0000051C) General purpose retention register                         */
++  __IOM uint32_t  GPREGRET2;                    /*!< (@ 0x00000520) General purpose retention register                         */
++  __IM  uint32_t  RESERVED10[21];
++  __IOM uint32_t  DCDCEN;                       /*!< (@ 0x00000578) Enable DC/DC converter for REG1 stage                      */
++  __IM  uint32_t  RESERVED11;
++  __IOM uint32_t  DCDCEN0;                      /*!< (@ 0x00000580) Enable DC/DC converter for REG0 stage                      */
++  __IM  uint32_t  RESERVED12[47];
++  __IM  uint32_t  MAINREGSTATUS;                /*!< (@ 0x00000640) Main supply status                                         */
++  __IM  uint32_t  RESERVED13[175];
++  __IOM POWER_RAM_Type RAM[9];                  /*!< (@ 0x00000900) Unspecified                                                */
++} NRF_POWER_Type;                               /*!< Size = 2448 (0x990)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            P0                                             ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief GPIO Port 1 (P0)
++  */
++
++typedef struct {                                /*!< (@ 0x50000000) P0 Structure                                               */
++  __IM  uint32_t  RESERVED[321];
++  __IOM uint32_t  OUT;                          /*!< (@ 0x00000504) Write GPIO port                                            */
++  __IOM uint32_t  OUTSET;                       /*!< (@ 0x00000508) Set individual bits in GPIO port                           */
++  __IOM uint32_t  OUTCLR;                       /*!< (@ 0x0000050C) Clear individual bits in GPIO port                         */
++  __IM  uint32_t  IN;                           /*!< (@ 0x00000510) Read GPIO port                                             */
++  __IOM uint32_t  DIR;                          /*!< (@ 0x00000514) Direction of GPIO pins                                     */
++  __IOM uint32_t  DIRSET;                       /*!< (@ 0x00000518) DIR set register                                           */
++  __IOM uint32_t  DIRCLR;                       /*!< (@ 0x0000051C) DIR clear register                                         */
++  __IOM uint32_t  LATCH;                        /*!< (@ 0x00000520) Latch register indicating what GPIO pins that
++                                                                    have met the criteria set in the PIN_CNF[n].SENSE
++                                                                    registers                                                  */
++  __IOM uint32_t  DETECTMODE;                   /*!< (@ 0x00000524) Select between default DETECT signal behavior
++                                                                    and LDETECT mode                                           */
++  __IM  uint32_t  RESERVED1[118];
++  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000700) Description collection: Configuration of GPIO
++                                                                    pins                                                       */
++} NRF_GPIO_Type;                                /*!< Size = 1920 (0x780)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           RADIO                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief 2.4 GHz radio (RADIO)
++  */
++
++typedef struct {                                /*!< (@ 0x40001000) RADIO Structure                                            */
++  __OM  uint32_t  TASKS_TXEN;                   /*!< (@ 0x00000000) Enable RADIO in TX mode                                    */
++  __OM  uint32_t  TASKS_RXEN;                   /*!< (@ 0x00000004) Enable RADIO in RX mode                                    */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000008) Start RADIO                                                */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x0000000C) Stop RADIO                                                 */
++  __OM  uint32_t  TASKS_DISABLE;                /*!< (@ 0x00000010) Disable RADIO                                              */
++  __OM  uint32_t  TASKS_RSSISTART;              /*!< (@ 0x00000014) Start the RSSI and take one single sample of
++                                                                    the receive signal strength                                */
++  __OM  uint32_t  TASKS_RSSISTOP;               /*!< (@ 0x00000018) Stop the RSSI measurement                                  */
++  __OM  uint32_t  TASKS_BCSTART;                /*!< (@ 0x0000001C) Start the bit counter                                      */
++  __OM  uint32_t  TASKS_BCSTOP;                 /*!< (@ 0x00000020) Stop the bit counter                                       */
++  __OM  uint32_t  TASKS_EDSTART;                /*!< (@ 0x00000024) Start the energy detect measurement used in IEEE
++                                                                    802.15.4 mode                                              */
++  __OM  uint32_t  TASKS_EDSTOP;                 /*!< (@ 0x00000028) Stop the energy detect measurement                         */
++  __OM  uint32_t  TASKS_CCASTART;               /*!< (@ 0x0000002C) Start the clear channel assessment used in IEEE
++                                                                    802.15.4 mode                                              */
++  __OM  uint32_t  TASKS_CCASTOP;                /*!< (@ 0x00000030) Stop the clear channel assessment                          */
++  __IM  uint32_t  RESERVED[51];
++  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) RADIO has ramped up and is ready to be started             */
++  __IOM uint32_t  EVENTS_ADDRESS;               /*!< (@ 0x00000104) Address sent or received                                   */
++  __IOM uint32_t  EVENTS_PAYLOAD;               /*!< (@ 0x00000108) Packet payload sent or received                            */
++  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x0000010C) Packet sent or received                                    */
++  __IOM uint32_t  EVENTS_DISABLED;              /*!< (@ 0x00000110) RADIO has been disabled                                    */
++  __IOM uint32_t  EVENTS_DEVMATCH;              /*!< (@ 0x00000114) A device address match occurred on the last received
++                                                                    packet                                                     */
++  __IOM uint32_t  EVENTS_DEVMISS;               /*!< (@ 0x00000118) No device address match occurred on the last
++                                                                    received packet                                            */
++  __IOM uint32_t  EVENTS_RSSIEND;               /*!< (@ 0x0000011C) Sampling of receive signal strength complete               */
++  __IM  uint32_t  RESERVED1[2];
++  __IOM uint32_t  EVENTS_BCMATCH;               /*!< (@ 0x00000128) Bit counter reached bit count value                        */
++  __IM  uint32_t  RESERVED2;
++  __IOM uint32_t  EVENTS_CRCOK;                 /*!< (@ 0x00000130) Packet received with CRC ok                                */
++  __IOM uint32_t  EVENTS_CRCERROR;              /*!< (@ 0x00000134) Packet received with CRC error                             */
++  __IOM uint32_t  EVENTS_FRAMESTART;            /*!< (@ 0x00000138) IEEE 802.15.4 length field received                        */
++  __IOM uint32_t  EVENTS_EDEND;                 /*!< (@ 0x0000013C) Sampling of energy detection complete. A new
++                                                                    ED sample is ready for readout from the
++                                                                    RADIO.EDSAMPLE register.                                   */
++  __IOM uint32_t  EVENTS_EDSTOPPED;             /*!< (@ 0x00000140) The sampling of energy detection has stopped               */
++  __IOM uint32_t  EVENTS_CCAIDLE;               /*!< (@ 0x00000144) Wireless medium in idle - clear to send                    */
++  __IOM uint32_t  EVENTS_CCABUSY;               /*!< (@ 0x00000148) Wireless medium busy - do not send                         */
++  __IOM uint32_t  EVENTS_CCASTOPPED;            /*!< (@ 0x0000014C) The CCA has stopped                                        */
++  __IOM uint32_t  EVENTS_RATEBOOST;             /*!< (@ 0x00000150) Ble_LR CI field received, receive mode is changed
++                                                                    from Ble_LR125Kbit to Ble_LR500Kbit.                       */
++  __IOM uint32_t  EVENTS_TXREADY;               /*!< (@ 0x00000154) RADIO has ramped up and is ready to be started
++                                                                    TX path                                                    */
++  __IOM uint32_t  EVENTS_RXREADY;               /*!< (@ 0x00000158) RADIO has ramped up and is ready to be started
++                                                                    RX path                                                    */
++  __IOM uint32_t  EVENTS_MHRMATCH;              /*!< (@ 0x0000015C) MAC header match found                                     */
++  __IM  uint32_t  RESERVED3[2];
++  __IOM uint32_t  EVENTS_SYNC;                  /*!< (@ 0x00000168) Preamble indicator.                                        */
++  __IOM uint32_t  EVENTS_PHYEND;                /*!< (@ 0x0000016C) Generated in Ble_LR125Kbit, Ble_LR500Kbit and
++                                                                    Ieee802154_250Kbit modes when last bit is
++                                                                    sent on air.                                               */
++  __IM  uint32_t  RESERVED4[36];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED5[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED6[61];
++  __IM  uint32_t  CRCSTATUS;                    /*!< (@ 0x00000400) CRC status                                                 */
++  __IM  uint32_t  RESERVED7;
++  __IM  uint32_t  RXMATCH;                      /*!< (@ 0x00000408) Received address                                           */
++  __IM  uint32_t  RXCRC;                        /*!< (@ 0x0000040C) CRC field of previously received packet                    */
++  __IM  uint32_t  DAI;                          /*!< (@ 0x00000410) Device address match index                                 */
++  __IM  uint32_t  PDUSTAT;                      /*!< (@ 0x00000414) Payload status                                             */
++  __IM  uint32_t  RESERVED8[59];
++  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000504) Packet pointer                                             */
++  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000508) Frequency                                                  */
++  __IOM uint32_t  TXPOWER;                      /*!< (@ 0x0000050C) Output power                                               */
++  __IOM uint32_t  MODE;                         /*!< (@ 0x00000510) Data rate and modulation                                   */
++  __IOM uint32_t  PCNF0;                        /*!< (@ 0x00000514) Packet configuration register 0                            */
++  __IOM uint32_t  PCNF1;                        /*!< (@ 0x00000518) Packet configuration register 1                            */
++  __IOM uint32_t  BASE0;                        /*!< (@ 0x0000051C) Base address 0                                             */
++  __IOM uint32_t  BASE1;                        /*!< (@ 0x00000520) Base address 1                                             */
++  __IOM uint32_t  PREFIX0;                      /*!< (@ 0x00000524) Prefixes bytes for logical addresses 0-3                   */
++  __IOM uint32_t  PREFIX1;                      /*!< (@ 0x00000528) Prefixes bytes for logical addresses 4-7                   */
++  __IOM uint32_t  TXADDRESS;                    /*!< (@ 0x0000052C) Transmit address select                                    */
++  __IOM uint32_t  RXADDRESSES;                  /*!< (@ 0x00000530) Receive address select                                     */
++  __IOM uint32_t  CRCCNF;                       /*!< (@ 0x00000534) CRC configuration                                          */
++  __IOM uint32_t  CRCPOLY;                      /*!< (@ 0x00000538) CRC polynomial                                             */
++  __IOM uint32_t  CRCINIT;                      /*!< (@ 0x0000053C) CRC initial value                                          */
++  __IM  uint32_t  RESERVED9;
++  __IOM uint32_t  TIFS;                         /*!< (@ 0x00000544) Interframe spacing in us                                   */
++  __IM  uint32_t  RSSISAMPLE;                   /*!< (@ 0x00000548) RSSI sample                                                */
++  __IM  uint32_t  RESERVED10;
++  __IM  uint32_t  STATE;                        /*!< (@ 0x00000550) Current radio state                                        */
++  __IOM uint32_t  DATAWHITEIV;                  /*!< (@ 0x00000554) Data whitening initial value                               */
++  __IM  uint32_t  RESERVED11[2];
++  __IOM uint32_t  BCC;                          /*!< (@ 0x00000560) Bit counter compare                                        */
++  __IM  uint32_t  RESERVED12[39];
++  __IOM uint32_t  DAB[8];                       /*!< (@ 0x00000600) Description collection: Device address base segment
++                                                                    n                                                          */
++  __IOM uint32_t  DAP[8];                       /*!< (@ 0x00000620) Description collection: Device address prefix
++                                                                    n                                                          */
++  __IOM uint32_t  DACNF;                        /*!< (@ 0x00000640) Device address match configuration                         */
++  __IOM uint32_t  MHRMATCHCONF;                 /*!< (@ 0x00000644) Search pattern configuration                               */
++  __IOM uint32_t  MHRMATCHMAS;                  /*!< (@ 0x00000648) Pattern mask                                               */
++  __IM  uint32_t  RESERVED13;
++  __IOM uint32_t  MODECNF0;                     /*!< (@ 0x00000650) Radio mode configuration register 0                        */
++  __IM  uint32_t  RESERVED14[3];
++  __IOM uint32_t  SFD;                          /*!< (@ 0x00000660) IEEE 802.15.4 start of frame delimiter                     */
++  __IOM uint32_t  EDCNT;                        /*!< (@ 0x00000664) IEEE 802.15.4 energy detect loop count                     */
++  __IOM uint32_t  EDSAMPLE;                     /*!< (@ 0x00000668) IEEE 802.15.4 energy detect level                          */
++  __IOM uint32_t  CCACTRL;                      /*!< (@ 0x0000066C) IEEE 802.15.4 clear channel assessment control             */
++  __IM  uint32_t  RESERVED15[611];
++  __IOM uint32_t  POWER;                        /*!< (@ 0x00000FFC) Peripheral power control                                   */
++} NRF_RADIO_Type;                               /*!< Size = 4096 (0x1000)                                                      */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           UART0                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Universal Asynchronous Receiver/Transmitter (UART0)
++  */
++
++typedef struct {                                /*!< (@ 0x40002000) UART0 Structure                                            */
++  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start UART receiver                                        */
++  __OM  uint32_t  TASKS_STOPRX;                 /*!< (@ 0x00000004) Stop UART receiver                                         */
++  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start UART transmitter                                     */
++  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x0000000C) Stop UART transmitter                                      */
++  __IM  uint32_t  RESERVED[3];
++  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend UART                                               */
++  __IM  uint32_t  RESERVED1[56];
++  __IOM uint32_t  EVENTS_CTS;                   /*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
++  __IOM uint32_t  EVENTS_NCTS;                  /*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
++  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD                                       */
++  __IM  uint32_t  RESERVED2[4];
++  __IOM uint32_t  EVENTS_TXDRDY;                /*!< (@ 0x0000011C) Data sent from TXD                                         */
++  __IM  uint32_t  RESERVED3;
++  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) Error detected                                             */
++  __IM  uint32_t  RESERVED4[7];
++  __IOM uint32_t  EVENTS_RXTO;                  /*!< (@ 0x00000144) Receiver timeout                                           */
++  __IM  uint32_t  RESERVED5[46];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED6[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED7[93];
++  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source                                               */
++  __IM  uint32_t  RESERVED8[31];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable UART                                                */
++  __IM  uint32_t  RESERVED9;
++  __IOM UART_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
++  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
++  __OM  uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
++  __IM  uint32_t  RESERVED10;
++  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
++                                                                    selected.                                                  */
++  __IM  uint32_t  RESERVED11[17];
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
++} NRF_UART_Type;                                /*!< Size = 1392 (0x570)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                          UARTE0                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief UART with EasyDMA 0 (UARTE0)
++  */
++
++typedef struct {                                /*!< (@ 0x40002000) UARTE0 Structure                                           */
++  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start UART receiver                                        */
++  __OM  uint32_t  TASKS_STOPRX;                 /*!< (@ 0x00000004) Stop UART receiver                                         */
++  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start UART transmitter                                     */
++  __OM  uint32_t  TASKS_STOPTX;                 /*!< (@ 0x0000000C) Stop UART transmitter                                      */
++  __IM  uint32_t  RESERVED[7];
++  __OM  uint32_t  TASKS_FLUSHRX;                /*!< (@ 0x0000002C) Flush RX FIFO into RX buffer                               */
++  __IM  uint32_t  RESERVED1[52];
++  __IOM uint32_t  EVENTS_CTS;                   /*!< (@ 0x00000100) CTS is activated (set low). Clear To Send.                 */
++  __IOM uint32_t  EVENTS_NCTS;                  /*!< (@ 0x00000104) CTS is deactivated (set high). Not Clear To Send.          */
++  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD (but potentially not yet
++                                                                    transferred to Data RAM)                                   */
++  __IM  uint32_t  RESERVED2;
++  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) Receive buffer is filled up                                */
++  __IM  uint32_t  RESERVED3[2];
++  __IOM uint32_t  EVENTS_TXDRDY;                /*!< (@ 0x0000011C) Data sent from TXD                                         */
++  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) Last TX byte transmitted                                   */
++  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) Error detected                                             */
++  __IM  uint32_t  RESERVED4[7];
++  __IOM uint32_t  EVENTS_RXTO;                  /*!< (@ 0x00000144) Receiver timeout                                           */
++  __IM  uint32_t  RESERVED5;
++  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) UART receiver has started                                  */
++  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) UART transmitter has started                               */
++  __IM  uint32_t  RESERVED6;
++  __IOM uint32_t  EVENTS_TXSTOPPED;             /*!< (@ 0x00000158) Transmitter stopped                                        */
++  __IM  uint32_t  RESERVED7[41];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED8[63];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED9[93];
++  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source This register is read/write one
++                                                                    to clear.                                                  */
++  __IM  uint32_t  RESERVED10[31];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable UART                                                */
++  __IM  uint32_t  RESERVED11;
++  __IOM UARTE_PSEL_Type PSEL;                   /*!< (@ 0x00000508) Unspecified                                                */
++  __IM  uint32_t  RESERVED12[3];
++  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
++                                                                    selected.                                                  */
++  __IM  uint32_t  RESERVED13[3];
++  __IOM UARTE_RXD_Type RXD;                     /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
++  __IM  uint32_t  RESERVED14;
++  __IOM UARTE_TXD_Type TXD;                     /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
++  __IM  uint32_t  RESERVED15[7];
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000056C) Configuration of parity and hardware flow control          */
++} NRF_UARTE_Type;                               /*!< Size = 1392 (0x570)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           SPI0                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Serial Peripheral Interface 0 (SPI0)
++  */
++
++typedef struct {                                /*!< (@ 0x40003000) SPI0 Structure                                             */
++  __IM  uint32_t  RESERVED[66];
++  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000108) TXD byte sent and RXD byte received                        */
++  __IM  uint32_t  RESERVED1[126];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED2[125];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI                                                 */
++  __IM  uint32_t  RESERVED3;
++  __IOM SPI_PSEL_Type PSEL;                     /*!< (@ 0x00000508) Unspecified                                                */
++  __IM  uint32_t  RESERVED4;
++  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
++  __IOM uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
++  __IM  uint32_t  RESERVED5;
++  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
++                                                                    source selected.                                           */
++  __IM  uint32_t  RESERVED6[11];
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
++} NRF_SPI_Type;                                 /*!< Size = 1368 (0x558)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           SPIM0                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Serial Peripheral Interface Master with EasyDMA 0 (SPIM0)
++  */
++
++typedef struct {                                /*!< (@ 0x40003000) SPIM0 Structure                                            */
++  __IM  uint32_t  RESERVED[4];
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000010) Start SPI transaction                                      */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop SPI transaction                                       */
++  __IM  uint32_t  RESERVED1;
++  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend SPI transaction                                    */
++  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume SPI transaction                                     */
++  __IM  uint32_t  RESERVED2[56];
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) SPI transaction has stopped                                */
++  __IM  uint32_t  RESERVED3[2];
++  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
++  __IM  uint32_t  RESERVED4;
++  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000118) End of RXD buffer and TXD buffer reached                   */
++  __IM  uint32_t  RESERVED5;
++  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000120) End of TXD buffer reached                                  */
++  __IM  uint32_t  RESERVED6[10];
++  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x0000014C) Transaction started                                        */
++  __IM  uint32_t  RESERVED7[44];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED8[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED9[61];
++  __IOM uint32_t  STALLSTAT;                    /*!< (@ 0x00000400) Stall status for EasyDMA RAM accesses. The fields
++                                                                    in this register are set to STALL by hardware
++                                                                    whenever a stall occurs and can be cleared
++                                                                    (set to NOSTALL) by the CPU.                               */
++  __IM  uint32_t  RESERVED10[63];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPIM                                                */
++  __IM  uint32_t  RESERVED11;
++  __IOM SPIM_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
++  __IM  uint32_t  RESERVED12[3];
++  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
++                                                                    source selected.                                           */
++  __IM  uint32_t  RESERVED13[3];
++  __IOM SPIM_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
++  __IOM SPIM_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
++  __IM  uint32_t  RESERVED14[2];
++  __IOM SPIM_IFTIMING_Type IFTIMING;            /*!< (@ 0x00000560) Unspecified                                                */
++  __IOM uint32_t  CSNPOL;                       /*!< (@ 0x00000568) Polarity of CSN output                                     */
++  __IOM uint32_t  PSELDCX;                      /*!< (@ 0x0000056C) Pin select for DCX signal                                  */
++  __IOM uint32_t  DCXCNT;                       /*!< (@ 0x00000570) DCX configuration                                          */
++  __IM  uint32_t  RESERVED15[19];
++  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Byte transmitted after TXD.MAXCNT bytes have
++                                                                    been transmitted in the case when RXD.MAXCNT
++                                                                    is greater than TXD.MAXCNT                                 */
++} NRF_SPIM_Type;                                /*!< Size = 1476 (0x5c4)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           SPIS0                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief SPI Slave 0 (SPIS0)
++  */
++
++typedef struct {                                /*!< (@ 0x40003000) SPIS0 Structure                                            */
++  __IM  uint32_t  RESERVED[9];
++  __OM  uint32_t  TASKS_ACQUIRE;                /*!< (@ 0x00000024) Acquire SPI semaphore                                      */
++  __OM  uint32_t  TASKS_RELEASE;                /*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
++                                                                    to acquire it                                              */
++  __IM  uint32_t  RESERVED1[54];
++  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) Granted transaction completed                              */
++  __IM  uint32_t  RESERVED2[2];
++  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x00000110) End of RXD buffer reached                                  */
++  __IM  uint32_t  RESERVED3[5];
++  __IOM uint32_t  EVENTS_ACQUIRED;              /*!< (@ 0x00000128) Semaphore acquired                                         */
++  __IM  uint32_t  RESERVED4[53];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED5[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED6[61];
++  __IM  uint32_t  SEMSTAT;                      /*!< (@ 0x00000400) Semaphore status register                                  */
++  __IM  uint32_t  RESERVED7[15];
++  __IOM uint32_t  STATUS;                       /*!< (@ 0x00000440) Status from last transaction                               */
++  __IM  uint32_t  RESERVED8[47];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable SPI slave                                           */
++  __IM  uint32_t  RESERVED9;
++  __IOM SPIS_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
++  __IM  uint32_t  RESERVED10[7];
++  __IOM SPIS_RXD_Type RXD;                      /*!< (@ 0x00000534) Unspecified                                                */
++  __IOM SPIS_TXD_Type TXD;                      /*!< (@ 0x00000544) Unspecified                                                */
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000554) Configuration register                                     */
++  __IM  uint32_t  RESERVED11;
++  __IOM uint32_t  DEF;                          /*!< (@ 0x0000055C) Default character. Character clocked out in case
++                                                                    of an ignored transaction.                                 */
++  __IM  uint32_t  RESERVED12[24];
++  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character                                        */
++} NRF_SPIS_Type;                                /*!< Size = 1476 (0x5c4)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           TWI0                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief I2C compatible Two-Wire Interface 0 (TWI0)
++  */
++
++typedef struct {                                /*!< (@ 0x40003000) TWI0 Structure                                             */
++  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start TWI receive sequence                                 */
++  __IM  uint32_t  RESERVED;
++  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start TWI transmit sequence                                */
++  __IM  uint32_t  RESERVED1[2];
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction                                       */
++  __IM  uint32_t  RESERVED2;
++  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
++  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
++  __IM  uint32_t  RESERVED3[56];
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
++  __IOM uint32_t  EVENTS_RXDREADY;              /*!< (@ 0x00000108) TWI RXD byte received                                      */
++  __IM  uint32_t  RESERVED4[4];
++  __IOM uint32_t  EVENTS_TXDSENT;               /*!< (@ 0x0000011C) TWI TXD byte sent                                          */
++  __IM  uint32_t  RESERVED5;
++  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
++  __IM  uint32_t  RESERVED6[4];
++  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
++                                                                    that is sent or received                                   */
++  __IM  uint32_t  RESERVED7[3];
++  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) TWI entered the suspended state                            */
++  __IM  uint32_t  RESERVED8[45];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED9[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED10[110];
++  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004C4) Error source                                               */
++  __IM  uint32_t  RESERVED11[14];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWI                                                 */
++  __IM  uint32_t  RESERVED12;
++  __IOM TWI_PSEL_Type PSEL;                     /*!< (@ 0x00000508) Unspecified                                                */
++  __IM  uint32_t  RESERVED13[2];
++  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register                                               */
++  __IOM uint32_t  TXD;                          /*!< (@ 0x0000051C) TXD register                                               */
++  __IM  uint32_t  RESERVED14;
++  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
++                                                                    source selected.                                           */
++  __IM  uint32_t  RESERVED15[24];
++  __IOM uint32_t  ADDRESS;                      /*!< (@ 0x00000588) Address used in the TWI transfer                           */
++} NRF_TWI_Type;                                 /*!< Size = 1420 (0x58c)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           TWIM0                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief I2C compatible Two-Wire Master Interface with EasyDMA 0 (TWIM0)
++  */
++
++typedef struct {                                /*!< (@ 0x40003000) TWIM0 Structure                                            */
++  __OM  uint32_t  TASKS_STARTRX;                /*!< (@ 0x00000000) Start TWI receive sequence                                 */
++  __IM  uint32_t  RESERVED;
++  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x00000008) Start TWI transmit sequence                                */
++  __IM  uint32_t  RESERVED1[2];
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction. Must be issued while the
++                                                                    TWI master is not suspended.                               */
++  __IM  uint32_t  RESERVED2;
++  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
++  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
++  __IM  uint32_t  RESERVED3[56];
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
++  __IM  uint32_t  RESERVED4[7];
++  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
++  __IM  uint32_t  RESERVED5[8];
++  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) SUSPEND task has been issued, TWI traffic is
++                                                                    now suspended.                                             */
++  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) Receive sequence started                                   */
++  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) Transmit sequence started                                  */
++  __IM  uint32_t  RESERVED6[2];
++  __IOM uint32_t  EVENTS_LASTRX;                /*!< (@ 0x0000015C) Byte boundary, starting to receive the last byte           */
++  __IOM uint32_t  EVENTS_LASTTX;                /*!< (@ 0x00000160) Byte boundary, starting to transmit the last
++                                                                    byte                                                       */
++  __IM  uint32_t  RESERVED7[39];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED8[63];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED9[110];
++  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004C4) Error source                                               */
++  __IM  uint32_t  RESERVED10[14];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWIM                                                */
++  __IM  uint32_t  RESERVED11;
++  __IOM TWIM_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
++  __IM  uint32_t  RESERVED12[5];
++  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
++                                                                    source selected.                                           */
++  __IM  uint32_t  RESERVED13[3];
++  __IOM TWIM_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
++  __IOM TWIM_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
++  __IM  uint32_t  RESERVED14[13];
++  __IOM uint32_t  ADDRESS;                      /*!< (@ 0x00000588) Address used in the TWI transfer                           */
++} NRF_TWIM_Type;                                /*!< Size = 1420 (0x58c)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           TWIS0                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief I2C compatible Two-Wire Slave Interface with EasyDMA 0 (TWIS0)
++  */
++
++typedef struct {                                /*!< (@ 0x40003000) TWIS0 Structure                                            */
++  __IM  uint32_t  RESERVED[5];
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction                                       */
++  __IM  uint32_t  RESERVED1;
++  __OM  uint32_t  TASKS_SUSPEND;                /*!< (@ 0x0000001C) Suspend TWI transaction                                    */
++  __OM  uint32_t  TASKS_RESUME;                 /*!< (@ 0x00000020) Resume TWI transaction                                     */
++  __IM  uint32_t  RESERVED2[3];
++  __OM  uint32_t  TASKS_PREPARERX;              /*!< (@ 0x00000030) Prepare the TWI slave to respond to a write command        */
++  __OM  uint32_t  TASKS_PREPARETX;              /*!< (@ 0x00000034) Prepare the TWI slave to respond to a read command         */
++  __IM  uint32_t  RESERVED3[51];
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) TWI stopped                                                */
++  __IM  uint32_t  RESERVED4[7];
++  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000124) TWI error                                                  */
++  __IM  uint32_t  RESERVED5[9];
++  __IOM uint32_t  EVENTS_RXSTARTED;             /*!< (@ 0x0000014C) Receive sequence started                                   */
++  __IOM uint32_t  EVENTS_TXSTARTED;             /*!< (@ 0x00000150) Transmit sequence started                                  */
++  __IM  uint32_t  RESERVED6[4];
++  __IOM uint32_t  EVENTS_WRITE;                 /*!< (@ 0x00000164) Write command received                                     */
++  __IOM uint32_t  EVENTS_READ;                  /*!< (@ 0x00000168) Read command received                                      */
++  __IM  uint32_t  RESERVED7[37];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED8[63];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED9[113];
++  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x000004D0) Error source                                               */
++  __IM  uint32_t  MATCH;                        /*!< (@ 0x000004D4) Status register indicating which address had
++                                                                    a match                                                    */
++  __IM  uint32_t  RESERVED10[10];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable TWIS                                                */
++  __IM  uint32_t  RESERVED11;
++  __IOM TWIS_PSEL_Type PSEL;                    /*!< (@ 0x00000508) Unspecified                                                */
++  __IM  uint32_t  RESERVED12[9];
++  __IOM TWIS_RXD_Type RXD;                      /*!< (@ 0x00000534) RXD EasyDMA channel                                        */
++  __IOM TWIS_TXD_Type TXD;                      /*!< (@ 0x00000544) TXD EasyDMA channel                                        */
++  __IM  uint32_t  RESERVED13[13];
++  __IOM uint32_t  ADDRESS[2];                   /*!< (@ 0x00000588) Description collection: TWI slave address n                */
++  __IM  uint32_t  RESERVED14;
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000594) Configuration register for the address match
++                                                                    mechanism                                                  */
++  __IM  uint32_t  RESERVED15[10];
++  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character sent out in case
++                                                                    of an over-read of the transmit buffer.                    */
++} NRF_TWIS_Type;                                /*!< Size = 1476 (0x5c4)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           NFCT                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief NFC-A compatible radio (NFCT)
++  */
++
++typedef struct {                                /*!< (@ 0x40005000) NFCT Structure                                             */
++  __OM  uint32_t  TASKS_ACTIVATE;               /*!< (@ 0x00000000) Activate NFCT peripheral for incoming and outgoing
++                                                                    frames, change state to activated                          */
++  __OM  uint32_t  TASKS_DISABLE;                /*!< (@ 0x00000004) Disable NFCT peripheral                                    */
++  __OM  uint32_t  TASKS_SENSE;                  /*!< (@ 0x00000008) Enable NFC sense field mode, change state to
++                                                                    sense mode                                                 */
++  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x0000000C) Start transmission of an outgoing frame, change
++                                                                    state to transmit                                          */
++  __IM  uint32_t  RESERVED[3];
++  __OM  uint32_t  TASKS_ENABLERXDATA;           /*!< (@ 0x0000001C) Initializes the EasyDMA for receive.                       */
++  __IM  uint32_t  RESERVED1;
++  __OM  uint32_t  TASKS_GOIDLE;                 /*!< (@ 0x00000024) Force state machine to IDLE state                          */
++  __OM  uint32_t  TASKS_GOSLEEP;                /*!< (@ 0x00000028) Force state machine to SLEEP_A state                       */
++  __IM  uint32_t  RESERVED2[53];
++  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) The NFCT peripheral is ready to receive and send
++                                                                    frames                                                     */
++  __IOM uint32_t  EVENTS_FIELDDETECTED;         /*!< (@ 0x00000104) Remote NFC field detected                                  */
++  __IOM uint32_t  EVENTS_FIELDLOST;             /*!< (@ 0x00000108) Remote NFC field lost                                      */
++  __IOM uint32_t  EVENTS_TXFRAMESTART;          /*!< (@ 0x0000010C) Marks the start of the first symbol of a transmitted
++                                                                    frame                                                      */
++  __IOM uint32_t  EVENTS_TXFRAMEEND;            /*!< (@ 0x00000110) Marks the end of the last transmitted on-air
++                                                                    symbol of a frame                                          */
++  __IOM uint32_t  EVENTS_RXFRAMESTART;          /*!< (@ 0x00000114) Marks the end of the first symbol of a received
++                                                                    frame                                                      */
++  __IOM uint32_t  EVENTS_RXFRAMEEND;            /*!< (@ 0x00000118) Received data has been checked (CRC, parity)
++                                                                    and transferred to RAM, and EasyDMA has
++                                                                    ended accessing the RX buffer                              */
++  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x0000011C) NFC error reported. The ERRORSTATUS register
++                                                                    contains details on the source of the error.               */
++  __IM  uint32_t  RESERVED3[2];
++  __IOM uint32_t  EVENTS_RXERROR;               /*!< (@ 0x00000128) NFC RX frame error reported. The FRAMESTATUS.RX
++                                                                    register contains details on the source
++                                                                    of the error.                                              */
++  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x0000012C) RX buffer (as defined by PACKETPTR and MAXLEN)
++                                                                    in Data RAM full.                                          */
++  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000130) Transmission of data in RAM has ended, and EasyDMA
++                                                                    has ended accessing the TX buffer                          */
++  __IM  uint32_t  RESERVED4;
++  __IOM uint32_t  EVENTS_AUTOCOLRESSTARTED;     /*!< (@ 0x00000138) Auto collision resolution process has started              */
++  __IM  uint32_t  RESERVED5[3];
++  __IOM uint32_t  EVENTS_COLLISION;             /*!< (@ 0x00000148) NFC auto collision resolution error reported.              */
++  __IOM uint32_t  EVENTS_SELECTED;              /*!< (@ 0x0000014C) NFC auto collision resolution successfully completed       */
++  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000150) EasyDMA is ready to receive or send frames.                */
++  __IM  uint32_t  RESERVED6[43];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED7[63];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED8[62];
++  __IOM uint32_t  ERRORSTATUS;                  /*!< (@ 0x00000404) NFC Error Status register                                  */
++  __IM  uint32_t  RESERVED9;
++  __IOM NFCT_FRAMESTATUS_Type FRAMESTATUS;      /*!< (@ 0x0000040C) Unspecified                                                */
++  __IM  uint32_t  NFCTAGSTATE;                  /*!< (@ 0x00000410) NfcTag state register                                      */
++  __IM  uint32_t  RESERVED10[3];
++  __IM  uint32_t  SLEEPSTATE;                   /*!< (@ 0x00000420) Sleep state during automatic collision resolution          */
++  __IM  uint32_t  RESERVED11[6];
++  __IM  uint32_t  FIELDPRESENT;                 /*!< (@ 0x0000043C) Indicates the presence or not of a valid field             */
++  __IM  uint32_t  RESERVED12[49];
++  __IOM uint32_t  FRAMEDELAYMIN;                /*!< (@ 0x00000504) Minimum frame delay                                        */
++  __IOM uint32_t  FRAMEDELAYMAX;                /*!< (@ 0x00000508) Maximum frame delay                                        */
++  __IOM uint32_t  FRAMEDELAYMODE;               /*!< (@ 0x0000050C) Configuration register for the Frame Delay Timer           */
++  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000510) Packet pointer for TXD and RXD data storage in
++                                                                    Data RAM                                                   */
++  __IOM uint32_t  MAXLEN;                       /*!< (@ 0x00000514) Size of the RAM buffer allocated to TXD and RXD
++                                                                    data storage each                                          */
++  __IOM NFCT_TXD_Type TXD;                      /*!< (@ 0x00000518) Unspecified                                                */
++  __IOM NFCT_RXD_Type RXD;                      /*!< (@ 0x00000520) Unspecified                                                */
++  __IM  uint32_t  RESERVED13[26];
++  __IOM uint32_t  NFCID1_LAST;                  /*!< (@ 0x00000590) Last NFCID1 part (4, 7 or 10 bytes ID)                     */
++  __IOM uint32_t  NFCID1_2ND_LAST;              /*!< (@ 0x00000594) Second last NFCID1 part (7 or 10 bytes ID)                 */
++  __IOM uint32_t  NFCID1_3RD_LAST;              /*!< (@ 0x00000598) Third last NFCID1 part (10 bytes ID)                       */
++  __IOM uint32_t  AUTOCOLRESCONFIG;             /*!< (@ 0x0000059C) Controls the auto collision resolution function.
++                                                                    This setting must be done before the NFCT
++                                                                    peripheral is activated.                                   */
++  __IOM uint32_t  SENSRES;                      /*!< (@ 0x000005A0) NFC-A SENS_RES auto-response settings                      */
++  __IOM uint32_t  SELRES;                       /*!< (@ 0x000005A4) NFC-A SEL_RES auto-response settings                       */
++} NRF_NFCT_Type;                                /*!< Size = 1448 (0x5a8)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                          GPIOTE                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief GPIO Tasks and Events (GPIOTE)
++  */
++
++typedef struct {                                /*!< (@ 0x40006000) GPIOTE Structure                                           */
++  __OM  uint32_t  TASKS_OUT[8];                 /*!< (@ 0x00000000) Description collection: Task for writing to pin
++                                                                    specified in CONFIG[n].PSEL. Action on pin
++                                                                    is configured in CONFIG[n].POLARITY.                       */
++  __IM  uint32_t  RESERVED[4];
++  __OM  uint32_t  TASKS_SET[8];                 /*!< (@ 0x00000030) Description collection: Task for writing to pin
++                                                                    specified in CONFIG[n].PSEL. Action on pin
++                                                                    is to set it high.                                         */
++  __IM  uint32_t  RESERVED1[4];
++  __OM  uint32_t  TASKS_CLR[8];                 /*!< (@ 0x00000060) Description collection: Task for writing to pin
++                                                                    specified in CONFIG[n].PSEL. Action on pin
++                                                                    is to set it low.                                          */
++  __IM  uint32_t  RESERVED2[32];
++  __IOM uint32_t  EVENTS_IN[8];                 /*!< (@ 0x00000100) Description collection: Event generated from
++                                                                    pin specified in CONFIG[n].PSEL                            */
++  __IM  uint32_t  RESERVED3[23];
++  __IOM uint32_t  EVENTS_PORT;                  /*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
++                                                                    with SENSE mechanism enabled                               */
++  __IM  uint32_t  RESERVED4[97];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED5[129];
++  __IOM uint32_t  CONFIG[8];                    /*!< (@ 0x00000510) Description collection: Configuration for OUT[n],
++                                                                    SET[n], and CLR[n] tasks and IN[n] event                   */
++} NRF_GPIOTE_Type;                              /*!< Size = 1328 (0x530)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           SAADC                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Successive approximation register (SAR) analog-to-digital converter (SAADC)
++  */
++
++typedef struct {                                /*!< (@ 0x40007000) SAADC Structure                                            */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts the SAADC and prepares the result buffer
++                                                                    in RAM                                                     */
++  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000004) Takes one SAADC sample                                     */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stops the SAADC and terminates all on-going conversions    */
++  __OM  uint32_t  TASKS_CALIBRATEOFFSET;        /*!< (@ 0x0000000C) Starts offset auto-calibration                             */
++  __IM  uint32_t  RESERVED[60];
++  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) The SAADC has started                                      */
++  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000104) The SAADC has filled up the result buffer                  */
++  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000108) A conversion task has been completed. Depending
++                                                                    on the configuration, multiple conversions
++                                                                    might be needed for a result to be transferred
++                                                                    to RAM.                                                    */
++  __IOM uint32_t  EVENTS_RESULTDONE;            /*!< (@ 0x0000010C) Result ready for transfer to RAM                           */
++  __IOM uint32_t  EVENTS_CALIBRATEDONE;         /*!< (@ 0x00000110) Calibration is complete                                    */
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000114) The SAADC has stopped                                      */
++  __IOM SAADC_EVENTS_CH_Type EVENTS_CH[8];      /*!< (@ 0x00000118) Peripheral events.                                         */
++  __IM  uint32_t  RESERVED1[106];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED2[61];
++  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) Status                                                     */
++  __IM  uint32_t  RESERVED3[63];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable or disable SAADC                                    */
++  __IM  uint32_t  RESERVED4[3];
++  __IOM SAADC_CH_Type CH[8];                    /*!< (@ 0x00000510) Unspecified                                                */
++  __IM  uint32_t  RESERVED5[24];
++  __IOM uint32_t  RESOLUTION;                   /*!< (@ 0x000005F0) Resolution configuration                                   */
++  __IOM uint32_t  OVERSAMPLE;                   /*!< (@ 0x000005F4) Oversampling configuration. The RESOLUTION is
++                                                                    applied before averaging, thus for high
++                                                                    OVERSAMPLE a higher RESOLUTION should be
++                                                                    used.                                                      */
++  __IOM uint32_t  SAMPLERATE;                   /*!< (@ 0x000005F8) Controls normal or continuous sample rate                  */
++  __IM  uint32_t  RESERVED6[12];
++  __IOM SAADC_RESULT_Type RESULT;               /*!< (@ 0x0000062C) RESULT EasyDMA channel                                     */
++} NRF_SAADC_Type;                               /*!< Size = 1592 (0x638)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                          TIMER0                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Timer/Counter 0 (TIMER0)
++  */
++
++typedef struct {                                /*!< (@ 0x40008000) TIMER0 Structure                                           */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start Timer                                                */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop Timer                                                 */
++  __OM  uint32_t  TASKS_COUNT;                  /*!< (@ 0x00000008) Increment Timer (Counter mode only)                        */
++  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x0000000C) Clear time                                                 */
++  __OM  uint32_t  TASKS_SHUTDOWN;               /*!< (@ 0x00000010) Deprecated register - Shut down timer                      */
++  __IM  uint32_t  RESERVED[11];
++  __OM  uint32_t  TASKS_CAPTURE[6];             /*!< (@ 0x00000040) Description collection: Capture Timer value to
++                                                                    CC[n] register                                             */
++  __IM  uint32_t  RESERVED1[58];
++  __IOM uint32_t  EVENTS_COMPARE[6];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
++                                                                    match                                                      */
++  __IM  uint32_t  RESERVED2[42];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED3[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED4[126];
++  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Timer mode selection                                       */
++  __IOM uint32_t  BITMODE;                      /*!< (@ 0x00000508) Configure the number of bits used by the TIMER             */
++  __IM  uint32_t  RESERVED5;
++  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000510) Timer prescaler register                                   */
++  __IM  uint32_t  RESERVED6[11];
++  __IOM uint32_t  CC[6];                        /*!< (@ 0x00000540) Description collection: Capture/Compare register
++                                                                    n                                                          */
++} NRF_TIMER_Type;                               /*!< Size = 1368 (0x558)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           RTC0                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Real time counter 0 (RTC0)
++  */
++
++typedef struct {                                /*!< (@ 0x4000B000) RTC0 Structure                                             */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start RTC COUNTER                                          */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop RTC COUNTER                                           */
++  __OM  uint32_t  TASKS_CLEAR;                  /*!< (@ 0x00000008) Clear RTC COUNTER                                          */
++  __OM  uint32_t  TASKS_TRIGOVRFLW;             /*!< (@ 0x0000000C) Set COUNTER to 0xFFFFF0                                    */
++  __IM  uint32_t  RESERVED[60];
++  __IOM uint32_t  EVENTS_TICK;                  /*!< (@ 0x00000100) Event on COUNTER increment                                 */
++  __IOM uint32_t  EVENTS_OVRFLW;                /*!< (@ 0x00000104) Event on COUNTER overflow                                  */
++  __IM  uint32_t  RESERVED1[14];
++  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
++                                                                    match                                                      */
++  __IM  uint32_t  RESERVED2[109];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[13];
++  __IOM uint32_t  EVTEN;                        /*!< (@ 0x00000340) Enable or disable event routing                            */
++  __IOM uint32_t  EVTENSET;                     /*!< (@ 0x00000344) Enable event routing                                       */
++  __IOM uint32_t  EVTENCLR;                     /*!< (@ 0x00000348) Disable event routing                                      */
++  __IM  uint32_t  RESERVED4[110];
++  __IM  uint32_t  COUNTER;                      /*!< (@ 0x00000504) Current COUNTER value                                      */
++  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000508) 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).
++                                                                    Must be written when RTC is stopped.                       */
++  __IM  uint32_t  RESERVED5[13];
++  __IOM uint32_t  CC[4];                        /*!< (@ 0x00000540) Description collection: Compare register n                 */
++} NRF_RTC_Type;                                 /*!< Size = 1360 (0x550)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           TEMP                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Temperature Sensor (TEMP)
++  */
++
++typedef struct {                                /*!< (@ 0x4000C000) TEMP Structure                                             */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start temperature measurement                              */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop temperature measurement                               */
++  __IM  uint32_t  RESERVED[62];
++  __IOM uint32_t  EVENTS_DATARDY;               /*!< (@ 0x00000100) Temperature measurement complete, data ready               */
++  __IM  uint32_t  RESERVED1[128];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED2[127];
++  __IM  int32_t   TEMP;                         /*!< (@ 0x00000508) Temperature in degC (0.25deg steps)                        */
++  __IM  uint32_t  RESERVED3[5];
++  __IOM uint32_t  A0;                           /*!< (@ 0x00000520) Slope of first piecewise linear function                   */
++  __IOM uint32_t  A1;                           /*!< (@ 0x00000524) Slope of second piecewise linear function                  */
++  __IOM uint32_t  A2;                           /*!< (@ 0x00000528) Slope of third piecewise linear function                   */
++  __IOM uint32_t  A3;                           /*!< (@ 0x0000052C) Slope of fourth piecewise linear function                  */
++  __IOM uint32_t  A4;                           /*!< (@ 0x00000530) Slope of fifth piecewise linear function                   */
++  __IOM uint32_t  A5;                           /*!< (@ 0x00000534) Slope of sixth piecewise linear function                   */
++  __IM  uint32_t  RESERVED4[2];
++  __IOM uint32_t  B0;                           /*!< (@ 0x00000540) y-intercept of first piecewise linear function             */
++  __IOM uint32_t  B1;                           /*!< (@ 0x00000544) y-intercept of second piecewise linear function            */
++  __IOM uint32_t  B2;                           /*!< (@ 0x00000548) y-intercept of third piecewise linear function             */
++  __IOM uint32_t  B3;                           /*!< (@ 0x0000054C) y-intercept of fourth piecewise linear function            */
++  __IOM uint32_t  B4;                           /*!< (@ 0x00000550) y-intercept of fifth piecewise linear function             */
++  __IOM uint32_t  B5;                           /*!< (@ 0x00000554) y-intercept of sixth piecewise linear function             */
++  __IM  uint32_t  RESERVED5[2];
++  __IOM uint32_t  T0;                           /*!< (@ 0x00000560) End point of first piecewise linear function               */
++  __IOM uint32_t  T1;                           /*!< (@ 0x00000564) End point of second piecewise linear function              */
++  __IOM uint32_t  T2;                           /*!< (@ 0x00000568) End point of third piecewise linear function               */
++  __IOM uint32_t  T3;                           /*!< (@ 0x0000056C) End point of fourth piecewise linear function              */
++  __IOM uint32_t  T4;                           /*!< (@ 0x00000570) End point of fifth piecewise linear function               */
++} NRF_TEMP_Type;                                /*!< Size = 1396 (0x574)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            RNG                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Random Number Generator (RNG)
++  */
++
++typedef struct {                                /*!< (@ 0x4000D000) RNG Structure                                              */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the random number generator                  */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the random number generator                  */
++  __IM  uint32_t  RESERVED[62];
++  __IOM uint32_t  EVENTS_VALRDY;                /*!< (@ 0x00000100) Event being generated for every new random number
++                                                                    written to the VALUE register                              */
++  __IM  uint32_t  RESERVED1[63];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED2[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[126];
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
++  __IM  uint32_t  VALUE;                        /*!< (@ 0x00000508) Output random number                                       */
++} NRF_RNG_Type;                                 /*!< Size = 1292 (0x50c)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            ECB                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief AES ECB Mode Encryption (ECB)
++  */
++
++typedef struct {                                /*!< (@ 0x4000E000) ECB Structure                                              */
++  __OM  uint32_t  TASKS_STARTECB;               /*!< (@ 0x00000000) Start ECB block encrypt                                    */
++  __OM  uint32_t  TASKS_STOPECB;                /*!< (@ 0x00000004) Abort a possible executing ECB operation                   */
++  __IM  uint32_t  RESERVED[62];
++  __IOM uint32_t  EVENTS_ENDECB;                /*!< (@ 0x00000100) ECB block encrypt complete                                 */
++  __IOM uint32_t  EVENTS_ERRORECB;              /*!< (@ 0x00000104) ECB block encrypt aborted because of a STOPECB
++                                                                    task or due to an error                                    */
++  __IM  uint32_t  RESERVED1[127];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED2[126];
++  __IOM uint32_t  ECBDATAPTR;                   /*!< (@ 0x00000504) ECB block encrypt memory pointers                          */
++} NRF_ECB_Type;                                 /*!< Size = 1288 (0x508)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            AAR                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Accelerated Address Resolver (AAR)
++  */
++
++typedef struct {                                /*!< (@ 0x4000F000) AAR Structure                                              */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start resolving addresses based on IRKs specified
++                                                                    in the IRK data structure                                  */
++  __IM  uint32_t  RESERVED;
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop resolving addresses                                   */
++  __IM  uint32_t  RESERVED1[61];
++  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000100) Address resolution procedure complete                      */
++  __IOM uint32_t  EVENTS_RESOLVED;              /*!< (@ 0x00000104) Address resolved                                           */
++  __IOM uint32_t  EVENTS_NOTRESOLVED;           /*!< (@ 0x00000108) Address not resolved                                       */
++  __IM  uint32_t  RESERVED2[126];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[61];
++  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000400) Resolution status                                          */
++  __IM  uint32_t  RESERVED4[63];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable AAR                                                 */
++  __IOM uint32_t  NIRK;                         /*!< (@ 0x00000504) Number of IRKs                                             */
++  __IOM uint32_t  IRKPTR;                       /*!< (@ 0x00000508) Pointer to IRK data structure                              */
++  __IM  uint32_t  RESERVED5;
++  __IOM uint32_t  ADDRPTR;                      /*!< (@ 0x00000510) Pointer to the resolvable address                          */
++  __IOM uint32_t  SCRATCHPTR;                   /*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
++} NRF_AAR_Type;                                 /*!< Size = 1304 (0x518)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            CCM                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief AES CCM Mode Encryption (CCM)
++  */
++
++typedef struct {                                /*!< (@ 0x4000F000) CCM Structure                                              */
++  __OM  uint32_t  TASKS_KSGEN;                  /*!< (@ 0x00000000) Start generation of keystream. This operation
++                                                                    will stop by itself when completed.                        */
++  __OM  uint32_t  TASKS_CRYPT;                  /*!< (@ 0x00000004) Start encryption/decryption. This operation will
++                                                                    stop by itself when completed.                             */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000008) Stop encryption/decryption                                 */
++  __OM  uint32_t  TASKS_RATEOVERRIDE;           /*!< (@ 0x0000000C) Override DATARATE setting in MODE register with
++                                                                    the contents of the RATEOVERRIDE register
++                                                                    for any ongoing encryption/decryption                      */
++  __IM  uint32_t  RESERVED[60];
++  __IOM uint32_t  EVENTS_ENDKSGEN;              /*!< (@ 0x00000100) Keystream generation complete                              */
++  __IOM uint32_t  EVENTS_ENDCRYPT;              /*!< (@ 0x00000104) Encrypt/decrypt complete                                   */
++  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x00000108) Deprecated register - CCM error event                      */
++  __IM  uint32_t  RESERVED1[61];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED2[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[61];
++  __IM  uint32_t  MICSTATUS;                    /*!< (@ 0x00000400) MIC check result                                           */
++  __IM  uint32_t  RESERVED4[63];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable                                                     */
++  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Operation mode                                             */
++  __IOM uint32_t  CNFPTR;                       /*!< (@ 0x00000508) Pointer to data structure holding AES key and
++                                                                    NONCE vector                                               */
++  __IOM uint32_t  INPTR;                        /*!< (@ 0x0000050C) Input pointer                                              */
++  __IOM uint32_t  OUTPTR;                       /*!< (@ 0x00000510) Output pointer                                             */
++  __IOM uint32_t  SCRATCHPTR;                   /*!< (@ 0x00000514) Pointer to data area used for temporary storage            */
++  __IOM uint32_t  MAXPACKETSIZE;                /*!< (@ 0x00000518) Length of keystream generated when MODE.LENGTH
++                                                                    = Extended.                                                */
++  __IOM uint32_t  RATEOVERRIDE;                 /*!< (@ 0x0000051C) Data rate override setting.                                */
++} NRF_CCM_Type;                                 /*!< Size = 1312 (0x520)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            WDT                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Watchdog Timer (WDT)
++  */
++
++typedef struct {                                /*!< (@ 0x40010000) WDT Structure                                              */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the watchdog                                         */
++  __IM  uint32_t  RESERVED[63];
++  __IOM uint32_t  EVENTS_TIMEOUT;               /*!< (@ 0x00000100) Watchdog timeout                                           */
++  __IM  uint32_t  RESERVED1[128];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED2[61];
++  __IM  uint32_t  RUNSTATUS;                    /*!< (@ 0x00000400) Run status                                                 */
++  __IM  uint32_t  REQSTATUS;                    /*!< (@ 0x00000404) Request status                                             */
++  __IM  uint32_t  RESERVED3[63];
++  __IOM uint32_t  CRV;                          /*!< (@ 0x00000504) Counter reload value                                       */
++  __IOM uint32_t  RREN;                         /*!< (@ 0x00000508) Enable register for reload request registers               */
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x0000050C) Configuration register                                     */
++  __IM  uint32_t  RESERVED4[60];
++  __OM  uint32_t  RR[8];                        /*!< (@ 0x00000600) Description collection: Reload request n                   */
++} NRF_WDT_Type;                                 /*!< Size = 1568 (0x620)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           QDEC                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Quadrature Decoder (QDEC)
++  */
++
++typedef struct {                                /*!< (@ 0x40012000) QDEC Structure                                             */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Task starting the quadrature decoder                       */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Task stopping the quadrature decoder                       */
++  __OM  uint32_t  TASKS_READCLRACC;             /*!< (@ 0x00000008) Read and clear ACC and ACCDBL                              */
++  __OM  uint32_t  TASKS_RDCLRACC;               /*!< (@ 0x0000000C) Read and clear ACC                                         */
++  __OM  uint32_t  TASKS_RDCLRDBL;               /*!< (@ 0x00000010) Read and clear ACCDBL                                      */
++  __IM  uint32_t  RESERVED[59];
++  __IOM uint32_t  EVENTS_SAMPLERDY;             /*!< (@ 0x00000100) Event being generated for every new sample value
++                                                                    written to the SAMPLE register                             */
++  __IOM uint32_t  EVENTS_REPORTRDY;             /*!< (@ 0x00000104) Non-null report ready                                      */
++  __IOM uint32_t  EVENTS_ACCOF;                 /*!< (@ 0x00000108) ACC or ACCDBL register overflow                            */
++  __IOM uint32_t  EVENTS_DBLRDY;                /*!< (@ 0x0000010C) Double displacement(s) detected                            */
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000110) QDEC has been stopped                                      */
++  __IM  uint32_t  RESERVED1[59];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED2[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[125];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable the quadrature decoder                              */
++  __IOM uint32_t  LEDPOL;                       /*!< (@ 0x00000504) LED output pin polarity                                    */
++  __IOM uint32_t  SAMPLEPER;                    /*!< (@ 0x00000508) Sample period                                              */
++  __IM  int32_t   SAMPLE;                       /*!< (@ 0x0000050C) Motion sample value                                        */
++  __IOM uint32_t  REPORTPER;                    /*!< (@ 0x00000510) Number of samples to be taken before REPORTRDY
++                                                                    and DBLRDY events can be generated                         */
++  __IM  int32_t   ACC;                          /*!< (@ 0x00000514) Register accumulating the valid transitions                */
++  __IM  int32_t   ACCREAD;                      /*!< (@ 0x00000518) Snapshot of the ACC register, updated by the
++                                                                    READCLRACC or RDCLRACC task                                */
++  __IOM QDEC_PSEL_Type PSEL;                    /*!< (@ 0x0000051C) Unspecified                                                */
++  __IOM uint32_t  DBFEN;                        /*!< (@ 0x00000528) Enable input debounce filters                              */
++  __IM  uint32_t  RESERVED4[5];
++  __IOM uint32_t  LEDPRE;                       /*!< (@ 0x00000540) Time period the LED is switched ON prior to sampling       */
++  __IM  uint32_t  ACCDBL;                       /*!< (@ 0x00000544) Register accumulating the number of detected
++                                                                    double transitions                                         */
++  __IM  uint32_t  ACCDBLREAD;                   /*!< (@ 0x00000548) Snapshot of the ACCDBL, updated by the READCLRACC
++                                                                    or RDCLRDBL task                                           */
++} NRF_QDEC_Type;                                /*!< Size = 1356 (0x54c)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           COMP                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Comparator (COMP)
++  */
++
++typedef struct {                                /*!< (@ 0x40013000) COMP Structure                                             */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start comparator                                           */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop comparator                                            */
++  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000008) Sample comparator value                                    */
++  __IM  uint32_t  RESERVED[61];
++  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) COMP is ready and output is valid                          */
++  __IOM uint32_t  EVENTS_DOWN;                  /*!< (@ 0x00000104) Downward crossing                                          */
++  __IOM uint32_t  EVENTS_UP;                    /*!< (@ 0x00000108) Upward crossing                                            */
++  __IOM uint32_t  EVENTS_CROSS;                 /*!< (@ 0x0000010C) Downward or upward crossing                                */
++  __IM  uint32_t  RESERVED1[60];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED2[63];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[61];
++  __IM  uint32_t  RESULT;                       /*!< (@ 0x00000400) Compare result                                             */
++  __IM  uint32_t  RESERVED4[63];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) COMP enable                                                */
++  __IOM uint32_t  PSEL;                         /*!< (@ 0x00000504) Pin select                                                 */
++  __IOM uint32_t  REFSEL;                       /*!< (@ 0x00000508) Reference source select for single-ended mode              */
++  __IOM uint32_t  EXTREFSEL;                    /*!< (@ 0x0000050C) External reference select                                  */
++  __IM  uint32_t  RESERVED5[8];
++  __IOM uint32_t  TH;                           /*!< (@ 0x00000530) Threshold configuration for hysteresis unit                */
++  __IOM uint32_t  MODE;                         /*!< (@ 0x00000534) Mode configuration                                         */
++  __IOM uint32_t  HYST;                         /*!< (@ 0x00000538) Comparator hysteresis enable                               */
++} NRF_COMP_Type;                                /*!< Size = 1340 (0x53c)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                          LPCOMP                                           ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Low-power comparator (LPCOMP)
++  */
++
++typedef struct {                                /*!< (@ 0x40013000) LPCOMP Structure                                           */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start comparator                                           */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stop comparator                                            */
++  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000008) Sample comparator value                                    */
++  __IM  uint32_t  RESERVED[61];
++  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) LPCOMP is ready and output is valid                        */
++  __IOM uint32_t  EVENTS_DOWN;                  /*!< (@ 0x00000104) Downward crossing                                          */
++  __IOM uint32_t  EVENTS_UP;                    /*!< (@ 0x00000108) Upward crossing                                            */
++  __IOM uint32_t  EVENTS_CROSS;                 /*!< (@ 0x0000010C) Downward or upward crossing                                */
++  __IM  uint32_t  RESERVED1[60];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED2[64];
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[61];
++  __IM  uint32_t  RESULT;                       /*!< (@ 0x00000400) Compare result                                             */
++  __IM  uint32_t  RESERVED4[63];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable LPCOMP                                              */
++  __IOM uint32_t  PSEL;                         /*!< (@ 0x00000504) Input pin select                                           */
++  __IOM uint32_t  REFSEL;                       /*!< (@ 0x00000508) Reference select                                           */
++  __IOM uint32_t  EXTREFSEL;                    /*!< (@ 0x0000050C) External reference select                                  */
++  __IM  uint32_t  RESERVED5[4];
++  __IOM uint32_t  ANADETECT;                    /*!< (@ 0x00000520) Analog detect configuration                                */
++  __IM  uint32_t  RESERVED6[5];
++  __IOM uint32_t  HYST;                         /*!< (@ 0x00000538) Comparator hysteresis enable                               */
++} NRF_LPCOMP_Type;                              /*!< Size = 1340 (0x53c)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           EGU0                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Event generator unit 0 (EGU0)
++  */
++
++typedef struct {                                /*!< (@ 0x40014000) EGU0 Structure                                             */
++  __OM  uint32_t  TASKS_TRIGGER[16];            /*!< (@ 0x00000000) Description collection: Trigger n for triggering
++                                                                    the corresponding TRIGGERED[n] event                       */
++  __IM  uint32_t  RESERVED[48];
++  __IOM uint32_t  EVENTS_TRIGGERED[16];         /*!< (@ 0x00000100) Description collection: Event number n generated
++                                                                    by triggering the corresponding TRIGGER[n]
++                                                                    task                                                       */
++  __IM  uint32_t  RESERVED1[112];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++} NRF_EGU_Type;                                 /*!< Size = 780 (0x30c)                                                        */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           SWI0                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Software interrupt 0 (SWI0)
++  */
++
++typedef struct {                                /*!< (@ 0x40014000) SWI0 Structure                                             */
++  __IM  uint32_t  UNUSED;                       /*!< (@ 0x00000000) Unused.                                                    */
++} NRF_SWI_Type;                                 /*!< Size = 4 (0x4)                                                            */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           PWM0                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Pulse width modulation unit 0 (PWM0)
++  */
++
++typedef struct {                                /*!< (@ 0x4001C000) PWM0 Structure                                             */
++  __IM  uint32_t  RESERVED;
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PWM pulse generation on all channels at
++                                                                    the end of current PWM period, and stops
++                                                                    sequence playback                                          */
++  __OM  uint32_t  TASKS_SEQSTART[2];            /*!< (@ 0x00000008) Description collection: Loads the first PWM value
++                                                                    on all enabled channels from sequence n,
++                                                                    and starts playing that sequence at the
++                                                                    rate defined in SEQ[n]REFRESH and/or DECODER.MODE.
++                                                                    Causes PWM generation to start if not running.             */
++  __OM  uint32_t  TASKS_NEXTSTEP;               /*!< (@ 0x00000010) Steps by one value in the current sequence on
++                                                                    all enabled channels if DECODER.MODE=NextStep.
++                                                                    Does not cause PWM generation to start if
++                                                                    not running.                                               */
++  __IM  uint32_t  RESERVED1[60];
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) Response to STOP task, emitted when PWM pulses
++                                                                    are no longer generated                                    */
++  __IOM uint32_t  EVENTS_SEQSTARTED[2];         /*!< (@ 0x00000108) Description collection: First PWM period started
++                                                                    on sequence n                                              */
++  __IOM uint32_t  EVENTS_SEQEND[2];             /*!< (@ 0x00000110) Description collection: Emitted at end of every
++                                                                    sequence n, when last value from RAM has
++                                                                    been applied to wave counter                               */
++  __IOM uint32_t  EVENTS_PWMPERIODEND;          /*!< (@ 0x00000118) Emitted at the end of each PWM period                      */
++  __IOM uint32_t  EVENTS_LOOPSDONE;             /*!< (@ 0x0000011C) Concatenated sequences have been played the amount
++                                                                    of times defined in LOOP.CNT                               */
++  __IM  uint32_t  RESERVED2[56];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED3[63];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED4[125];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) PWM module enable register                                 */
++  __IOM uint32_t  MODE;                         /*!< (@ 0x00000504) Selects operating mode of the wave counter                 */
++  __IOM uint32_t  COUNTERTOP;                   /*!< (@ 0x00000508) Value up to which the pulse generator counter
++                                                                    counts                                                     */
++  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x0000050C) Configuration for PWM_CLK                                  */
++  __IOM uint32_t  DECODER;                      /*!< (@ 0x00000510) Configuration of the decoder                               */
++  __IOM uint32_t  LOOP;                         /*!< (@ 0x00000514) Number of playbacks of a loop                              */
++  __IM  uint32_t  RESERVED5[2];
++  __IOM PWM_SEQ_Type SEQ[2];                    /*!< (@ 0x00000520) Unspecified                                                */
++  __IOM PWM_PSEL_Type PSEL;                     /*!< (@ 0x00000560) Unspecified                                                */
++} NRF_PWM_Type;                                 /*!< Size = 1392 (0x570)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            PDM                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Pulse Density Modulation (Digital Microphone) Interface (PDM)
++  */
++
++typedef struct {                                /*!< (@ 0x4001D000) PDM Structure                                              */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous PDM transfer                             */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PDM transfer                                         */
++  __IM  uint32_t  RESERVED[62];
++  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000100) PDM transfer has started                                   */
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) PDM transfer has finished                                  */
++  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000108) The PDM has written the last sample specified
++                                                                    by SAMPLE.MAXCNT (or the last sample after
++                                                                    a STOP task has been received) to Data RAM                 */
++  __IM  uint32_t  RESERVED1[125];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED2[125];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) PDM module enable register                                 */
++  __IOM uint32_t  PDMCLKCTRL;                   /*!< (@ 0x00000504) PDM clock generator control                                */
++  __IOM uint32_t  MODE;                         /*!< (@ 0x00000508) Defines the routing of the connected PDM microphones'
++                                                                    signals                                                    */
++  __IM  uint32_t  RESERVED3[3];
++  __IOM uint32_t  GAINL;                        /*!< (@ 0x00000518) Left output gain adjustment                                */
++  __IOM uint32_t  GAINR;                        /*!< (@ 0x0000051C) Right output gain adjustment                               */
++  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000520) Selects the ratio between PDM_CLK and output
++                                                                    sample rate. Change PDMCLKCTRL accordingly.                */
++  __IM  uint32_t  RESERVED4[7];
++  __IOM PDM_PSEL_Type PSEL;                     /*!< (@ 0x00000540) Unspecified                                                */
++  __IM  uint32_t  RESERVED5[6];
++  __IOM PDM_SAMPLE_Type SAMPLE;                 /*!< (@ 0x00000560) Unspecified                                                */
++} NRF_PDM_Type;                                 /*!< Size = 1384 (0x568)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            ACL                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Access control lists (ACL)
++  */
++
++typedef struct {                                /*!< (@ 0x4001E000) ACL Structure                                              */
++  __IM  uint32_t  RESERVED[512];
++  __IOM ACL_ACL_Type ACL[8];                    /*!< (@ 0x00000800) Unspecified                                                */
++} NRF_ACL_Type;                                 /*!< Size = 2176 (0x880)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           NVMC                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Non Volatile Memory Controller (NVMC)
++  */
++
++typedef struct {                                /*!< (@ 0x4001E000) NVMC Structure                                             */
++  __IM  uint32_t  RESERVED[256];
++  __IM  uint32_t  READY;                        /*!< (@ 0x00000400) Ready flag                                                 */
++  __IM  uint32_t  RESERVED1;
++  __IM  uint32_t  READYNEXT;                    /*!< (@ 0x00000408) Ready flag                                                 */
++  __IM  uint32_t  RESERVED2[62];
++  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000504) Configuration register                                     */
++  
++  union {
++    __OM  uint32_t ERASEPAGE;                   /*!< (@ 0x00000508) Register for erasing a page in code area                   */
++    __OM  uint32_t ERASEPCR1;                   /*!< (@ 0x00000508) Deprecated register - Register for erasing a
++                                                                    page in code area, equivalent to ERASEPAGE                 */
++  };
++  __OM  uint32_t  ERASEALL;                     /*!< (@ 0x0000050C) Register for erasing all non-volatile user memory          */
++  __OM  uint32_t  ERASEPCR0;                    /*!< (@ 0x00000510) Deprecated register - Register for erasing a
++                                                                    page in code area, equivalent to ERASEPAGE                 */
++  __OM  uint32_t  ERASEUICR;                    /*!< (@ 0x00000514) Register for erasing user information configuration
++                                                                    registers                                                  */
++  __OM  uint32_t  ERASEPAGEPARTIAL;             /*!< (@ 0x00000518) Register for partial erase of a page in code
++                                                                    area                                                       */
++  __IOM uint32_t  ERASEPAGEPARTIALCFG;          /*!< (@ 0x0000051C) Register for partial erase configuration                   */
++  __IM  uint32_t  RESERVED3[8];
++  __IOM uint32_t  ICACHECNF;                    /*!< (@ 0x00000540) I-code cache configuration register                        */
++  __IM  uint32_t  RESERVED4;
++  __IOM uint32_t  IHIT;                         /*!< (@ 0x00000548) I-code cache hit counter                                   */
++  __IOM uint32_t  IMISS;                        /*!< (@ 0x0000054C) I-code cache miss counter                                  */
++} NRF_NVMC_Type;                                /*!< Size = 1360 (0x550)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            PPI                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Programmable Peripheral Interconnect (PPI)
++  */
++
++typedef struct {                                /*!< (@ 0x4001F000) PPI Structure                                              */
++  __OM  PPI_TASKS_CHG_Type TASKS_CHG[6];        /*!< (@ 0x00000000) Channel group tasks                                        */
++  __IM  uint32_t  RESERVED[308];
++  __IOM uint32_t  CHEN;                         /*!< (@ 0x00000500) Channel enable register                                    */
++  __IOM uint32_t  CHENSET;                      /*!< (@ 0x00000504) Channel enable set register                                */
++  __IOM uint32_t  CHENCLR;                      /*!< (@ 0x00000508) Channel enable clear register                              */
++  __IM  uint32_t  RESERVED1;
++  __IOM PPI_CH_Type CH[20];                     /*!< (@ 0x00000510) PPI Channel                                                */
++  __IM  uint32_t  RESERVED2[148];
++  __IOM uint32_t  CHG[6];                       /*!< (@ 0x00000800) Description collection: Channel group n                    */
++  __IM  uint32_t  RESERVED3[62];
++  __IOM PPI_FORK_Type FORK[32];                 /*!< (@ 0x00000910) Fork                                                       */
++} NRF_PPI_Type;                                 /*!< Size = 2448 (0x990)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            MWU                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Memory Watch Unit (MWU)
++  */
++
++typedef struct {                                /*!< (@ 0x40020000) MWU Structure                                              */
++  __IM  uint32_t  RESERVED[64];
++  __IOM MWU_EVENTS_REGION_Type EVENTS_REGION[4];/*!< (@ 0x00000100) Peripheral events.                                         */
++  __IM  uint32_t  RESERVED1[16];
++  __IOM MWU_EVENTS_PREGION_Type EVENTS_PREGION[2];/*!< (@ 0x00000160) Peripheral events.                                       */
++  __IM  uint32_t  RESERVED2[100];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[5];
++  __IOM uint32_t  NMIEN;                        /*!< (@ 0x00000320) Enable or disable interrupt                                */
++  __IOM uint32_t  NMIENSET;                     /*!< (@ 0x00000324) Enable interrupt                                           */
++  __IOM uint32_t  NMIENCLR;                     /*!< (@ 0x00000328) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED4[53];
++  __IOM MWU_PERREGION_Type PERREGION[2];        /*!< (@ 0x00000400) Unspecified                                                */
++  __IM  uint32_t  RESERVED5[64];
++  __IOM uint32_t  REGIONEN;                     /*!< (@ 0x00000510) Enable/disable regions watch                               */
++  __IOM uint32_t  REGIONENSET;                  /*!< (@ 0x00000514) Enable regions watch                                       */
++  __IOM uint32_t  REGIONENCLR;                  /*!< (@ 0x00000518) Disable regions watch                                      */
++  __IM  uint32_t  RESERVED6[57];
++  __IOM MWU_REGION_Type REGION[4];              /*!< (@ 0x00000600) Unspecified                                                */
++  __IM  uint32_t  RESERVED7[32];
++  __IOM MWU_PREGION_Type PREGION[2];            /*!< (@ 0x000006C0) Unspecified                                                */
++} NRF_MWU_Type;                                 /*!< Size = 1760 (0x6e0)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            I2S                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Inter-IC Sound (I2S)
++  */
++
++typedef struct {                                /*!< (@ 0x40025000) I2S Structure                                              */
++  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous I2S transfer. Also starts MCK
++                                                                    generator when this is enabled.                            */
++  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops I2S transfer. Also stops MCK generator.
++                                                                    Triggering this task will cause the STOPPED
++                                                                    event to be generated.                                     */
++  __IM  uint32_t  RESERVED[63];
++  __IOM uint32_t  EVENTS_RXPTRUPD;              /*!< (@ 0x00000104) The RXD.PTR register has been copied to internal
++                                                                    double-buffers. When the I2S module is started
++                                                                    and RX is enabled, this event will be generated
++                                                                    for every RXTXD.MAXCNT words that are received
++                                                                    on the SDIN pin.                                           */
++  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000108) I2S transfer stopped.                                      */
++  __IM  uint32_t  RESERVED1[2];
++  __IOM uint32_t  EVENTS_TXPTRUPD;              /*!< (@ 0x00000114) The TDX.PTR register has been copied to internal
++                                                                    double-buffers. When the I2S module is started
++                                                                    and TX is enabled, this event will be generated
++                                                                    for every RXTXD.MAXCNT words that are sent
++                                                                    on the SDOUT pin.                                          */
++  __IM  uint32_t  RESERVED2[122];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED3[125];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable I2S module.                                         */
++  __IOM I2S_CONFIG_Type CONFIG;                 /*!< (@ 0x00000504) Unspecified                                                */
++  __IM  uint32_t  RESERVED4[3];
++  __IOM I2S_RXD_Type RXD;                       /*!< (@ 0x00000538) Unspecified                                                */
++  __IM  uint32_t  RESERVED5;
++  __IOM I2S_TXD_Type TXD;                       /*!< (@ 0x00000540) Unspecified                                                */
++  __IM  uint32_t  RESERVED6[3];
++  __IOM I2S_RXTXD_Type RXTXD;                   /*!< (@ 0x00000550) Unspecified                                                */
++  __IM  uint32_t  RESERVED7[3];
++  __IOM I2S_PSEL_Type PSEL;                     /*!< (@ 0x00000560) Unspecified                                                */
++} NRF_I2S_Type;                                 /*!< Size = 1396 (0x574)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                            FPU                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief FPU (FPU)
++  */
++
++typedef struct {                                /*!< (@ 0x40026000) FPU Structure                                              */
++  __IM  uint32_t  UNUSED;                       /*!< (@ 0x00000000) Unused.                                                    */
++} NRF_FPU_Type;                                 /*!< Size = 4 (0x4)                                                            */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           USBD                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief Universal serial bus device (USBD)
++  */
++
++typedef struct {                                /*!< (@ 0x40027000) USBD Structure                                             */
++  __IM  uint32_t  RESERVED;
++  __OM  uint32_t  TASKS_STARTEPIN[8];           /*!< (@ 0x00000004) Description collection: Captures the EPIN[n].PTR
++                                                                    and EPIN[n].MAXCNT registers values, and
++                                                                    enables endpoint IN n to respond to traffic
++                                                                    from host                                                  */
++  __OM  uint32_t  TASKS_STARTISOIN;             /*!< (@ 0x00000024) Captures the ISOIN.PTR and ISOIN.MAXCNT registers
++                                                                    values, and enables sending data on ISO
++                                                                    endpoint                                                   */
++  __OM  uint32_t  TASKS_STARTEPOUT[8];          /*!< (@ 0x00000028) Description collection: Captures the EPOUT[n].PTR
++                                                                    and EPOUT[n].MAXCNT registers values, and
++                                                                    enables endpoint n to respond to traffic
++                                                                    from host                                                  */
++  __OM  uint32_t  TASKS_STARTISOOUT;            /*!< (@ 0x00000048) Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers
++                                                                    values, and enables receiving of data on
++                                                                    ISO endpoint                                               */
++  __OM  uint32_t  TASKS_EP0RCVOUT;              /*!< (@ 0x0000004C) Allows OUT data stage on control endpoint 0                */
++  __OM  uint32_t  TASKS_EP0STATUS;              /*!< (@ 0x00000050) Allows status stage on control endpoint 0                  */
++  __OM  uint32_t  TASKS_EP0STALL;               /*!< (@ 0x00000054) Stalls data and status stage on control endpoint
++                                                                    0                                                          */
++  __OM  uint32_t  TASKS_DPDMDRIVE;              /*!< (@ 0x00000058) Forces D+ and D- lines into the state defined
++                                                                    in the DPDMVALUE register                                  */
++  __OM  uint32_t  TASKS_DPDMNODRIVE;            /*!< (@ 0x0000005C) Stops forcing D+ and D- lines into any state
++                                                                    (USB engine takes control)                                 */
++  __IM  uint32_t  RESERVED1[40];
++  __IOM uint32_t  EVENTS_USBRESET;              /*!< (@ 0x00000100) Signals that a USB reset condition has been detected
++                                                                    on USB lines                                               */
++  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000104) Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT,
++                                                                    or EPOUT[n].PTR and EPOUT[n].MAXCNT registers
++                                                                    have been captured on all endpoints reported
++                                                                    in the EPSTATUS register                                   */
++  __IOM uint32_t  EVENTS_ENDEPIN[8];            /*!< (@ 0x00000108) Description collection: The whole EPIN[n] buffer
++                                                                    has been consumed. The buffer can be accessed
++                                                                    safely by software.                                        */
++  __IOM uint32_t  EVENTS_EP0DATADONE;           /*!< (@ 0x00000128) An acknowledged data transfer has taken place
++                                                                    on the control endpoint                                    */
++  __IOM uint32_t  EVENTS_ENDISOIN;              /*!< (@ 0x0000012C) The whole ISOIN buffer has been consumed. The
++                                                                    buffer can be accessed safely by software.                 */
++  __IOM uint32_t  EVENTS_ENDEPOUT[8];           /*!< (@ 0x00000130) Description collection: The whole EPOUT[n] buffer
++                                                                    has been consumed. The buffer can be accessed
++                                                                    safely by software.                                        */
++  __IOM uint32_t  EVENTS_ENDISOOUT;             /*!< (@ 0x00000150) The whole ISOOUT buffer has been consumed. The
++                                                                    buffer can be accessed safely by software.                 */
++  __IOM uint32_t  EVENTS_SOF;                   /*!< (@ 0x00000154) Signals that a SOF (start of frame) condition
++                                                                    has been detected on USB lines                             */
++  __IOM uint32_t  EVENTS_USBEVENT;              /*!< (@ 0x00000158) An event or an error not covered by specific
++                                                                    events has occurred. Check EVENTCAUSE register
++                                                                    to find the cause.                                         */
++  __IOM uint32_t  EVENTS_EP0SETUP;              /*!< (@ 0x0000015C) A valid SETUP token has been received (and acknowledged)
++                                                                    on the control endpoint                                    */
++  __IOM uint32_t  EVENTS_EPDATA;                /*!< (@ 0x00000160) A data transfer has occurred on a data endpoint,
++                                                                    indicated by the EPDATASTATUS register                     */
++  __IM  uint32_t  RESERVED2[39];
++  __IOM uint32_t  SHORTS;                       /*!< (@ 0x00000200) Shortcuts between local events and tasks                   */
++  __IM  uint32_t  RESERVED3[63];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED4[61];
++  __IOM uint32_t  EVENTCAUSE;                   /*!< (@ 0x00000400) Details on what caused the USBEVENT event                  */
++  __IM  uint32_t  RESERVED5[7];
++  __IOM USBD_HALTED_Type HALTED;                /*!< (@ 0x00000420) Unspecified                                                */
++  __IM  uint32_t  RESERVED6;
++  __IOM uint32_t  EPSTATUS;                     /*!< (@ 0x00000468) Provides information on which endpoint's EasyDMA
++                                                                    registers have been captured                               */
++  __IOM uint32_t  EPDATASTATUS;                 /*!< (@ 0x0000046C) Provides information on which endpoint(s) an
++                                                                    acknowledged data transfer has occurred
++                                                                    (EPDATA event)                                             */
++  __IM  uint32_t  USBADDR;                      /*!< (@ 0x00000470) Device USB address                                         */
++  __IM  uint32_t  RESERVED7[3];
++  __IM  uint32_t  BMREQUESTTYPE;                /*!< (@ 0x00000480) SETUP data, byte 0, bmRequestType                          */
++  __IM  uint32_t  BREQUEST;                     /*!< (@ 0x00000484) SETUP data, byte 1, bRequest                               */
++  __IM  uint32_t  WVALUEL;                      /*!< (@ 0x00000488) SETUP data, byte 2, LSB of wValue                          */
++  __IM  uint32_t  WVALUEH;                      /*!< (@ 0x0000048C) SETUP data, byte 3, MSB of wValue                          */
++  __IM  uint32_t  WINDEXL;                      /*!< (@ 0x00000490) SETUP data, byte 4, LSB of wIndex                          */
++  __IM  uint32_t  WINDEXH;                      /*!< (@ 0x00000494) SETUP data, byte 5, MSB of wIndex                          */
++  __IM  uint32_t  WLENGTHL;                     /*!< (@ 0x00000498) SETUP data, byte 6, LSB of wLength                         */
++  __IM  uint32_t  WLENGTHH;                     /*!< (@ 0x0000049C) SETUP data, byte 7, MSB of wLength                         */
++  __IOM USBD_SIZE_Type SIZE;                    /*!< (@ 0x000004A0) Unspecified                                                */
++  __IM  uint32_t  RESERVED8[15];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable USB                                                 */
++  __IOM uint32_t  USBPULLUP;                    /*!< (@ 0x00000504) Control of the USB pull-up                                 */
++  __IOM uint32_t  DPDMVALUE;                    /*!< (@ 0x00000508) State D+ and D- lines will be forced into by
++                                                                    the DPDMDRIVE task. The DPDMNODRIVE task
++                                                                    reverts the control of the lines to MAC
++                                                                    IP (no forcing).                                           */
++  __IOM uint32_t  DTOGGLE;                      /*!< (@ 0x0000050C) Data toggle control and status                             */
++  __IOM uint32_t  EPINEN;                       /*!< (@ 0x00000510) Endpoint IN enable                                         */
++  __IOM uint32_t  EPOUTEN;                      /*!< (@ 0x00000514) Endpoint OUT enable                                        */
++  __OM  uint32_t  EPSTALL;                      /*!< (@ 0x00000518) STALL endpoints                                            */
++  __IOM uint32_t  ISOSPLIT;                     /*!< (@ 0x0000051C) Controls the split of ISO buffers                          */
++  __IM  uint32_t  FRAMECNTR;                    /*!< (@ 0x00000520) Returns the current value of the start of frame
++                                                                    counter                                                    */
++  __IM  uint32_t  RESERVED9[2];
++  __IOM uint32_t  LOWPOWER;                     /*!< (@ 0x0000052C) Controls USBD peripheral low power mode during
++                                                                    USB suspend                                                */
++  __IOM uint32_t  ISOINCONFIG;                  /*!< (@ 0x00000530) Controls the response of the ISO IN endpoint
++                                                                    to an IN token when no data is ready to
++                                                                    be sent                                                    */
++  __IM  uint32_t  RESERVED10[51];
++  __IOM USBD_EPIN_Type EPIN[8];                 /*!< (@ 0x00000600) Unspecified                                                */
++  __IOM USBD_ISOIN_Type ISOIN;                  /*!< (@ 0x000006A0) Unspecified                                                */
++  __IM  uint32_t  RESERVED11[21];
++  __IOM USBD_EPOUT_Type EPOUT[8];               /*!< (@ 0x00000700) Unspecified                                                */
++  __IOM USBD_ISOOUT_Type ISOOUT;                /*!< (@ 0x000007A0) Unspecified                                                */
++} NRF_USBD_Type;                                /*!< Size = 1964 (0x7ac)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                           QSPI                                            ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief External flash interface (QSPI)
++  */
++
++typedef struct {                                /*!< (@ 0x40029000) QSPI Structure                                             */
++  __OM  uint32_t  TASKS_ACTIVATE;               /*!< (@ 0x00000000) Activate QSPI interface                                    */
++  __OM  uint32_t  TASKS_READSTART;              /*!< (@ 0x00000004) Start transfer from external flash memory to
++                                                                    internal RAM                                               */
++  __OM  uint32_t  TASKS_WRITESTART;             /*!< (@ 0x00000008) Start transfer from internal RAM to external
++                                                                    flash memory                                               */
++  __OM  uint32_t  TASKS_ERASESTART;             /*!< (@ 0x0000000C) Start external flash memory erase operation                */
++  __OM  uint32_t  TASKS_DEACTIVATE;             /*!< (@ 0x00000010) Deactivate QSPI interface                                  */
++  __IM  uint32_t  RESERVED[59];
++  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) QSPI peripheral is ready. This event will be
++                                                                    generated as a response to any QSPI task.                  */
++  __IM  uint32_t  RESERVED1[127];
++  __IOM uint32_t  INTEN;                        /*!< (@ 0x00000300) Enable or disable interrupt                                */
++  __IOM uint32_t  INTENSET;                     /*!< (@ 0x00000304) Enable interrupt                                           */
++  __IOM uint32_t  INTENCLR;                     /*!< (@ 0x00000308) Disable interrupt                                          */
++  __IM  uint32_t  RESERVED2[125];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable QSPI peripheral and acquire the pins selected
++                                                                    in PSELn registers                                         */
++  __IOM QSPI_READ_Type READ;                    /*!< (@ 0x00000504) Unspecified                                                */
++  __IOM QSPI_WRITE_Type WRITE;                  /*!< (@ 0x00000510) Unspecified                                                */
++  __IOM QSPI_ERASE_Type ERASE;                  /*!< (@ 0x0000051C) Unspecified                                                */
++  __IOM QSPI_PSEL_Type PSEL;                    /*!< (@ 0x00000524) Unspecified                                                */
++  __IOM uint32_t  XIPOFFSET;                    /*!< (@ 0x00000540) Address offset into the external memory for Execute
++                                                                    in Place operation.                                        */
++  __IOM uint32_t  IFCONFIG0;                    /*!< (@ 0x00000544) Interface configuration.                                   */
++  __IM  uint32_t  RESERVED3[46];
++  __IOM uint32_t  IFCONFIG1;                    /*!< (@ 0x00000600) Interface configuration.                                   */
++  __IM  uint32_t  STATUS;                       /*!< (@ 0x00000604) Status register.                                           */
++  __IM  uint32_t  RESERVED4[3];
++  __IOM uint32_t  DPMDUR;                       /*!< (@ 0x00000614) Set the duration required to enter/exit deep
++                                                                    power-down mode (DPM).                                     */
++  __IM  uint32_t  RESERVED5[3];
++  __IOM uint32_t  ADDRCONF;                     /*!< (@ 0x00000624) Extended address configuration.                            */
++  __IM  uint32_t  RESERVED6[3];
++  __IOM uint32_t  CINSTRCONF;                   /*!< (@ 0x00000634) Custom instruction configuration register.                 */
++  __IOM uint32_t  CINSTRDAT0;                   /*!< (@ 0x00000638) Custom instruction data register 0.                        */
++  __IOM uint32_t  CINSTRDAT1;                   /*!< (@ 0x0000063C) Custom instruction data register 1.                        */
++  __IOM uint32_t  IFTIMING;                     /*!< (@ 0x00000640) SPI interface timing.                                      */
++} NRF_QSPI_Type;                                /*!< Size = 1604 (0x644)                                                       */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                        CC_HOST_RGF                                        ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief CRYPTOCELL HOST_RGF interface (CC_HOST_RGF)
++  */
++
++typedef struct {                                /*!< (@ 0x5002A000) CC_HOST_RGF Structure                                      */
++  __IM  uint32_t  RESERVED[1678];
++  __IOM uint32_t  HOST_CRYPTOKEY_SEL;           /*!< (@ 0x00001A38) AES hardware key select                                    */
++  __IM  uint32_t  RESERVED1[4];
++  __IOM uint32_t  HOST_IOT_KPRTL_LOCK;          /*!< (@ 0x00001A4C) This write-once register is the K_PRTL lock register.
++                                                                    When this register is set, K_PRTL cannot
++                                                                    be used and a zeroed key will be used instead.
++                                                                    The value of this register is saved in the
++                                                                    CRYPTOCELL AO power domain.                                */
++  __IOM uint32_t  HOST_IOT_KDR0;                /*!< (@ 0x00001A50) This register holds bits 31:0 of K_DR. The value
++                                                                    of this register is saved in the CRYPTOCELL
++                                                                    AO power domain. Reading from this address
++                                                                    returns the K_DR valid status indicating
++                                                                    if K_DR is successfully retained.                          */
++  __OM  uint32_t  HOST_IOT_KDR1;                /*!< (@ 0x00001A54) This register holds bits 63:32 of K_DR. The value
++                                                                    of this register is saved in the CRYPTOCELL
++                                                                    AO power domain.                                           */
++  __OM  uint32_t  HOST_IOT_KDR2;                /*!< (@ 0x00001A58) This register holds bits 95:64 of K_DR. The value
++                                                                    of this register is saved in the CRYPTOCELL
++                                                                    AO power domain.                                           */
++  __OM  uint32_t  HOST_IOT_KDR3;                /*!< (@ 0x00001A5C) This register holds bits 127:96 of K_DR. The
++                                                                    value of this register is saved in the CRYPTOCELL
++                                                                    AO power domain.                                           */
++  __IOM uint32_t  HOST_IOT_LCS;                 /*!< (@ 0x00001A60) Controls lifecycle state (LCS) for CRYPTOCELL
++                                                                    subsystem                                                  */
++} NRF_CC_HOST_RGF_Type;                         /*!< Size = 6756 (0x1a64)                                                      */
++
++
++
++/* =========================================================================================================================== */
++/* ================                                        CRYPTOCELL                                         ================ */
++/* =========================================================================================================================== */
++
++
++/**
++  * @brief ARM TrustZone CryptoCell register interface (CRYPTOCELL)
++  */
++
++typedef struct {                                /*!< (@ 0x5002A000) CRYPTOCELL Structure                                       */
++  __IM  uint32_t  RESERVED[320];
++  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable CRYPTOCELL subsystem                                */
++} NRF_CRYPTOCELL_Type;                          /*!< Size = 1284 (0x504)                                                       */
++
++
++/** @} */ /* End of group Device_Peripheral_peripherals */
++
++
++/* =========================================================================================================================== */
++/* ================                          Device Specific Peripheral Address Map                           ================ */
++/* =========================================================================================================================== */
++
++
++/** @addtogroup Device_Peripheral_peripheralAddr
++  * @{
++  */
++
++#define NRF_FICR_BASE               0x10000000UL
++#define NRF_UICR_BASE               0x10001000UL
++#define NRF_APPROTECT_BASE          0x40000000UL
++#define NRF_CLOCK_BASE              0x40000000UL
++#define NRF_POWER_BASE              0x40000000UL
++#define NRF_P0_BASE                 0x50000000UL
++#define NRF_P1_BASE                 0x50000300UL
++#define NRF_RADIO_BASE              0x40001000UL
++#define NRF_UART0_BASE              0x40002000UL
++#define NRF_UARTE0_BASE             0x40002000UL
++#define NRF_SPI0_BASE               0x40003000UL
++#define NRF_SPIM0_BASE              0x40003000UL
++#define NRF_SPIS0_BASE              0x40003000UL
++#define NRF_TWI0_BASE               0x40003000UL
++#define NRF_TWIM0_BASE              0x40003000UL
++#define NRF_TWIS0_BASE              0x40003000UL
++#define NRF_SPI1_BASE               0x40004000UL
++#define NRF_SPIM1_BASE              0x40004000UL
++#define NRF_SPIS1_BASE              0x40004000UL
++#define NRF_TWI1_BASE               0x40004000UL
++#define NRF_TWIM1_BASE              0x40004000UL
++#define NRF_TWIS1_BASE              0x40004000UL
++#define NRF_NFCT_BASE               0x40005000UL
++#define NRF_GPIOTE_BASE             0x40006000UL
++#define NRF_SAADC_BASE              0x40007000UL
++#define NRF_TIMER0_BASE             0x40008000UL
++#define NRF_TIMER1_BASE             0x40009000UL
++#define NRF_TIMER2_BASE             0x4000A000UL
++#define NRF_RTC0_BASE               0x4000B000UL
++#define NRF_TEMP_BASE               0x4000C000UL
++#define NRF_RNG_BASE                0x4000D000UL
++#define NRF_ECB_BASE                0x4000E000UL
++#define NRF_AAR_BASE                0x4000F000UL
++#define NRF_CCM_BASE                0x4000F000UL
++#define NRF_WDT_BASE                0x40010000UL
++#define NRF_RTC1_BASE               0x40011000UL
++#define NRF_QDEC_BASE               0x40012000UL
++#define NRF_COMP_BASE               0x40013000UL
++#define NRF_LPCOMP_BASE             0x40013000UL
++#define NRF_EGU0_BASE               0x40014000UL
++#define NRF_SWI0_BASE               0x40014000UL
++#define NRF_EGU1_BASE               0x40015000UL
++#define NRF_SWI1_BASE               0x40015000UL
++#define NRF_EGU2_BASE               0x40016000UL
++#define NRF_SWI2_BASE               0x40016000UL
++#define NRF_EGU3_BASE               0x40017000UL
++#define NRF_SWI3_BASE               0x40017000UL
++#define NRF_EGU4_BASE               0x40018000UL
++#define NRF_SWI4_BASE               0x40018000UL
++#define NRF_EGU5_BASE               0x40019000UL
++#define NRF_SWI5_BASE               0x40019000UL
++#define NRF_TIMER3_BASE             0x4001A000UL
++#define NRF_TIMER4_BASE             0x4001B000UL
++#define NRF_PWM0_BASE               0x4001C000UL
++#define NRF_PDM_BASE                0x4001D000UL
++#define NRF_ACL_BASE                0x4001E000UL
++#define NRF_NVMC_BASE               0x4001E000UL
++#define NRF_PPI_BASE                0x4001F000UL
++#define NRF_MWU_BASE                0x40020000UL
++#define NRF_PWM1_BASE               0x40021000UL
++#define NRF_PWM2_BASE               0x40022000UL
++#define NRF_SPI2_BASE               0x40023000UL
++#define NRF_SPIM2_BASE              0x40023000UL
++#define NRF_SPIS2_BASE              0x40023000UL
++#define NRF_RTC2_BASE               0x40024000UL
++#define NRF_I2S_BASE                0x40025000UL
++#define NRF_FPU_BASE                0x40026000UL
++#define NRF_USBD_BASE               0x40027000UL
++#define NRF_UARTE1_BASE             0x40028000UL
++#define NRF_QSPI_BASE               0x40029000UL
++#define NRF_CC_HOST_RGF_BASE        0x5002A000UL
++#define NRF_CRYPTOCELL_BASE         0x5002A000UL
++#define NRF_PWM3_BASE               0x4002D000UL
++#define NRF_SPIM3_BASE              0x4002F000UL
++
++/** @} */ /* End of group Device_Peripheral_peripheralAddr */
++
++
++/* =========================================================================================================================== */
++/* ================                                  Peripheral declaration                                   ================ */
++/* =========================================================================================================================== */
++
++
++/** @addtogroup Device_Peripheral_declaration
++  * @{
++  */
++
++#define NRF_FICR                    ((NRF_FICR_Type*)          NRF_FICR_BASE)
++#define NRF_UICR                    ((NRF_UICR_Type*)          NRF_UICR_BASE)
++#define NRF_APPROTECT               ((NRF_APPROTECT_Type*)     NRF_APPROTECT_BASE)
++#define NRF_CLOCK                   ((NRF_CLOCK_Type*)         NRF_CLOCK_BASE)
++#define NRF_POWER                   ((NRF_POWER_Type*)         NRF_POWER_BASE)
++#define NRF_P0                      ((NRF_GPIO_Type*)          NRF_P0_BASE)
++#define NRF_P1                      ((NRF_GPIO_Type*)          NRF_P1_BASE)
++#define NRF_RADIO                   ((NRF_RADIO_Type*)         NRF_RADIO_BASE)
++#define NRF_UART0                   ((NRF_UART_Type*)          NRF_UART0_BASE)
++#define NRF_UARTE0                  ((NRF_UARTE_Type*)         NRF_UARTE0_BASE)
++#define NRF_SPI0                    ((NRF_SPI_Type*)           NRF_SPI0_BASE)
++#define NRF_SPIM0                   ((NRF_SPIM_Type*)          NRF_SPIM0_BASE)
++#define NRF_SPIS0                   ((NRF_SPIS_Type*)          NRF_SPIS0_BASE)
++#define NRF_TWI0                    ((NRF_TWI_Type*)           NRF_TWI0_BASE)
++#define NRF_TWIM0                   ((NRF_TWIM_Type*)          NRF_TWIM0_BASE)
++#define NRF_TWIS0                   ((NRF_TWIS_Type*)          NRF_TWIS0_BASE)
++#define NRF_SPI1                    ((NRF_SPI_Type*)           NRF_SPI1_BASE)
++#define NRF_SPIM1                   ((NRF_SPIM_Type*)          NRF_SPIM1_BASE)
++#define NRF_SPIS1                   ((NRF_SPIS_Type*)          NRF_SPIS1_BASE)
++#define NRF_TWI1                    ((NRF_TWI_Type*)           NRF_TWI1_BASE)
++#define NRF_TWIM1                   ((NRF_TWIM_Type*)          NRF_TWIM1_BASE)
++#define NRF_TWIS1                   ((NRF_TWIS_Type*)          NRF_TWIS1_BASE)
++#define NRF_NFCT                    ((NRF_NFCT_Type*)          NRF_NFCT_BASE)
++#define NRF_GPIOTE                  ((NRF_GPIOTE_Type*)        NRF_GPIOTE_BASE)
++#define NRF_SAADC                   ((NRF_SAADC_Type*)         NRF_SAADC_BASE)
++#define NRF_TIMER0                  ((NRF_TIMER_Type*)         NRF_TIMER0_BASE)
++#define NRF_TIMER1                  ((NRF_TIMER_Type*)         NRF_TIMER1_BASE)
++#define NRF_TIMER2                  ((NRF_TIMER_Type*)         NRF_TIMER2_BASE)
++#define NRF_RTC0                    ((NRF_RTC_Type*)           NRF_RTC0_BASE)
++#define NRF_TEMP                    ((NRF_TEMP_Type*)          NRF_TEMP_BASE)
++#define NRF_RNG                     ((NRF_RNG_Type*)           NRF_RNG_BASE)
++#define NRF_ECB                     ((NRF_ECB_Type*)           NRF_ECB_BASE)
++#define NRF_AAR                     ((NRF_AAR_Type*)           NRF_AAR_BASE)
++#define NRF_CCM                     ((NRF_CCM_Type*)           NRF_CCM_BASE)
++#define NRF_WDT                     ((NRF_WDT_Type*)           NRF_WDT_BASE)
++#define NRF_RTC1                    ((NRF_RTC_Type*)           NRF_RTC1_BASE)
++#define NRF_QDEC                    ((NRF_QDEC_Type*)          NRF_QDEC_BASE)
++#define NRF_COMP                    ((NRF_COMP_Type*)          NRF_COMP_BASE)
++#define NRF_LPCOMP                  ((NRF_LPCOMP_Type*)        NRF_LPCOMP_BASE)
++#define NRF_EGU0                    ((NRF_EGU_Type*)           NRF_EGU0_BASE)
++#define NRF_SWI0                    ((NRF_SWI_Type*)           NRF_SWI0_BASE)
++#define NRF_EGU1                    ((NRF_EGU_Type*)           NRF_EGU1_BASE)
++#define NRF_SWI1                    ((NRF_SWI_Type*)           NRF_SWI1_BASE)
++#define NRF_EGU2                    ((NRF_EGU_Type*)           NRF_EGU2_BASE)
++#define NRF_SWI2                    ((NRF_SWI_Type*)           NRF_SWI2_BASE)
++#define NRF_EGU3                    ((NRF_EGU_Type*)           NRF_EGU3_BASE)
++#define NRF_SWI3                    ((NRF_SWI_Type*)           NRF_SWI3_BASE)
++#define NRF_EGU4                    ((NRF_EGU_Type*)           NRF_EGU4_BASE)
++#define NRF_SWI4                    ((NRF_SWI_Type*)           NRF_SWI4_BASE)
++#define NRF_EGU5                    ((NRF_EGU_Type*)           NRF_EGU5_BASE)
++#define NRF_SWI5                    ((NRF_SWI_Type*)           NRF_SWI5_BASE)
++#define NRF_TIMER3                  ((NRF_TIMER_Type*)         NRF_TIMER3_BASE)
++#define NRF_TIMER4                  ((NRF_TIMER_Type*)         NRF_TIMER4_BASE)
++#define NRF_PWM0                    ((NRF_PWM_Type*)           NRF_PWM0_BASE)
++#define NRF_PDM                     ((NRF_PDM_Type*)           NRF_PDM_BASE)
++#define NRF_ACL                     ((NRF_ACL_Type*)           NRF_ACL_BASE)
++#define NRF_NVMC                    ((NRF_NVMC_Type*)          NRF_NVMC_BASE)
++#define NRF_PPI                     ((NRF_PPI_Type*)           NRF_PPI_BASE)
++#define NRF_MWU                     ((NRF_MWU_Type*)           NRF_MWU_BASE)
++#define NRF_PWM1                    ((NRF_PWM_Type*)           NRF_PWM1_BASE)
++#define NRF_PWM2                    ((NRF_PWM_Type*)           NRF_PWM2_BASE)
++#define NRF_SPI2                    ((NRF_SPI_Type*)           NRF_SPI2_BASE)
++#define NRF_SPIM2                   ((NRF_SPIM_Type*)          NRF_SPIM2_BASE)
++#define NRF_SPIS2                   ((NRF_SPIS_Type*)          NRF_SPIS2_BASE)
++#define NRF_RTC2                    ((NRF_RTC_Type*)           NRF_RTC2_BASE)
++#define NRF_I2S                     ((NRF_I2S_Type*)           NRF_I2S_BASE)
++#define NRF_FPU                     ((NRF_FPU_Type*)           NRF_FPU_BASE)
++#define NRF_USBD                    ((NRF_USBD_Type*)          NRF_USBD_BASE)
++#define NRF_UARTE1                  ((NRF_UARTE_Type*)         NRF_UARTE1_BASE)
++#define NRF_QSPI                    ((NRF_QSPI_Type*)          NRF_QSPI_BASE)
++#define NRF_CC_HOST_RGF             ((NRF_CC_HOST_RGF_Type*)   NRF_CC_HOST_RGF_BASE)
++#define NRF_CRYPTOCELL              ((NRF_CRYPTOCELL_Type*)    NRF_CRYPTOCELL_BASE)
++#define NRF_PWM3                    ((NRF_PWM_Type*)           NRF_PWM3_BASE)
++#define NRF_SPIM3                   ((NRF_SPIM_Type*)          NRF_SPIM3_BASE)
++
++/** @} */ /* End of group Device_Peripheral_declaration */
++
++
++/* =========================================  End of section using anonymous unions  ========================================= */
++#if defined (__CC_ARM)
++  #pragma pop
++#elif defined (__ICCARM__)
++  /* leave anonymous unions enabled */
++#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
++  #pragma clang diagnostic pop
++#elif defined (__GNUC__)
++  /* anonymous unions are enabled by default */
++#elif defined (__TMS470__)
++  /* anonymous unions are enabled by default */
++#elif defined (__TASKING__)
++  #pragma warning restore
++#elif defined (__CSMC__)
++  /* anonymous unions are enabled by default */
++#endif
++
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* NRF52840_H */
++
++
++/** @} */ /* End of group nrf52840 */
++
++/** @} */ /* End of group Nordic Semiconductor */
+diff --git a/projects/nrf52840_dk/nrf52840_bitfields.h b/projects/nrf52840_dk/nrf52840_bitfields.h
+new file mode 100644
+index 00000000..e4742bb3
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf52840_bitfields.h
+@@ -0,0 +1,17465 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#ifndef __NRF52840_BITS_H
++#define __NRF52840_BITS_H
++
++/*lint ++flb "Enter library region" */
++
++/* Peripheral: AAR */
++/* Description: Accelerated Address Resolver */
++
++/* Register: AAR_TASKS_START */
++/* Description: Start resolving addresses based on IRKs specified in the IRK data structure */
++
++/* Bit 0 : Start resolving addresses based on IRKs specified in the IRK data structure */
++#define AAR_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define AAR_TASKS_START_TASKS_START_Msk (0x1UL << AAR_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define AAR_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: AAR_TASKS_STOP */
++/* Description: Stop resolving addresses */
++
++/* Bit 0 : Stop resolving addresses */
++#define AAR_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define AAR_TASKS_STOP_TASKS_STOP_Msk (0x1UL << AAR_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define AAR_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: AAR_EVENTS_END */
++/* Description: Address resolution procedure complete */
++
++/* Bit 0 : Address resolution procedure complete */
++#define AAR_EVENTS_END_EVENTS_END_Pos (0UL) /*!< Position of EVENTS_END field. */
++#define AAR_EVENTS_END_EVENTS_END_Msk (0x1UL << AAR_EVENTS_END_EVENTS_END_Pos) /*!< Bit mask of EVENTS_END field. */
++#define AAR_EVENTS_END_EVENTS_END_NotGenerated (0UL) /*!< Event not generated */
++#define AAR_EVENTS_END_EVENTS_END_Generated (1UL) /*!< Event generated */
++
++/* Register: AAR_EVENTS_RESOLVED */
++/* Description: Address resolved */
++
++/* Bit 0 : Address resolved */
++#define AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_Pos (0UL) /*!< Position of EVENTS_RESOLVED field. */
++#define AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_Msk (0x1UL << AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_Pos) /*!< Bit mask of EVENTS_RESOLVED field. */
++#define AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_NotGenerated (0UL) /*!< Event not generated */
++#define AAR_EVENTS_RESOLVED_EVENTS_RESOLVED_Generated (1UL) /*!< Event generated */
++
++/* Register: AAR_EVENTS_NOTRESOLVED */
++/* Description: Address not resolved */
++
++/* Bit 0 : Address not resolved */
++#define AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_Pos (0UL) /*!< Position of EVENTS_NOTRESOLVED field. */
++#define AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_Msk (0x1UL << AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_Pos) /*!< Bit mask of EVENTS_NOTRESOLVED field. */
++#define AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_NotGenerated (0UL) /*!< Event not generated */
++#define AAR_EVENTS_NOTRESOLVED_EVENTS_NOTRESOLVED_Generated (1UL) /*!< Event generated */
++
++/* Register: AAR_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 2 : Write '1' to enable interrupt for event NOTRESOLVED */
++#define AAR_INTENSET_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
++#define AAR_INTENSET_NOTRESOLVED_Msk (0x1UL << AAR_INTENSET_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
++#define AAR_INTENSET_NOTRESOLVED_Disabled (0UL) /*!< Read: Disabled */
++#define AAR_INTENSET_NOTRESOLVED_Enabled (1UL) /*!< Read: Enabled */
++#define AAR_INTENSET_NOTRESOLVED_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event RESOLVED */
++#define AAR_INTENSET_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
++#define AAR_INTENSET_RESOLVED_Msk (0x1UL << AAR_INTENSET_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
++#define AAR_INTENSET_RESOLVED_Disabled (0UL) /*!< Read: Disabled */
++#define AAR_INTENSET_RESOLVED_Enabled (1UL) /*!< Read: Enabled */
++#define AAR_INTENSET_RESOLVED_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event END */
++#define AAR_INTENSET_END_Pos (0UL) /*!< Position of END field. */
++#define AAR_INTENSET_END_Msk (0x1UL << AAR_INTENSET_END_Pos) /*!< Bit mask of END field. */
++#define AAR_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
++#define AAR_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
++#define AAR_INTENSET_END_Set (1UL) /*!< Enable */
++
++/* Register: AAR_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 2 : Write '1' to disable interrupt for event NOTRESOLVED */
++#define AAR_INTENCLR_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
++#define AAR_INTENCLR_NOTRESOLVED_Msk (0x1UL << AAR_INTENCLR_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
++#define AAR_INTENCLR_NOTRESOLVED_Disabled (0UL) /*!< Read: Disabled */
++#define AAR_INTENCLR_NOTRESOLVED_Enabled (1UL) /*!< Read: Enabled */
++#define AAR_INTENCLR_NOTRESOLVED_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event RESOLVED */
++#define AAR_INTENCLR_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
++#define AAR_INTENCLR_RESOLVED_Msk (0x1UL << AAR_INTENCLR_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
++#define AAR_INTENCLR_RESOLVED_Disabled (0UL) /*!< Read: Disabled */
++#define AAR_INTENCLR_RESOLVED_Enabled (1UL) /*!< Read: Enabled */
++#define AAR_INTENCLR_RESOLVED_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event END */
++#define AAR_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
++#define AAR_INTENCLR_END_Msk (0x1UL << AAR_INTENCLR_END_Pos) /*!< Bit mask of END field. */
++#define AAR_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
++#define AAR_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
++#define AAR_INTENCLR_END_Clear (1UL) /*!< Disable */
++
++/* Register: AAR_STATUS */
++/* Description: Resolution status */
++
++/* Bits 3..0 : The IRK that was used last time an address was resolved */
++#define AAR_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
++#define AAR_STATUS_STATUS_Msk (0xFUL << AAR_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
++
++/* Register: AAR_ENABLE */
++/* Description: Enable AAR */
++
++/* Bits 1..0 : Enable or disable AAR */
++#define AAR_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define AAR_ENABLE_ENABLE_Msk (0x3UL << AAR_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define AAR_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
++#define AAR_ENABLE_ENABLE_Enabled (3UL) /*!< Enable */
++
++/* Register: AAR_NIRK */
++/* Description: Number of IRKs */
++
++/* Bits 4..0 : Number of Identity Root Keys available in the IRK data structure */
++#define AAR_NIRK_NIRK_Pos (0UL) /*!< Position of NIRK field. */
++#define AAR_NIRK_NIRK_Msk (0x1FUL << AAR_NIRK_NIRK_Pos) /*!< Bit mask of NIRK field. */
++
++/* Register: AAR_IRKPTR */
++/* Description: Pointer to IRK data structure */
++
++/* Bits 31..0 : Pointer to the IRK data structure */
++#define AAR_IRKPTR_IRKPTR_Pos (0UL) /*!< Position of IRKPTR field. */
++#define AAR_IRKPTR_IRKPTR_Msk (0xFFFFFFFFUL << AAR_IRKPTR_IRKPTR_Pos) /*!< Bit mask of IRKPTR field. */
++
++/* Register: AAR_ADDRPTR */
++/* Description: Pointer to the resolvable address */
++
++/* Bits 31..0 : Pointer to the resolvable address (6-bytes) */
++#define AAR_ADDRPTR_ADDRPTR_Pos (0UL) /*!< Position of ADDRPTR field. */
++#define AAR_ADDRPTR_ADDRPTR_Msk (0xFFFFFFFFUL << AAR_ADDRPTR_ADDRPTR_Pos) /*!< Bit mask of ADDRPTR field. */
++
++/* Register: AAR_SCRATCHPTR */
++/* Description: Pointer to data area used for temporary storage */
++
++/* Bits 31..0 : Pointer to a scratch data area used for temporary storage during resolution. A space of minimum 3 bytes must be reserved. */
++#define AAR_SCRATCHPTR_SCRATCHPTR_Pos (0UL) /*!< Position of SCRATCHPTR field. */
++#define AAR_SCRATCHPTR_SCRATCHPTR_Msk (0xFFFFFFFFUL << AAR_SCRATCHPTR_SCRATCHPTR_Pos) /*!< Bit mask of SCRATCHPTR field. */
++
++
++/* Peripheral: ACL */
++/* Description: Access control lists */
++
++/* Register: ACL_ACL_ADDR */
++/* Description: Description cluster: Start address of region to protect. The start address must be word-aligned. */
++
++/* Bits 31..0 : Start address of flash region n. The start address must point to a flash page boundary. */
++#define ACL_ACL_ADDR_ADDR_Pos (0UL) /*!< Position of ADDR field. */
++#define ACL_ACL_ADDR_ADDR_Msk (0xFFFFFFFFUL << ACL_ACL_ADDR_ADDR_Pos) /*!< Bit mask of ADDR field. */
++
++/* Register: ACL_ACL_SIZE */
++/* Description: Description cluster: Size of region to protect counting from address ACL[n].ADDR. Write '0' as no effect. */
++
++/* Bits 31..0 : Size of flash region n in bytes. Must be a multiple of the flash page size. */
++#define ACL_ACL_SIZE_SIZE_Pos (0UL) /*!< Position of SIZE field. */
++#define ACL_ACL_SIZE_SIZE_Msk (0xFFFFFFFFUL << ACL_ACL_SIZE_SIZE_Pos) /*!< Bit mask of SIZE field. */
++
++/* Register: ACL_ACL_PERM */
++/* Description: Description cluster: Access permissions for region n as defined by start address ACL[n].ADDR and size ACL[n].SIZE */
++
++/* Bit 2 : Configure read permissions for region n. Write '0' has no effect. */
++#define ACL_ACL_PERM_READ_Pos (2UL) /*!< Position of READ field. */
++#define ACL_ACL_PERM_READ_Msk (0x1UL << ACL_ACL_PERM_READ_Pos) /*!< Bit mask of READ field. */
++#define ACL_ACL_PERM_READ_Enable (0UL) /*!< Allow read instructions to region n */
++#define ACL_ACL_PERM_READ_Disable (1UL) /*!< Block read instructions to region n */
++
++/* Bit 1 : Configure write and erase permissions for region n. Write '0' has no effect. */
++#define ACL_ACL_PERM_WRITE_Pos (1UL) /*!< Position of WRITE field. */
++#define ACL_ACL_PERM_WRITE_Msk (0x1UL << ACL_ACL_PERM_WRITE_Pos) /*!< Bit mask of WRITE field. */
++#define ACL_ACL_PERM_WRITE_Enable (0UL) /*!< Allow write and erase instructions to region n */
++#define ACL_ACL_PERM_WRITE_Disable (1UL) /*!< Block write and erase instructions to region n */
++
++
++/* Peripheral: APPROTECT */
++/* Description: Access Port Protection */
++
++/* Register: APPROTECT_FORCEPROTECT */
++/* Description: Software force enable APPROTECT mechanism until next reset. */
++
++/* Bits 7..0 : Write 0x0 to force enable APPROTECT mechanism */
++#define APPROTECT_FORCEPROTECT_FORCEPROTECT_Pos (0UL) /*!< Position of FORCEPROTECT field. */
++#define APPROTECT_FORCEPROTECT_FORCEPROTECT_Msk (0xFFUL << APPROTECT_FORCEPROTECT_FORCEPROTECT_Pos) /*!< Bit mask of FORCEPROTECT field. */
++#define APPROTECT_FORCEPROTECT_FORCEPROTECT_Force (0x0UL) /*!< Software force enable APPROTECT mechanism */
++
++/* Register: APPROTECT_DISABLE */
++/* Description: Software disable APPROTECT mechanism */
++
++/* Bits 7..0 : Software disable APPROTECT mechanism */
++#define APPROTECT_DISABLE_DISABLE_Pos (0UL) /*!< Position of DISABLE field. */
++#define APPROTECT_DISABLE_DISABLE_Msk (0xFFUL << APPROTECT_DISABLE_DISABLE_Pos) /*!< Bit mask of DISABLE field. */
++#define APPROTECT_DISABLE_DISABLE_SwDisable (0x5AUL) /*!< Software disable APPROTECT mechanism */
++
++
++/* Peripheral: CCM */
++/* Description: AES CCM Mode Encryption */
++
++/* Register: CCM_TASKS_KSGEN */
++/* Description: Start generation of keystream. This operation will stop by itself when completed. */
++
++/* Bit 0 : Start generation of keystream. This operation will stop by itself when completed. */
++#define CCM_TASKS_KSGEN_TASKS_KSGEN_Pos (0UL) /*!< Position of TASKS_KSGEN field. */
++#define CCM_TASKS_KSGEN_TASKS_KSGEN_Msk (0x1UL << CCM_TASKS_KSGEN_TASKS_KSGEN_Pos) /*!< Bit mask of TASKS_KSGEN field. */
++#define CCM_TASKS_KSGEN_TASKS_KSGEN_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CCM_TASKS_CRYPT */
++/* Description: Start encryption/decryption. This operation will stop by itself when completed. */
++
++/* Bit 0 : Start encryption/decryption. This operation will stop by itself when completed. */
++#define CCM_TASKS_CRYPT_TASKS_CRYPT_Pos (0UL) /*!< Position of TASKS_CRYPT field. */
++#define CCM_TASKS_CRYPT_TASKS_CRYPT_Msk (0x1UL << CCM_TASKS_CRYPT_TASKS_CRYPT_Pos) /*!< Bit mask of TASKS_CRYPT field. */
++#define CCM_TASKS_CRYPT_TASKS_CRYPT_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CCM_TASKS_STOP */
++/* Description: Stop encryption/decryption */
++
++/* Bit 0 : Stop encryption/decryption */
++#define CCM_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define CCM_TASKS_STOP_TASKS_STOP_Msk (0x1UL << CCM_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define CCM_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CCM_TASKS_RATEOVERRIDE */
++/* Description: Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption */
++
++/* Bit 0 : Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption */
++#define CCM_TASKS_RATEOVERRIDE_TASKS_RATEOVERRIDE_Pos (0UL) /*!< Position of TASKS_RATEOVERRIDE field. */
++#define CCM_TASKS_RATEOVERRIDE_TASKS_RATEOVERRIDE_Msk (0x1UL << CCM_TASKS_RATEOVERRIDE_TASKS_RATEOVERRIDE_Pos) /*!< Bit mask of TASKS_RATEOVERRIDE field. */
++#define CCM_TASKS_RATEOVERRIDE_TASKS_RATEOVERRIDE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CCM_EVENTS_ENDKSGEN */
++/* Description: Keystream generation complete */
++
++/* Bit 0 : Keystream generation complete */
++#define CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_Pos (0UL) /*!< Position of EVENTS_ENDKSGEN field. */
++#define CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_Msk (0x1UL << CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_Pos) /*!< Bit mask of EVENTS_ENDKSGEN field. */
++#define CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_NotGenerated (0UL) /*!< Event not generated */
++#define CCM_EVENTS_ENDKSGEN_EVENTS_ENDKSGEN_Generated (1UL) /*!< Event generated */
++
++/* Register: CCM_EVENTS_ENDCRYPT */
++/* Description: Encrypt/decrypt complete */
++
++/* Bit 0 : Encrypt/decrypt complete */
++#define CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_Pos (0UL) /*!< Position of EVENTS_ENDCRYPT field. */
++#define CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_Msk (0x1UL << CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_Pos) /*!< Bit mask of EVENTS_ENDCRYPT field. */
++#define CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_NotGenerated (0UL) /*!< Event not generated */
++#define CCM_EVENTS_ENDCRYPT_EVENTS_ENDCRYPT_Generated (1UL) /*!< Event generated */
++
++/* Register: CCM_EVENTS_ERROR */
++/* Description: Deprecated register - CCM error event */
++
++/* Bit 0 : Deprecated field -  CCM error event */
++#define CCM_EVENTS_ERROR_EVENTS_ERROR_Pos (0UL) /*!< Position of EVENTS_ERROR field. */
++#define CCM_EVENTS_ERROR_EVENTS_ERROR_Msk (0x1UL << CCM_EVENTS_ERROR_EVENTS_ERROR_Pos) /*!< Bit mask of EVENTS_ERROR field. */
++#define CCM_EVENTS_ERROR_EVENTS_ERROR_NotGenerated (0UL) /*!< Event not generated */
++#define CCM_EVENTS_ERROR_EVENTS_ERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: CCM_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 0 : Shortcut between event ENDKSGEN and task CRYPT */
++#define CCM_SHORTS_ENDKSGEN_CRYPT_Pos (0UL) /*!< Position of ENDKSGEN_CRYPT field. */
++#define CCM_SHORTS_ENDKSGEN_CRYPT_Msk (0x1UL << CCM_SHORTS_ENDKSGEN_CRYPT_Pos) /*!< Bit mask of ENDKSGEN_CRYPT field. */
++#define CCM_SHORTS_ENDKSGEN_CRYPT_Disabled (0UL) /*!< Disable shortcut */
++#define CCM_SHORTS_ENDKSGEN_CRYPT_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: CCM_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 2 : Deprecated intsetfield -  Write '1' to enable interrupt for event ERROR */
++#define CCM_INTENSET_ERROR_Pos (2UL) /*!< Position of ERROR field. */
++#define CCM_INTENSET_ERROR_Msk (0x1UL << CCM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define CCM_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define CCM_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define CCM_INTENSET_ERROR_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event ENDCRYPT */
++#define CCM_INTENSET_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
++#define CCM_INTENSET_ENDCRYPT_Msk (0x1UL << CCM_INTENSET_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
++#define CCM_INTENSET_ENDCRYPT_Disabled (0UL) /*!< Read: Disabled */
++#define CCM_INTENSET_ENDCRYPT_Enabled (1UL) /*!< Read: Enabled */
++#define CCM_INTENSET_ENDCRYPT_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event ENDKSGEN */
++#define CCM_INTENSET_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
++#define CCM_INTENSET_ENDKSGEN_Msk (0x1UL << CCM_INTENSET_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
++#define CCM_INTENSET_ENDKSGEN_Disabled (0UL) /*!< Read: Disabled */
++#define CCM_INTENSET_ENDKSGEN_Enabled (1UL) /*!< Read: Enabled */
++#define CCM_INTENSET_ENDKSGEN_Set (1UL) /*!< Enable */
++
++/* Register: CCM_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 2 : Deprecated intclrfield -  Write '1' to disable interrupt for event ERROR */
++#define CCM_INTENCLR_ERROR_Pos (2UL) /*!< Position of ERROR field. */
++#define CCM_INTENCLR_ERROR_Msk (0x1UL << CCM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define CCM_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define CCM_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define CCM_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event ENDCRYPT */
++#define CCM_INTENCLR_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
++#define CCM_INTENCLR_ENDCRYPT_Msk (0x1UL << CCM_INTENCLR_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
++#define CCM_INTENCLR_ENDCRYPT_Disabled (0UL) /*!< Read: Disabled */
++#define CCM_INTENCLR_ENDCRYPT_Enabled (1UL) /*!< Read: Enabled */
++#define CCM_INTENCLR_ENDCRYPT_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event ENDKSGEN */
++#define CCM_INTENCLR_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
++#define CCM_INTENCLR_ENDKSGEN_Msk (0x1UL << CCM_INTENCLR_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
++#define CCM_INTENCLR_ENDKSGEN_Disabled (0UL) /*!< Read: Disabled */
++#define CCM_INTENCLR_ENDKSGEN_Enabled (1UL) /*!< Read: Enabled */
++#define CCM_INTENCLR_ENDKSGEN_Clear (1UL) /*!< Disable */
++
++/* Register: CCM_MICSTATUS */
++/* Description: MIC check result */
++
++/* Bit 0 : The result of the MIC check performed during the previous decryption operation */
++#define CCM_MICSTATUS_MICSTATUS_Pos (0UL) /*!< Position of MICSTATUS field. */
++#define CCM_MICSTATUS_MICSTATUS_Msk (0x1UL << CCM_MICSTATUS_MICSTATUS_Pos) /*!< Bit mask of MICSTATUS field. */
++#define CCM_MICSTATUS_MICSTATUS_CheckFailed (0UL) /*!< MIC check failed */
++#define CCM_MICSTATUS_MICSTATUS_CheckPassed (1UL) /*!< MIC check passed */
++
++/* Register: CCM_ENABLE */
++/* Description: Enable */
++
++/* Bits 1..0 : Enable or disable CCM */
++#define CCM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define CCM_ENABLE_ENABLE_Msk (0x3UL << CCM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define CCM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
++#define CCM_ENABLE_ENABLE_Enabled (2UL) /*!< Enable */
++
++/* Register: CCM_MODE */
++/* Description: Operation mode */
++
++/* Bit 24 : Packet length configuration */
++#define CCM_MODE_LENGTH_Pos (24UL) /*!< Position of LENGTH field. */
++#define CCM_MODE_LENGTH_Msk (0x1UL << CCM_MODE_LENGTH_Pos) /*!< Bit mask of LENGTH field. */
++#define CCM_MODE_LENGTH_Default (0UL) /*!< Default length. Effective length of LENGTH field in encrypted/decrypted packet is 5 bits. A keystream for packet payloads up to 27 bytes will be generated. */
++#define CCM_MODE_LENGTH_Extended (1UL) /*!< Extended length. Effective length of LENGTH field in encrypted/decrypted packet is 8 bits. A keystream for packet payloads up to MAXPACKETSIZE bytes will be generated. */
++
++/* Bits 17..16 : Radio data rate that the CCM shall run synchronous with */
++#define CCM_MODE_DATARATE_Pos (16UL) /*!< Position of DATARATE field. */
++#define CCM_MODE_DATARATE_Msk (0x3UL << CCM_MODE_DATARATE_Pos) /*!< Bit mask of DATARATE field. */
++#define CCM_MODE_DATARATE_1Mbit (0UL) /*!< 1 Mbps */
++#define CCM_MODE_DATARATE_2Mbit (1UL) /*!< 2 Mbps */
++#define CCM_MODE_DATARATE_125Kbps (2UL) /*!< 125 Kbps */
++#define CCM_MODE_DATARATE_500Kbps (3UL) /*!< 500 Kbps */
++
++/* Bit 0 : The mode of operation to be used. The settings in this register apply whenever either the KSGEN or CRYPT tasks are triggered. */
++#define CCM_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
++#define CCM_MODE_MODE_Msk (0x1UL << CCM_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
++#define CCM_MODE_MODE_Encryption (0UL) /*!< AES CCM packet encryption mode */
++#define CCM_MODE_MODE_Decryption (1UL) /*!< AES CCM packet decryption mode */
++
++/* Register: CCM_CNFPTR */
++/* Description: Pointer to data structure holding AES key and NONCE vector */
++
++/* Bits 31..0 : Pointer to the data structure holding the AES key and the CCM NONCE vector (see Table 1 CCM data structure overview) */
++#define CCM_CNFPTR_CNFPTR_Pos (0UL) /*!< Position of CNFPTR field. */
++#define CCM_CNFPTR_CNFPTR_Msk (0xFFFFFFFFUL << CCM_CNFPTR_CNFPTR_Pos) /*!< Bit mask of CNFPTR field. */
++
++/* Register: CCM_INPTR */
++/* Description: Input pointer */
++
++/* Bits 31..0 : Input pointer */
++#define CCM_INPTR_INPTR_Pos (0UL) /*!< Position of INPTR field. */
++#define CCM_INPTR_INPTR_Msk (0xFFFFFFFFUL << CCM_INPTR_INPTR_Pos) /*!< Bit mask of INPTR field. */
++
++/* Register: CCM_OUTPTR */
++/* Description: Output pointer */
++
++/* Bits 31..0 : Output pointer */
++#define CCM_OUTPTR_OUTPTR_Pos (0UL) /*!< Position of OUTPTR field. */
++#define CCM_OUTPTR_OUTPTR_Msk (0xFFFFFFFFUL << CCM_OUTPTR_OUTPTR_Pos) /*!< Bit mask of OUTPTR field. */
++
++/* Register: CCM_SCRATCHPTR */
++/* Description: Pointer to data area used for temporary storage */
++
++/* Bits 31..0 : Pointer to a scratch data area used for temporary storage during keystream generation,
++        MIC generation and encryption/decryption. */
++#define CCM_SCRATCHPTR_SCRATCHPTR_Pos (0UL) /*!< Position of SCRATCHPTR field. */
++#define CCM_SCRATCHPTR_SCRATCHPTR_Msk (0xFFFFFFFFUL << CCM_SCRATCHPTR_SCRATCHPTR_Pos) /*!< Bit mask of SCRATCHPTR field. */
++
++/* Register: CCM_MAXPACKETSIZE */
++/* Description: Length of keystream generated when MODE.LENGTH = Extended. */
++
++/* Bits 7..0 : Length of keystream generated when MODE.LENGTH = Extended. This value must be greater or equal to the subsequent packet payload to be encrypted/decrypted. */
++#define CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos (0UL) /*!< Position of MAXPACKETSIZE field. */
++#define CCM_MAXPACKETSIZE_MAXPACKETSIZE_Msk (0xFFUL << CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos) /*!< Bit mask of MAXPACKETSIZE field. */
++
++/* Register: CCM_RATEOVERRIDE */
++/* Description: Data rate override setting. */
++
++/* Bits 1..0 : Data rate override setting. */
++#define CCM_RATEOVERRIDE_RATEOVERRIDE_Pos (0UL) /*!< Position of RATEOVERRIDE field. */
++#define CCM_RATEOVERRIDE_RATEOVERRIDE_Msk (0x3UL << CCM_RATEOVERRIDE_RATEOVERRIDE_Pos) /*!< Bit mask of RATEOVERRIDE field. */
++#define CCM_RATEOVERRIDE_RATEOVERRIDE_1Mbit (0UL) /*!< 1 Mbps */
++#define CCM_RATEOVERRIDE_RATEOVERRIDE_2Mbit (1UL) /*!< 2 Mbps */
++#define CCM_RATEOVERRIDE_RATEOVERRIDE_125Kbps (2UL) /*!< 125 Kbps */
++#define CCM_RATEOVERRIDE_RATEOVERRIDE_500Kbps (3UL) /*!< 500 Kbps */
++
++
++/* Peripheral: CC_HOST_RGF */
++/* Description: CRYPTOCELL HOST_RGF interface */
++
++/* Register: CC_HOST_RGF_HOST_CRYPTOKEY_SEL */
++/* Description: AES hardware key select */
++
++/* Bits 1..0 : Select the source of the HW key that is used by the AES engine */
++#define CC_HOST_RGF_HOST_CRYPTOKEY_SEL_HOST_CRYPTOKEY_SEL_Pos (0UL) /*!< Position of HOST_CRYPTOKEY_SEL field. */
++#define CC_HOST_RGF_HOST_CRYPTOKEY_SEL_HOST_CRYPTOKEY_SEL_Msk (0x3UL << CC_HOST_RGF_HOST_CRYPTOKEY_SEL_HOST_CRYPTOKEY_SEL_Pos) /*!< Bit mask of HOST_CRYPTOKEY_SEL field. */
++#define CC_HOST_RGF_HOST_CRYPTOKEY_SEL_HOST_CRYPTOKEY_SEL_K_DR (0UL) /*!< Use device root key K_DR from CRYPTOCELL AO power domain */
++#define CC_HOST_RGF_HOST_CRYPTOKEY_SEL_HOST_CRYPTOKEY_SEL_K_PRTL (1UL) /*!< Use hard-coded RTL key K_PRTL */
++#define CC_HOST_RGF_HOST_CRYPTOKEY_SEL_HOST_CRYPTOKEY_SEL_Session (2UL) /*!< Use provided session key */
++
++/* Register: CC_HOST_RGF_HOST_IOT_KPRTL_LOCK */
++/* Description: This write-once register is the K_PRTL lock register. When this register is set, K_PRTL cannot be used and a zeroed key will be used instead. The value of this register is saved in the CRYPTOCELL AO power domain. */
++
++/* Bit 0 : This register is the K_PRTL lock register. When this register is set, K_PRTL cannot be used and a zeroed key will be used instead. The value of this register is saved in the CRYPTOCELL AO power domain. */
++#define CC_HOST_RGF_HOST_IOT_KPRTL_LOCK_HOST_IOT_KPRTL_LOCK_Pos (0UL) /*!< Position of HOST_IOT_KPRTL_LOCK field. */
++#define CC_HOST_RGF_HOST_IOT_KPRTL_LOCK_HOST_IOT_KPRTL_LOCK_Msk (0x1UL << CC_HOST_RGF_HOST_IOT_KPRTL_LOCK_HOST_IOT_KPRTL_LOCK_Pos) /*!< Bit mask of HOST_IOT_KPRTL_LOCK field. */
++#define CC_HOST_RGF_HOST_IOT_KPRTL_LOCK_HOST_IOT_KPRTL_LOCK_Disabled (0UL) /*!< K_PRTL can be selected for use from register HOST_CRYPTOKEY_SEL */
++#define CC_HOST_RGF_HOST_IOT_KPRTL_LOCK_HOST_IOT_KPRTL_LOCK_Enabled (1UL) /*!< K_PRTL has been locked until next power-on reset (POR). If K_PRTL is selected anyway, a zeroed key will be used instead. */
++
++/* Register: CC_HOST_RGF_HOST_IOT_KDR0 */
++/* Description: This register holds bits 31:0 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain. Reading from this address returns the K_DR valid status indicating if K_DR is successfully retained. */
++
++/* Bits 31..0 : Write: K_DR bits 31:0. Read: 0x00000000 when 128-bit K_DR key value is not yet retained in the CRYPTOCELL AO power domain. Read: 0x00000001 when 128-bit K_DR key value is successfully retained in the CRYPTOCELL AO power domain. */
++#define CC_HOST_RGF_HOST_IOT_KDR0_HOST_IOT_KDR0_Pos (0UL) /*!< Position of HOST_IOT_KDR0 field. */
++#define CC_HOST_RGF_HOST_IOT_KDR0_HOST_IOT_KDR0_Msk (0xFFFFFFFFUL << CC_HOST_RGF_HOST_IOT_KDR0_HOST_IOT_KDR0_Pos) /*!< Bit mask of HOST_IOT_KDR0 field. */
++
++/* Register: CC_HOST_RGF_HOST_IOT_KDR1 */
++/* Description: This register holds bits 63:32 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain. */
++
++/* Bits 31..0 : K_DR bits 63:32 */
++#define CC_HOST_RGF_HOST_IOT_KDR1_HOST_IOT_KDR1_Pos (0UL) /*!< Position of HOST_IOT_KDR1 field. */
++#define CC_HOST_RGF_HOST_IOT_KDR1_HOST_IOT_KDR1_Msk (0xFFFFFFFFUL << CC_HOST_RGF_HOST_IOT_KDR1_HOST_IOT_KDR1_Pos) /*!< Bit mask of HOST_IOT_KDR1 field. */
++
++/* Register: CC_HOST_RGF_HOST_IOT_KDR2 */
++/* Description: This register holds bits 95:64 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain. */
++
++/* Bits 31..0 : K_DR bits 95:64 */
++#define CC_HOST_RGF_HOST_IOT_KDR2_HOST_IOT_KDR2_Pos (0UL) /*!< Position of HOST_IOT_KDR2 field. */
++#define CC_HOST_RGF_HOST_IOT_KDR2_HOST_IOT_KDR2_Msk (0xFFFFFFFFUL << CC_HOST_RGF_HOST_IOT_KDR2_HOST_IOT_KDR2_Pos) /*!< Bit mask of HOST_IOT_KDR2 field. */
++
++/* Register: CC_HOST_RGF_HOST_IOT_KDR3 */
++/* Description: This register holds bits 127:96 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain. */
++
++/* Bits 31..0 : K_DR bits 127:96 */
++#define CC_HOST_RGF_HOST_IOT_KDR3_HOST_IOT_KDR3_Pos (0UL) /*!< Position of HOST_IOT_KDR3 field. */
++#define CC_HOST_RGF_HOST_IOT_KDR3_HOST_IOT_KDR3_Msk (0xFFFFFFFFUL << CC_HOST_RGF_HOST_IOT_KDR3_HOST_IOT_KDR3_Pos) /*!< Bit mask of HOST_IOT_KDR3 field. */
++
++/* Register: CC_HOST_RGF_HOST_IOT_LCS */
++/* Description: Controls lifecycle state (LCS) for CRYPTOCELL subsystem */
++
++/* Bit 8 : Read-only field. Indicates if CRYPTOCELL LCS has been successfully configured since last reset. */
++#define CC_HOST_RGF_HOST_IOT_LCS_LCS_IS_VALID_Pos (8UL) /*!< Position of LCS_IS_VALID field. */
++#define CC_HOST_RGF_HOST_IOT_LCS_LCS_IS_VALID_Msk (0x1UL << CC_HOST_RGF_HOST_IOT_LCS_LCS_IS_VALID_Pos) /*!< Bit mask of LCS_IS_VALID field. */
++#define CC_HOST_RGF_HOST_IOT_LCS_LCS_IS_VALID_Invalid (0UL) /*!< Valid LCS not yet retained in the CRYPTOCELL AO power domain */
++#define CC_HOST_RGF_HOST_IOT_LCS_LCS_IS_VALID_Valid (1UL) /*!< Valid LCS successfully retained in the CRYPTOCELL AO power domain */
++
++/* Bits 2..0 : Lifecycle state value. This field is write-once per reset. */
++#define CC_HOST_RGF_HOST_IOT_LCS_LCS_Pos (0UL) /*!< Position of LCS field. */
++#define CC_HOST_RGF_HOST_IOT_LCS_LCS_Msk (0x7UL << CC_HOST_RGF_HOST_IOT_LCS_LCS_Pos) /*!< Bit mask of LCS field. */
++#define CC_HOST_RGF_HOST_IOT_LCS_LCS_Debug (0UL) /*!< CC310 operates in debug mode */
++#define CC_HOST_RGF_HOST_IOT_LCS_LCS_Secure (2UL) /*!< CC310 operates in secure mode */
++
++
++/* Peripheral: CLOCK */
++/* Description: Clock control */
++
++/* Register: CLOCK_TASKS_HFCLKSTART */
++/* Description: Start HFXO crystal oscillator */
++
++/* Bit 0 : Start HFXO crystal oscillator */
++#define CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Pos (0UL) /*!< Position of TASKS_HFCLKSTART field. */
++#define CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Msk (0x1UL << CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Pos) /*!< Bit mask of TASKS_HFCLKSTART field. */
++#define CLOCK_TASKS_HFCLKSTART_TASKS_HFCLKSTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CLOCK_TASKS_HFCLKSTOP */
++/* Description: Stop HFXO crystal oscillator */
++
++/* Bit 0 : Stop HFXO crystal oscillator */
++#define CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Pos (0UL) /*!< Position of TASKS_HFCLKSTOP field. */
++#define CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Msk (0x1UL << CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Pos) /*!< Bit mask of TASKS_HFCLKSTOP field. */
++#define CLOCK_TASKS_HFCLKSTOP_TASKS_HFCLKSTOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CLOCK_TASKS_LFCLKSTART */
++/* Description: Start LFCLK */
++
++/* Bit 0 : Start LFCLK */
++#define CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Pos (0UL) /*!< Position of TASKS_LFCLKSTART field. */
++#define CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Msk (0x1UL << CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Pos) /*!< Bit mask of TASKS_LFCLKSTART field. */
++#define CLOCK_TASKS_LFCLKSTART_TASKS_LFCLKSTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CLOCK_TASKS_LFCLKSTOP */
++/* Description: Stop LFCLK */
++
++/* Bit 0 : Stop LFCLK */
++#define CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Pos (0UL) /*!< Position of TASKS_LFCLKSTOP field. */
++#define CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Msk (0x1UL << CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Pos) /*!< Bit mask of TASKS_LFCLKSTOP field. */
++#define CLOCK_TASKS_LFCLKSTOP_TASKS_LFCLKSTOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CLOCK_TASKS_CAL */
++/* Description: Start calibration of LFRC */
++
++/* Bit 0 : Start calibration of LFRC */
++#define CLOCK_TASKS_CAL_TASKS_CAL_Pos (0UL) /*!< Position of TASKS_CAL field. */
++#define CLOCK_TASKS_CAL_TASKS_CAL_Msk (0x1UL << CLOCK_TASKS_CAL_TASKS_CAL_Pos) /*!< Bit mask of TASKS_CAL field. */
++#define CLOCK_TASKS_CAL_TASKS_CAL_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CLOCK_TASKS_CTSTART */
++/* Description: Start calibration timer */
++
++/* Bit 0 : Start calibration timer */
++#define CLOCK_TASKS_CTSTART_TASKS_CTSTART_Pos (0UL) /*!< Position of TASKS_CTSTART field. */
++#define CLOCK_TASKS_CTSTART_TASKS_CTSTART_Msk (0x1UL << CLOCK_TASKS_CTSTART_TASKS_CTSTART_Pos) /*!< Bit mask of TASKS_CTSTART field. */
++#define CLOCK_TASKS_CTSTART_TASKS_CTSTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CLOCK_TASKS_CTSTOP */
++/* Description: Stop calibration timer */
++
++/* Bit 0 : Stop calibration timer */
++#define CLOCK_TASKS_CTSTOP_TASKS_CTSTOP_Pos (0UL) /*!< Position of TASKS_CTSTOP field. */
++#define CLOCK_TASKS_CTSTOP_TASKS_CTSTOP_Msk (0x1UL << CLOCK_TASKS_CTSTOP_TASKS_CTSTOP_Pos) /*!< Bit mask of TASKS_CTSTOP field. */
++#define CLOCK_TASKS_CTSTOP_TASKS_CTSTOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: CLOCK_EVENTS_HFCLKSTARTED */
++/* Description: HFXO crystal oscillator started */
++
++/* Bit 0 : HFXO crystal oscillator started */
++#define CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Pos (0UL) /*!< Position of EVENTS_HFCLKSTARTED field. */
++#define CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Msk (0x1UL << CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Pos) /*!< Bit mask of EVENTS_HFCLKSTARTED field. */
++#define CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define CLOCK_EVENTS_HFCLKSTARTED_EVENTS_HFCLKSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: CLOCK_EVENTS_LFCLKSTARTED */
++/* Description: LFCLK started */
++
++/* Bit 0 : LFCLK started */
++#define CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Pos (0UL) /*!< Position of EVENTS_LFCLKSTARTED field. */
++#define CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Msk (0x1UL << CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Pos) /*!< Bit mask of EVENTS_LFCLKSTARTED field. */
++#define CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define CLOCK_EVENTS_LFCLKSTARTED_EVENTS_LFCLKSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: CLOCK_EVENTS_DONE */
++/* Description: Calibration of LFRC completed */
++
++/* Bit 0 : Calibration of LFRC completed */
++#define CLOCK_EVENTS_DONE_EVENTS_DONE_Pos (0UL) /*!< Position of EVENTS_DONE field. */
++#define CLOCK_EVENTS_DONE_EVENTS_DONE_Msk (0x1UL << CLOCK_EVENTS_DONE_EVENTS_DONE_Pos) /*!< Bit mask of EVENTS_DONE field. */
++#define CLOCK_EVENTS_DONE_EVENTS_DONE_NotGenerated (0UL) /*!< Event not generated */
++#define CLOCK_EVENTS_DONE_EVENTS_DONE_Generated (1UL) /*!< Event generated */
++
++/* Register: CLOCK_EVENTS_CTTO */
++/* Description: Calibration timer timeout */
++
++/* Bit 0 : Calibration timer timeout */
++#define CLOCK_EVENTS_CTTO_EVENTS_CTTO_Pos (0UL) /*!< Position of EVENTS_CTTO field. */
++#define CLOCK_EVENTS_CTTO_EVENTS_CTTO_Msk (0x1UL << CLOCK_EVENTS_CTTO_EVENTS_CTTO_Pos) /*!< Bit mask of EVENTS_CTTO field. */
++#define CLOCK_EVENTS_CTTO_EVENTS_CTTO_NotGenerated (0UL) /*!< Event not generated */
++#define CLOCK_EVENTS_CTTO_EVENTS_CTTO_Generated (1UL) /*!< Event generated */
++
++/* Register: CLOCK_EVENTS_CTSTARTED */
++/* Description: Calibration timer has been started and is ready to process new tasks */
++
++/* Bit 0 : Calibration timer has been started and is ready to process new tasks */
++#define CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_Pos (0UL) /*!< Position of EVENTS_CTSTARTED field. */
++#define CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_Msk (0x1UL << CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_Pos) /*!< Bit mask of EVENTS_CTSTARTED field. */
++#define CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define CLOCK_EVENTS_CTSTARTED_EVENTS_CTSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: CLOCK_EVENTS_CTSTOPPED */
++/* Description: Calibration timer has been stopped and is ready to process new tasks */
++
++/* Bit 0 : Calibration timer has been stopped and is ready to process new tasks */
++#define CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_Pos (0UL) /*!< Position of EVENTS_CTSTOPPED field. */
++#define CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_Msk (0x1UL << CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_Pos) /*!< Bit mask of EVENTS_CTSTOPPED field. */
++#define CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define CLOCK_EVENTS_CTSTOPPED_EVENTS_CTSTOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: CLOCK_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 11 : Write '1' to enable interrupt for event CTSTOPPED */
++#define CLOCK_INTENSET_CTSTOPPED_Pos (11UL) /*!< Position of CTSTOPPED field. */
++#define CLOCK_INTENSET_CTSTOPPED_Msk (0x1UL << CLOCK_INTENSET_CTSTOPPED_Pos) /*!< Bit mask of CTSTOPPED field. */
++#define CLOCK_INTENSET_CTSTOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENSET_CTSTOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENSET_CTSTOPPED_Set (1UL) /*!< Enable */
++
++/* Bit 10 : Write '1' to enable interrupt for event CTSTARTED */
++#define CLOCK_INTENSET_CTSTARTED_Pos (10UL) /*!< Position of CTSTARTED field. */
++#define CLOCK_INTENSET_CTSTARTED_Msk (0x1UL << CLOCK_INTENSET_CTSTARTED_Pos) /*!< Bit mask of CTSTARTED field. */
++#define CLOCK_INTENSET_CTSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENSET_CTSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENSET_CTSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event CTTO */
++#define CLOCK_INTENSET_CTTO_Pos (4UL) /*!< Position of CTTO field. */
++#define CLOCK_INTENSET_CTTO_Msk (0x1UL << CLOCK_INTENSET_CTTO_Pos) /*!< Bit mask of CTTO field. */
++#define CLOCK_INTENSET_CTTO_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENSET_CTTO_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENSET_CTTO_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event DONE */
++#define CLOCK_INTENSET_DONE_Pos (3UL) /*!< Position of DONE field. */
++#define CLOCK_INTENSET_DONE_Msk (0x1UL << CLOCK_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
++#define CLOCK_INTENSET_DONE_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENSET_DONE_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENSET_DONE_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event LFCLKSTARTED */
++#define CLOCK_INTENSET_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
++#define CLOCK_INTENSET_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
++#define CLOCK_INTENSET_LFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENSET_LFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENSET_LFCLKSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event HFCLKSTARTED */
++#define CLOCK_INTENSET_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
++#define CLOCK_INTENSET_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
++#define CLOCK_INTENSET_HFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENSET_HFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENSET_HFCLKSTARTED_Set (1UL) /*!< Enable */
++
++/* Register: CLOCK_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 11 : Write '1' to disable interrupt for event CTSTOPPED */
++#define CLOCK_INTENCLR_CTSTOPPED_Pos (11UL) /*!< Position of CTSTOPPED field. */
++#define CLOCK_INTENCLR_CTSTOPPED_Msk (0x1UL << CLOCK_INTENCLR_CTSTOPPED_Pos) /*!< Bit mask of CTSTOPPED field. */
++#define CLOCK_INTENCLR_CTSTOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENCLR_CTSTOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENCLR_CTSTOPPED_Clear (1UL) /*!< Disable */
++
++/* Bit 10 : Write '1' to disable interrupt for event CTSTARTED */
++#define CLOCK_INTENCLR_CTSTARTED_Pos (10UL) /*!< Position of CTSTARTED field. */
++#define CLOCK_INTENCLR_CTSTARTED_Msk (0x1UL << CLOCK_INTENCLR_CTSTARTED_Pos) /*!< Bit mask of CTSTARTED field. */
++#define CLOCK_INTENCLR_CTSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENCLR_CTSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENCLR_CTSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event CTTO */
++#define CLOCK_INTENCLR_CTTO_Pos (4UL) /*!< Position of CTTO field. */
++#define CLOCK_INTENCLR_CTTO_Msk (0x1UL << CLOCK_INTENCLR_CTTO_Pos) /*!< Bit mask of CTTO field. */
++#define CLOCK_INTENCLR_CTTO_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENCLR_CTTO_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENCLR_CTTO_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event DONE */
++#define CLOCK_INTENCLR_DONE_Pos (3UL) /*!< Position of DONE field. */
++#define CLOCK_INTENCLR_DONE_Msk (0x1UL << CLOCK_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
++#define CLOCK_INTENCLR_DONE_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENCLR_DONE_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENCLR_DONE_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event LFCLKSTARTED */
++#define CLOCK_INTENCLR_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
++#define CLOCK_INTENCLR_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
++#define CLOCK_INTENCLR_LFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENCLR_LFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENCLR_LFCLKSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event HFCLKSTARTED */
++#define CLOCK_INTENCLR_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
++#define CLOCK_INTENCLR_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
++#define CLOCK_INTENCLR_HFCLKSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define CLOCK_INTENCLR_HFCLKSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define CLOCK_INTENCLR_HFCLKSTARTED_Clear (1UL) /*!< Disable */
++
++/* Register: CLOCK_HFCLKRUN */
++/* Description: Status indicating that HFCLKSTART task has been triggered */
++
++/* Bit 0 : HFCLKSTART task triggered or not */
++#define CLOCK_HFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
++#define CLOCK_HFCLKRUN_STATUS_Msk (0x1UL << CLOCK_HFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
++#define CLOCK_HFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task not triggered */
++#define CLOCK_HFCLKRUN_STATUS_Triggered (1UL) /*!< Task triggered */
++
++/* Register: CLOCK_HFCLKSTAT */
++/* Description: HFCLK status */
++
++/* Bit 16 : HFCLK state */
++#define CLOCK_HFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
++#define CLOCK_HFCLKSTAT_STATE_Msk (0x1UL << CLOCK_HFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
++#define CLOCK_HFCLKSTAT_STATE_NotRunning (0UL) /*!< HFCLK not running */
++#define CLOCK_HFCLKSTAT_STATE_Running (1UL) /*!< HFCLK running */
++
++/* Bit 0 : Source of HFCLK */
++#define CLOCK_HFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
++#define CLOCK_HFCLKSTAT_SRC_Msk (0x1UL << CLOCK_HFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
++#define CLOCK_HFCLKSTAT_SRC_RC (0UL) /*!< 64 MHz internal oscillator (HFINT) */
++#define CLOCK_HFCLKSTAT_SRC_Xtal (1UL) /*!< 64 MHz crystal oscillator (HFXO) */
++
++/* Register: CLOCK_LFCLKRUN */
++/* Description: Status indicating that LFCLKSTART task has been triggered */
++
++/* Bit 0 : LFCLKSTART task triggered or not */
++#define CLOCK_LFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
++#define CLOCK_LFCLKRUN_STATUS_Msk (0x1UL << CLOCK_LFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
++#define CLOCK_LFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task not triggered */
++#define CLOCK_LFCLKRUN_STATUS_Triggered (1UL) /*!< Task triggered */
++
++/* Register: CLOCK_LFCLKSTAT */
++/* Description: LFCLK status */
++
++/* Bit 16 : LFCLK state */
++#define CLOCK_LFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
++#define CLOCK_LFCLKSTAT_STATE_Msk (0x1UL << CLOCK_LFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
++#define CLOCK_LFCLKSTAT_STATE_NotRunning (0UL) /*!< LFCLK not running */
++#define CLOCK_LFCLKSTAT_STATE_Running (1UL) /*!< LFCLK running */
++
++/* Bits 1..0 : Source of LFCLK */
++#define CLOCK_LFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
++#define CLOCK_LFCLKSTAT_SRC_Msk (0x3UL << CLOCK_LFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
++#define CLOCK_LFCLKSTAT_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator (LFRC) */
++#define CLOCK_LFCLKSTAT_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator (LFXO) */
++#define CLOCK_LFCLKSTAT_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK (LFSYNT) */
++
++/* Register: CLOCK_LFCLKSRCCOPY */
++/* Description: Copy of LFCLKSRC register, set when LFCLKSTART task was triggered */
++
++/* Bits 1..0 : Clock source */
++#define CLOCK_LFCLKSRCCOPY_SRC_Pos (0UL) /*!< Position of SRC field. */
++#define CLOCK_LFCLKSRCCOPY_SRC_Msk (0x3UL << CLOCK_LFCLKSRCCOPY_SRC_Pos) /*!< Bit mask of SRC field. */
++#define CLOCK_LFCLKSRCCOPY_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator (LFRC) */
++#define CLOCK_LFCLKSRCCOPY_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator (LFXO) */
++#define CLOCK_LFCLKSRCCOPY_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK (LFSYNT) */
++
++/* Register: CLOCK_LFCLKSRC */
++/* Description: Clock source for the LFCLK */
++
++/* Bit 17 : Enable or disable external source for LFCLK */
++#define CLOCK_LFCLKSRC_EXTERNAL_Pos (17UL) /*!< Position of EXTERNAL field. */
++#define CLOCK_LFCLKSRC_EXTERNAL_Msk (0x1UL << CLOCK_LFCLKSRC_EXTERNAL_Pos) /*!< Bit mask of EXTERNAL field. */
++#define CLOCK_LFCLKSRC_EXTERNAL_Disabled (0UL) /*!< Disable external source (use with Xtal) */
++#define CLOCK_LFCLKSRC_EXTERNAL_Enabled (1UL) /*!< Enable use of external source instead of Xtal (SRC needs to be set to Xtal) */
++
++/* Bit 16 : Enable or disable bypass of LFCLK crystal oscillator with external clock source */
++#define CLOCK_LFCLKSRC_BYPASS_Pos (16UL) /*!< Position of BYPASS field. */
++#define CLOCK_LFCLKSRC_BYPASS_Msk (0x1UL << CLOCK_LFCLKSRC_BYPASS_Pos) /*!< Bit mask of BYPASS field. */
++#define CLOCK_LFCLKSRC_BYPASS_Disabled (0UL) /*!< Disable (use with Xtal or low-swing external source) */
++#define CLOCK_LFCLKSRC_BYPASS_Enabled (1UL) /*!< Enable (use with rail-to-rail external source) */
++
++/* Bits 1..0 : Clock source */
++#define CLOCK_LFCLKSRC_SRC_Pos (0UL) /*!< Position of SRC field. */
++#define CLOCK_LFCLKSRC_SRC_Msk (0x3UL << CLOCK_LFCLKSRC_SRC_Pos) /*!< Bit mask of SRC field. */
++#define CLOCK_LFCLKSRC_SRC_RC (0UL) /*!< 32.768 kHz RC oscillator (LFRC) */
++#define CLOCK_LFCLKSRC_SRC_Xtal (1UL) /*!< 32.768 kHz crystal oscillator (LFXO) */
++#define CLOCK_LFCLKSRC_SRC_Synth (2UL) /*!< 32.768 kHz synthesized from HFCLK (LFSYNT) */
++
++/* Register: CLOCK_HFXODEBOUNCE */
++/* Description: HFXO debounce time. The HFXO is started by triggering the TASKS_HFCLKSTART task. */
++
++/* Bits 7..0 : HFXO debounce time. Debounce time = HFXODEBOUNCE * 16 us. */
++#define CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Pos (0UL) /*!< Position of HFXODEBOUNCE field. */
++#define CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Msk (0xFFUL << CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Pos) /*!< Bit mask of HFXODEBOUNCE field. */
++#define CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Db256us (0x10UL) /*!< 256 us debounce time. Recommended for TSX-3225, FA-20H and FA-128 crystals. */
++#define CLOCK_HFXODEBOUNCE_HFXODEBOUNCE_Db1024us (0x40UL) /*!< 1024 us debounce time. Recommended for NX1612AA and NX1210AB crystals. */
++
++/* Register: CLOCK_CTIV */
++/* Description: Calibration timer interval */
++
++/* Bits 6..0 : Calibration timer interval in multiple of 0.25 seconds. Range: 0.25 seconds to 31.75 seconds. */
++#define CLOCK_CTIV_CTIV_Pos (0UL) /*!< Position of CTIV field. */
++#define CLOCK_CTIV_CTIV_Msk (0x7FUL << CLOCK_CTIV_CTIV_Pos) /*!< Bit mask of CTIV field. */
++
++/* Register: CLOCK_TRACECONFIG */
++/* Description: Clocking options for the trace port debug interface */
++
++/* Bits 17..16 : Pin multiplexing of trace signals. See pin assignment chapter for more details. */
++#define CLOCK_TRACECONFIG_TRACEMUX_Pos (16UL) /*!< Position of TRACEMUX field. */
++#define CLOCK_TRACECONFIG_TRACEMUX_Msk (0x3UL << CLOCK_TRACECONFIG_TRACEMUX_Pos) /*!< Bit mask of TRACEMUX field. */
++#define CLOCK_TRACECONFIG_TRACEMUX_GPIO (0UL) /*!< No trace signals routed to pins. All pins can be used as regular GPIOs. */
++#define CLOCK_TRACECONFIG_TRACEMUX_Serial (1UL) /*!< SWO trace signal routed to pin. Remaining pins can be used as regular GPIOs. */
++#define CLOCK_TRACECONFIG_TRACEMUX_Parallel (2UL) /*!< All trace signals (TRACECLK and TRACEDATA[n]) routed to pins. */
++
++/* Bits 1..0 : Speed of trace port clock. Note that the TRACECLK pin will output this clock divided by two. */
++#define CLOCK_TRACECONFIG_TRACEPORTSPEED_Pos (0UL) /*!< Position of TRACEPORTSPEED field. */
++#define CLOCK_TRACECONFIG_TRACEPORTSPEED_Msk (0x3UL << CLOCK_TRACECONFIG_TRACEPORTSPEED_Pos) /*!< Bit mask of TRACEPORTSPEED field. */
++#define CLOCK_TRACECONFIG_TRACEPORTSPEED_32MHz (0UL) /*!< 32 MHz trace port clock (TRACECLK = 16 MHz) */
++#define CLOCK_TRACECONFIG_TRACEPORTSPEED_16MHz (1UL) /*!< 16 MHz trace port clock (TRACECLK = 8 MHz) */
++#define CLOCK_TRACECONFIG_TRACEPORTSPEED_8MHz (2UL) /*!< 8 MHz trace port clock (TRACECLK = 4 MHz) */
++#define CLOCK_TRACECONFIG_TRACEPORTSPEED_4MHz (3UL) /*!< 4 MHz trace port clock (TRACECLK = 2 MHz) */
++
++/* Register: CLOCK_LFRCMODE */
++/* Description: LFRC mode configuration */
++
++/* Bit 16 : Active LFRC mode. This field is read only. */
++#define CLOCK_LFRCMODE_STATUS_Pos (16UL) /*!< Position of STATUS field. */
++#define CLOCK_LFRCMODE_STATUS_Msk (0x1UL << CLOCK_LFRCMODE_STATUS_Pos) /*!< Bit mask of STATUS field. */
++#define CLOCK_LFRCMODE_STATUS_Normal (0UL) /*!< Normal mode */
++#define CLOCK_LFRCMODE_STATUS_ULP (1UL) /*!< Ultra-low power mode (ULP) */
++
++/* Bit 0 : Set LFRC mode */
++#define CLOCK_LFRCMODE_MODE_Pos (0UL) /*!< Position of MODE field. */
++#define CLOCK_LFRCMODE_MODE_Msk (0x1UL << CLOCK_LFRCMODE_MODE_Pos) /*!< Bit mask of MODE field. */
++#define CLOCK_LFRCMODE_MODE_Normal (0UL) /*!< Normal mode */
++#define CLOCK_LFRCMODE_MODE_ULP (1UL) /*!< Ultra-low power mode (ULP) */
++
++
++/* Peripheral: COMP */
++/* Description: Comparator */
++
++/* Register: COMP_TASKS_START */
++/* Description: Start comparator */
++
++/* Bit 0 : Start comparator */
++#define COMP_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define COMP_TASKS_START_TASKS_START_Msk (0x1UL << COMP_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define COMP_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: COMP_TASKS_STOP */
++/* Description: Stop comparator */
++
++/* Bit 0 : Stop comparator */
++#define COMP_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define COMP_TASKS_STOP_TASKS_STOP_Msk (0x1UL << COMP_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define COMP_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: COMP_TASKS_SAMPLE */
++/* Description: Sample comparator value */
++
++/* Bit 0 : Sample comparator value */
++#define COMP_TASKS_SAMPLE_TASKS_SAMPLE_Pos (0UL) /*!< Position of TASKS_SAMPLE field. */
++#define COMP_TASKS_SAMPLE_TASKS_SAMPLE_Msk (0x1UL << COMP_TASKS_SAMPLE_TASKS_SAMPLE_Pos) /*!< Bit mask of TASKS_SAMPLE field. */
++#define COMP_TASKS_SAMPLE_TASKS_SAMPLE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: COMP_EVENTS_READY */
++/* Description: COMP is ready and output is valid */
++
++/* Bit 0 : COMP is ready and output is valid */
++#define COMP_EVENTS_READY_EVENTS_READY_Pos (0UL) /*!< Position of EVENTS_READY field. */
++#define COMP_EVENTS_READY_EVENTS_READY_Msk (0x1UL << COMP_EVENTS_READY_EVENTS_READY_Pos) /*!< Bit mask of EVENTS_READY field. */
++#define COMP_EVENTS_READY_EVENTS_READY_NotGenerated (0UL) /*!< Event not generated */
++#define COMP_EVENTS_READY_EVENTS_READY_Generated (1UL) /*!< Event generated */
++
++/* Register: COMP_EVENTS_DOWN */
++/* Description: Downward crossing */
++
++/* Bit 0 : Downward crossing */
++#define COMP_EVENTS_DOWN_EVENTS_DOWN_Pos (0UL) /*!< Position of EVENTS_DOWN field. */
++#define COMP_EVENTS_DOWN_EVENTS_DOWN_Msk (0x1UL << COMP_EVENTS_DOWN_EVENTS_DOWN_Pos) /*!< Bit mask of EVENTS_DOWN field. */
++#define COMP_EVENTS_DOWN_EVENTS_DOWN_NotGenerated (0UL) /*!< Event not generated */
++#define COMP_EVENTS_DOWN_EVENTS_DOWN_Generated (1UL) /*!< Event generated */
++
++/* Register: COMP_EVENTS_UP */
++/* Description: Upward crossing */
++
++/* Bit 0 : Upward crossing */
++#define COMP_EVENTS_UP_EVENTS_UP_Pos (0UL) /*!< Position of EVENTS_UP field. */
++#define COMP_EVENTS_UP_EVENTS_UP_Msk (0x1UL << COMP_EVENTS_UP_EVENTS_UP_Pos) /*!< Bit mask of EVENTS_UP field. */
++#define COMP_EVENTS_UP_EVENTS_UP_NotGenerated (0UL) /*!< Event not generated */
++#define COMP_EVENTS_UP_EVENTS_UP_Generated (1UL) /*!< Event generated */
++
++/* Register: COMP_EVENTS_CROSS */
++/* Description: Downward or upward crossing */
++
++/* Bit 0 : Downward or upward crossing */
++#define COMP_EVENTS_CROSS_EVENTS_CROSS_Pos (0UL) /*!< Position of EVENTS_CROSS field. */
++#define COMP_EVENTS_CROSS_EVENTS_CROSS_Msk (0x1UL << COMP_EVENTS_CROSS_EVENTS_CROSS_Pos) /*!< Bit mask of EVENTS_CROSS field. */
++#define COMP_EVENTS_CROSS_EVENTS_CROSS_NotGenerated (0UL) /*!< Event not generated */
++#define COMP_EVENTS_CROSS_EVENTS_CROSS_Generated (1UL) /*!< Event generated */
++
++/* Register: COMP_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 4 : Shortcut between event CROSS and task STOP */
++#define COMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
++#define COMP_SHORTS_CROSS_STOP_Msk (0x1UL << COMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
++#define COMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define COMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 3 : Shortcut between event UP and task STOP */
++#define COMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
++#define COMP_SHORTS_UP_STOP_Msk (0x1UL << COMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
++#define COMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define COMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 2 : Shortcut between event DOWN and task STOP */
++#define COMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
++#define COMP_SHORTS_DOWN_STOP_Msk (0x1UL << COMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
++#define COMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define COMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 1 : Shortcut between event READY and task STOP */
++#define COMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
++#define COMP_SHORTS_READY_STOP_Msk (0x1UL << COMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
++#define COMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define COMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event READY and task SAMPLE */
++#define COMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
++#define COMP_SHORTS_READY_SAMPLE_Msk (0x1UL << COMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
++#define COMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Disable shortcut */
++#define COMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: COMP_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 3 : Enable or disable interrupt for event CROSS */
++#define COMP_INTEN_CROSS_Pos (3UL) /*!< Position of CROSS field. */
++#define COMP_INTEN_CROSS_Msk (0x1UL << COMP_INTEN_CROSS_Pos) /*!< Bit mask of CROSS field. */
++#define COMP_INTEN_CROSS_Disabled (0UL) /*!< Disable */
++#define COMP_INTEN_CROSS_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event UP */
++#define COMP_INTEN_UP_Pos (2UL) /*!< Position of UP field. */
++#define COMP_INTEN_UP_Msk (0x1UL << COMP_INTEN_UP_Pos) /*!< Bit mask of UP field. */
++#define COMP_INTEN_UP_Disabled (0UL) /*!< Disable */
++#define COMP_INTEN_UP_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event DOWN */
++#define COMP_INTEN_DOWN_Pos (1UL) /*!< Position of DOWN field. */
++#define COMP_INTEN_DOWN_Msk (0x1UL << COMP_INTEN_DOWN_Pos) /*!< Bit mask of DOWN field. */
++#define COMP_INTEN_DOWN_Disabled (0UL) /*!< Disable */
++#define COMP_INTEN_DOWN_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event READY */
++#define COMP_INTEN_READY_Pos (0UL) /*!< Position of READY field. */
++#define COMP_INTEN_READY_Msk (0x1UL << COMP_INTEN_READY_Pos) /*!< Bit mask of READY field. */
++#define COMP_INTEN_READY_Disabled (0UL) /*!< Disable */
++#define COMP_INTEN_READY_Enabled (1UL) /*!< Enable */
++
++/* Register: COMP_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 3 : Write '1' to enable interrupt for event CROSS */
++#define COMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
++#define COMP_INTENSET_CROSS_Msk (0x1UL << COMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
++#define COMP_INTENSET_CROSS_Disabled (0UL) /*!< Read: Disabled */
++#define COMP_INTENSET_CROSS_Enabled (1UL) /*!< Read: Enabled */
++#define COMP_INTENSET_CROSS_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event UP */
++#define COMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
++#define COMP_INTENSET_UP_Msk (0x1UL << COMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
++#define COMP_INTENSET_UP_Disabled (0UL) /*!< Read: Disabled */
++#define COMP_INTENSET_UP_Enabled (1UL) /*!< Read: Enabled */
++#define COMP_INTENSET_UP_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event DOWN */
++#define COMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
++#define COMP_INTENSET_DOWN_Msk (0x1UL << COMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
++#define COMP_INTENSET_DOWN_Disabled (0UL) /*!< Read: Disabled */
++#define COMP_INTENSET_DOWN_Enabled (1UL) /*!< Read: Enabled */
++#define COMP_INTENSET_DOWN_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event READY */
++#define COMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
++#define COMP_INTENSET_READY_Msk (0x1UL << COMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
++#define COMP_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
++#define COMP_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
++#define COMP_INTENSET_READY_Set (1UL) /*!< Enable */
++
++/* Register: COMP_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 3 : Write '1' to disable interrupt for event CROSS */
++#define COMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
++#define COMP_INTENCLR_CROSS_Msk (0x1UL << COMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
++#define COMP_INTENCLR_CROSS_Disabled (0UL) /*!< Read: Disabled */
++#define COMP_INTENCLR_CROSS_Enabled (1UL) /*!< Read: Enabled */
++#define COMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event UP */
++#define COMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
++#define COMP_INTENCLR_UP_Msk (0x1UL << COMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
++#define COMP_INTENCLR_UP_Disabled (0UL) /*!< Read: Disabled */
++#define COMP_INTENCLR_UP_Enabled (1UL) /*!< Read: Enabled */
++#define COMP_INTENCLR_UP_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event DOWN */
++#define COMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
++#define COMP_INTENCLR_DOWN_Msk (0x1UL << COMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
++#define COMP_INTENCLR_DOWN_Disabled (0UL) /*!< Read: Disabled */
++#define COMP_INTENCLR_DOWN_Enabled (1UL) /*!< Read: Enabled */
++#define COMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event READY */
++#define COMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
++#define COMP_INTENCLR_READY_Msk (0x1UL << COMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
++#define COMP_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
++#define COMP_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
++#define COMP_INTENCLR_READY_Clear (1UL) /*!< Disable */
++
++/* Register: COMP_RESULT */
++/* Description: Compare result */
++
++/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
++#define COMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
++#define COMP_RESULT_RESULT_Msk (0x1UL << COMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
++#define COMP_RESULT_RESULT_Below (0UL) /*!< Input voltage is below the threshold (VIN+ &lt; VIN-) */
++#define COMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the threshold (VIN+ &gt; VIN-) */
++
++/* Register: COMP_ENABLE */
++/* Description: COMP enable */
++
++/* Bits 1..0 : Enable or disable COMP */
++#define COMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define COMP_ENABLE_ENABLE_Msk (0x3UL << COMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define COMP_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
++#define COMP_ENABLE_ENABLE_Enabled (2UL) /*!< Enable */
++
++/* Register: COMP_PSEL */
++/* Description: Pin select */
++
++/* Bits 2..0 : Analog pin select */
++#define COMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
++#define COMP_PSEL_PSEL_Msk (0x7UL << COMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
++#define COMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< AIN0 selected as analog input */
++#define COMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< AIN1 selected as analog input */
++#define COMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< AIN2 selected as analog input */
++#define COMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< AIN3 selected as analog input */
++#define COMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< AIN4 selected as analog input */
++#define COMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< AIN5 selected as analog input */
++#define COMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< AIN6 selected as analog input */
++#define COMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< AIN7 selected as analog input */
++
++/* Register: COMP_REFSEL */
++/* Description: Reference source select for single-ended mode */
++
++/* Bits 2..0 : Reference select */
++#define COMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
++#define COMP_REFSEL_REFSEL_Msk (0x7UL << COMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
++#define COMP_REFSEL_REFSEL_Int1V2 (0UL) /*!< VREF = internal 1.2 V reference (VDD &gt;= 1.7 V) */
++#define COMP_REFSEL_REFSEL_Int1V8 (1UL) /*!< VREF = internal 1.8 V reference (VDD &gt;= VREF + 0.2 V) */
++#define COMP_REFSEL_REFSEL_Int2V4 (2UL) /*!< VREF = internal 2.4 V reference (VDD &gt;= VREF + 0.2 V) */
++#define COMP_REFSEL_REFSEL_VDD (4UL) /*!< VREF = VDD */
++#define COMP_REFSEL_REFSEL_ARef (5UL) /*!< VREF = AREF */
++
++/* Register: COMP_EXTREFSEL */
++/* Description: External reference select */
++
++/* Bits 2..0 : External analog reference select */
++#define COMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
++#define COMP_EXTREFSEL_EXTREFSEL_Msk (0x7UL << COMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
++#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use AIN0 as external analog reference */
++#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use AIN1 as external analog reference */
++#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference2 (2UL) /*!< Use AIN2 as external analog reference */
++#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference3 (3UL) /*!< Use AIN3 as external analog reference */
++#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference4 (4UL) /*!< Use AIN4 as external analog reference */
++#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference5 (5UL) /*!< Use AIN5 as external analog reference */
++#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference6 (6UL) /*!< Use AIN6 as external analog reference */
++#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference7 (7UL) /*!< Use AIN7 as external analog reference */
++
++/* Register: COMP_TH */
++/* Description: Threshold configuration for hysteresis unit */
++
++/* Bits 13..8 : VUP = (THUP+1)/64*VREF */
++#define COMP_TH_THUP_Pos (8UL) /*!< Position of THUP field. */
++#define COMP_TH_THUP_Msk (0x3FUL << COMP_TH_THUP_Pos) /*!< Bit mask of THUP field. */
++
++/* Bits 5..0 : VDOWN = (THDOWN+1)/64*VREF */
++#define COMP_TH_THDOWN_Pos (0UL) /*!< Position of THDOWN field. */
++#define COMP_TH_THDOWN_Msk (0x3FUL << COMP_TH_THDOWN_Pos) /*!< Bit mask of THDOWN field. */
++
++/* Register: COMP_MODE */
++/* Description: Mode configuration */
++
++/* Bit 8 : Main operation modes */
++#define COMP_MODE_MAIN_Pos (8UL) /*!< Position of MAIN field. */
++#define COMP_MODE_MAIN_Msk (0x1UL << COMP_MODE_MAIN_Pos) /*!< Bit mask of MAIN field. */
++#define COMP_MODE_MAIN_SE (0UL) /*!< Single-ended mode */
++#define COMP_MODE_MAIN_Diff (1UL) /*!< Differential mode */
++
++/* Bits 1..0 : Speed and power modes */
++#define COMP_MODE_SP_Pos (0UL) /*!< Position of SP field. */
++#define COMP_MODE_SP_Msk (0x3UL << COMP_MODE_SP_Pos) /*!< Bit mask of SP field. */
++#define COMP_MODE_SP_Low (0UL) /*!< Low-power mode */
++#define COMP_MODE_SP_Normal (1UL) /*!< Normal mode */
++#define COMP_MODE_SP_High (2UL) /*!< High-speed mode */
++
++/* Register: COMP_HYST */
++/* Description: Comparator hysteresis enable */
++
++/* Bit 0 : Comparator hysteresis */
++#define COMP_HYST_HYST_Pos (0UL) /*!< Position of HYST field. */
++#define COMP_HYST_HYST_Msk (0x1UL << COMP_HYST_HYST_Pos) /*!< Bit mask of HYST field. */
++#define COMP_HYST_HYST_NoHyst (0UL) /*!< Comparator hysteresis disabled */
++#define COMP_HYST_HYST_Hyst50mV (1UL) /*!< Comparator hysteresis enabled */
++
++
++/* Peripheral: CRYPTOCELL */
++/* Description: ARM TrustZone CryptoCell register interface */
++
++/* Register: CRYPTOCELL_ENABLE */
++/* Description: Enable CRYPTOCELL subsystem */
++
++/* Bit 0 : Enable or disable the CRYPTOCELL subsystem */
++#define CRYPTOCELL_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define CRYPTOCELL_ENABLE_ENABLE_Msk (0x1UL << CRYPTOCELL_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define CRYPTOCELL_ENABLE_ENABLE_Disabled (0UL) /*!< CRYPTOCELL subsystem disabled */
++#define CRYPTOCELL_ENABLE_ENABLE_Enabled (1UL) /*!< CRYPTOCELL subsystem enabled. */
++
++
++/* Peripheral: ECB */
++/* Description: AES ECB Mode Encryption */
++
++/* Register: ECB_TASKS_STARTECB */
++/* Description: Start ECB block encrypt */
++
++/* Bit 0 : Start ECB block encrypt */
++#define ECB_TASKS_STARTECB_TASKS_STARTECB_Pos (0UL) /*!< Position of TASKS_STARTECB field. */
++#define ECB_TASKS_STARTECB_TASKS_STARTECB_Msk (0x1UL << ECB_TASKS_STARTECB_TASKS_STARTECB_Pos) /*!< Bit mask of TASKS_STARTECB field. */
++#define ECB_TASKS_STARTECB_TASKS_STARTECB_Trigger (1UL) /*!< Trigger task */
++
++/* Register: ECB_TASKS_STOPECB */
++/* Description: Abort a possible executing ECB operation */
++
++/* Bit 0 : Abort a possible executing ECB operation */
++#define ECB_TASKS_STOPECB_TASKS_STOPECB_Pos (0UL) /*!< Position of TASKS_STOPECB field. */
++#define ECB_TASKS_STOPECB_TASKS_STOPECB_Msk (0x1UL << ECB_TASKS_STOPECB_TASKS_STOPECB_Pos) /*!< Bit mask of TASKS_STOPECB field. */
++#define ECB_TASKS_STOPECB_TASKS_STOPECB_Trigger (1UL) /*!< Trigger task */
++
++/* Register: ECB_EVENTS_ENDECB */
++/* Description: ECB block encrypt complete */
++
++/* Bit 0 : ECB block encrypt complete */
++#define ECB_EVENTS_ENDECB_EVENTS_ENDECB_Pos (0UL) /*!< Position of EVENTS_ENDECB field. */
++#define ECB_EVENTS_ENDECB_EVENTS_ENDECB_Msk (0x1UL << ECB_EVENTS_ENDECB_EVENTS_ENDECB_Pos) /*!< Bit mask of EVENTS_ENDECB field. */
++#define ECB_EVENTS_ENDECB_EVENTS_ENDECB_NotGenerated (0UL) /*!< Event not generated */
++#define ECB_EVENTS_ENDECB_EVENTS_ENDECB_Generated (1UL) /*!< Event generated */
++
++/* Register: ECB_EVENTS_ERRORECB */
++/* Description: ECB block encrypt aborted because of a STOPECB task or due to an error */
++
++/* Bit 0 : ECB block encrypt aborted because of a STOPECB task or due to an error */
++#define ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_Pos (0UL) /*!< Position of EVENTS_ERRORECB field. */
++#define ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_Msk (0x1UL << ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_Pos) /*!< Bit mask of EVENTS_ERRORECB field. */
++#define ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_NotGenerated (0UL) /*!< Event not generated */
++#define ECB_EVENTS_ERRORECB_EVENTS_ERRORECB_Generated (1UL) /*!< Event generated */
++
++/* Register: ECB_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 1 : Write '1' to enable interrupt for event ERRORECB */
++#define ECB_INTENSET_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
++#define ECB_INTENSET_ERRORECB_Msk (0x1UL << ECB_INTENSET_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
++#define ECB_INTENSET_ERRORECB_Disabled (0UL) /*!< Read: Disabled */
++#define ECB_INTENSET_ERRORECB_Enabled (1UL) /*!< Read: Enabled */
++#define ECB_INTENSET_ERRORECB_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event ENDECB */
++#define ECB_INTENSET_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
++#define ECB_INTENSET_ENDECB_Msk (0x1UL << ECB_INTENSET_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
++#define ECB_INTENSET_ENDECB_Disabled (0UL) /*!< Read: Disabled */
++#define ECB_INTENSET_ENDECB_Enabled (1UL) /*!< Read: Enabled */
++#define ECB_INTENSET_ENDECB_Set (1UL) /*!< Enable */
++
++/* Register: ECB_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 1 : Write '1' to disable interrupt for event ERRORECB */
++#define ECB_INTENCLR_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
++#define ECB_INTENCLR_ERRORECB_Msk (0x1UL << ECB_INTENCLR_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
++#define ECB_INTENCLR_ERRORECB_Disabled (0UL) /*!< Read: Disabled */
++#define ECB_INTENCLR_ERRORECB_Enabled (1UL) /*!< Read: Enabled */
++#define ECB_INTENCLR_ERRORECB_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event ENDECB */
++#define ECB_INTENCLR_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
++#define ECB_INTENCLR_ENDECB_Msk (0x1UL << ECB_INTENCLR_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
++#define ECB_INTENCLR_ENDECB_Disabled (0UL) /*!< Read: Disabled */
++#define ECB_INTENCLR_ENDECB_Enabled (1UL) /*!< Read: Enabled */
++#define ECB_INTENCLR_ENDECB_Clear (1UL) /*!< Disable */
++
++/* Register: ECB_ECBDATAPTR */
++/* Description: ECB block encrypt memory pointers */
++
++/* Bits 31..0 : Pointer to the ECB data structure (see Table 1 ECB data structure overview) */
++#define ECB_ECBDATAPTR_ECBDATAPTR_Pos (0UL) /*!< Position of ECBDATAPTR field. */
++#define ECB_ECBDATAPTR_ECBDATAPTR_Msk (0xFFFFFFFFUL << ECB_ECBDATAPTR_ECBDATAPTR_Pos) /*!< Bit mask of ECBDATAPTR field. */
++
++
++/* Peripheral: EGU */
++/* Description: Event generator unit 0 */
++
++/* Register: EGU_TASKS_TRIGGER */
++/* Description: Description collection: Trigger n for triggering the corresponding TRIGGERED[n] event */
++
++/* Bit 0 : Trigger n for triggering the corresponding TRIGGERED[n] event */
++#define EGU_TASKS_TRIGGER_TASKS_TRIGGER_Pos (0UL) /*!< Position of TASKS_TRIGGER field. */
++#define EGU_TASKS_TRIGGER_TASKS_TRIGGER_Msk (0x1UL << EGU_TASKS_TRIGGER_TASKS_TRIGGER_Pos) /*!< Bit mask of TASKS_TRIGGER field. */
++#define EGU_TASKS_TRIGGER_TASKS_TRIGGER_Trigger (1UL) /*!< Trigger task */
++
++/* Register: EGU_EVENTS_TRIGGERED */
++/* Description: Description collection: Event number n generated by triggering the corresponding TRIGGER[n] task */
++
++/* Bit 0 : Event number n generated by triggering the corresponding TRIGGER[n] task */
++#define EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Pos (0UL) /*!< Position of EVENTS_TRIGGERED field. */
++#define EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Msk (0x1UL << EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Pos) /*!< Bit mask of EVENTS_TRIGGERED field. */
++#define EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_NotGenerated (0UL) /*!< Event not generated */
++#define EGU_EVENTS_TRIGGERED_EVENTS_TRIGGERED_Generated (1UL) /*!< Event generated */
++
++/* Register: EGU_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 15 : Enable or disable interrupt for event TRIGGERED[15] */
++#define EGU_INTEN_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
++#define EGU_INTEN_TRIGGERED15_Msk (0x1UL << EGU_INTEN_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
++#define EGU_INTEN_TRIGGERED15_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED15_Enabled (1UL) /*!< Enable */
++
++/* Bit 14 : Enable or disable interrupt for event TRIGGERED[14] */
++#define EGU_INTEN_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
++#define EGU_INTEN_TRIGGERED14_Msk (0x1UL << EGU_INTEN_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
++#define EGU_INTEN_TRIGGERED14_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED14_Enabled (1UL) /*!< Enable */
++
++/* Bit 13 : Enable or disable interrupt for event TRIGGERED[13] */
++#define EGU_INTEN_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
++#define EGU_INTEN_TRIGGERED13_Msk (0x1UL << EGU_INTEN_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
++#define EGU_INTEN_TRIGGERED13_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED13_Enabled (1UL) /*!< Enable */
++
++/* Bit 12 : Enable or disable interrupt for event TRIGGERED[12] */
++#define EGU_INTEN_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
++#define EGU_INTEN_TRIGGERED12_Msk (0x1UL << EGU_INTEN_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
++#define EGU_INTEN_TRIGGERED12_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED12_Enabled (1UL) /*!< Enable */
++
++/* Bit 11 : Enable or disable interrupt for event TRIGGERED[11] */
++#define EGU_INTEN_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
++#define EGU_INTEN_TRIGGERED11_Msk (0x1UL << EGU_INTEN_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
++#define EGU_INTEN_TRIGGERED11_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED11_Enabled (1UL) /*!< Enable */
++
++/* Bit 10 : Enable or disable interrupt for event TRIGGERED[10] */
++#define EGU_INTEN_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
++#define EGU_INTEN_TRIGGERED10_Msk (0x1UL << EGU_INTEN_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
++#define EGU_INTEN_TRIGGERED10_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED10_Enabled (1UL) /*!< Enable */
++
++/* Bit 9 : Enable or disable interrupt for event TRIGGERED[9] */
++#define EGU_INTEN_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
++#define EGU_INTEN_TRIGGERED9_Msk (0x1UL << EGU_INTEN_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
++#define EGU_INTEN_TRIGGERED9_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED9_Enabled (1UL) /*!< Enable */
++
++/* Bit 8 : Enable or disable interrupt for event TRIGGERED[8] */
++#define EGU_INTEN_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
++#define EGU_INTEN_TRIGGERED8_Msk (0x1UL << EGU_INTEN_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
++#define EGU_INTEN_TRIGGERED8_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED8_Enabled (1UL) /*!< Enable */
++
++/* Bit 7 : Enable or disable interrupt for event TRIGGERED[7] */
++#define EGU_INTEN_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
++#define EGU_INTEN_TRIGGERED7_Msk (0x1UL << EGU_INTEN_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
++#define EGU_INTEN_TRIGGERED7_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED7_Enabled (1UL) /*!< Enable */
++
++/* Bit 6 : Enable or disable interrupt for event TRIGGERED[6] */
++#define EGU_INTEN_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
++#define EGU_INTEN_TRIGGERED6_Msk (0x1UL << EGU_INTEN_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
++#define EGU_INTEN_TRIGGERED6_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED6_Enabled (1UL) /*!< Enable */
++
++/* Bit 5 : Enable or disable interrupt for event TRIGGERED[5] */
++#define EGU_INTEN_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
++#define EGU_INTEN_TRIGGERED5_Msk (0x1UL << EGU_INTEN_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
++#define EGU_INTEN_TRIGGERED5_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED5_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable interrupt for event TRIGGERED[4] */
++#define EGU_INTEN_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
++#define EGU_INTEN_TRIGGERED4_Msk (0x1UL << EGU_INTEN_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
++#define EGU_INTEN_TRIGGERED4_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED4_Enabled (1UL) /*!< Enable */
++
++/* Bit 3 : Enable or disable interrupt for event TRIGGERED[3] */
++#define EGU_INTEN_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
++#define EGU_INTEN_TRIGGERED3_Msk (0x1UL << EGU_INTEN_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
++#define EGU_INTEN_TRIGGERED3_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED3_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event TRIGGERED[2] */
++#define EGU_INTEN_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
++#define EGU_INTEN_TRIGGERED2_Msk (0x1UL << EGU_INTEN_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
++#define EGU_INTEN_TRIGGERED2_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED2_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event TRIGGERED[1] */
++#define EGU_INTEN_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
++#define EGU_INTEN_TRIGGERED1_Msk (0x1UL << EGU_INTEN_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
++#define EGU_INTEN_TRIGGERED1_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED1_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event TRIGGERED[0] */
++#define EGU_INTEN_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
++#define EGU_INTEN_TRIGGERED0_Msk (0x1UL << EGU_INTEN_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
++#define EGU_INTEN_TRIGGERED0_Disabled (0UL) /*!< Disable */
++#define EGU_INTEN_TRIGGERED0_Enabled (1UL) /*!< Enable */
++
++/* Register: EGU_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 15 : Write '1' to enable interrupt for event TRIGGERED[15] */
++#define EGU_INTENSET_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
++#define EGU_INTENSET_TRIGGERED15_Msk (0x1UL << EGU_INTENSET_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
++#define EGU_INTENSET_TRIGGERED15_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED15_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED15_Set (1UL) /*!< Enable */
++
++/* Bit 14 : Write '1' to enable interrupt for event TRIGGERED[14] */
++#define EGU_INTENSET_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
++#define EGU_INTENSET_TRIGGERED14_Msk (0x1UL << EGU_INTENSET_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
++#define EGU_INTENSET_TRIGGERED14_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED14_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED14_Set (1UL) /*!< Enable */
++
++/* Bit 13 : Write '1' to enable interrupt for event TRIGGERED[13] */
++#define EGU_INTENSET_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
++#define EGU_INTENSET_TRIGGERED13_Msk (0x1UL << EGU_INTENSET_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
++#define EGU_INTENSET_TRIGGERED13_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED13_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED13_Set (1UL) /*!< Enable */
++
++/* Bit 12 : Write '1' to enable interrupt for event TRIGGERED[12] */
++#define EGU_INTENSET_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
++#define EGU_INTENSET_TRIGGERED12_Msk (0x1UL << EGU_INTENSET_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
++#define EGU_INTENSET_TRIGGERED12_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED12_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED12_Set (1UL) /*!< Enable */
++
++/* Bit 11 : Write '1' to enable interrupt for event TRIGGERED[11] */
++#define EGU_INTENSET_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
++#define EGU_INTENSET_TRIGGERED11_Msk (0x1UL << EGU_INTENSET_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
++#define EGU_INTENSET_TRIGGERED11_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED11_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED11_Set (1UL) /*!< Enable */
++
++/* Bit 10 : Write '1' to enable interrupt for event TRIGGERED[10] */
++#define EGU_INTENSET_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
++#define EGU_INTENSET_TRIGGERED10_Msk (0x1UL << EGU_INTENSET_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
++#define EGU_INTENSET_TRIGGERED10_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED10_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED10_Set (1UL) /*!< Enable */
++
++/* Bit 9 : Write '1' to enable interrupt for event TRIGGERED[9] */
++#define EGU_INTENSET_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
++#define EGU_INTENSET_TRIGGERED9_Msk (0x1UL << EGU_INTENSET_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
++#define EGU_INTENSET_TRIGGERED9_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED9_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED9_Set (1UL) /*!< Enable */
++
++/* Bit 8 : Write '1' to enable interrupt for event TRIGGERED[8] */
++#define EGU_INTENSET_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
++#define EGU_INTENSET_TRIGGERED8_Msk (0x1UL << EGU_INTENSET_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
++#define EGU_INTENSET_TRIGGERED8_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED8_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED8_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event TRIGGERED[7] */
++#define EGU_INTENSET_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
++#define EGU_INTENSET_TRIGGERED7_Msk (0x1UL << EGU_INTENSET_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
++#define EGU_INTENSET_TRIGGERED7_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED7_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED7_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event TRIGGERED[6] */
++#define EGU_INTENSET_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
++#define EGU_INTENSET_TRIGGERED6_Msk (0x1UL << EGU_INTENSET_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
++#define EGU_INTENSET_TRIGGERED6_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED6_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED6_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event TRIGGERED[5] */
++#define EGU_INTENSET_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
++#define EGU_INTENSET_TRIGGERED5_Msk (0x1UL << EGU_INTENSET_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
++#define EGU_INTENSET_TRIGGERED5_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED5_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED5_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event TRIGGERED[4] */
++#define EGU_INTENSET_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
++#define EGU_INTENSET_TRIGGERED4_Msk (0x1UL << EGU_INTENSET_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
++#define EGU_INTENSET_TRIGGERED4_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED4_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED4_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event TRIGGERED[3] */
++#define EGU_INTENSET_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
++#define EGU_INTENSET_TRIGGERED3_Msk (0x1UL << EGU_INTENSET_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
++#define EGU_INTENSET_TRIGGERED3_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED3_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED3_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event TRIGGERED[2] */
++#define EGU_INTENSET_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
++#define EGU_INTENSET_TRIGGERED2_Msk (0x1UL << EGU_INTENSET_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
++#define EGU_INTENSET_TRIGGERED2_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED2_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED2_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event TRIGGERED[1] */
++#define EGU_INTENSET_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
++#define EGU_INTENSET_TRIGGERED1_Msk (0x1UL << EGU_INTENSET_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
++#define EGU_INTENSET_TRIGGERED1_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED1_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED1_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event TRIGGERED[0] */
++#define EGU_INTENSET_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
++#define EGU_INTENSET_TRIGGERED0_Msk (0x1UL << EGU_INTENSET_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
++#define EGU_INTENSET_TRIGGERED0_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENSET_TRIGGERED0_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENSET_TRIGGERED0_Set (1UL) /*!< Enable */
++
++/* Register: EGU_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 15 : Write '1' to disable interrupt for event TRIGGERED[15] */
++#define EGU_INTENCLR_TRIGGERED15_Pos (15UL) /*!< Position of TRIGGERED15 field. */
++#define EGU_INTENCLR_TRIGGERED15_Msk (0x1UL << EGU_INTENCLR_TRIGGERED15_Pos) /*!< Bit mask of TRIGGERED15 field. */
++#define EGU_INTENCLR_TRIGGERED15_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED15_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED15_Clear (1UL) /*!< Disable */
++
++/* Bit 14 : Write '1' to disable interrupt for event TRIGGERED[14] */
++#define EGU_INTENCLR_TRIGGERED14_Pos (14UL) /*!< Position of TRIGGERED14 field. */
++#define EGU_INTENCLR_TRIGGERED14_Msk (0x1UL << EGU_INTENCLR_TRIGGERED14_Pos) /*!< Bit mask of TRIGGERED14 field. */
++#define EGU_INTENCLR_TRIGGERED14_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED14_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED14_Clear (1UL) /*!< Disable */
++
++/* Bit 13 : Write '1' to disable interrupt for event TRIGGERED[13] */
++#define EGU_INTENCLR_TRIGGERED13_Pos (13UL) /*!< Position of TRIGGERED13 field. */
++#define EGU_INTENCLR_TRIGGERED13_Msk (0x1UL << EGU_INTENCLR_TRIGGERED13_Pos) /*!< Bit mask of TRIGGERED13 field. */
++#define EGU_INTENCLR_TRIGGERED13_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED13_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED13_Clear (1UL) /*!< Disable */
++
++/* Bit 12 : Write '1' to disable interrupt for event TRIGGERED[12] */
++#define EGU_INTENCLR_TRIGGERED12_Pos (12UL) /*!< Position of TRIGGERED12 field. */
++#define EGU_INTENCLR_TRIGGERED12_Msk (0x1UL << EGU_INTENCLR_TRIGGERED12_Pos) /*!< Bit mask of TRIGGERED12 field. */
++#define EGU_INTENCLR_TRIGGERED12_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED12_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED12_Clear (1UL) /*!< Disable */
++
++/* Bit 11 : Write '1' to disable interrupt for event TRIGGERED[11] */
++#define EGU_INTENCLR_TRIGGERED11_Pos (11UL) /*!< Position of TRIGGERED11 field. */
++#define EGU_INTENCLR_TRIGGERED11_Msk (0x1UL << EGU_INTENCLR_TRIGGERED11_Pos) /*!< Bit mask of TRIGGERED11 field. */
++#define EGU_INTENCLR_TRIGGERED11_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED11_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED11_Clear (1UL) /*!< Disable */
++
++/* Bit 10 : Write '1' to disable interrupt for event TRIGGERED[10] */
++#define EGU_INTENCLR_TRIGGERED10_Pos (10UL) /*!< Position of TRIGGERED10 field. */
++#define EGU_INTENCLR_TRIGGERED10_Msk (0x1UL << EGU_INTENCLR_TRIGGERED10_Pos) /*!< Bit mask of TRIGGERED10 field. */
++#define EGU_INTENCLR_TRIGGERED10_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED10_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED10_Clear (1UL) /*!< Disable */
++
++/* Bit 9 : Write '1' to disable interrupt for event TRIGGERED[9] */
++#define EGU_INTENCLR_TRIGGERED9_Pos (9UL) /*!< Position of TRIGGERED9 field. */
++#define EGU_INTENCLR_TRIGGERED9_Msk (0x1UL << EGU_INTENCLR_TRIGGERED9_Pos) /*!< Bit mask of TRIGGERED9 field. */
++#define EGU_INTENCLR_TRIGGERED9_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED9_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED9_Clear (1UL) /*!< Disable */
++
++/* Bit 8 : Write '1' to disable interrupt for event TRIGGERED[8] */
++#define EGU_INTENCLR_TRIGGERED8_Pos (8UL) /*!< Position of TRIGGERED8 field. */
++#define EGU_INTENCLR_TRIGGERED8_Msk (0x1UL << EGU_INTENCLR_TRIGGERED8_Pos) /*!< Bit mask of TRIGGERED8 field. */
++#define EGU_INTENCLR_TRIGGERED8_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED8_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED8_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event TRIGGERED[7] */
++#define EGU_INTENCLR_TRIGGERED7_Pos (7UL) /*!< Position of TRIGGERED7 field. */
++#define EGU_INTENCLR_TRIGGERED7_Msk (0x1UL << EGU_INTENCLR_TRIGGERED7_Pos) /*!< Bit mask of TRIGGERED7 field. */
++#define EGU_INTENCLR_TRIGGERED7_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED7_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED7_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event TRIGGERED[6] */
++#define EGU_INTENCLR_TRIGGERED6_Pos (6UL) /*!< Position of TRIGGERED6 field. */
++#define EGU_INTENCLR_TRIGGERED6_Msk (0x1UL << EGU_INTENCLR_TRIGGERED6_Pos) /*!< Bit mask of TRIGGERED6 field. */
++#define EGU_INTENCLR_TRIGGERED6_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED6_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED6_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event TRIGGERED[5] */
++#define EGU_INTENCLR_TRIGGERED5_Pos (5UL) /*!< Position of TRIGGERED5 field. */
++#define EGU_INTENCLR_TRIGGERED5_Msk (0x1UL << EGU_INTENCLR_TRIGGERED5_Pos) /*!< Bit mask of TRIGGERED5 field. */
++#define EGU_INTENCLR_TRIGGERED5_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED5_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED5_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event TRIGGERED[4] */
++#define EGU_INTENCLR_TRIGGERED4_Pos (4UL) /*!< Position of TRIGGERED4 field. */
++#define EGU_INTENCLR_TRIGGERED4_Msk (0x1UL << EGU_INTENCLR_TRIGGERED4_Pos) /*!< Bit mask of TRIGGERED4 field. */
++#define EGU_INTENCLR_TRIGGERED4_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED4_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED4_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event TRIGGERED[3] */
++#define EGU_INTENCLR_TRIGGERED3_Pos (3UL) /*!< Position of TRIGGERED3 field. */
++#define EGU_INTENCLR_TRIGGERED3_Msk (0x1UL << EGU_INTENCLR_TRIGGERED3_Pos) /*!< Bit mask of TRIGGERED3 field. */
++#define EGU_INTENCLR_TRIGGERED3_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED3_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED3_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event TRIGGERED[2] */
++#define EGU_INTENCLR_TRIGGERED2_Pos (2UL) /*!< Position of TRIGGERED2 field. */
++#define EGU_INTENCLR_TRIGGERED2_Msk (0x1UL << EGU_INTENCLR_TRIGGERED2_Pos) /*!< Bit mask of TRIGGERED2 field. */
++#define EGU_INTENCLR_TRIGGERED2_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED2_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED2_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event TRIGGERED[1] */
++#define EGU_INTENCLR_TRIGGERED1_Pos (1UL) /*!< Position of TRIGGERED1 field. */
++#define EGU_INTENCLR_TRIGGERED1_Msk (0x1UL << EGU_INTENCLR_TRIGGERED1_Pos) /*!< Bit mask of TRIGGERED1 field. */
++#define EGU_INTENCLR_TRIGGERED1_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED1_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED1_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event TRIGGERED[0] */
++#define EGU_INTENCLR_TRIGGERED0_Pos (0UL) /*!< Position of TRIGGERED0 field. */
++#define EGU_INTENCLR_TRIGGERED0_Msk (0x1UL << EGU_INTENCLR_TRIGGERED0_Pos) /*!< Bit mask of TRIGGERED0 field. */
++#define EGU_INTENCLR_TRIGGERED0_Disabled (0UL) /*!< Read: Disabled */
++#define EGU_INTENCLR_TRIGGERED0_Enabled (1UL) /*!< Read: Enabled */
++#define EGU_INTENCLR_TRIGGERED0_Clear (1UL) /*!< Disable */
++
++
++/* Peripheral: FICR */
++/* Description: Factory information configuration registers */
++
++/* Register: FICR_CODEPAGESIZE */
++/* Description: Code memory page size */
++
++/* Bits 31..0 : Code memory page size */
++#define FICR_CODEPAGESIZE_CODEPAGESIZE_Pos (0UL) /*!< Position of CODEPAGESIZE field. */
++#define FICR_CODEPAGESIZE_CODEPAGESIZE_Msk (0xFFFFFFFFUL << FICR_CODEPAGESIZE_CODEPAGESIZE_Pos) /*!< Bit mask of CODEPAGESIZE field. */
++
++/* Register: FICR_CODESIZE */
++/* Description: Code memory size */
++
++/* Bits 31..0 : Code memory size in number of pages */
++#define FICR_CODESIZE_CODESIZE_Pos (0UL) /*!< Position of CODESIZE field. */
++#define FICR_CODESIZE_CODESIZE_Msk (0xFFFFFFFFUL << FICR_CODESIZE_CODESIZE_Pos) /*!< Bit mask of CODESIZE field. */
++
++/* Register: FICR_DEVICEID */
++/* Description: Description collection: Device identifier */
++
++/* Bits 31..0 : 64 bit unique device identifier */
++#define FICR_DEVICEID_DEVICEID_Pos (0UL) /*!< Position of DEVICEID field. */
++#define FICR_DEVICEID_DEVICEID_Msk (0xFFFFFFFFUL << FICR_DEVICEID_DEVICEID_Pos) /*!< Bit mask of DEVICEID field. */
++
++/* Register: FICR_ER */
++/* Description: Description collection: Encryption root, word n */
++
++/* Bits 31..0 : Encryption root, word n */
++#define FICR_ER_ER_Pos (0UL) /*!< Position of ER field. */
++#define FICR_ER_ER_Msk (0xFFFFFFFFUL << FICR_ER_ER_Pos) /*!< Bit mask of ER field. */
++
++/* Register: FICR_IR */
++/* Description: Description collection: Identity Root, word n */
++
++/* Bits 31..0 : Identity Root, word n */
++#define FICR_IR_IR_Pos (0UL) /*!< Position of IR field. */
++#define FICR_IR_IR_Msk (0xFFFFFFFFUL << FICR_IR_IR_Pos) /*!< Bit mask of IR field. */
++
++/* Register: FICR_DEVICEADDRTYPE */
++/* Description: Device address type */
++
++/* Bit 0 : Device address type */
++#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos (0UL) /*!< Position of DEVICEADDRTYPE field. */
++#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk (0x1UL << FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos) /*!< Bit mask of DEVICEADDRTYPE field. */
++#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public (0UL) /*!< Public address */
++#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random (1UL) /*!< Random address */
++
++/* Register: FICR_DEVICEADDR */
++/* Description: Description collection: Device address n */
++
++/* Bits 31..0 : 48 bit device address */
++#define FICR_DEVICEADDR_DEVICEADDR_Pos (0UL) /*!< Position of DEVICEADDR field. */
++#define FICR_DEVICEADDR_DEVICEADDR_Msk (0xFFFFFFFFUL << FICR_DEVICEADDR_DEVICEADDR_Pos) /*!< Bit mask of DEVICEADDR field. */
++
++/* Register: FICR_INFO_PART */
++/* Description: Part code */
++
++/* Bits 31..0 : Part code */
++#define FICR_INFO_PART_PART_Pos (0UL) /*!< Position of PART field. */
++#define FICR_INFO_PART_PART_Msk (0xFFFFFFFFUL << FICR_INFO_PART_PART_Pos) /*!< Bit mask of PART field. */
++#define FICR_INFO_PART_PART_N52820 (0x52820UL) /*!< nRF52820 */
++#define FICR_INFO_PART_PART_N52833 (0x52833UL) /*!< nRF52833 */
++#define FICR_INFO_PART_PART_N52840 (0x52840UL) /*!< nRF52840 */
++#define FICR_INFO_PART_PART_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
++
++/* Register: FICR_INFO_VARIANT */
++/* Description: Build code (hardware version and production configuration) */
++
++/* Bits 31..0 : Build code (hardware version and production configuration). Encoded as ASCII. */
++#define FICR_INFO_VARIANT_VARIANT_Pos (0UL) /*!< Position of VARIANT field. */
++#define FICR_INFO_VARIANT_VARIANT_Msk (0xFFFFFFFFUL << FICR_INFO_VARIANT_VARIANT_Pos) /*!< Bit mask of VARIANT field. */
++#define FICR_INFO_VARIANT_VARIANT_AAAA (0x41414141UL) /*!< AAAA */
++#define FICR_INFO_VARIANT_VARIANT_AAAB (0x41414142UL) /*!< AAAB */
++#define FICR_INFO_VARIANT_VARIANT_AABA (0x41414241UL) /*!< AABA */
++#define FICR_INFO_VARIANT_VARIANT_AABB (0x41414242UL) /*!< AABB */
++#define FICR_INFO_VARIANT_VARIANT_AAC0 (0x41414330UL) /*!< AAC0 */
++#define FICR_INFO_VARIANT_VARIANT_AACA (0x41414341UL) /*!< AACA */
++#define FICR_INFO_VARIANT_VARIANT_AAD0 (0x41414430UL) /*!< AAD0 */
++#define FICR_INFO_VARIANT_VARIANT_AAD1 (0x41414431UL) /*!< AAD1 */
++#define FICR_INFO_VARIANT_VARIANT_AADA (0x41414441UL) /*!< AADA */
++#define FICR_INFO_VARIANT_VARIANT_AAEA (0x41414541UL) /*!< AAEA */
++#define FICR_INFO_VARIANT_VARIANT_BAAA (0x42414141UL) /*!< BAAA */
++#define FICR_INFO_VARIANT_VARIANT_CAAA (0x43414141UL) /*!< CAAA */
++#define FICR_INFO_VARIANT_VARIANT_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
++
++/* Register: FICR_INFO_PACKAGE */
++/* Description: Package option */
++
++/* Bits 31..0 : Package option */
++#define FICR_INFO_PACKAGE_PACKAGE_Pos (0UL) /*!< Position of PACKAGE field. */
++#define FICR_INFO_PACKAGE_PACKAGE_Msk (0xFFFFFFFFUL << FICR_INFO_PACKAGE_PACKAGE_Pos) /*!< Bit mask of PACKAGE field. */
++#define FICR_INFO_PACKAGE_PACKAGE_QI (0x2004UL) /*!< QIxx - 7x7 73-pin aQFN */
++#define FICR_INFO_PACKAGE_PACKAGE_CK (0x2005UL) /*!< CKxx - 3.544 x 3.607 WLCSP */
++#define FICR_INFO_PACKAGE_PACKAGE_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
++
++/* Register: FICR_INFO_RAM */
++/* Description: RAM variant */
++
++/* Bits 31..0 : RAM variant */
++#define FICR_INFO_RAM_RAM_Pos (0UL) /*!< Position of RAM field. */
++#define FICR_INFO_RAM_RAM_Msk (0xFFFFFFFFUL << FICR_INFO_RAM_RAM_Pos) /*!< Bit mask of RAM field. */
++#define FICR_INFO_RAM_RAM_K16 (0x10UL) /*!< 16 kByte RAM */
++#define FICR_INFO_RAM_RAM_K32 (0x20UL) /*!< 32 kByte RAM */
++#define FICR_INFO_RAM_RAM_K64 (0x40UL) /*!< 64 kByte RAM */
++#define FICR_INFO_RAM_RAM_K128 (0x80UL) /*!< 128 kByte RAM */
++#define FICR_INFO_RAM_RAM_K256 (0x100UL) /*!< 256 kByte RAM */
++#define FICR_INFO_RAM_RAM_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
++
++/* Register: FICR_INFO_FLASH */
++/* Description: Flash variant */
++
++/* Bits 31..0 : Flash variant */
++#define FICR_INFO_FLASH_FLASH_Pos (0UL) /*!< Position of FLASH field. */
++#define FICR_INFO_FLASH_FLASH_Msk (0xFFFFFFFFUL << FICR_INFO_FLASH_FLASH_Pos) /*!< Bit mask of FLASH field. */
++#define FICR_INFO_FLASH_FLASH_K128 (0x80UL) /*!< 128 kByte FLASH */
++#define FICR_INFO_FLASH_FLASH_K256 (0x100UL) /*!< 256 kByte FLASH */
++#define FICR_INFO_FLASH_FLASH_K512 (0x200UL) /*!< 512 kByte FLASH */
++#define FICR_INFO_FLASH_FLASH_K1024 (0x400UL) /*!< 1 MByte FLASH */
++#define FICR_INFO_FLASH_FLASH_K2048 (0x800UL) /*!< 2 MByte FLASH */
++#define FICR_INFO_FLASH_FLASH_Unspecified (0xFFFFFFFFUL) /*!< Unspecified */
++
++/* Register: FICR_PRODTEST */
++/* Description: Description collection: Production test signature n */
++
++/* Bits 31..0 : Production test signature n */
++#define FICR_PRODTEST_PRODTEST_Pos (0UL) /*!< Position of PRODTEST field. */
++#define FICR_PRODTEST_PRODTEST_Msk (0xFFFFFFFFUL << FICR_PRODTEST_PRODTEST_Pos) /*!< Bit mask of PRODTEST field. */
++#define FICR_PRODTEST_PRODTEST_Done (0xBB42319FUL) /*!< Production tests done */
++#define FICR_PRODTEST_PRODTEST_NotDone (0xFFFFFFFFUL) /*!< Production tests not done */
++
++/* Register: FICR_TEMP_A0 */
++/* Description: Slope definition A0 */
++
++/* Bits 11..0 : A (slope definition) register. */
++#define FICR_TEMP_A0_A_Pos (0UL) /*!< Position of A field. */
++#define FICR_TEMP_A0_A_Msk (0xFFFUL << FICR_TEMP_A0_A_Pos) /*!< Bit mask of A field. */
++
++/* Register: FICR_TEMP_A1 */
++/* Description: Slope definition A1 */
++
++/* Bits 11..0 : A (slope definition) register. */
++#define FICR_TEMP_A1_A_Pos (0UL) /*!< Position of A field. */
++#define FICR_TEMP_A1_A_Msk (0xFFFUL << FICR_TEMP_A1_A_Pos) /*!< Bit mask of A field. */
++
++/* Register: FICR_TEMP_A2 */
++/* Description: Slope definition A2 */
++
++/* Bits 11..0 : A (slope definition) register. */
++#define FICR_TEMP_A2_A_Pos (0UL) /*!< Position of A field. */
++#define FICR_TEMP_A2_A_Msk (0xFFFUL << FICR_TEMP_A2_A_Pos) /*!< Bit mask of A field. */
++
++/* Register: FICR_TEMP_A3 */
++/* Description: Slope definition A3 */
++
++/* Bits 11..0 : A (slope definition) register. */
++#define FICR_TEMP_A3_A_Pos (0UL) /*!< Position of A field. */
++#define FICR_TEMP_A3_A_Msk (0xFFFUL << FICR_TEMP_A3_A_Pos) /*!< Bit mask of A field. */
++
++/* Register: FICR_TEMP_A4 */
++/* Description: Slope definition A4 */
++
++/* Bits 11..0 : A (slope definition) register. */
++#define FICR_TEMP_A4_A_Pos (0UL) /*!< Position of A field. */
++#define FICR_TEMP_A4_A_Msk (0xFFFUL << FICR_TEMP_A4_A_Pos) /*!< Bit mask of A field. */
++
++/* Register: FICR_TEMP_A5 */
++/* Description: Slope definition A5 */
++
++/* Bits 11..0 : A (slope definition) register. */
++#define FICR_TEMP_A5_A_Pos (0UL) /*!< Position of A field. */
++#define FICR_TEMP_A5_A_Msk (0xFFFUL << FICR_TEMP_A5_A_Pos) /*!< Bit mask of A field. */
++
++/* Register: FICR_TEMP_B0 */
++/* Description: Y-intercept B0 */
++
++/* Bits 13..0 : B (y-intercept) */
++#define FICR_TEMP_B0_B_Pos (0UL) /*!< Position of B field. */
++#define FICR_TEMP_B0_B_Msk (0x3FFFUL << FICR_TEMP_B0_B_Pos) /*!< Bit mask of B field. */
++
++/* Register: FICR_TEMP_B1 */
++/* Description: Y-intercept B1 */
++
++/* Bits 13..0 : B (y-intercept) */
++#define FICR_TEMP_B1_B_Pos (0UL) /*!< Position of B field. */
++#define FICR_TEMP_B1_B_Msk (0x3FFFUL << FICR_TEMP_B1_B_Pos) /*!< Bit mask of B field. */
++
++/* Register: FICR_TEMP_B2 */
++/* Description: Y-intercept B2 */
++
++/* Bits 13..0 : B (y-intercept) */
++#define FICR_TEMP_B2_B_Pos (0UL) /*!< Position of B field. */
++#define FICR_TEMP_B2_B_Msk (0x3FFFUL << FICR_TEMP_B2_B_Pos) /*!< Bit mask of B field. */
++
++/* Register: FICR_TEMP_B3 */
++/* Description: Y-intercept B3 */
++
++/* Bits 13..0 : B (y-intercept) */
++#define FICR_TEMP_B3_B_Pos (0UL) /*!< Position of B field. */
++#define FICR_TEMP_B3_B_Msk (0x3FFFUL << FICR_TEMP_B3_B_Pos) /*!< Bit mask of B field. */
++
++/* Register: FICR_TEMP_B4 */
++/* Description: Y-intercept B4 */
++
++/* Bits 13..0 : B (y-intercept) */
++#define FICR_TEMP_B4_B_Pos (0UL) /*!< Position of B field. */
++#define FICR_TEMP_B4_B_Msk (0x3FFFUL << FICR_TEMP_B4_B_Pos) /*!< Bit mask of B field. */
++
++/* Register: FICR_TEMP_B5 */
++/* Description: Y-intercept B5 */
++
++/* Bits 13..0 : B (y-intercept) */
++#define FICR_TEMP_B5_B_Pos (0UL) /*!< Position of B field. */
++#define FICR_TEMP_B5_B_Msk (0x3FFFUL << FICR_TEMP_B5_B_Pos) /*!< Bit mask of B field. */
++
++/* Register: FICR_TEMP_T0 */
++/* Description: Segment end T0 */
++
++/* Bits 7..0 : T (segment end) register */
++#define FICR_TEMP_T0_T_Pos (0UL) /*!< Position of T field. */
++#define FICR_TEMP_T0_T_Msk (0xFFUL << FICR_TEMP_T0_T_Pos) /*!< Bit mask of T field. */
++
++/* Register: FICR_TEMP_T1 */
++/* Description: Segment end T1 */
++
++/* Bits 7..0 : T (segment end) register */
++#define FICR_TEMP_T1_T_Pos (0UL) /*!< Position of T field. */
++#define FICR_TEMP_T1_T_Msk (0xFFUL << FICR_TEMP_T1_T_Pos) /*!< Bit mask of T field. */
++
++/* Register: FICR_TEMP_T2 */
++/* Description: Segment end T2 */
++
++/* Bits 7..0 : T (segment end) register */
++#define FICR_TEMP_T2_T_Pos (0UL) /*!< Position of T field. */
++#define FICR_TEMP_T2_T_Msk (0xFFUL << FICR_TEMP_T2_T_Pos) /*!< Bit mask of T field. */
++
++/* Register: FICR_TEMP_T3 */
++/* Description: Segment end T3 */
++
++/* Bits 7..0 : T (segment end) register */
++#define FICR_TEMP_T3_T_Pos (0UL) /*!< Position of T field. */
++#define FICR_TEMP_T3_T_Msk (0xFFUL << FICR_TEMP_T3_T_Pos) /*!< Bit mask of T field. */
++
++/* Register: FICR_TEMP_T4 */
++/* Description: Segment end T4 */
++
++/* Bits 7..0 : T (segment end) register */
++#define FICR_TEMP_T4_T_Pos (0UL) /*!< Position of T field. */
++#define FICR_TEMP_T4_T_Msk (0xFFUL << FICR_TEMP_T4_T_Pos) /*!< Bit mask of T field. */
++
++/* Register: FICR_NFC_TAGHEADER0 */
++/* Description: Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST. */
++
++/* Bits 31..24 : Unique identifier byte 3 */
++#define FICR_NFC_TAGHEADER0_UD3_Pos (24UL) /*!< Position of UD3 field. */
++#define FICR_NFC_TAGHEADER0_UD3_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD3_Pos) /*!< Bit mask of UD3 field. */
++
++/* Bits 23..16 : Unique identifier byte 2 */
++#define FICR_NFC_TAGHEADER0_UD2_Pos (16UL) /*!< Position of UD2 field. */
++#define FICR_NFC_TAGHEADER0_UD2_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD2_Pos) /*!< Bit mask of UD2 field. */
++
++/* Bits 15..8 : Unique identifier byte 1 */
++#define FICR_NFC_TAGHEADER0_UD1_Pos (8UL) /*!< Position of UD1 field. */
++#define FICR_NFC_TAGHEADER0_UD1_Msk (0xFFUL << FICR_NFC_TAGHEADER0_UD1_Pos) /*!< Bit mask of UD1 field. */
++
++/* Bits 7..0 : Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F */
++#define FICR_NFC_TAGHEADER0_MFGID_Pos (0UL) /*!< Position of MFGID field. */
++#define FICR_NFC_TAGHEADER0_MFGID_Msk (0xFFUL << FICR_NFC_TAGHEADER0_MFGID_Pos) /*!< Bit mask of MFGID field. */
++
++/* Register: FICR_NFC_TAGHEADER1 */
++/* Description: Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST. */
++
++/* Bits 31..24 : Unique identifier byte 7 */
++#define FICR_NFC_TAGHEADER1_UD7_Pos (24UL) /*!< Position of UD7 field. */
++#define FICR_NFC_TAGHEADER1_UD7_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD7_Pos) /*!< Bit mask of UD7 field. */
++
++/* Bits 23..16 : Unique identifier byte 6 */
++#define FICR_NFC_TAGHEADER1_UD6_Pos (16UL) /*!< Position of UD6 field. */
++#define FICR_NFC_TAGHEADER1_UD6_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD6_Pos) /*!< Bit mask of UD6 field. */
++
++/* Bits 15..8 : Unique identifier byte 5 */
++#define FICR_NFC_TAGHEADER1_UD5_Pos (8UL) /*!< Position of UD5 field. */
++#define FICR_NFC_TAGHEADER1_UD5_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD5_Pos) /*!< Bit mask of UD5 field. */
++
++/* Bits 7..0 : Unique identifier byte 4 */
++#define FICR_NFC_TAGHEADER1_UD4_Pos (0UL) /*!< Position of UD4 field. */
++#define FICR_NFC_TAGHEADER1_UD4_Msk (0xFFUL << FICR_NFC_TAGHEADER1_UD4_Pos) /*!< Bit mask of UD4 field. */
++
++/* Register: FICR_NFC_TAGHEADER2 */
++/* Description: Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST. */
++
++/* Bits 31..24 : Unique identifier byte 11 */
++#define FICR_NFC_TAGHEADER2_UD11_Pos (24UL) /*!< Position of UD11 field. */
++#define FICR_NFC_TAGHEADER2_UD11_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD11_Pos) /*!< Bit mask of UD11 field. */
++
++/* Bits 23..16 : Unique identifier byte 10 */
++#define FICR_NFC_TAGHEADER2_UD10_Pos (16UL) /*!< Position of UD10 field. */
++#define FICR_NFC_TAGHEADER2_UD10_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD10_Pos) /*!< Bit mask of UD10 field. */
++
++/* Bits 15..8 : Unique identifier byte 9 */
++#define FICR_NFC_TAGHEADER2_UD9_Pos (8UL) /*!< Position of UD9 field. */
++#define FICR_NFC_TAGHEADER2_UD9_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD9_Pos) /*!< Bit mask of UD9 field. */
++
++/* Bits 7..0 : Unique identifier byte 8 */
++#define FICR_NFC_TAGHEADER2_UD8_Pos (0UL) /*!< Position of UD8 field. */
++#define FICR_NFC_TAGHEADER2_UD8_Msk (0xFFUL << FICR_NFC_TAGHEADER2_UD8_Pos) /*!< Bit mask of UD8 field. */
++
++/* Register: FICR_NFC_TAGHEADER3 */
++/* Description: Default header for NFC tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST, and NFCID1_LAST. */
++
++/* Bits 31..24 : Unique identifier byte 15 */
++#define FICR_NFC_TAGHEADER3_UD15_Pos (24UL) /*!< Position of UD15 field. */
++#define FICR_NFC_TAGHEADER3_UD15_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD15_Pos) /*!< Bit mask of UD15 field. */
++
++/* Bits 23..16 : Unique identifier byte 14 */
++#define FICR_NFC_TAGHEADER3_UD14_Pos (16UL) /*!< Position of UD14 field. */
++#define FICR_NFC_TAGHEADER3_UD14_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD14_Pos) /*!< Bit mask of UD14 field. */
++
++/* Bits 15..8 : Unique identifier byte 13 */
++#define FICR_NFC_TAGHEADER3_UD13_Pos (8UL) /*!< Position of UD13 field. */
++#define FICR_NFC_TAGHEADER3_UD13_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD13_Pos) /*!< Bit mask of UD13 field. */
++
++/* Bits 7..0 : Unique identifier byte 12 */
++#define FICR_NFC_TAGHEADER3_UD12_Pos (0UL) /*!< Position of UD12 field. */
++#define FICR_NFC_TAGHEADER3_UD12_Msk (0xFFUL << FICR_NFC_TAGHEADER3_UD12_Pos) /*!< Bit mask of UD12 field. */
++
++/* Register: FICR_TRNG90B_BYTES */
++/* Description: Amount of bytes for the required entropy bits */
++
++/* Bits 31..0 : Amount of bytes for the required entropy bits */
++#define FICR_TRNG90B_BYTES_BYTES_Pos (0UL) /*!< Position of BYTES field. */
++#define FICR_TRNG90B_BYTES_BYTES_Msk (0xFFFFFFFFUL << FICR_TRNG90B_BYTES_BYTES_Pos) /*!< Bit mask of BYTES field. */
++
++/* Register: FICR_TRNG90B_RCCUTOFF */
++/* Description: Repetition counter cutoff */
++
++/* Bits 31..0 : Repetition counter cutoff */
++#define FICR_TRNG90B_RCCUTOFF_RCCUTOFF_Pos (0UL) /*!< Position of RCCUTOFF field. */
++#define FICR_TRNG90B_RCCUTOFF_RCCUTOFF_Msk (0xFFFFFFFFUL << FICR_TRNG90B_RCCUTOFF_RCCUTOFF_Pos) /*!< Bit mask of RCCUTOFF field. */
++
++/* Register: FICR_TRNG90B_APCUTOFF */
++/* Description: Adaptive proportion cutoff */
++
++/* Bits 31..0 : Adaptive proportion cutoff */
++#define FICR_TRNG90B_APCUTOFF_APCUTOFF_Pos (0UL) /*!< Position of APCUTOFF field. */
++#define FICR_TRNG90B_APCUTOFF_APCUTOFF_Msk (0xFFFFFFFFUL << FICR_TRNG90B_APCUTOFF_APCUTOFF_Pos) /*!< Bit mask of APCUTOFF field. */
++
++/* Register: FICR_TRNG90B_STARTUP */
++/* Description: Amount of bytes for the startup tests */
++
++/* Bits 31..0 : Amount of bytes for the startup tests */
++#define FICR_TRNG90B_STARTUP_STARTUP_Pos (0UL) /*!< Position of STARTUP field. */
++#define FICR_TRNG90B_STARTUP_STARTUP_Msk (0xFFFFFFFFUL << FICR_TRNG90B_STARTUP_STARTUP_Pos) /*!< Bit mask of STARTUP field. */
++
++/* Register: FICR_TRNG90B_ROSC1 */
++/* Description: Sample count for ring oscillator 1 */
++
++/* Bits 31..0 : Sample count for ring oscillator 1 */
++#define FICR_TRNG90B_ROSC1_ROSC1_Pos (0UL) /*!< Position of ROSC1 field. */
++#define FICR_TRNG90B_ROSC1_ROSC1_Msk (0xFFFFFFFFUL << FICR_TRNG90B_ROSC1_ROSC1_Pos) /*!< Bit mask of ROSC1 field. */
++
++/* Register: FICR_TRNG90B_ROSC2 */
++/* Description: Sample count for ring oscillator 2 */
++
++/* Bits 31..0 : Sample count for ring oscillator 2 */
++#define FICR_TRNG90B_ROSC2_ROSC2_Pos (0UL) /*!< Position of ROSC2 field. */
++#define FICR_TRNG90B_ROSC2_ROSC2_Msk (0xFFFFFFFFUL << FICR_TRNG90B_ROSC2_ROSC2_Pos) /*!< Bit mask of ROSC2 field. */
++
++/* Register: FICR_TRNG90B_ROSC3 */
++/* Description: Sample count for ring oscillator 3 */
++
++/* Bits 31..0 : Sample count for ring oscillator 3 */
++#define FICR_TRNG90B_ROSC3_ROSC3_Pos (0UL) /*!< Position of ROSC3 field. */
++#define FICR_TRNG90B_ROSC3_ROSC3_Msk (0xFFFFFFFFUL << FICR_TRNG90B_ROSC3_ROSC3_Pos) /*!< Bit mask of ROSC3 field. */
++
++/* Register: FICR_TRNG90B_ROSC4 */
++/* Description: Sample count for ring oscillator 4 */
++
++/* Bits 31..0 : Sample count for ring oscillator 4 */
++#define FICR_TRNG90B_ROSC4_ROSC4_Pos (0UL) /*!< Position of ROSC4 field. */
++#define FICR_TRNG90B_ROSC4_ROSC4_Msk (0xFFFFFFFFUL << FICR_TRNG90B_ROSC4_ROSC4_Pos) /*!< Bit mask of ROSC4 field. */
++
++
++/* Peripheral: GPIOTE */
++/* Description: GPIO Tasks and Events */
++
++/* Register: GPIOTE_TASKS_OUT */
++/* Description: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY. */
++
++/* Bit 0 : Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is configured in CONFIG[n].POLARITY. */
++#define GPIOTE_TASKS_OUT_TASKS_OUT_Pos (0UL) /*!< Position of TASKS_OUT field. */
++#define GPIOTE_TASKS_OUT_TASKS_OUT_Msk (0x1UL << GPIOTE_TASKS_OUT_TASKS_OUT_Pos) /*!< Bit mask of TASKS_OUT field. */
++#define GPIOTE_TASKS_OUT_TASKS_OUT_Trigger (1UL) /*!< Trigger task */
++
++/* Register: GPIOTE_TASKS_SET */
++/* Description: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high. */
++
++/* Bit 0 : Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it high. */
++#define GPIOTE_TASKS_SET_TASKS_SET_Pos (0UL) /*!< Position of TASKS_SET field. */
++#define GPIOTE_TASKS_SET_TASKS_SET_Msk (0x1UL << GPIOTE_TASKS_SET_TASKS_SET_Pos) /*!< Bit mask of TASKS_SET field. */
++#define GPIOTE_TASKS_SET_TASKS_SET_Trigger (1UL) /*!< Trigger task */
++
++/* Register: GPIOTE_TASKS_CLR */
++/* Description: Description collection: Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low. */
++
++/* Bit 0 : Task for writing to pin specified in CONFIG[n].PSEL. Action on pin is to set it low. */
++#define GPIOTE_TASKS_CLR_TASKS_CLR_Pos (0UL) /*!< Position of TASKS_CLR field. */
++#define GPIOTE_TASKS_CLR_TASKS_CLR_Msk (0x1UL << GPIOTE_TASKS_CLR_TASKS_CLR_Pos) /*!< Bit mask of TASKS_CLR field. */
++#define GPIOTE_TASKS_CLR_TASKS_CLR_Trigger (1UL) /*!< Trigger task */
++
++/* Register: GPIOTE_EVENTS_IN */
++/* Description: Description collection: Event generated from pin specified in CONFIG[n].PSEL */
++
++/* Bit 0 : Event generated from pin specified in CONFIG[n].PSEL */
++#define GPIOTE_EVENTS_IN_EVENTS_IN_Pos (0UL) /*!< Position of EVENTS_IN field. */
++#define GPIOTE_EVENTS_IN_EVENTS_IN_Msk (0x1UL << GPIOTE_EVENTS_IN_EVENTS_IN_Pos) /*!< Bit mask of EVENTS_IN field. */
++#define GPIOTE_EVENTS_IN_EVENTS_IN_NotGenerated (0UL) /*!< Event not generated */
++#define GPIOTE_EVENTS_IN_EVENTS_IN_Generated (1UL) /*!< Event generated */
++
++/* Register: GPIOTE_EVENTS_PORT */
++/* Description: Event generated from multiple input GPIO pins with SENSE mechanism enabled */
++
++/* Bit 0 : Event generated from multiple input GPIO pins with SENSE mechanism enabled */
++#define GPIOTE_EVENTS_PORT_EVENTS_PORT_Pos (0UL) /*!< Position of EVENTS_PORT field. */
++#define GPIOTE_EVENTS_PORT_EVENTS_PORT_Msk (0x1UL << GPIOTE_EVENTS_PORT_EVENTS_PORT_Pos) /*!< Bit mask of EVENTS_PORT field. */
++#define GPIOTE_EVENTS_PORT_EVENTS_PORT_NotGenerated (0UL) /*!< Event not generated */
++#define GPIOTE_EVENTS_PORT_EVENTS_PORT_Generated (1UL) /*!< Event generated */
++
++/* Register: GPIOTE_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 31 : Write '1' to enable interrupt for event PORT */
++#define GPIOTE_INTENSET_PORT_Pos (31UL) /*!< Position of PORT field. */
++#define GPIOTE_INTENSET_PORT_Msk (0x1UL << GPIOTE_INTENSET_PORT_Pos) /*!< Bit mask of PORT field. */
++#define GPIOTE_INTENSET_PORT_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_PORT_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_PORT_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event IN[7] */
++#define GPIOTE_INTENSET_IN7_Pos (7UL) /*!< Position of IN7 field. */
++#define GPIOTE_INTENSET_IN7_Msk (0x1UL << GPIOTE_INTENSET_IN7_Pos) /*!< Bit mask of IN7 field. */
++#define GPIOTE_INTENSET_IN7_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_IN7_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_IN7_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event IN[6] */
++#define GPIOTE_INTENSET_IN6_Pos (6UL) /*!< Position of IN6 field. */
++#define GPIOTE_INTENSET_IN6_Msk (0x1UL << GPIOTE_INTENSET_IN6_Pos) /*!< Bit mask of IN6 field. */
++#define GPIOTE_INTENSET_IN6_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_IN6_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_IN6_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event IN[5] */
++#define GPIOTE_INTENSET_IN5_Pos (5UL) /*!< Position of IN5 field. */
++#define GPIOTE_INTENSET_IN5_Msk (0x1UL << GPIOTE_INTENSET_IN5_Pos) /*!< Bit mask of IN5 field. */
++#define GPIOTE_INTENSET_IN5_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_IN5_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_IN5_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event IN[4] */
++#define GPIOTE_INTENSET_IN4_Pos (4UL) /*!< Position of IN4 field. */
++#define GPIOTE_INTENSET_IN4_Msk (0x1UL << GPIOTE_INTENSET_IN4_Pos) /*!< Bit mask of IN4 field. */
++#define GPIOTE_INTENSET_IN4_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_IN4_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_IN4_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event IN[3] */
++#define GPIOTE_INTENSET_IN3_Pos (3UL) /*!< Position of IN3 field. */
++#define GPIOTE_INTENSET_IN3_Msk (0x1UL << GPIOTE_INTENSET_IN3_Pos) /*!< Bit mask of IN3 field. */
++#define GPIOTE_INTENSET_IN3_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_IN3_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_IN3_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event IN[2] */
++#define GPIOTE_INTENSET_IN2_Pos (2UL) /*!< Position of IN2 field. */
++#define GPIOTE_INTENSET_IN2_Msk (0x1UL << GPIOTE_INTENSET_IN2_Pos) /*!< Bit mask of IN2 field. */
++#define GPIOTE_INTENSET_IN2_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_IN2_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_IN2_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event IN[1] */
++#define GPIOTE_INTENSET_IN1_Pos (1UL) /*!< Position of IN1 field. */
++#define GPIOTE_INTENSET_IN1_Msk (0x1UL << GPIOTE_INTENSET_IN1_Pos) /*!< Bit mask of IN1 field. */
++#define GPIOTE_INTENSET_IN1_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_IN1_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_IN1_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event IN[0] */
++#define GPIOTE_INTENSET_IN0_Pos (0UL) /*!< Position of IN0 field. */
++#define GPIOTE_INTENSET_IN0_Msk (0x1UL << GPIOTE_INTENSET_IN0_Pos) /*!< Bit mask of IN0 field. */
++#define GPIOTE_INTENSET_IN0_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENSET_IN0_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENSET_IN0_Set (1UL) /*!< Enable */
++
++/* Register: GPIOTE_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 31 : Write '1' to disable interrupt for event PORT */
++#define GPIOTE_INTENCLR_PORT_Pos (31UL) /*!< Position of PORT field. */
++#define GPIOTE_INTENCLR_PORT_Msk (0x1UL << GPIOTE_INTENCLR_PORT_Pos) /*!< Bit mask of PORT field. */
++#define GPIOTE_INTENCLR_PORT_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_PORT_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_PORT_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event IN[7] */
++#define GPIOTE_INTENCLR_IN7_Pos (7UL) /*!< Position of IN7 field. */
++#define GPIOTE_INTENCLR_IN7_Msk (0x1UL << GPIOTE_INTENCLR_IN7_Pos) /*!< Bit mask of IN7 field. */
++#define GPIOTE_INTENCLR_IN7_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_IN7_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_IN7_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event IN[6] */
++#define GPIOTE_INTENCLR_IN6_Pos (6UL) /*!< Position of IN6 field. */
++#define GPIOTE_INTENCLR_IN6_Msk (0x1UL << GPIOTE_INTENCLR_IN6_Pos) /*!< Bit mask of IN6 field. */
++#define GPIOTE_INTENCLR_IN6_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_IN6_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_IN6_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event IN[5] */
++#define GPIOTE_INTENCLR_IN5_Pos (5UL) /*!< Position of IN5 field. */
++#define GPIOTE_INTENCLR_IN5_Msk (0x1UL << GPIOTE_INTENCLR_IN5_Pos) /*!< Bit mask of IN5 field. */
++#define GPIOTE_INTENCLR_IN5_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_IN5_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_IN5_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event IN[4] */
++#define GPIOTE_INTENCLR_IN4_Pos (4UL) /*!< Position of IN4 field. */
++#define GPIOTE_INTENCLR_IN4_Msk (0x1UL << GPIOTE_INTENCLR_IN4_Pos) /*!< Bit mask of IN4 field. */
++#define GPIOTE_INTENCLR_IN4_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_IN4_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_IN4_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event IN[3] */
++#define GPIOTE_INTENCLR_IN3_Pos (3UL) /*!< Position of IN3 field. */
++#define GPIOTE_INTENCLR_IN3_Msk (0x1UL << GPIOTE_INTENCLR_IN3_Pos) /*!< Bit mask of IN3 field. */
++#define GPIOTE_INTENCLR_IN3_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_IN3_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_IN3_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event IN[2] */
++#define GPIOTE_INTENCLR_IN2_Pos (2UL) /*!< Position of IN2 field. */
++#define GPIOTE_INTENCLR_IN2_Msk (0x1UL << GPIOTE_INTENCLR_IN2_Pos) /*!< Bit mask of IN2 field. */
++#define GPIOTE_INTENCLR_IN2_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_IN2_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_IN2_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event IN[1] */
++#define GPIOTE_INTENCLR_IN1_Pos (1UL) /*!< Position of IN1 field. */
++#define GPIOTE_INTENCLR_IN1_Msk (0x1UL << GPIOTE_INTENCLR_IN1_Pos) /*!< Bit mask of IN1 field. */
++#define GPIOTE_INTENCLR_IN1_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_IN1_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_IN1_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event IN[0] */
++#define GPIOTE_INTENCLR_IN0_Pos (0UL) /*!< Position of IN0 field. */
++#define GPIOTE_INTENCLR_IN0_Msk (0x1UL << GPIOTE_INTENCLR_IN0_Pos) /*!< Bit mask of IN0 field. */
++#define GPIOTE_INTENCLR_IN0_Disabled (0UL) /*!< Read: Disabled */
++#define GPIOTE_INTENCLR_IN0_Enabled (1UL) /*!< Read: Enabled */
++#define GPIOTE_INTENCLR_IN0_Clear (1UL) /*!< Disable */
++
++/* Register: GPIOTE_CONFIG */
++/* Description: Description collection: Configuration for OUT[n], SET[n], and CLR[n] tasks and IN[n] event */
++
++/* Bit 20 : When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect. */
++#define GPIOTE_CONFIG_OUTINIT_Pos (20UL) /*!< Position of OUTINIT field. */
++#define GPIOTE_CONFIG_OUTINIT_Msk (0x1UL << GPIOTE_CONFIG_OUTINIT_Pos) /*!< Bit mask of OUTINIT field. */
++#define GPIOTE_CONFIG_OUTINIT_Low (0UL) /*!< Task mode: Initial value of pin before task triggering is low */
++#define GPIOTE_CONFIG_OUTINIT_High (1UL) /*!< Task mode: Initial value of pin before task triggering is high */
++
++/* Bits 17..16 : When In task mode: Operation to be performed on output when OUT[n] task is triggered. When In event mode: Operation on input that shall trigger IN[n] event. */
++#define GPIOTE_CONFIG_POLARITY_Pos (16UL) /*!< Position of POLARITY field. */
++#define GPIOTE_CONFIG_POLARITY_Msk (0x3UL << GPIOTE_CONFIG_POLARITY_Pos) /*!< Bit mask of POLARITY field. */
++#define GPIOTE_CONFIG_POLARITY_None (0UL) /*!< Task mode: No effect on pin from OUT[n] task. Event mode: no IN[n] event generated on pin activity. */
++#define GPIOTE_CONFIG_POLARITY_LoToHi (1UL) /*!< Task mode: Set pin from OUT[n] task. Event mode: Generate IN[n] event when rising edge on pin. */
++#define GPIOTE_CONFIG_POLARITY_HiToLo (2UL) /*!< Task mode: Clear pin from OUT[n] task. Event mode: Generate IN[n] event when falling edge on pin. */
++#define GPIOTE_CONFIG_POLARITY_Toggle (3UL) /*!< Task mode: Toggle pin from OUT[n]. Event mode: Generate IN[n] when any change on pin. */
++
++/* Bit 13 : Port number */
++#define GPIOTE_CONFIG_PORT_Pos (13UL) /*!< Position of PORT field. */
++#define GPIOTE_CONFIG_PORT_Msk (0x1UL << GPIOTE_CONFIG_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 12..8 : GPIO number associated with SET[n], CLR[n], and OUT[n] tasks and IN[n] event */
++#define GPIOTE_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
++#define GPIOTE_CONFIG_PSEL_Msk (0x1FUL << GPIOTE_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
++
++/* Bits 1..0 : Mode */
++#define GPIOTE_CONFIG_MODE_Pos (0UL) /*!< Position of MODE field. */
++#define GPIOTE_CONFIG_MODE_Msk (0x3UL << GPIOTE_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
++#define GPIOTE_CONFIG_MODE_Disabled (0UL) /*!< Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module. */
++#define GPIOTE_CONFIG_MODE_Event (1UL) /*!< Event mode */
++#define GPIOTE_CONFIG_MODE_Task (3UL) /*!< Task mode */
++
++
++/* Peripheral: I2S */
++/* Description: Inter-IC Sound */
++
++/* Register: I2S_TASKS_START */
++/* Description: Starts continuous I2S transfer. Also starts MCK generator when this is enabled. */
++
++/* Bit 0 : Starts continuous I2S transfer. Also starts MCK generator when this is enabled. */
++#define I2S_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define I2S_TASKS_START_TASKS_START_Msk (0x1UL << I2S_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define I2S_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: I2S_TASKS_STOP */
++/* Description: Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated. */
++
++/* Bit 0 : Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated. */
++#define I2S_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define I2S_TASKS_STOP_TASKS_STOP_Msk (0x1UL << I2S_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define I2S_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: I2S_EVENTS_RXPTRUPD */
++/* Description: The RXD.PTR register has been copied to internal double-buffers.
++      When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin. */
++
++/* Bit 0 : The RXD.PTR register has been copied to internal double-buffers.
++      When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin. */
++#define I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_Pos (0UL) /*!< Position of EVENTS_RXPTRUPD field. */
++#define I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_Msk (0x1UL << I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_Pos) /*!< Bit mask of EVENTS_RXPTRUPD field. */
++#define I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_NotGenerated (0UL) /*!< Event not generated */
++#define I2S_EVENTS_RXPTRUPD_EVENTS_RXPTRUPD_Generated (1UL) /*!< Event generated */
++
++/* Register: I2S_EVENTS_STOPPED */
++/* Description: I2S transfer stopped. */
++
++/* Bit 0 : I2S transfer stopped. */
++#define I2S_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define I2S_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << I2S_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define I2S_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define I2S_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: I2S_EVENTS_TXPTRUPD */
++/* Description: The TDX.PTR register has been copied to internal double-buffers.
++      When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin. */
++
++/* Bit 0 : The TDX.PTR register has been copied to internal double-buffers.
++      When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin. */
++#define I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_Pos (0UL) /*!< Position of EVENTS_TXPTRUPD field. */
++#define I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_Msk (0x1UL << I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_Pos) /*!< Bit mask of EVENTS_TXPTRUPD field. */
++#define I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_NotGenerated (0UL) /*!< Event not generated */
++#define I2S_EVENTS_TXPTRUPD_EVENTS_TXPTRUPD_Generated (1UL) /*!< Event generated */
++
++/* Register: I2S_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 5 : Enable or disable interrupt for event TXPTRUPD */
++#define I2S_INTEN_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
++#define I2S_INTEN_TXPTRUPD_Msk (0x1UL << I2S_INTEN_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
++#define I2S_INTEN_TXPTRUPD_Disabled (0UL) /*!< Disable */
++#define I2S_INTEN_TXPTRUPD_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event STOPPED */
++#define I2S_INTEN_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
++#define I2S_INTEN_STOPPED_Msk (0x1UL << I2S_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define I2S_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
++#define I2S_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event RXPTRUPD */
++#define I2S_INTEN_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
++#define I2S_INTEN_RXPTRUPD_Msk (0x1UL << I2S_INTEN_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
++#define I2S_INTEN_RXPTRUPD_Disabled (0UL) /*!< Disable */
++#define I2S_INTEN_RXPTRUPD_Enabled (1UL) /*!< Enable */
++
++/* Register: I2S_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 5 : Write '1' to enable interrupt for event TXPTRUPD */
++#define I2S_INTENSET_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
++#define I2S_INTENSET_TXPTRUPD_Msk (0x1UL << I2S_INTENSET_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
++#define I2S_INTENSET_TXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
++#define I2S_INTENSET_TXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
++#define I2S_INTENSET_TXPTRUPD_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event STOPPED */
++#define I2S_INTENSET_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
++#define I2S_INTENSET_STOPPED_Msk (0x1UL << I2S_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define I2S_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define I2S_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define I2S_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event RXPTRUPD */
++#define I2S_INTENSET_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
++#define I2S_INTENSET_RXPTRUPD_Msk (0x1UL << I2S_INTENSET_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
++#define I2S_INTENSET_RXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
++#define I2S_INTENSET_RXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
++#define I2S_INTENSET_RXPTRUPD_Set (1UL) /*!< Enable */
++
++/* Register: I2S_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 5 : Write '1' to disable interrupt for event TXPTRUPD */
++#define I2S_INTENCLR_TXPTRUPD_Pos (5UL) /*!< Position of TXPTRUPD field. */
++#define I2S_INTENCLR_TXPTRUPD_Msk (0x1UL << I2S_INTENCLR_TXPTRUPD_Pos) /*!< Bit mask of TXPTRUPD field. */
++#define I2S_INTENCLR_TXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
++#define I2S_INTENCLR_TXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
++#define I2S_INTENCLR_TXPTRUPD_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event STOPPED */
++#define I2S_INTENCLR_STOPPED_Pos (2UL) /*!< Position of STOPPED field. */
++#define I2S_INTENCLR_STOPPED_Msk (0x1UL << I2S_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define I2S_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define I2S_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define I2S_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event RXPTRUPD */
++#define I2S_INTENCLR_RXPTRUPD_Pos (1UL) /*!< Position of RXPTRUPD field. */
++#define I2S_INTENCLR_RXPTRUPD_Msk (0x1UL << I2S_INTENCLR_RXPTRUPD_Pos) /*!< Bit mask of RXPTRUPD field. */
++#define I2S_INTENCLR_RXPTRUPD_Disabled (0UL) /*!< Read: Disabled */
++#define I2S_INTENCLR_RXPTRUPD_Enabled (1UL) /*!< Read: Enabled */
++#define I2S_INTENCLR_RXPTRUPD_Clear (1UL) /*!< Disable */
++
++/* Register: I2S_ENABLE */
++/* Description: Enable I2S module. */
++
++/* Bit 0 : Enable I2S module. */
++#define I2S_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define I2S_ENABLE_ENABLE_Msk (0x1UL << I2S_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define I2S_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
++#define I2S_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
++
++/* Register: I2S_CONFIG_MODE */
++/* Description: I2S mode. */
++
++/* Bit 0 : I2S mode. */
++#define I2S_CONFIG_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
++#define I2S_CONFIG_MODE_MODE_Msk (0x1UL << I2S_CONFIG_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
++#define I2S_CONFIG_MODE_MODE_Master (0UL) /*!< Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx. */
++#define I2S_CONFIG_MODE_MODE_Slave (1UL) /*!< Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx */
++
++/* Register: I2S_CONFIG_RXEN */
++/* Description: Reception (RX) enable. */
++
++/* Bit 0 : Reception (RX) enable. */
++#define I2S_CONFIG_RXEN_RXEN_Pos (0UL) /*!< Position of RXEN field. */
++#define I2S_CONFIG_RXEN_RXEN_Msk (0x1UL << I2S_CONFIG_RXEN_RXEN_Pos) /*!< Bit mask of RXEN field. */
++#define I2S_CONFIG_RXEN_RXEN_Disabled (0UL) /*!< Reception disabled and now data will be written to the RXD.PTR address. */
++#define I2S_CONFIG_RXEN_RXEN_Enabled (1UL) /*!< Reception enabled. */
++
++/* Register: I2S_CONFIG_TXEN */
++/* Description: Transmission (TX) enable. */
++
++/* Bit 0 : Transmission (TX) enable. */
++#define I2S_CONFIG_TXEN_TXEN_Pos (0UL) /*!< Position of TXEN field. */
++#define I2S_CONFIG_TXEN_TXEN_Msk (0x1UL << I2S_CONFIG_TXEN_TXEN_Pos) /*!< Bit mask of TXEN field. */
++#define I2S_CONFIG_TXEN_TXEN_Disabled (0UL) /*!< Transmission disabled and now data will be read from the RXD.TXD address. */
++#define I2S_CONFIG_TXEN_TXEN_Enabled (1UL) /*!< Transmission enabled. */
++
++/* Register: I2S_CONFIG_MCKEN */
++/* Description: Master clock generator enable. */
++
++/* Bit 0 : Master clock generator enable. */
++#define I2S_CONFIG_MCKEN_MCKEN_Pos (0UL) /*!< Position of MCKEN field. */
++#define I2S_CONFIG_MCKEN_MCKEN_Msk (0x1UL << I2S_CONFIG_MCKEN_MCKEN_Pos) /*!< Bit mask of MCKEN field. */
++#define I2S_CONFIG_MCKEN_MCKEN_Disabled (0UL) /*!< Master clock generator disabled and PSEL.MCK not connected(available as GPIO). */
++#define I2S_CONFIG_MCKEN_MCKEN_Enabled (1UL) /*!< Master clock generator running and MCK output on PSEL.MCK. */
++
++/* Register: I2S_CONFIG_MCKFREQ */
++/* Description: Master clock generator frequency. */
++
++/* Bits 31..0 : Master clock generator frequency. */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_Pos (0UL) /*!< Position of MCKFREQ field. */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_Msk (0xFFFFFFFFUL << I2S_CONFIG_MCKFREQ_MCKFREQ_Pos) /*!< Bit mask of MCKFREQ field. */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV125 (0x020C0000UL) /*!< 32 MHz / 125 = 0.256 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV63 (0x04100000UL) /*!< 32 MHz / 63 = 0.5079365 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV42 (0x06000000UL) /*!< 32 MHz / 42 = 0.7619048 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV32 (0x08000000UL) /*!< 32 MHz / 32 = 1.0 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV31 (0x08400000UL) /*!< 32 MHz / 31 = 1.0322581 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV30 (0x08800000UL) /*!< 32 MHz / 30 = 1.0666667 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV23 (0x0B000000UL) /*!< 32 MHz / 23 = 1.3913043 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV21 (0x0C000000UL) /*!< 32 MHz / 21 = 1.5238095 */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV16 (0x10000000UL) /*!< 32 MHz / 16 = 2.0 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV15 (0x11000000UL) /*!< 32 MHz / 15 = 2.1333333 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV11 (0x16000000UL) /*!< 32 MHz / 11 = 2.9090909 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV10 (0x18000000UL) /*!< 32 MHz / 10 = 3.2 MHz */
++#define I2S_CONFIG_MCKFREQ_MCKFREQ_32MDIV8 (0x20000000UL) /*!< 32 MHz / 8 = 4.0 MHz */
++
++/* Register: I2S_CONFIG_RATIO */
++/* Description: MCK / LRCK ratio. */
++
++/* Bits 3..0 : MCK / LRCK ratio. */
++#define I2S_CONFIG_RATIO_RATIO_Pos (0UL) /*!< Position of RATIO field. */
++#define I2S_CONFIG_RATIO_RATIO_Msk (0xFUL << I2S_CONFIG_RATIO_RATIO_Pos) /*!< Bit mask of RATIO field. */
++#define I2S_CONFIG_RATIO_RATIO_32X (0UL) /*!< LRCK = MCK / 32 */
++#define I2S_CONFIG_RATIO_RATIO_48X (1UL) /*!< LRCK = MCK / 48 */
++#define I2S_CONFIG_RATIO_RATIO_64X (2UL) /*!< LRCK = MCK / 64 */
++#define I2S_CONFIG_RATIO_RATIO_96X (3UL) /*!< LRCK = MCK / 96 */
++#define I2S_CONFIG_RATIO_RATIO_128X (4UL) /*!< LRCK = MCK / 128 */
++#define I2S_CONFIG_RATIO_RATIO_192X (5UL) /*!< LRCK = MCK / 192 */
++#define I2S_CONFIG_RATIO_RATIO_256X (6UL) /*!< LRCK = MCK / 256 */
++#define I2S_CONFIG_RATIO_RATIO_384X (7UL) /*!< LRCK = MCK / 384 */
++#define I2S_CONFIG_RATIO_RATIO_512X (8UL) /*!< LRCK = MCK / 512 */
++
++/* Register: I2S_CONFIG_SWIDTH */
++/* Description: Sample width. */
++
++/* Bits 1..0 : Sample width. */
++#define I2S_CONFIG_SWIDTH_SWIDTH_Pos (0UL) /*!< Position of SWIDTH field. */
++#define I2S_CONFIG_SWIDTH_SWIDTH_Msk (0x3UL << I2S_CONFIG_SWIDTH_SWIDTH_Pos) /*!< Bit mask of SWIDTH field. */
++#define I2S_CONFIG_SWIDTH_SWIDTH_8Bit (0UL) /*!< 8 bit. */
++#define I2S_CONFIG_SWIDTH_SWIDTH_16Bit (1UL) /*!< 16 bit. */
++#define I2S_CONFIG_SWIDTH_SWIDTH_24Bit (2UL) /*!< 24 bit. */
++
++/* Register: I2S_CONFIG_ALIGN */
++/* Description: Alignment of sample within a frame. */
++
++/* Bit 0 : Alignment of sample within a frame. */
++#define I2S_CONFIG_ALIGN_ALIGN_Pos (0UL) /*!< Position of ALIGN field. */
++#define I2S_CONFIG_ALIGN_ALIGN_Msk (0x1UL << I2S_CONFIG_ALIGN_ALIGN_Pos) /*!< Bit mask of ALIGN field. */
++#define I2S_CONFIG_ALIGN_ALIGN_Left (0UL) /*!< Left-aligned. */
++#define I2S_CONFIG_ALIGN_ALIGN_Right (1UL) /*!< Right-aligned. */
++
++/* Register: I2S_CONFIG_FORMAT */
++/* Description: Frame format. */
++
++/* Bit 0 : Frame format. */
++#define I2S_CONFIG_FORMAT_FORMAT_Pos (0UL) /*!< Position of FORMAT field. */
++#define I2S_CONFIG_FORMAT_FORMAT_Msk (0x1UL << I2S_CONFIG_FORMAT_FORMAT_Pos) /*!< Bit mask of FORMAT field. */
++#define I2S_CONFIG_FORMAT_FORMAT_I2S (0UL) /*!< Original I2S format. */
++#define I2S_CONFIG_FORMAT_FORMAT_Aligned (1UL) /*!< Alternate (left- or right-aligned) format. */
++
++/* Register: I2S_CONFIG_CHANNELS */
++/* Description: Enable channels. */
++
++/* Bits 1..0 : Enable channels. */
++#define I2S_CONFIG_CHANNELS_CHANNELS_Pos (0UL) /*!< Position of CHANNELS field. */
++#define I2S_CONFIG_CHANNELS_CHANNELS_Msk (0x3UL << I2S_CONFIG_CHANNELS_CHANNELS_Pos) /*!< Bit mask of CHANNELS field. */
++#define I2S_CONFIG_CHANNELS_CHANNELS_Stereo (0UL) /*!< Stereo. */
++#define I2S_CONFIG_CHANNELS_CHANNELS_Left (1UL) /*!< Left only. */
++#define I2S_CONFIG_CHANNELS_CHANNELS_Right (2UL) /*!< Right only. */
++
++/* Register: I2S_RXD_PTR */
++/* Description: Receive buffer RAM start address. */
++
++/* Bits 31..0 : Receive buffer Data RAM start address. When receiving, words containing samples will be written to this address. This address is a word aligned Data RAM address. */
++#define I2S_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define I2S_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << I2S_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: I2S_TXD_PTR */
++/* Description: Transmit buffer RAM start address. */
++
++/* Bits 31..0 : Transmit buffer Data RAM start address. When transmitting, words containing samples will be fetched from this address. This address is a word aligned Data RAM address. */
++#define I2S_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define I2S_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << I2S_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: I2S_RXTXD_MAXCNT */
++/* Description: Size of RXD and TXD buffers. */
++
++/* Bits 13..0 : Size of RXD and TXD buffers in number of 32 bit words. */
++#define I2S_RXTXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define I2S_RXTXD_MAXCNT_MAXCNT_Msk (0x3FFFUL << I2S_RXTXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: I2S_PSEL_MCK */
++/* Description: Pin select for MCK signal. */
++
++/* Bit 31 : Connection */
++#define I2S_PSEL_MCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define I2S_PSEL_MCK_CONNECT_Msk (0x1UL << I2S_PSEL_MCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define I2S_PSEL_MCK_CONNECT_Connected (0UL) /*!< Connect */
++#define I2S_PSEL_MCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define I2S_PSEL_MCK_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define I2S_PSEL_MCK_PORT_Msk (0x1UL << I2S_PSEL_MCK_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define I2S_PSEL_MCK_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define I2S_PSEL_MCK_PIN_Msk (0x1FUL << I2S_PSEL_MCK_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: I2S_PSEL_SCK */
++/* Description: Pin select for SCK signal. */
++
++/* Bit 31 : Connection */
++#define I2S_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define I2S_PSEL_SCK_CONNECT_Msk (0x1UL << I2S_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define I2S_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
++#define I2S_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define I2S_PSEL_SCK_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define I2S_PSEL_SCK_PORT_Msk (0x1UL << I2S_PSEL_SCK_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define I2S_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define I2S_PSEL_SCK_PIN_Msk (0x1FUL << I2S_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: I2S_PSEL_LRCK */
++/* Description: Pin select for LRCK signal. */
++
++/* Bit 31 : Connection */
++#define I2S_PSEL_LRCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define I2S_PSEL_LRCK_CONNECT_Msk (0x1UL << I2S_PSEL_LRCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define I2S_PSEL_LRCK_CONNECT_Connected (0UL) /*!< Connect */
++#define I2S_PSEL_LRCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define I2S_PSEL_LRCK_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define I2S_PSEL_LRCK_PORT_Msk (0x1UL << I2S_PSEL_LRCK_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define I2S_PSEL_LRCK_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define I2S_PSEL_LRCK_PIN_Msk (0x1FUL << I2S_PSEL_LRCK_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: I2S_PSEL_SDIN */
++/* Description: Pin select for SDIN signal. */
++
++/* Bit 31 : Connection */
++#define I2S_PSEL_SDIN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define I2S_PSEL_SDIN_CONNECT_Msk (0x1UL << I2S_PSEL_SDIN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define I2S_PSEL_SDIN_CONNECT_Connected (0UL) /*!< Connect */
++#define I2S_PSEL_SDIN_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define I2S_PSEL_SDIN_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define I2S_PSEL_SDIN_PORT_Msk (0x1UL << I2S_PSEL_SDIN_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define I2S_PSEL_SDIN_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define I2S_PSEL_SDIN_PIN_Msk (0x1FUL << I2S_PSEL_SDIN_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: I2S_PSEL_SDOUT */
++/* Description: Pin select for SDOUT signal. */
++
++/* Bit 31 : Connection */
++#define I2S_PSEL_SDOUT_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define I2S_PSEL_SDOUT_CONNECT_Msk (0x1UL << I2S_PSEL_SDOUT_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define I2S_PSEL_SDOUT_CONNECT_Connected (0UL) /*!< Connect */
++#define I2S_PSEL_SDOUT_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define I2S_PSEL_SDOUT_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define I2S_PSEL_SDOUT_PORT_Msk (0x1UL << I2S_PSEL_SDOUT_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define I2S_PSEL_SDOUT_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define I2S_PSEL_SDOUT_PIN_Msk (0x1FUL << I2S_PSEL_SDOUT_PIN_Pos) /*!< Bit mask of PIN field. */
++
++
++/* Peripheral: LPCOMP */
++/* Description: Low-power comparator */
++
++/* Register: LPCOMP_TASKS_START */
++/* Description: Start comparator */
++
++/* Bit 0 : Start comparator */
++#define LPCOMP_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define LPCOMP_TASKS_START_TASKS_START_Msk (0x1UL << LPCOMP_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define LPCOMP_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: LPCOMP_TASKS_STOP */
++/* Description: Stop comparator */
++
++/* Bit 0 : Stop comparator */
++#define LPCOMP_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define LPCOMP_TASKS_STOP_TASKS_STOP_Msk (0x1UL << LPCOMP_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define LPCOMP_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: LPCOMP_TASKS_SAMPLE */
++/* Description: Sample comparator value */
++
++/* Bit 0 : Sample comparator value */
++#define LPCOMP_TASKS_SAMPLE_TASKS_SAMPLE_Pos (0UL) /*!< Position of TASKS_SAMPLE field. */
++#define LPCOMP_TASKS_SAMPLE_TASKS_SAMPLE_Msk (0x1UL << LPCOMP_TASKS_SAMPLE_TASKS_SAMPLE_Pos) /*!< Bit mask of TASKS_SAMPLE field. */
++#define LPCOMP_TASKS_SAMPLE_TASKS_SAMPLE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: LPCOMP_EVENTS_READY */
++/* Description: LPCOMP is ready and output is valid */
++
++/* Bit 0 : LPCOMP is ready and output is valid */
++#define LPCOMP_EVENTS_READY_EVENTS_READY_Pos (0UL) /*!< Position of EVENTS_READY field. */
++#define LPCOMP_EVENTS_READY_EVENTS_READY_Msk (0x1UL << LPCOMP_EVENTS_READY_EVENTS_READY_Pos) /*!< Bit mask of EVENTS_READY field. */
++#define LPCOMP_EVENTS_READY_EVENTS_READY_NotGenerated (0UL) /*!< Event not generated */
++#define LPCOMP_EVENTS_READY_EVENTS_READY_Generated (1UL) /*!< Event generated */
++
++/* Register: LPCOMP_EVENTS_DOWN */
++/* Description: Downward crossing */
++
++/* Bit 0 : Downward crossing */
++#define LPCOMP_EVENTS_DOWN_EVENTS_DOWN_Pos (0UL) /*!< Position of EVENTS_DOWN field. */
++#define LPCOMP_EVENTS_DOWN_EVENTS_DOWN_Msk (0x1UL << LPCOMP_EVENTS_DOWN_EVENTS_DOWN_Pos) /*!< Bit mask of EVENTS_DOWN field. */
++#define LPCOMP_EVENTS_DOWN_EVENTS_DOWN_NotGenerated (0UL) /*!< Event not generated */
++#define LPCOMP_EVENTS_DOWN_EVENTS_DOWN_Generated (1UL) /*!< Event generated */
++
++/* Register: LPCOMP_EVENTS_UP */
++/* Description: Upward crossing */
++
++/* Bit 0 : Upward crossing */
++#define LPCOMP_EVENTS_UP_EVENTS_UP_Pos (0UL) /*!< Position of EVENTS_UP field. */
++#define LPCOMP_EVENTS_UP_EVENTS_UP_Msk (0x1UL << LPCOMP_EVENTS_UP_EVENTS_UP_Pos) /*!< Bit mask of EVENTS_UP field. */
++#define LPCOMP_EVENTS_UP_EVENTS_UP_NotGenerated (0UL) /*!< Event not generated */
++#define LPCOMP_EVENTS_UP_EVENTS_UP_Generated (1UL) /*!< Event generated */
++
++/* Register: LPCOMP_EVENTS_CROSS */
++/* Description: Downward or upward crossing */
++
++/* Bit 0 : Downward or upward crossing */
++#define LPCOMP_EVENTS_CROSS_EVENTS_CROSS_Pos (0UL) /*!< Position of EVENTS_CROSS field. */
++#define LPCOMP_EVENTS_CROSS_EVENTS_CROSS_Msk (0x1UL << LPCOMP_EVENTS_CROSS_EVENTS_CROSS_Pos) /*!< Bit mask of EVENTS_CROSS field. */
++#define LPCOMP_EVENTS_CROSS_EVENTS_CROSS_NotGenerated (0UL) /*!< Event not generated */
++#define LPCOMP_EVENTS_CROSS_EVENTS_CROSS_Generated (1UL) /*!< Event generated */
++
++/* Register: LPCOMP_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 4 : Shortcut between event CROSS and task STOP */
++#define LPCOMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
++#define LPCOMP_SHORTS_CROSS_STOP_Msk (0x1UL << LPCOMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
++#define LPCOMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define LPCOMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 3 : Shortcut between event UP and task STOP */
++#define LPCOMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
++#define LPCOMP_SHORTS_UP_STOP_Msk (0x1UL << LPCOMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
++#define LPCOMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define LPCOMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 2 : Shortcut between event DOWN and task STOP */
++#define LPCOMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
++#define LPCOMP_SHORTS_DOWN_STOP_Msk (0x1UL << LPCOMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
++#define LPCOMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define LPCOMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 1 : Shortcut between event READY and task STOP */
++#define LPCOMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
++#define LPCOMP_SHORTS_READY_STOP_Msk (0x1UL << LPCOMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
++#define LPCOMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define LPCOMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event READY and task SAMPLE */
++#define LPCOMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
++#define LPCOMP_SHORTS_READY_SAMPLE_Msk (0x1UL << LPCOMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
++#define LPCOMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Disable shortcut */
++#define LPCOMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: LPCOMP_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 3 : Write '1' to enable interrupt for event CROSS */
++#define LPCOMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
++#define LPCOMP_INTENSET_CROSS_Msk (0x1UL << LPCOMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
++#define LPCOMP_INTENSET_CROSS_Disabled (0UL) /*!< Read: Disabled */
++#define LPCOMP_INTENSET_CROSS_Enabled (1UL) /*!< Read: Enabled */
++#define LPCOMP_INTENSET_CROSS_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event UP */
++#define LPCOMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
++#define LPCOMP_INTENSET_UP_Msk (0x1UL << LPCOMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
++#define LPCOMP_INTENSET_UP_Disabled (0UL) /*!< Read: Disabled */
++#define LPCOMP_INTENSET_UP_Enabled (1UL) /*!< Read: Enabled */
++#define LPCOMP_INTENSET_UP_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event DOWN */
++#define LPCOMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
++#define LPCOMP_INTENSET_DOWN_Msk (0x1UL << LPCOMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
++#define LPCOMP_INTENSET_DOWN_Disabled (0UL) /*!< Read: Disabled */
++#define LPCOMP_INTENSET_DOWN_Enabled (1UL) /*!< Read: Enabled */
++#define LPCOMP_INTENSET_DOWN_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event READY */
++#define LPCOMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
++#define LPCOMP_INTENSET_READY_Msk (0x1UL << LPCOMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
++#define LPCOMP_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
++#define LPCOMP_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
++#define LPCOMP_INTENSET_READY_Set (1UL) /*!< Enable */
++
++/* Register: LPCOMP_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 3 : Write '1' to disable interrupt for event CROSS */
++#define LPCOMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
++#define LPCOMP_INTENCLR_CROSS_Msk (0x1UL << LPCOMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
++#define LPCOMP_INTENCLR_CROSS_Disabled (0UL) /*!< Read: Disabled */
++#define LPCOMP_INTENCLR_CROSS_Enabled (1UL) /*!< Read: Enabled */
++#define LPCOMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event UP */
++#define LPCOMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
++#define LPCOMP_INTENCLR_UP_Msk (0x1UL << LPCOMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
++#define LPCOMP_INTENCLR_UP_Disabled (0UL) /*!< Read: Disabled */
++#define LPCOMP_INTENCLR_UP_Enabled (1UL) /*!< Read: Enabled */
++#define LPCOMP_INTENCLR_UP_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event DOWN */
++#define LPCOMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
++#define LPCOMP_INTENCLR_DOWN_Msk (0x1UL << LPCOMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
++#define LPCOMP_INTENCLR_DOWN_Disabled (0UL) /*!< Read: Disabled */
++#define LPCOMP_INTENCLR_DOWN_Enabled (1UL) /*!< Read: Enabled */
++#define LPCOMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event READY */
++#define LPCOMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
++#define LPCOMP_INTENCLR_READY_Msk (0x1UL << LPCOMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
++#define LPCOMP_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
++#define LPCOMP_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
++#define LPCOMP_INTENCLR_READY_Clear (1UL) /*!< Disable */
++
++/* Register: LPCOMP_RESULT */
++/* Description: Compare result */
++
++/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
++#define LPCOMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
++#define LPCOMP_RESULT_RESULT_Msk (0x1UL << LPCOMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
++#define LPCOMP_RESULT_RESULT_Below (0UL) /*!< Input voltage is below the reference threshold (VIN+ &lt; VIN-) */
++#define LPCOMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold (VIN+ &gt; VIN-) */
++
++/* Register: LPCOMP_ENABLE */
++/* Description: Enable LPCOMP */
++
++/* Bits 1..0 : Enable or disable LPCOMP */
++#define LPCOMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define LPCOMP_ENABLE_ENABLE_Msk (0x3UL << LPCOMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define LPCOMP_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
++#define LPCOMP_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
++
++/* Register: LPCOMP_PSEL */
++/* Description: Input pin select */
++
++/* Bits 2..0 : Analog pin select */
++#define LPCOMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
++#define LPCOMP_PSEL_PSEL_Msk (0x7UL << LPCOMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
++#define LPCOMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< AIN0 selected as analog input */
++#define LPCOMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< AIN1 selected as analog input */
++#define LPCOMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< AIN2 selected as analog input */
++#define LPCOMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< AIN3 selected as analog input */
++#define LPCOMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< AIN4 selected as analog input */
++#define LPCOMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< AIN5 selected as analog input */
++#define LPCOMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< AIN6 selected as analog input */
++#define LPCOMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< AIN7 selected as analog input */
++
++/* Register: LPCOMP_REFSEL */
++/* Description: Reference select */
++
++/* Bits 3..0 : Reference select */
++#define LPCOMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
++#define LPCOMP_REFSEL_REFSEL_Msk (0xFUL << LPCOMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
++#define LPCOMP_REFSEL_REFSEL_Ref1_8Vdd (0UL) /*!< VDD * 1/8 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref2_8Vdd (1UL) /*!< VDD * 2/8 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref3_8Vdd (2UL) /*!< VDD * 3/8 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref4_8Vdd (3UL) /*!< VDD * 4/8 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref5_8Vdd (4UL) /*!< VDD * 5/8 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref6_8Vdd (5UL) /*!< VDD * 6/8 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref7_8Vdd (6UL) /*!< VDD * 7/8 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_ARef (7UL) /*!< External analog reference selected */
++#define LPCOMP_REFSEL_REFSEL_Ref1_16Vdd (8UL) /*!< VDD * 1/16 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref3_16Vdd (9UL) /*!< VDD * 3/16 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref5_16Vdd (10UL) /*!< VDD * 5/16 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref7_16Vdd (11UL) /*!< VDD * 7/16 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref9_16Vdd (12UL) /*!< VDD * 9/16 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref11_16Vdd (13UL) /*!< VDD * 11/16 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref13_16Vdd (14UL) /*!< VDD * 13/16 selected as reference */
++#define LPCOMP_REFSEL_REFSEL_Ref15_16Vdd (15UL) /*!< VDD * 15/16 selected as reference */
++
++/* Register: LPCOMP_EXTREFSEL */
++/* Description: External reference select */
++
++/* Bit 0 : External analog reference select */
++#define LPCOMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
++#define LPCOMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << LPCOMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
++#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use AIN0 as external analog reference */
++#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use AIN1 as external analog reference */
++
++/* Register: LPCOMP_ANADETECT */
++/* Description: Analog detect configuration */
++
++/* Bits 1..0 : Analog detect configuration */
++#define LPCOMP_ANADETECT_ANADETECT_Pos (0UL) /*!< Position of ANADETECT field. */
++#define LPCOMP_ANADETECT_ANADETECT_Msk (0x3UL << LPCOMP_ANADETECT_ANADETECT_Pos) /*!< Bit mask of ANADETECT field. */
++#define LPCOMP_ANADETECT_ANADETECT_Cross (0UL) /*!< Generate ANADETECT on crossing, both upward crossing and downward crossing */
++#define LPCOMP_ANADETECT_ANADETECT_Up (1UL) /*!< Generate ANADETECT on upward crossing only */
++#define LPCOMP_ANADETECT_ANADETECT_Down (2UL) /*!< Generate ANADETECT on downward crossing only */
++
++/* Register: LPCOMP_HYST */
++/* Description: Comparator hysteresis enable */
++
++/* Bit 0 : Comparator hysteresis enable */
++#define LPCOMP_HYST_HYST_Pos (0UL) /*!< Position of HYST field. */
++#define LPCOMP_HYST_HYST_Msk (0x1UL << LPCOMP_HYST_HYST_Pos) /*!< Bit mask of HYST field. */
++#define LPCOMP_HYST_HYST_Disabled (0UL) /*!< Comparator hysteresis disabled */
++#define LPCOMP_HYST_HYST_Enabled (1UL) /*!< Comparator hysteresis enabled */
++
++
++/* Peripheral: MWU */
++/* Description: Memory Watch Unit */
++
++/* Register: MWU_EVENTS_REGION_WA */
++/* Description: Description cluster: Write access to region n detected */
++
++/* Bit 0 : Write access to region n detected */
++#define MWU_EVENTS_REGION_WA_WA_Pos (0UL) /*!< Position of WA field. */
++#define MWU_EVENTS_REGION_WA_WA_Msk (0x1UL << MWU_EVENTS_REGION_WA_WA_Pos) /*!< Bit mask of WA field. */
++#define MWU_EVENTS_REGION_WA_WA_NotGenerated (0UL) /*!< Event not generated */
++#define MWU_EVENTS_REGION_WA_WA_Generated (1UL) /*!< Event generated */
++
++/* Register: MWU_EVENTS_REGION_RA */
++/* Description: Description cluster: Read access to region n detected */
++
++/* Bit 0 : Read access to region n detected */
++#define MWU_EVENTS_REGION_RA_RA_Pos (0UL) /*!< Position of RA field. */
++#define MWU_EVENTS_REGION_RA_RA_Msk (0x1UL << MWU_EVENTS_REGION_RA_RA_Pos) /*!< Bit mask of RA field. */
++#define MWU_EVENTS_REGION_RA_RA_NotGenerated (0UL) /*!< Event not generated */
++#define MWU_EVENTS_REGION_RA_RA_Generated (1UL) /*!< Event generated */
++
++/* Register: MWU_EVENTS_PREGION_WA */
++/* Description: Description cluster: Write access to peripheral region n detected */
++
++/* Bit 0 : Write access to peripheral region n detected */
++#define MWU_EVENTS_PREGION_WA_WA_Pos (0UL) /*!< Position of WA field. */
++#define MWU_EVENTS_PREGION_WA_WA_Msk (0x1UL << MWU_EVENTS_PREGION_WA_WA_Pos) /*!< Bit mask of WA field. */
++#define MWU_EVENTS_PREGION_WA_WA_NotGenerated (0UL) /*!< Event not generated */
++#define MWU_EVENTS_PREGION_WA_WA_Generated (1UL) /*!< Event generated */
++
++/* Register: MWU_EVENTS_PREGION_RA */
++/* Description: Description cluster: Read access to peripheral region n detected */
++
++/* Bit 0 : Read access to peripheral region n detected */
++#define MWU_EVENTS_PREGION_RA_RA_Pos (0UL) /*!< Position of RA field. */
++#define MWU_EVENTS_PREGION_RA_RA_Msk (0x1UL << MWU_EVENTS_PREGION_RA_RA_Pos) /*!< Bit mask of RA field. */
++#define MWU_EVENTS_PREGION_RA_RA_NotGenerated (0UL) /*!< Event not generated */
++#define MWU_EVENTS_PREGION_RA_RA_Generated (1UL) /*!< Event generated */
++
++/* Register: MWU_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 27 : Enable or disable interrupt for event PREGION1RA */
++#define MWU_INTEN_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
++#define MWU_INTEN_PREGION1RA_Msk (0x1UL << MWU_INTEN_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
++#define MWU_INTEN_PREGION1RA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_PREGION1RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 26 : Enable or disable interrupt for event PREGION1WA */
++#define MWU_INTEN_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
++#define MWU_INTEN_PREGION1WA_Msk (0x1UL << MWU_INTEN_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
++#define MWU_INTEN_PREGION1WA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_PREGION1WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 25 : Enable or disable interrupt for event PREGION0RA */
++#define MWU_INTEN_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
++#define MWU_INTEN_PREGION0RA_Msk (0x1UL << MWU_INTEN_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
++#define MWU_INTEN_PREGION0RA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_PREGION0RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 24 : Enable or disable interrupt for event PREGION0WA */
++#define MWU_INTEN_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
++#define MWU_INTEN_PREGION0WA_Msk (0x1UL << MWU_INTEN_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
++#define MWU_INTEN_PREGION0WA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_PREGION0WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 7 : Enable or disable interrupt for event REGION3RA */
++#define MWU_INTEN_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
++#define MWU_INTEN_REGION3RA_Msk (0x1UL << MWU_INTEN_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
++#define MWU_INTEN_REGION3RA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_REGION3RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 6 : Enable or disable interrupt for event REGION3WA */
++#define MWU_INTEN_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
++#define MWU_INTEN_REGION3WA_Msk (0x1UL << MWU_INTEN_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
++#define MWU_INTEN_REGION3WA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_REGION3WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 5 : Enable or disable interrupt for event REGION2RA */
++#define MWU_INTEN_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
++#define MWU_INTEN_REGION2RA_Msk (0x1UL << MWU_INTEN_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
++#define MWU_INTEN_REGION2RA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_REGION2RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable interrupt for event REGION2WA */
++#define MWU_INTEN_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
++#define MWU_INTEN_REGION2WA_Msk (0x1UL << MWU_INTEN_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
++#define MWU_INTEN_REGION2WA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_REGION2WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 3 : Enable or disable interrupt for event REGION1RA */
++#define MWU_INTEN_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
++#define MWU_INTEN_REGION1RA_Msk (0x1UL << MWU_INTEN_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
++#define MWU_INTEN_REGION1RA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_REGION1RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event REGION1WA */
++#define MWU_INTEN_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
++#define MWU_INTEN_REGION1WA_Msk (0x1UL << MWU_INTEN_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
++#define MWU_INTEN_REGION1WA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_REGION1WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event REGION0RA */
++#define MWU_INTEN_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
++#define MWU_INTEN_REGION0RA_Msk (0x1UL << MWU_INTEN_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
++#define MWU_INTEN_REGION0RA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_REGION0RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event REGION0WA */
++#define MWU_INTEN_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
++#define MWU_INTEN_REGION0WA_Msk (0x1UL << MWU_INTEN_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
++#define MWU_INTEN_REGION0WA_Disabled (0UL) /*!< Disable */
++#define MWU_INTEN_REGION0WA_Enabled (1UL) /*!< Enable */
++
++/* Register: MWU_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 27 : Write '1' to enable interrupt for event PREGION1RA */
++#define MWU_INTENSET_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
++#define MWU_INTENSET_PREGION1RA_Msk (0x1UL << MWU_INTENSET_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
++#define MWU_INTENSET_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_PREGION1RA_Set (1UL) /*!< Enable */
++
++/* Bit 26 : Write '1' to enable interrupt for event PREGION1WA */
++#define MWU_INTENSET_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
++#define MWU_INTENSET_PREGION1WA_Msk (0x1UL << MWU_INTENSET_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
++#define MWU_INTENSET_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_PREGION1WA_Set (1UL) /*!< Enable */
++
++/* Bit 25 : Write '1' to enable interrupt for event PREGION0RA */
++#define MWU_INTENSET_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
++#define MWU_INTENSET_PREGION0RA_Msk (0x1UL << MWU_INTENSET_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
++#define MWU_INTENSET_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_PREGION0RA_Set (1UL) /*!< Enable */
++
++/* Bit 24 : Write '1' to enable interrupt for event PREGION0WA */
++#define MWU_INTENSET_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
++#define MWU_INTENSET_PREGION0WA_Msk (0x1UL << MWU_INTENSET_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
++#define MWU_INTENSET_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_PREGION0WA_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event REGION3RA */
++#define MWU_INTENSET_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
++#define MWU_INTENSET_REGION3RA_Msk (0x1UL << MWU_INTENSET_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
++#define MWU_INTENSET_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_REGION3RA_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event REGION3WA */
++#define MWU_INTENSET_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
++#define MWU_INTENSET_REGION3WA_Msk (0x1UL << MWU_INTENSET_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
++#define MWU_INTENSET_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_REGION3WA_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event REGION2RA */
++#define MWU_INTENSET_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
++#define MWU_INTENSET_REGION2RA_Msk (0x1UL << MWU_INTENSET_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
++#define MWU_INTENSET_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_REGION2RA_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event REGION2WA */
++#define MWU_INTENSET_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
++#define MWU_INTENSET_REGION2WA_Msk (0x1UL << MWU_INTENSET_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
++#define MWU_INTENSET_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_REGION2WA_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event REGION1RA */
++#define MWU_INTENSET_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
++#define MWU_INTENSET_REGION1RA_Msk (0x1UL << MWU_INTENSET_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
++#define MWU_INTENSET_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_REGION1RA_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event REGION1WA */
++#define MWU_INTENSET_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
++#define MWU_INTENSET_REGION1WA_Msk (0x1UL << MWU_INTENSET_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
++#define MWU_INTENSET_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_REGION1WA_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event REGION0RA */
++#define MWU_INTENSET_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
++#define MWU_INTENSET_REGION0RA_Msk (0x1UL << MWU_INTENSET_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
++#define MWU_INTENSET_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_REGION0RA_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event REGION0WA */
++#define MWU_INTENSET_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
++#define MWU_INTENSET_REGION0WA_Msk (0x1UL << MWU_INTENSET_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
++#define MWU_INTENSET_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENSET_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENSET_REGION0WA_Set (1UL) /*!< Enable */
++
++/* Register: MWU_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 27 : Write '1' to disable interrupt for event PREGION1RA */
++#define MWU_INTENCLR_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
++#define MWU_INTENCLR_PREGION1RA_Msk (0x1UL << MWU_INTENCLR_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
++#define MWU_INTENCLR_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_PREGION1RA_Clear (1UL) /*!< Disable */
++
++/* Bit 26 : Write '1' to disable interrupt for event PREGION1WA */
++#define MWU_INTENCLR_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
++#define MWU_INTENCLR_PREGION1WA_Msk (0x1UL << MWU_INTENCLR_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
++#define MWU_INTENCLR_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_PREGION1WA_Clear (1UL) /*!< Disable */
++
++/* Bit 25 : Write '1' to disable interrupt for event PREGION0RA */
++#define MWU_INTENCLR_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
++#define MWU_INTENCLR_PREGION0RA_Msk (0x1UL << MWU_INTENCLR_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
++#define MWU_INTENCLR_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_PREGION0RA_Clear (1UL) /*!< Disable */
++
++/* Bit 24 : Write '1' to disable interrupt for event PREGION0WA */
++#define MWU_INTENCLR_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
++#define MWU_INTENCLR_PREGION0WA_Msk (0x1UL << MWU_INTENCLR_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
++#define MWU_INTENCLR_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_PREGION0WA_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event REGION3RA */
++#define MWU_INTENCLR_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
++#define MWU_INTENCLR_REGION3RA_Msk (0x1UL << MWU_INTENCLR_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
++#define MWU_INTENCLR_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_REGION3RA_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event REGION3WA */
++#define MWU_INTENCLR_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
++#define MWU_INTENCLR_REGION3WA_Msk (0x1UL << MWU_INTENCLR_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
++#define MWU_INTENCLR_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_REGION3WA_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event REGION2RA */
++#define MWU_INTENCLR_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
++#define MWU_INTENCLR_REGION2RA_Msk (0x1UL << MWU_INTENCLR_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
++#define MWU_INTENCLR_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_REGION2RA_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event REGION2WA */
++#define MWU_INTENCLR_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
++#define MWU_INTENCLR_REGION2WA_Msk (0x1UL << MWU_INTENCLR_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
++#define MWU_INTENCLR_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_REGION2WA_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event REGION1RA */
++#define MWU_INTENCLR_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
++#define MWU_INTENCLR_REGION1RA_Msk (0x1UL << MWU_INTENCLR_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
++#define MWU_INTENCLR_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_REGION1RA_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event REGION1WA */
++#define MWU_INTENCLR_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
++#define MWU_INTENCLR_REGION1WA_Msk (0x1UL << MWU_INTENCLR_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
++#define MWU_INTENCLR_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_REGION1WA_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event REGION0RA */
++#define MWU_INTENCLR_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
++#define MWU_INTENCLR_REGION0RA_Msk (0x1UL << MWU_INTENCLR_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
++#define MWU_INTENCLR_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_REGION0RA_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event REGION0WA */
++#define MWU_INTENCLR_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
++#define MWU_INTENCLR_REGION0WA_Msk (0x1UL << MWU_INTENCLR_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
++#define MWU_INTENCLR_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_INTENCLR_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_INTENCLR_REGION0WA_Clear (1UL) /*!< Disable */
++
++/* Register: MWU_NMIEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 27 : Enable or disable interrupt for event PREGION1RA */
++#define MWU_NMIEN_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
++#define MWU_NMIEN_PREGION1RA_Msk (0x1UL << MWU_NMIEN_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
++#define MWU_NMIEN_PREGION1RA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_PREGION1RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 26 : Enable or disable interrupt for event PREGION1WA */
++#define MWU_NMIEN_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
++#define MWU_NMIEN_PREGION1WA_Msk (0x1UL << MWU_NMIEN_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
++#define MWU_NMIEN_PREGION1WA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_PREGION1WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 25 : Enable or disable interrupt for event PREGION0RA */
++#define MWU_NMIEN_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
++#define MWU_NMIEN_PREGION0RA_Msk (0x1UL << MWU_NMIEN_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
++#define MWU_NMIEN_PREGION0RA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_PREGION0RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 24 : Enable or disable interrupt for event PREGION0WA */
++#define MWU_NMIEN_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
++#define MWU_NMIEN_PREGION0WA_Msk (0x1UL << MWU_NMIEN_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
++#define MWU_NMIEN_PREGION0WA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_PREGION0WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 7 : Enable or disable interrupt for event REGION3RA */
++#define MWU_NMIEN_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
++#define MWU_NMIEN_REGION3RA_Msk (0x1UL << MWU_NMIEN_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
++#define MWU_NMIEN_REGION3RA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_REGION3RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 6 : Enable or disable interrupt for event REGION3WA */
++#define MWU_NMIEN_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
++#define MWU_NMIEN_REGION3WA_Msk (0x1UL << MWU_NMIEN_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
++#define MWU_NMIEN_REGION3WA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_REGION3WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 5 : Enable or disable interrupt for event REGION2RA */
++#define MWU_NMIEN_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
++#define MWU_NMIEN_REGION2RA_Msk (0x1UL << MWU_NMIEN_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
++#define MWU_NMIEN_REGION2RA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_REGION2RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable interrupt for event REGION2WA */
++#define MWU_NMIEN_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
++#define MWU_NMIEN_REGION2WA_Msk (0x1UL << MWU_NMIEN_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
++#define MWU_NMIEN_REGION2WA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_REGION2WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 3 : Enable or disable interrupt for event REGION1RA */
++#define MWU_NMIEN_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
++#define MWU_NMIEN_REGION1RA_Msk (0x1UL << MWU_NMIEN_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
++#define MWU_NMIEN_REGION1RA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_REGION1RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event REGION1WA */
++#define MWU_NMIEN_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
++#define MWU_NMIEN_REGION1WA_Msk (0x1UL << MWU_NMIEN_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
++#define MWU_NMIEN_REGION1WA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_REGION1WA_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event REGION0RA */
++#define MWU_NMIEN_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
++#define MWU_NMIEN_REGION0RA_Msk (0x1UL << MWU_NMIEN_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
++#define MWU_NMIEN_REGION0RA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_REGION0RA_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event REGION0WA */
++#define MWU_NMIEN_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
++#define MWU_NMIEN_REGION0WA_Msk (0x1UL << MWU_NMIEN_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
++#define MWU_NMIEN_REGION0WA_Disabled (0UL) /*!< Disable */
++#define MWU_NMIEN_REGION0WA_Enabled (1UL) /*!< Enable */
++
++/* Register: MWU_NMIENSET */
++/* Description: Enable interrupt */
++
++/* Bit 27 : Write '1' to enable interrupt for event PREGION1RA */
++#define MWU_NMIENSET_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
++#define MWU_NMIENSET_PREGION1RA_Msk (0x1UL << MWU_NMIENSET_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
++#define MWU_NMIENSET_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_PREGION1RA_Set (1UL) /*!< Enable */
++
++/* Bit 26 : Write '1' to enable interrupt for event PREGION1WA */
++#define MWU_NMIENSET_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
++#define MWU_NMIENSET_PREGION1WA_Msk (0x1UL << MWU_NMIENSET_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
++#define MWU_NMIENSET_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_PREGION1WA_Set (1UL) /*!< Enable */
++
++/* Bit 25 : Write '1' to enable interrupt for event PREGION0RA */
++#define MWU_NMIENSET_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
++#define MWU_NMIENSET_PREGION0RA_Msk (0x1UL << MWU_NMIENSET_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
++#define MWU_NMIENSET_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_PREGION0RA_Set (1UL) /*!< Enable */
++
++/* Bit 24 : Write '1' to enable interrupt for event PREGION0WA */
++#define MWU_NMIENSET_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
++#define MWU_NMIENSET_PREGION0WA_Msk (0x1UL << MWU_NMIENSET_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
++#define MWU_NMIENSET_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_PREGION0WA_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event REGION3RA */
++#define MWU_NMIENSET_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
++#define MWU_NMIENSET_REGION3RA_Msk (0x1UL << MWU_NMIENSET_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
++#define MWU_NMIENSET_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_REGION3RA_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event REGION3WA */
++#define MWU_NMIENSET_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
++#define MWU_NMIENSET_REGION3WA_Msk (0x1UL << MWU_NMIENSET_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
++#define MWU_NMIENSET_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_REGION3WA_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event REGION2RA */
++#define MWU_NMIENSET_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
++#define MWU_NMIENSET_REGION2RA_Msk (0x1UL << MWU_NMIENSET_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
++#define MWU_NMIENSET_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_REGION2RA_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event REGION2WA */
++#define MWU_NMIENSET_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
++#define MWU_NMIENSET_REGION2WA_Msk (0x1UL << MWU_NMIENSET_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
++#define MWU_NMIENSET_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_REGION2WA_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event REGION1RA */
++#define MWU_NMIENSET_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
++#define MWU_NMIENSET_REGION1RA_Msk (0x1UL << MWU_NMIENSET_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
++#define MWU_NMIENSET_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_REGION1RA_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event REGION1WA */
++#define MWU_NMIENSET_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
++#define MWU_NMIENSET_REGION1WA_Msk (0x1UL << MWU_NMIENSET_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
++#define MWU_NMIENSET_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_REGION1WA_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event REGION0RA */
++#define MWU_NMIENSET_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
++#define MWU_NMIENSET_REGION0RA_Msk (0x1UL << MWU_NMIENSET_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
++#define MWU_NMIENSET_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_REGION0RA_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event REGION0WA */
++#define MWU_NMIENSET_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
++#define MWU_NMIENSET_REGION0WA_Msk (0x1UL << MWU_NMIENSET_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
++#define MWU_NMIENSET_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENSET_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENSET_REGION0WA_Set (1UL) /*!< Enable */
++
++/* Register: MWU_NMIENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 27 : Write '1' to disable interrupt for event PREGION1RA */
++#define MWU_NMIENCLR_PREGION1RA_Pos (27UL) /*!< Position of PREGION1RA field. */
++#define MWU_NMIENCLR_PREGION1RA_Msk (0x1UL << MWU_NMIENCLR_PREGION1RA_Pos) /*!< Bit mask of PREGION1RA field. */
++#define MWU_NMIENCLR_PREGION1RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_PREGION1RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_PREGION1RA_Clear (1UL) /*!< Disable */
++
++/* Bit 26 : Write '1' to disable interrupt for event PREGION1WA */
++#define MWU_NMIENCLR_PREGION1WA_Pos (26UL) /*!< Position of PREGION1WA field. */
++#define MWU_NMIENCLR_PREGION1WA_Msk (0x1UL << MWU_NMIENCLR_PREGION1WA_Pos) /*!< Bit mask of PREGION1WA field. */
++#define MWU_NMIENCLR_PREGION1WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_PREGION1WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_PREGION1WA_Clear (1UL) /*!< Disable */
++
++/* Bit 25 : Write '1' to disable interrupt for event PREGION0RA */
++#define MWU_NMIENCLR_PREGION0RA_Pos (25UL) /*!< Position of PREGION0RA field. */
++#define MWU_NMIENCLR_PREGION0RA_Msk (0x1UL << MWU_NMIENCLR_PREGION0RA_Pos) /*!< Bit mask of PREGION0RA field. */
++#define MWU_NMIENCLR_PREGION0RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_PREGION0RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_PREGION0RA_Clear (1UL) /*!< Disable */
++
++/* Bit 24 : Write '1' to disable interrupt for event PREGION0WA */
++#define MWU_NMIENCLR_PREGION0WA_Pos (24UL) /*!< Position of PREGION0WA field. */
++#define MWU_NMIENCLR_PREGION0WA_Msk (0x1UL << MWU_NMIENCLR_PREGION0WA_Pos) /*!< Bit mask of PREGION0WA field. */
++#define MWU_NMIENCLR_PREGION0WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_PREGION0WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_PREGION0WA_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event REGION3RA */
++#define MWU_NMIENCLR_REGION3RA_Pos (7UL) /*!< Position of REGION3RA field. */
++#define MWU_NMIENCLR_REGION3RA_Msk (0x1UL << MWU_NMIENCLR_REGION3RA_Pos) /*!< Bit mask of REGION3RA field. */
++#define MWU_NMIENCLR_REGION3RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_REGION3RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_REGION3RA_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event REGION3WA */
++#define MWU_NMIENCLR_REGION3WA_Pos (6UL) /*!< Position of REGION3WA field. */
++#define MWU_NMIENCLR_REGION3WA_Msk (0x1UL << MWU_NMIENCLR_REGION3WA_Pos) /*!< Bit mask of REGION3WA field. */
++#define MWU_NMIENCLR_REGION3WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_REGION3WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_REGION3WA_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event REGION2RA */
++#define MWU_NMIENCLR_REGION2RA_Pos (5UL) /*!< Position of REGION2RA field. */
++#define MWU_NMIENCLR_REGION2RA_Msk (0x1UL << MWU_NMIENCLR_REGION2RA_Pos) /*!< Bit mask of REGION2RA field. */
++#define MWU_NMIENCLR_REGION2RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_REGION2RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_REGION2RA_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event REGION2WA */
++#define MWU_NMIENCLR_REGION2WA_Pos (4UL) /*!< Position of REGION2WA field. */
++#define MWU_NMIENCLR_REGION2WA_Msk (0x1UL << MWU_NMIENCLR_REGION2WA_Pos) /*!< Bit mask of REGION2WA field. */
++#define MWU_NMIENCLR_REGION2WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_REGION2WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_REGION2WA_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event REGION1RA */
++#define MWU_NMIENCLR_REGION1RA_Pos (3UL) /*!< Position of REGION1RA field. */
++#define MWU_NMIENCLR_REGION1RA_Msk (0x1UL << MWU_NMIENCLR_REGION1RA_Pos) /*!< Bit mask of REGION1RA field. */
++#define MWU_NMIENCLR_REGION1RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_REGION1RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_REGION1RA_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event REGION1WA */
++#define MWU_NMIENCLR_REGION1WA_Pos (2UL) /*!< Position of REGION1WA field. */
++#define MWU_NMIENCLR_REGION1WA_Msk (0x1UL << MWU_NMIENCLR_REGION1WA_Pos) /*!< Bit mask of REGION1WA field. */
++#define MWU_NMIENCLR_REGION1WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_REGION1WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_REGION1WA_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event REGION0RA */
++#define MWU_NMIENCLR_REGION0RA_Pos (1UL) /*!< Position of REGION0RA field. */
++#define MWU_NMIENCLR_REGION0RA_Msk (0x1UL << MWU_NMIENCLR_REGION0RA_Pos) /*!< Bit mask of REGION0RA field. */
++#define MWU_NMIENCLR_REGION0RA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_REGION0RA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_REGION0RA_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event REGION0WA */
++#define MWU_NMIENCLR_REGION0WA_Pos (0UL) /*!< Position of REGION0WA field. */
++#define MWU_NMIENCLR_REGION0WA_Msk (0x1UL << MWU_NMIENCLR_REGION0WA_Pos) /*!< Bit mask of REGION0WA field. */
++#define MWU_NMIENCLR_REGION0WA_Disabled (0UL) /*!< Read: Disabled */
++#define MWU_NMIENCLR_REGION0WA_Enabled (1UL) /*!< Read: Enabled */
++#define MWU_NMIENCLR_REGION0WA_Clear (1UL) /*!< Disable */
++
++/* Register: MWU_PERREGION_SUBSTATWA */
++/* Description: Description cluster: Source of event/interrupt in region n, write access detected while corresponding subregion was enabled for watching */
++
++/* Bit 31 : Subregion 31 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR31_Pos (31UL) /*!< Position of SR31 field. */
++#define MWU_PERREGION_SUBSTATWA_SR31_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR31_Pos) /*!< Bit mask of SR31 field. */
++#define MWU_PERREGION_SUBSTATWA_SR31_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR31_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 30 : Subregion 30 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR30_Pos (30UL) /*!< Position of SR30 field. */
++#define MWU_PERREGION_SUBSTATWA_SR30_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR30_Pos) /*!< Bit mask of SR30 field. */
++#define MWU_PERREGION_SUBSTATWA_SR30_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR30_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 29 : Subregion 29 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR29_Pos (29UL) /*!< Position of SR29 field. */
++#define MWU_PERREGION_SUBSTATWA_SR29_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR29_Pos) /*!< Bit mask of SR29 field. */
++#define MWU_PERREGION_SUBSTATWA_SR29_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR29_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 28 : Subregion 28 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR28_Pos (28UL) /*!< Position of SR28 field. */
++#define MWU_PERREGION_SUBSTATWA_SR28_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR28_Pos) /*!< Bit mask of SR28 field. */
++#define MWU_PERREGION_SUBSTATWA_SR28_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR28_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 27 : Subregion 27 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR27_Pos (27UL) /*!< Position of SR27 field. */
++#define MWU_PERREGION_SUBSTATWA_SR27_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR27_Pos) /*!< Bit mask of SR27 field. */
++#define MWU_PERREGION_SUBSTATWA_SR27_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR27_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 26 : Subregion 26 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR26_Pos (26UL) /*!< Position of SR26 field. */
++#define MWU_PERREGION_SUBSTATWA_SR26_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR26_Pos) /*!< Bit mask of SR26 field. */
++#define MWU_PERREGION_SUBSTATWA_SR26_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR26_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 25 : Subregion 25 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR25_Pos (25UL) /*!< Position of SR25 field. */
++#define MWU_PERREGION_SUBSTATWA_SR25_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR25_Pos) /*!< Bit mask of SR25 field. */
++#define MWU_PERREGION_SUBSTATWA_SR25_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR25_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 24 : Subregion 24 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR24_Pos (24UL) /*!< Position of SR24 field. */
++#define MWU_PERREGION_SUBSTATWA_SR24_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR24_Pos) /*!< Bit mask of SR24 field. */
++#define MWU_PERREGION_SUBSTATWA_SR24_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR24_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 23 : Subregion 23 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR23_Pos (23UL) /*!< Position of SR23 field. */
++#define MWU_PERREGION_SUBSTATWA_SR23_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR23_Pos) /*!< Bit mask of SR23 field. */
++#define MWU_PERREGION_SUBSTATWA_SR23_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR23_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 22 : Subregion 22 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR22_Pos (22UL) /*!< Position of SR22 field. */
++#define MWU_PERREGION_SUBSTATWA_SR22_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR22_Pos) /*!< Bit mask of SR22 field. */
++#define MWU_PERREGION_SUBSTATWA_SR22_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR22_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 21 : Subregion 21 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR21_Pos (21UL) /*!< Position of SR21 field. */
++#define MWU_PERREGION_SUBSTATWA_SR21_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR21_Pos) /*!< Bit mask of SR21 field. */
++#define MWU_PERREGION_SUBSTATWA_SR21_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR21_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 20 : Subregion 20 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR20_Pos (20UL) /*!< Position of SR20 field. */
++#define MWU_PERREGION_SUBSTATWA_SR20_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR20_Pos) /*!< Bit mask of SR20 field. */
++#define MWU_PERREGION_SUBSTATWA_SR20_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR20_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 19 : Subregion 19 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR19_Pos (19UL) /*!< Position of SR19 field. */
++#define MWU_PERREGION_SUBSTATWA_SR19_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR19_Pos) /*!< Bit mask of SR19 field. */
++#define MWU_PERREGION_SUBSTATWA_SR19_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR19_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 18 : Subregion 18 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR18_Pos (18UL) /*!< Position of SR18 field. */
++#define MWU_PERREGION_SUBSTATWA_SR18_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR18_Pos) /*!< Bit mask of SR18 field. */
++#define MWU_PERREGION_SUBSTATWA_SR18_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR18_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 17 : Subregion 17 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR17_Pos (17UL) /*!< Position of SR17 field. */
++#define MWU_PERREGION_SUBSTATWA_SR17_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR17_Pos) /*!< Bit mask of SR17 field. */
++#define MWU_PERREGION_SUBSTATWA_SR17_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR17_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 16 : Subregion 16 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR16_Pos (16UL) /*!< Position of SR16 field. */
++#define MWU_PERREGION_SUBSTATWA_SR16_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR16_Pos) /*!< Bit mask of SR16 field. */
++#define MWU_PERREGION_SUBSTATWA_SR16_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR16_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 15 : Subregion 15 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR15_Pos (15UL) /*!< Position of SR15 field. */
++#define MWU_PERREGION_SUBSTATWA_SR15_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR15_Pos) /*!< Bit mask of SR15 field. */
++#define MWU_PERREGION_SUBSTATWA_SR15_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR15_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 14 : Subregion 14 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR14_Pos (14UL) /*!< Position of SR14 field. */
++#define MWU_PERREGION_SUBSTATWA_SR14_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR14_Pos) /*!< Bit mask of SR14 field. */
++#define MWU_PERREGION_SUBSTATWA_SR14_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR14_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 13 : Subregion 13 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR13_Pos (13UL) /*!< Position of SR13 field. */
++#define MWU_PERREGION_SUBSTATWA_SR13_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR13_Pos) /*!< Bit mask of SR13 field. */
++#define MWU_PERREGION_SUBSTATWA_SR13_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR13_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 12 : Subregion 12 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR12_Pos (12UL) /*!< Position of SR12 field. */
++#define MWU_PERREGION_SUBSTATWA_SR12_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR12_Pos) /*!< Bit mask of SR12 field. */
++#define MWU_PERREGION_SUBSTATWA_SR12_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR12_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 11 : Subregion 11 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR11_Pos (11UL) /*!< Position of SR11 field. */
++#define MWU_PERREGION_SUBSTATWA_SR11_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR11_Pos) /*!< Bit mask of SR11 field. */
++#define MWU_PERREGION_SUBSTATWA_SR11_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR11_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 10 : Subregion 10 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR10_Pos (10UL) /*!< Position of SR10 field. */
++#define MWU_PERREGION_SUBSTATWA_SR10_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR10_Pos) /*!< Bit mask of SR10 field. */
++#define MWU_PERREGION_SUBSTATWA_SR10_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR10_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 9 : Subregion 9 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR9_Pos (9UL) /*!< Position of SR9 field. */
++#define MWU_PERREGION_SUBSTATWA_SR9_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR9_Pos) /*!< Bit mask of SR9 field. */
++#define MWU_PERREGION_SUBSTATWA_SR9_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR9_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 8 : Subregion 8 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR8_Pos (8UL) /*!< Position of SR8 field. */
++#define MWU_PERREGION_SUBSTATWA_SR8_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR8_Pos) /*!< Bit mask of SR8 field. */
++#define MWU_PERREGION_SUBSTATWA_SR8_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR8_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 7 : Subregion 7 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR7_Pos (7UL) /*!< Position of SR7 field. */
++#define MWU_PERREGION_SUBSTATWA_SR7_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR7_Pos) /*!< Bit mask of SR7 field. */
++#define MWU_PERREGION_SUBSTATWA_SR7_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR7_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 6 : Subregion 6 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR6_Pos (6UL) /*!< Position of SR6 field. */
++#define MWU_PERREGION_SUBSTATWA_SR6_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR6_Pos) /*!< Bit mask of SR6 field. */
++#define MWU_PERREGION_SUBSTATWA_SR6_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR6_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 5 : Subregion 5 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR5_Pos (5UL) /*!< Position of SR5 field. */
++#define MWU_PERREGION_SUBSTATWA_SR5_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR5_Pos) /*!< Bit mask of SR5 field. */
++#define MWU_PERREGION_SUBSTATWA_SR5_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR5_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 4 : Subregion 4 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR4_Pos (4UL) /*!< Position of SR4 field. */
++#define MWU_PERREGION_SUBSTATWA_SR4_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR4_Pos) /*!< Bit mask of SR4 field. */
++#define MWU_PERREGION_SUBSTATWA_SR4_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR4_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 3 : Subregion 3 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR3_Pos (3UL) /*!< Position of SR3 field. */
++#define MWU_PERREGION_SUBSTATWA_SR3_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR3_Pos) /*!< Bit mask of SR3 field. */
++#define MWU_PERREGION_SUBSTATWA_SR3_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR3_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 2 : Subregion 2 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR2_Pos (2UL) /*!< Position of SR2 field. */
++#define MWU_PERREGION_SUBSTATWA_SR2_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR2_Pos) /*!< Bit mask of SR2 field. */
++#define MWU_PERREGION_SUBSTATWA_SR2_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR2_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 1 : Subregion 1 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR1_Pos (1UL) /*!< Position of SR1 field. */
++#define MWU_PERREGION_SUBSTATWA_SR1_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR1_Pos) /*!< Bit mask of SR1 field. */
++#define MWU_PERREGION_SUBSTATWA_SR1_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR1_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Bit 0 : Subregion 0 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATWA_SR0_Pos (0UL) /*!< Position of SR0 field. */
++#define MWU_PERREGION_SUBSTATWA_SR0_Msk (0x1UL << MWU_PERREGION_SUBSTATWA_SR0_Pos) /*!< Bit mask of SR0 field. */
++#define MWU_PERREGION_SUBSTATWA_SR0_NoAccess (0UL) /*!< No write access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATWA_SR0_Access (1UL) /*!< Write access(es) occurred in this subregion */
++
++/* Register: MWU_PERREGION_SUBSTATRA */
++/* Description: Description cluster: Source of event/interrupt in region n, read access detected while corresponding subregion was enabled for watching */
++
++/* Bit 31 : Subregion 31 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR31_Pos (31UL) /*!< Position of SR31 field. */
++#define MWU_PERREGION_SUBSTATRA_SR31_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR31_Pos) /*!< Bit mask of SR31 field. */
++#define MWU_PERREGION_SUBSTATRA_SR31_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR31_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 30 : Subregion 30 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR30_Pos (30UL) /*!< Position of SR30 field. */
++#define MWU_PERREGION_SUBSTATRA_SR30_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR30_Pos) /*!< Bit mask of SR30 field. */
++#define MWU_PERREGION_SUBSTATRA_SR30_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR30_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 29 : Subregion 29 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR29_Pos (29UL) /*!< Position of SR29 field. */
++#define MWU_PERREGION_SUBSTATRA_SR29_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR29_Pos) /*!< Bit mask of SR29 field. */
++#define MWU_PERREGION_SUBSTATRA_SR29_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR29_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 28 : Subregion 28 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR28_Pos (28UL) /*!< Position of SR28 field. */
++#define MWU_PERREGION_SUBSTATRA_SR28_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR28_Pos) /*!< Bit mask of SR28 field. */
++#define MWU_PERREGION_SUBSTATRA_SR28_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR28_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 27 : Subregion 27 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR27_Pos (27UL) /*!< Position of SR27 field. */
++#define MWU_PERREGION_SUBSTATRA_SR27_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR27_Pos) /*!< Bit mask of SR27 field. */
++#define MWU_PERREGION_SUBSTATRA_SR27_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR27_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 26 : Subregion 26 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR26_Pos (26UL) /*!< Position of SR26 field. */
++#define MWU_PERREGION_SUBSTATRA_SR26_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR26_Pos) /*!< Bit mask of SR26 field. */
++#define MWU_PERREGION_SUBSTATRA_SR26_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR26_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 25 : Subregion 25 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR25_Pos (25UL) /*!< Position of SR25 field. */
++#define MWU_PERREGION_SUBSTATRA_SR25_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR25_Pos) /*!< Bit mask of SR25 field. */
++#define MWU_PERREGION_SUBSTATRA_SR25_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR25_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 24 : Subregion 24 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR24_Pos (24UL) /*!< Position of SR24 field. */
++#define MWU_PERREGION_SUBSTATRA_SR24_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR24_Pos) /*!< Bit mask of SR24 field. */
++#define MWU_PERREGION_SUBSTATRA_SR24_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR24_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 23 : Subregion 23 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR23_Pos (23UL) /*!< Position of SR23 field. */
++#define MWU_PERREGION_SUBSTATRA_SR23_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR23_Pos) /*!< Bit mask of SR23 field. */
++#define MWU_PERREGION_SUBSTATRA_SR23_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR23_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 22 : Subregion 22 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR22_Pos (22UL) /*!< Position of SR22 field. */
++#define MWU_PERREGION_SUBSTATRA_SR22_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR22_Pos) /*!< Bit mask of SR22 field. */
++#define MWU_PERREGION_SUBSTATRA_SR22_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR22_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 21 : Subregion 21 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR21_Pos (21UL) /*!< Position of SR21 field. */
++#define MWU_PERREGION_SUBSTATRA_SR21_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR21_Pos) /*!< Bit mask of SR21 field. */
++#define MWU_PERREGION_SUBSTATRA_SR21_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR21_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 20 : Subregion 20 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR20_Pos (20UL) /*!< Position of SR20 field. */
++#define MWU_PERREGION_SUBSTATRA_SR20_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR20_Pos) /*!< Bit mask of SR20 field. */
++#define MWU_PERREGION_SUBSTATRA_SR20_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR20_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 19 : Subregion 19 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR19_Pos (19UL) /*!< Position of SR19 field. */
++#define MWU_PERREGION_SUBSTATRA_SR19_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR19_Pos) /*!< Bit mask of SR19 field. */
++#define MWU_PERREGION_SUBSTATRA_SR19_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR19_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 18 : Subregion 18 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR18_Pos (18UL) /*!< Position of SR18 field. */
++#define MWU_PERREGION_SUBSTATRA_SR18_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR18_Pos) /*!< Bit mask of SR18 field. */
++#define MWU_PERREGION_SUBSTATRA_SR18_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR18_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 17 : Subregion 17 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR17_Pos (17UL) /*!< Position of SR17 field. */
++#define MWU_PERREGION_SUBSTATRA_SR17_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR17_Pos) /*!< Bit mask of SR17 field. */
++#define MWU_PERREGION_SUBSTATRA_SR17_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR17_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 16 : Subregion 16 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR16_Pos (16UL) /*!< Position of SR16 field. */
++#define MWU_PERREGION_SUBSTATRA_SR16_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR16_Pos) /*!< Bit mask of SR16 field. */
++#define MWU_PERREGION_SUBSTATRA_SR16_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR16_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 15 : Subregion 15 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR15_Pos (15UL) /*!< Position of SR15 field. */
++#define MWU_PERREGION_SUBSTATRA_SR15_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR15_Pos) /*!< Bit mask of SR15 field. */
++#define MWU_PERREGION_SUBSTATRA_SR15_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR15_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 14 : Subregion 14 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR14_Pos (14UL) /*!< Position of SR14 field. */
++#define MWU_PERREGION_SUBSTATRA_SR14_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR14_Pos) /*!< Bit mask of SR14 field. */
++#define MWU_PERREGION_SUBSTATRA_SR14_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR14_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 13 : Subregion 13 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR13_Pos (13UL) /*!< Position of SR13 field. */
++#define MWU_PERREGION_SUBSTATRA_SR13_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR13_Pos) /*!< Bit mask of SR13 field. */
++#define MWU_PERREGION_SUBSTATRA_SR13_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR13_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 12 : Subregion 12 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR12_Pos (12UL) /*!< Position of SR12 field. */
++#define MWU_PERREGION_SUBSTATRA_SR12_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR12_Pos) /*!< Bit mask of SR12 field. */
++#define MWU_PERREGION_SUBSTATRA_SR12_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR12_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 11 : Subregion 11 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR11_Pos (11UL) /*!< Position of SR11 field. */
++#define MWU_PERREGION_SUBSTATRA_SR11_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR11_Pos) /*!< Bit mask of SR11 field. */
++#define MWU_PERREGION_SUBSTATRA_SR11_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR11_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 10 : Subregion 10 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR10_Pos (10UL) /*!< Position of SR10 field. */
++#define MWU_PERREGION_SUBSTATRA_SR10_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR10_Pos) /*!< Bit mask of SR10 field. */
++#define MWU_PERREGION_SUBSTATRA_SR10_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR10_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 9 : Subregion 9 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR9_Pos (9UL) /*!< Position of SR9 field. */
++#define MWU_PERREGION_SUBSTATRA_SR9_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR9_Pos) /*!< Bit mask of SR9 field. */
++#define MWU_PERREGION_SUBSTATRA_SR9_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR9_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 8 : Subregion 8 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR8_Pos (8UL) /*!< Position of SR8 field. */
++#define MWU_PERREGION_SUBSTATRA_SR8_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR8_Pos) /*!< Bit mask of SR8 field. */
++#define MWU_PERREGION_SUBSTATRA_SR8_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR8_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 7 : Subregion 7 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR7_Pos (7UL) /*!< Position of SR7 field. */
++#define MWU_PERREGION_SUBSTATRA_SR7_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR7_Pos) /*!< Bit mask of SR7 field. */
++#define MWU_PERREGION_SUBSTATRA_SR7_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR7_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 6 : Subregion 6 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR6_Pos (6UL) /*!< Position of SR6 field. */
++#define MWU_PERREGION_SUBSTATRA_SR6_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR6_Pos) /*!< Bit mask of SR6 field. */
++#define MWU_PERREGION_SUBSTATRA_SR6_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR6_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 5 : Subregion 5 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR5_Pos (5UL) /*!< Position of SR5 field. */
++#define MWU_PERREGION_SUBSTATRA_SR5_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR5_Pos) /*!< Bit mask of SR5 field. */
++#define MWU_PERREGION_SUBSTATRA_SR5_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR5_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 4 : Subregion 4 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR4_Pos (4UL) /*!< Position of SR4 field. */
++#define MWU_PERREGION_SUBSTATRA_SR4_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR4_Pos) /*!< Bit mask of SR4 field. */
++#define MWU_PERREGION_SUBSTATRA_SR4_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR4_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 3 : Subregion 3 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR3_Pos (3UL) /*!< Position of SR3 field. */
++#define MWU_PERREGION_SUBSTATRA_SR3_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR3_Pos) /*!< Bit mask of SR3 field. */
++#define MWU_PERREGION_SUBSTATRA_SR3_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR3_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 2 : Subregion 2 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR2_Pos (2UL) /*!< Position of SR2 field. */
++#define MWU_PERREGION_SUBSTATRA_SR2_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR2_Pos) /*!< Bit mask of SR2 field. */
++#define MWU_PERREGION_SUBSTATRA_SR2_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR2_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 1 : Subregion 1 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR1_Pos (1UL) /*!< Position of SR1 field. */
++#define MWU_PERREGION_SUBSTATRA_SR1_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR1_Pos) /*!< Bit mask of SR1 field. */
++#define MWU_PERREGION_SUBSTATRA_SR1_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR1_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Bit 0 : Subregion 0 in region n (write '1' to clear) */
++#define MWU_PERREGION_SUBSTATRA_SR0_Pos (0UL) /*!< Position of SR0 field. */
++#define MWU_PERREGION_SUBSTATRA_SR0_Msk (0x1UL << MWU_PERREGION_SUBSTATRA_SR0_Pos) /*!< Bit mask of SR0 field. */
++#define MWU_PERREGION_SUBSTATRA_SR0_NoAccess (0UL) /*!< No read access occurred in this subregion */
++#define MWU_PERREGION_SUBSTATRA_SR0_Access (1UL) /*!< Read access(es) occurred in this subregion */
++
++/* Register: MWU_REGIONEN */
++/* Description: Enable/disable regions watch */
++
++/* Bit 27 : Enable/disable read access watch in PREGION[1] */
++#define MWU_REGIONEN_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
++#define MWU_REGIONEN_PRGN1RA_Msk (0x1UL << MWU_REGIONEN_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
++#define MWU_REGIONEN_PRGN1RA_Disable (0UL) /*!< Disable read access watch in this PREGION */
++#define MWU_REGIONEN_PRGN1RA_Enable (1UL) /*!< Enable read access watch in this PREGION */
++
++/* Bit 26 : Enable/disable write access watch in PREGION[1] */
++#define MWU_REGIONEN_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
++#define MWU_REGIONEN_PRGN1WA_Msk (0x1UL << MWU_REGIONEN_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
++#define MWU_REGIONEN_PRGN1WA_Disable (0UL) /*!< Disable write access watch in this PREGION */
++#define MWU_REGIONEN_PRGN1WA_Enable (1UL) /*!< Enable write access watch in this PREGION */
++
++/* Bit 25 : Enable/disable read access watch in PREGION[0] */
++#define MWU_REGIONEN_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
++#define MWU_REGIONEN_PRGN0RA_Msk (0x1UL << MWU_REGIONEN_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
++#define MWU_REGIONEN_PRGN0RA_Disable (0UL) /*!< Disable read access watch in this PREGION */
++#define MWU_REGIONEN_PRGN0RA_Enable (1UL) /*!< Enable read access watch in this PREGION */
++
++/* Bit 24 : Enable/disable write access watch in PREGION[0] */
++#define MWU_REGIONEN_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
++#define MWU_REGIONEN_PRGN0WA_Msk (0x1UL << MWU_REGIONEN_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
++#define MWU_REGIONEN_PRGN0WA_Disable (0UL) /*!< Disable write access watch in this PREGION */
++#define MWU_REGIONEN_PRGN0WA_Enable (1UL) /*!< Enable write access watch in this PREGION */
++
++/* Bit 7 : Enable/disable read access watch in region[3] */
++#define MWU_REGIONEN_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
++#define MWU_REGIONEN_RGN3RA_Msk (0x1UL << MWU_REGIONEN_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
++#define MWU_REGIONEN_RGN3RA_Disable (0UL) /*!< Disable read access watch in this region */
++#define MWU_REGIONEN_RGN3RA_Enable (1UL) /*!< Enable read access watch in this region */
++
++/* Bit 6 : Enable/disable write access watch in region[3] */
++#define MWU_REGIONEN_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
++#define MWU_REGIONEN_RGN3WA_Msk (0x1UL << MWU_REGIONEN_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
++#define MWU_REGIONEN_RGN3WA_Disable (0UL) /*!< Disable write access watch in this region */
++#define MWU_REGIONEN_RGN3WA_Enable (1UL) /*!< Enable write access watch in this region */
++
++/* Bit 5 : Enable/disable read access watch in region[2] */
++#define MWU_REGIONEN_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
++#define MWU_REGIONEN_RGN2RA_Msk (0x1UL << MWU_REGIONEN_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
++#define MWU_REGIONEN_RGN2RA_Disable (0UL) /*!< Disable read access watch in this region */
++#define MWU_REGIONEN_RGN2RA_Enable (1UL) /*!< Enable read access watch in this region */
++
++/* Bit 4 : Enable/disable write access watch in region[2] */
++#define MWU_REGIONEN_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
++#define MWU_REGIONEN_RGN2WA_Msk (0x1UL << MWU_REGIONEN_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
++#define MWU_REGIONEN_RGN2WA_Disable (0UL) /*!< Disable write access watch in this region */
++#define MWU_REGIONEN_RGN2WA_Enable (1UL) /*!< Enable write access watch in this region */
++
++/* Bit 3 : Enable/disable read access watch in region[1] */
++#define MWU_REGIONEN_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
++#define MWU_REGIONEN_RGN1RA_Msk (0x1UL << MWU_REGIONEN_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
++#define MWU_REGIONEN_RGN1RA_Disable (0UL) /*!< Disable read access watch in this region */
++#define MWU_REGIONEN_RGN1RA_Enable (1UL) /*!< Enable read access watch in this region */
++
++/* Bit 2 : Enable/disable write access watch in region[1] */
++#define MWU_REGIONEN_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
++#define MWU_REGIONEN_RGN1WA_Msk (0x1UL << MWU_REGIONEN_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
++#define MWU_REGIONEN_RGN1WA_Disable (0UL) /*!< Disable write access watch in this region */
++#define MWU_REGIONEN_RGN1WA_Enable (1UL) /*!< Enable write access watch in this region */
++
++/* Bit 1 : Enable/disable read access watch in region[0] */
++#define MWU_REGIONEN_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
++#define MWU_REGIONEN_RGN0RA_Msk (0x1UL << MWU_REGIONEN_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
++#define MWU_REGIONEN_RGN0RA_Disable (0UL) /*!< Disable read access watch in this region */
++#define MWU_REGIONEN_RGN0RA_Enable (1UL) /*!< Enable read access watch in this region */
++
++/* Bit 0 : Enable/disable write access watch in region[0] */
++#define MWU_REGIONEN_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
++#define MWU_REGIONEN_RGN0WA_Msk (0x1UL << MWU_REGIONEN_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
++#define MWU_REGIONEN_RGN0WA_Disable (0UL) /*!< Disable write access watch in this region */
++#define MWU_REGIONEN_RGN0WA_Enable (1UL) /*!< Enable write access watch in this region */
++
++/* Register: MWU_REGIONENSET */
++/* Description: Enable regions watch */
++
++/* Bit 27 : Enable read access watch in PREGION[1] */
++#define MWU_REGIONENSET_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
++#define MWU_REGIONENSET_PRGN1RA_Msk (0x1UL << MWU_REGIONENSET_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
++#define MWU_REGIONENSET_PRGN1RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
++#define MWU_REGIONENSET_PRGN1RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
++#define MWU_REGIONENSET_PRGN1RA_Set (1UL) /*!< Enable read access watch in this PREGION */
++
++/* Bit 26 : Enable write access watch in PREGION[1] */
++#define MWU_REGIONENSET_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
++#define MWU_REGIONENSET_PRGN1WA_Msk (0x1UL << MWU_REGIONENSET_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
++#define MWU_REGIONENSET_PRGN1WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
++#define MWU_REGIONENSET_PRGN1WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
++#define MWU_REGIONENSET_PRGN1WA_Set (1UL) /*!< Enable write access watch in this PREGION */
++
++/* Bit 25 : Enable read access watch in PREGION[0] */
++#define MWU_REGIONENSET_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
++#define MWU_REGIONENSET_PRGN0RA_Msk (0x1UL << MWU_REGIONENSET_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
++#define MWU_REGIONENSET_PRGN0RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
++#define MWU_REGIONENSET_PRGN0RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
++#define MWU_REGIONENSET_PRGN0RA_Set (1UL) /*!< Enable read access watch in this PREGION */
++
++/* Bit 24 : Enable write access watch in PREGION[0] */
++#define MWU_REGIONENSET_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
++#define MWU_REGIONENSET_PRGN0WA_Msk (0x1UL << MWU_REGIONENSET_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
++#define MWU_REGIONENSET_PRGN0WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
++#define MWU_REGIONENSET_PRGN0WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
++#define MWU_REGIONENSET_PRGN0WA_Set (1UL) /*!< Enable write access watch in this PREGION */
++
++/* Bit 7 : Enable read access watch in region[3] */
++#define MWU_REGIONENSET_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
++#define MWU_REGIONENSET_RGN3RA_Msk (0x1UL << MWU_REGIONENSET_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
++#define MWU_REGIONENSET_RGN3RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
++#define MWU_REGIONENSET_RGN3RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
++#define MWU_REGIONENSET_RGN3RA_Set (1UL) /*!< Enable read access watch in this region */
++
++/* Bit 6 : Enable write access watch in region[3] */
++#define MWU_REGIONENSET_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
++#define MWU_REGIONENSET_RGN3WA_Msk (0x1UL << MWU_REGIONENSET_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
++#define MWU_REGIONENSET_RGN3WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
++#define MWU_REGIONENSET_RGN3WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
++#define MWU_REGIONENSET_RGN3WA_Set (1UL) /*!< Enable write access watch in this region */
++
++/* Bit 5 : Enable read access watch in region[2] */
++#define MWU_REGIONENSET_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
++#define MWU_REGIONENSET_RGN2RA_Msk (0x1UL << MWU_REGIONENSET_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
++#define MWU_REGIONENSET_RGN2RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
++#define MWU_REGIONENSET_RGN2RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
++#define MWU_REGIONENSET_RGN2RA_Set (1UL) /*!< Enable read access watch in this region */
++
++/* Bit 4 : Enable write access watch in region[2] */
++#define MWU_REGIONENSET_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
++#define MWU_REGIONENSET_RGN2WA_Msk (0x1UL << MWU_REGIONENSET_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
++#define MWU_REGIONENSET_RGN2WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
++#define MWU_REGIONENSET_RGN2WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
++#define MWU_REGIONENSET_RGN2WA_Set (1UL) /*!< Enable write access watch in this region */
++
++/* Bit 3 : Enable read access watch in region[1] */
++#define MWU_REGIONENSET_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
++#define MWU_REGIONENSET_RGN1RA_Msk (0x1UL << MWU_REGIONENSET_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
++#define MWU_REGIONENSET_RGN1RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
++#define MWU_REGIONENSET_RGN1RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
++#define MWU_REGIONENSET_RGN1RA_Set (1UL) /*!< Enable read access watch in this region */
++
++/* Bit 2 : Enable write access watch in region[1] */
++#define MWU_REGIONENSET_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
++#define MWU_REGIONENSET_RGN1WA_Msk (0x1UL << MWU_REGIONENSET_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
++#define MWU_REGIONENSET_RGN1WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
++#define MWU_REGIONENSET_RGN1WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
++#define MWU_REGIONENSET_RGN1WA_Set (1UL) /*!< Enable write access watch in this region */
++
++/* Bit 1 : Enable read access watch in region[0] */
++#define MWU_REGIONENSET_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
++#define MWU_REGIONENSET_RGN0RA_Msk (0x1UL << MWU_REGIONENSET_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
++#define MWU_REGIONENSET_RGN0RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
++#define MWU_REGIONENSET_RGN0RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
++#define MWU_REGIONENSET_RGN0RA_Set (1UL) /*!< Enable read access watch in this region */
++
++/* Bit 0 : Enable write access watch in region[0] */
++#define MWU_REGIONENSET_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
++#define MWU_REGIONENSET_RGN0WA_Msk (0x1UL << MWU_REGIONENSET_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
++#define MWU_REGIONENSET_RGN0WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
++#define MWU_REGIONENSET_RGN0WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
++#define MWU_REGIONENSET_RGN0WA_Set (1UL) /*!< Enable write access watch in this region */
++
++/* Register: MWU_REGIONENCLR */
++/* Description: Disable regions watch */
++
++/* Bit 27 : Disable read access watch in PREGION[1] */
++#define MWU_REGIONENCLR_PRGN1RA_Pos (27UL) /*!< Position of PRGN1RA field. */
++#define MWU_REGIONENCLR_PRGN1RA_Msk (0x1UL << MWU_REGIONENCLR_PRGN1RA_Pos) /*!< Bit mask of PRGN1RA field. */
++#define MWU_REGIONENCLR_PRGN1RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
++#define MWU_REGIONENCLR_PRGN1RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
++#define MWU_REGIONENCLR_PRGN1RA_Clear (1UL) /*!< Disable read access watch in this PREGION */
++
++/* Bit 26 : Disable write access watch in PREGION[1] */
++#define MWU_REGIONENCLR_PRGN1WA_Pos (26UL) /*!< Position of PRGN1WA field. */
++#define MWU_REGIONENCLR_PRGN1WA_Msk (0x1UL << MWU_REGIONENCLR_PRGN1WA_Pos) /*!< Bit mask of PRGN1WA field. */
++#define MWU_REGIONENCLR_PRGN1WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
++#define MWU_REGIONENCLR_PRGN1WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
++#define MWU_REGIONENCLR_PRGN1WA_Clear (1UL) /*!< Disable write access watch in this PREGION */
++
++/* Bit 25 : Disable read access watch in PREGION[0] */
++#define MWU_REGIONENCLR_PRGN0RA_Pos (25UL) /*!< Position of PRGN0RA field. */
++#define MWU_REGIONENCLR_PRGN0RA_Msk (0x1UL << MWU_REGIONENCLR_PRGN0RA_Pos) /*!< Bit mask of PRGN0RA field. */
++#define MWU_REGIONENCLR_PRGN0RA_Disabled (0UL) /*!< Read access watch in this PREGION is disabled */
++#define MWU_REGIONENCLR_PRGN0RA_Enabled (1UL) /*!< Read access watch in this PREGION is enabled */
++#define MWU_REGIONENCLR_PRGN0RA_Clear (1UL) /*!< Disable read access watch in this PREGION */
++
++/* Bit 24 : Disable write access watch in PREGION[0] */
++#define MWU_REGIONENCLR_PRGN0WA_Pos (24UL) /*!< Position of PRGN0WA field. */
++#define MWU_REGIONENCLR_PRGN0WA_Msk (0x1UL << MWU_REGIONENCLR_PRGN0WA_Pos) /*!< Bit mask of PRGN0WA field. */
++#define MWU_REGIONENCLR_PRGN0WA_Disabled (0UL) /*!< Write access watch in this PREGION is disabled */
++#define MWU_REGIONENCLR_PRGN0WA_Enabled (1UL) /*!< Write access watch in this PREGION is enabled */
++#define MWU_REGIONENCLR_PRGN0WA_Clear (1UL) /*!< Disable write access watch in this PREGION */
++
++/* Bit 7 : Disable read access watch in region[3] */
++#define MWU_REGIONENCLR_RGN3RA_Pos (7UL) /*!< Position of RGN3RA field. */
++#define MWU_REGIONENCLR_RGN3RA_Msk (0x1UL << MWU_REGIONENCLR_RGN3RA_Pos) /*!< Bit mask of RGN3RA field. */
++#define MWU_REGIONENCLR_RGN3RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
++#define MWU_REGIONENCLR_RGN3RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
++#define MWU_REGIONENCLR_RGN3RA_Clear (1UL) /*!< Disable read access watch in this region */
++
++/* Bit 6 : Disable write access watch in region[3] */
++#define MWU_REGIONENCLR_RGN3WA_Pos (6UL) /*!< Position of RGN3WA field. */
++#define MWU_REGIONENCLR_RGN3WA_Msk (0x1UL << MWU_REGIONENCLR_RGN3WA_Pos) /*!< Bit mask of RGN3WA field. */
++#define MWU_REGIONENCLR_RGN3WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
++#define MWU_REGIONENCLR_RGN3WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
++#define MWU_REGIONENCLR_RGN3WA_Clear (1UL) /*!< Disable write access watch in this region */
++
++/* Bit 5 : Disable read access watch in region[2] */
++#define MWU_REGIONENCLR_RGN2RA_Pos (5UL) /*!< Position of RGN2RA field. */
++#define MWU_REGIONENCLR_RGN2RA_Msk (0x1UL << MWU_REGIONENCLR_RGN2RA_Pos) /*!< Bit mask of RGN2RA field. */
++#define MWU_REGIONENCLR_RGN2RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
++#define MWU_REGIONENCLR_RGN2RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
++#define MWU_REGIONENCLR_RGN2RA_Clear (1UL) /*!< Disable read access watch in this region */
++
++/* Bit 4 : Disable write access watch in region[2] */
++#define MWU_REGIONENCLR_RGN2WA_Pos (4UL) /*!< Position of RGN2WA field. */
++#define MWU_REGIONENCLR_RGN2WA_Msk (0x1UL << MWU_REGIONENCLR_RGN2WA_Pos) /*!< Bit mask of RGN2WA field. */
++#define MWU_REGIONENCLR_RGN2WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
++#define MWU_REGIONENCLR_RGN2WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
++#define MWU_REGIONENCLR_RGN2WA_Clear (1UL) /*!< Disable write access watch in this region */
++
++/* Bit 3 : Disable read access watch in region[1] */
++#define MWU_REGIONENCLR_RGN1RA_Pos (3UL) /*!< Position of RGN1RA field. */
++#define MWU_REGIONENCLR_RGN1RA_Msk (0x1UL << MWU_REGIONENCLR_RGN1RA_Pos) /*!< Bit mask of RGN1RA field. */
++#define MWU_REGIONENCLR_RGN1RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
++#define MWU_REGIONENCLR_RGN1RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
++#define MWU_REGIONENCLR_RGN1RA_Clear (1UL) /*!< Disable read access watch in this region */
++
++/* Bit 2 : Disable write access watch in region[1] */
++#define MWU_REGIONENCLR_RGN1WA_Pos (2UL) /*!< Position of RGN1WA field. */
++#define MWU_REGIONENCLR_RGN1WA_Msk (0x1UL << MWU_REGIONENCLR_RGN1WA_Pos) /*!< Bit mask of RGN1WA field. */
++#define MWU_REGIONENCLR_RGN1WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
++#define MWU_REGIONENCLR_RGN1WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
++#define MWU_REGIONENCLR_RGN1WA_Clear (1UL) /*!< Disable write access watch in this region */
++
++/* Bit 1 : Disable read access watch in region[0] */
++#define MWU_REGIONENCLR_RGN0RA_Pos (1UL) /*!< Position of RGN0RA field. */
++#define MWU_REGIONENCLR_RGN0RA_Msk (0x1UL << MWU_REGIONENCLR_RGN0RA_Pos) /*!< Bit mask of RGN0RA field. */
++#define MWU_REGIONENCLR_RGN0RA_Disabled (0UL) /*!< Read access watch in this region is disabled */
++#define MWU_REGIONENCLR_RGN0RA_Enabled (1UL) /*!< Read access watch in this region is enabled */
++#define MWU_REGIONENCLR_RGN0RA_Clear (1UL) /*!< Disable read access watch in this region */
++
++/* Bit 0 : Disable write access watch in region[0] */
++#define MWU_REGIONENCLR_RGN0WA_Pos (0UL) /*!< Position of RGN0WA field. */
++#define MWU_REGIONENCLR_RGN0WA_Msk (0x1UL << MWU_REGIONENCLR_RGN0WA_Pos) /*!< Bit mask of RGN0WA field. */
++#define MWU_REGIONENCLR_RGN0WA_Disabled (0UL) /*!< Write access watch in this region is disabled */
++#define MWU_REGIONENCLR_RGN0WA_Enabled (1UL) /*!< Write access watch in this region is enabled */
++#define MWU_REGIONENCLR_RGN0WA_Clear (1UL) /*!< Disable write access watch in this region */
++
++/* Register: MWU_REGION_START */
++/* Description: Description cluster: Start address for region n */
++
++/* Bits 31..0 : Start address for region */
++#define MWU_REGION_START_START_Pos (0UL) /*!< Position of START field. */
++#define MWU_REGION_START_START_Msk (0xFFFFFFFFUL << MWU_REGION_START_START_Pos) /*!< Bit mask of START field. */
++
++/* Register: MWU_REGION_END */
++/* Description: Description cluster: End address of region n */
++
++/* Bits 31..0 : End address of region. */
++#define MWU_REGION_END_END_Pos (0UL) /*!< Position of END field. */
++#define MWU_REGION_END_END_Msk (0xFFFFFFFFUL << MWU_REGION_END_END_Pos) /*!< Bit mask of END field. */
++
++/* Register: MWU_PREGION_START */
++/* Description: Description cluster: Reserved for future use */
++
++/* Bits 31..0 : Reserved for future use */
++#define MWU_PREGION_START_START_Pos (0UL) /*!< Position of START field. */
++#define MWU_PREGION_START_START_Msk (0xFFFFFFFFUL << MWU_PREGION_START_START_Pos) /*!< Bit mask of START field. */
++
++/* Register: MWU_PREGION_END */
++/* Description: Description cluster: Reserved for future use */
++
++/* Bits 31..0 : Reserved for future use */
++#define MWU_PREGION_END_END_Pos (0UL) /*!< Position of END field. */
++#define MWU_PREGION_END_END_Msk (0xFFFFFFFFUL << MWU_PREGION_END_END_Pos) /*!< Bit mask of END field. */
++
++/* Register: MWU_PREGION_SUBS */
++/* Description: Description cluster: Subregions of region n */
++
++/* Bit 31 : Include or exclude subregion 31 in region */
++#define MWU_PREGION_SUBS_SR31_Pos (31UL) /*!< Position of SR31 field. */
++#define MWU_PREGION_SUBS_SR31_Msk (0x1UL << MWU_PREGION_SUBS_SR31_Pos) /*!< Bit mask of SR31 field. */
++#define MWU_PREGION_SUBS_SR31_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR31_Include (1UL) /*!< Include */
++
++/* Bit 30 : Include or exclude subregion 30 in region */
++#define MWU_PREGION_SUBS_SR30_Pos (30UL) /*!< Position of SR30 field. */
++#define MWU_PREGION_SUBS_SR30_Msk (0x1UL << MWU_PREGION_SUBS_SR30_Pos) /*!< Bit mask of SR30 field. */
++#define MWU_PREGION_SUBS_SR30_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR30_Include (1UL) /*!< Include */
++
++/* Bit 29 : Include or exclude subregion 29 in region */
++#define MWU_PREGION_SUBS_SR29_Pos (29UL) /*!< Position of SR29 field. */
++#define MWU_PREGION_SUBS_SR29_Msk (0x1UL << MWU_PREGION_SUBS_SR29_Pos) /*!< Bit mask of SR29 field. */
++#define MWU_PREGION_SUBS_SR29_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR29_Include (1UL) /*!< Include */
++
++/* Bit 28 : Include or exclude subregion 28 in region */
++#define MWU_PREGION_SUBS_SR28_Pos (28UL) /*!< Position of SR28 field. */
++#define MWU_PREGION_SUBS_SR28_Msk (0x1UL << MWU_PREGION_SUBS_SR28_Pos) /*!< Bit mask of SR28 field. */
++#define MWU_PREGION_SUBS_SR28_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR28_Include (1UL) /*!< Include */
++
++/* Bit 27 : Include or exclude subregion 27 in region */
++#define MWU_PREGION_SUBS_SR27_Pos (27UL) /*!< Position of SR27 field. */
++#define MWU_PREGION_SUBS_SR27_Msk (0x1UL << MWU_PREGION_SUBS_SR27_Pos) /*!< Bit mask of SR27 field. */
++#define MWU_PREGION_SUBS_SR27_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR27_Include (1UL) /*!< Include */
++
++/* Bit 26 : Include or exclude subregion 26 in region */
++#define MWU_PREGION_SUBS_SR26_Pos (26UL) /*!< Position of SR26 field. */
++#define MWU_PREGION_SUBS_SR26_Msk (0x1UL << MWU_PREGION_SUBS_SR26_Pos) /*!< Bit mask of SR26 field. */
++#define MWU_PREGION_SUBS_SR26_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR26_Include (1UL) /*!< Include */
++
++/* Bit 25 : Include or exclude subregion 25 in region */
++#define MWU_PREGION_SUBS_SR25_Pos (25UL) /*!< Position of SR25 field. */
++#define MWU_PREGION_SUBS_SR25_Msk (0x1UL << MWU_PREGION_SUBS_SR25_Pos) /*!< Bit mask of SR25 field. */
++#define MWU_PREGION_SUBS_SR25_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR25_Include (1UL) /*!< Include */
++
++/* Bit 24 : Include or exclude subregion 24 in region */
++#define MWU_PREGION_SUBS_SR24_Pos (24UL) /*!< Position of SR24 field. */
++#define MWU_PREGION_SUBS_SR24_Msk (0x1UL << MWU_PREGION_SUBS_SR24_Pos) /*!< Bit mask of SR24 field. */
++#define MWU_PREGION_SUBS_SR24_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR24_Include (1UL) /*!< Include */
++
++/* Bit 23 : Include or exclude subregion 23 in region */
++#define MWU_PREGION_SUBS_SR23_Pos (23UL) /*!< Position of SR23 field. */
++#define MWU_PREGION_SUBS_SR23_Msk (0x1UL << MWU_PREGION_SUBS_SR23_Pos) /*!< Bit mask of SR23 field. */
++#define MWU_PREGION_SUBS_SR23_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR23_Include (1UL) /*!< Include */
++
++/* Bit 22 : Include or exclude subregion 22 in region */
++#define MWU_PREGION_SUBS_SR22_Pos (22UL) /*!< Position of SR22 field. */
++#define MWU_PREGION_SUBS_SR22_Msk (0x1UL << MWU_PREGION_SUBS_SR22_Pos) /*!< Bit mask of SR22 field. */
++#define MWU_PREGION_SUBS_SR22_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR22_Include (1UL) /*!< Include */
++
++/* Bit 21 : Include or exclude subregion 21 in region */
++#define MWU_PREGION_SUBS_SR21_Pos (21UL) /*!< Position of SR21 field. */
++#define MWU_PREGION_SUBS_SR21_Msk (0x1UL << MWU_PREGION_SUBS_SR21_Pos) /*!< Bit mask of SR21 field. */
++#define MWU_PREGION_SUBS_SR21_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR21_Include (1UL) /*!< Include */
++
++/* Bit 20 : Include or exclude subregion 20 in region */
++#define MWU_PREGION_SUBS_SR20_Pos (20UL) /*!< Position of SR20 field. */
++#define MWU_PREGION_SUBS_SR20_Msk (0x1UL << MWU_PREGION_SUBS_SR20_Pos) /*!< Bit mask of SR20 field. */
++#define MWU_PREGION_SUBS_SR20_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR20_Include (1UL) /*!< Include */
++
++/* Bit 19 : Include or exclude subregion 19 in region */
++#define MWU_PREGION_SUBS_SR19_Pos (19UL) /*!< Position of SR19 field. */
++#define MWU_PREGION_SUBS_SR19_Msk (0x1UL << MWU_PREGION_SUBS_SR19_Pos) /*!< Bit mask of SR19 field. */
++#define MWU_PREGION_SUBS_SR19_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR19_Include (1UL) /*!< Include */
++
++/* Bit 18 : Include or exclude subregion 18 in region */
++#define MWU_PREGION_SUBS_SR18_Pos (18UL) /*!< Position of SR18 field. */
++#define MWU_PREGION_SUBS_SR18_Msk (0x1UL << MWU_PREGION_SUBS_SR18_Pos) /*!< Bit mask of SR18 field. */
++#define MWU_PREGION_SUBS_SR18_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR18_Include (1UL) /*!< Include */
++
++/* Bit 17 : Include or exclude subregion 17 in region */
++#define MWU_PREGION_SUBS_SR17_Pos (17UL) /*!< Position of SR17 field. */
++#define MWU_PREGION_SUBS_SR17_Msk (0x1UL << MWU_PREGION_SUBS_SR17_Pos) /*!< Bit mask of SR17 field. */
++#define MWU_PREGION_SUBS_SR17_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR17_Include (1UL) /*!< Include */
++
++/* Bit 16 : Include or exclude subregion 16 in region */
++#define MWU_PREGION_SUBS_SR16_Pos (16UL) /*!< Position of SR16 field. */
++#define MWU_PREGION_SUBS_SR16_Msk (0x1UL << MWU_PREGION_SUBS_SR16_Pos) /*!< Bit mask of SR16 field. */
++#define MWU_PREGION_SUBS_SR16_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR16_Include (1UL) /*!< Include */
++
++/* Bit 15 : Include or exclude subregion 15 in region */
++#define MWU_PREGION_SUBS_SR15_Pos (15UL) /*!< Position of SR15 field. */
++#define MWU_PREGION_SUBS_SR15_Msk (0x1UL << MWU_PREGION_SUBS_SR15_Pos) /*!< Bit mask of SR15 field. */
++#define MWU_PREGION_SUBS_SR15_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR15_Include (1UL) /*!< Include */
++
++/* Bit 14 : Include or exclude subregion 14 in region */
++#define MWU_PREGION_SUBS_SR14_Pos (14UL) /*!< Position of SR14 field. */
++#define MWU_PREGION_SUBS_SR14_Msk (0x1UL << MWU_PREGION_SUBS_SR14_Pos) /*!< Bit mask of SR14 field. */
++#define MWU_PREGION_SUBS_SR14_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR14_Include (1UL) /*!< Include */
++
++/* Bit 13 : Include or exclude subregion 13 in region */
++#define MWU_PREGION_SUBS_SR13_Pos (13UL) /*!< Position of SR13 field. */
++#define MWU_PREGION_SUBS_SR13_Msk (0x1UL << MWU_PREGION_SUBS_SR13_Pos) /*!< Bit mask of SR13 field. */
++#define MWU_PREGION_SUBS_SR13_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR13_Include (1UL) /*!< Include */
++
++/* Bit 12 : Include or exclude subregion 12 in region */
++#define MWU_PREGION_SUBS_SR12_Pos (12UL) /*!< Position of SR12 field. */
++#define MWU_PREGION_SUBS_SR12_Msk (0x1UL << MWU_PREGION_SUBS_SR12_Pos) /*!< Bit mask of SR12 field. */
++#define MWU_PREGION_SUBS_SR12_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR12_Include (1UL) /*!< Include */
++
++/* Bit 11 : Include or exclude subregion 11 in region */
++#define MWU_PREGION_SUBS_SR11_Pos (11UL) /*!< Position of SR11 field. */
++#define MWU_PREGION_SUBS_SR11_Msk (0x1UL << MWU_PREGION_SUBS_SR11_Pos) /*!< Bit mask of SR11 field. */
++#define MWU_PREGION_SUBS_SR11_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR11_Include (1UL) /*!< Include */
++
++/* Bit 10 : Include or exclude subregion 10 in region */
++#define MWU_PREGION_SUBS_SR10_Pos (10UL) /*!< Position of SR10 field. */
++#define MWU_PREGION_SUBS_SR10_Msk (0x1UL << MWU_PREGION_SUBS_SR10_Pos) /*!< Bit mask of SR10 field. */
++#define MWU_PREGION_SUBS_SR10_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR10_Include (1UL) /*!< Include */
++
++/* Bit 9 : Include or exclude subregion 9 in region */
++#define MWU_PREGION_SUBS_SR9_Pos (9UL) /*!< Position of SR9 field. */
++#define MWU_PREGION_SUBS_SR9_Msk (0x1UL << MWU_PREGION_SUBS_SR9_Pos) /*!< Bit mask of SR9 field. */
++#define MWU_PREGION_SUBS_SR9_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR9_Include (1UL) /*!< Include */
++
++/* Bit 8 : Include or exclude subregion 8 in region */
++#define MWU_PREGION_SUBS_SR8_Pos (8UL) /*!< Position of SR8 field. */
++#define MWU_PREGION_SUBS_SR8_Msk (0x1UL << MWU_PREGION_SUBS_SR8_Pos) /*!< Bit mask of SR8 field. */
++#define MWU_PREGION_SUBS_SR8_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR8_Include (1UL) /*!< Include */
++
++/* Bit 7 : Include or exclude subregion 7 in region */
++#define MWU_PREGION_SUBS_SR7_Pos (7UL) /*!< Position of SR7 field. */
++#define MWU_PREGION_SUBS_SR7_Msk (0x1UL << MWU_PREGION_SUBS_SR7_Pos) /*!< Bit mask of SR7 field. */
++#define MWU_PREGION_SUBS_SR7_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR7_Include (1UL) /*!< Include */
++
++/* Bit 6 : Include or exclude subregion 6 in region */
++#define MWU_PREGION_SUBS_SR6_Pos (6UL) /*!< Position of SR6 field. */
++#define MWU_PREGION_SUBS_SR6_Msk (0x1UL << MWU_PREGION_SUBS_SR6_Pos) /*!< Bit mask of SR6 field. */
++#define MWU_PREGION_SUBS_SR6_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR6_Include (1UL) /*!< Include */
++
++/* Bit 5 : Include or exclude subregion 5 in region */
++#define MWU_PREGION_SUBS_SR5_Pos (5UL) /*!< Position of SR5 field. */
++#define MWU_PREGION_SUBS_SR5_Msk (0x1UL << MWU_PREGION_SUBS_SR5_Pos) /*!< Bit mask of SR5 field. */
++#define MWU_PREGION_SUBS_SR5_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR5_Include (1UL) /*!< Include */
++
++/* Bit 4 : Include or exclude subregion 4 in region */
++#define MWU_PREGION_SUBS_SR4_Pos (4UL) /*!< Position of SR4 field. */
++#define MWU_PREGION_SUBS_SR4_Msk (0x1UL << MWU_PREGION_SUBS_SR4_Pos) /*!< Bit mask of SR4 field. */
++#define MWU_PREGION_SUBS_SR4_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR4_Include (1UL) /*!< Include */
++
++/* Bit 3 : Include or exclude subregion 3 in region */
++#define MWU_PREGION_SUBS_SR3_Pos (3UL) /*!< Position of SR3 field. */
++#define MWU_PREGION_SUBS_SR3_Msk (0x1UL << MWU_PREGION_SUBS_SR3_Pos) /*!< Bit mask of SR3 field. */
++#define MWU_PREGION_SUBS_SR3_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR3_Include (1UL) /*!< Include */
++
++/* Bit 2 : Include or exclude subregion 2 in region */
++#define MWU_PREGION_SUBS_SR2_Pos (2UL) /*!< Position of SR2 field. */
++#define MWU_PREGION_SUBS_SR2_Msk (0x1UL << MWU_PREGION_SUBS_SR2_Pos) /*!< Bit mask of SR2 field. */
++#define MWU_PREGION_SUBS_SR2_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR2_Include (1UL) /*!< Include */
++
++/* Bit 1 : Include or exclude subregion 1 in region */
++#define MWU_PREGION_SUBS_SR1_Pos (1UL) /*!< Position of SR1 field. */
++#define MWU_PREGION_SUBS_SR1_Msk (0x1UL << MWU_PREGION_SUBS_SR1_Pos) /*!< Bit mask of SR1 field. */
++#define MWU_PREGION_SUBS_SR1_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR1_Include (1UL) /*!< Include */
++
++/* Bit 0 : Include or exclude subregion 0 in region */
++#define MWU_PREGION_SUBS_SR0_Pos (0UL) /*!< Position of SR0 field. */
++#define MWU_PREGION_SUBS_SR0_Msk (0x1UL << MWU_PREGION_SUBS_SR0_Pos) /*!< Bit mask of SR0 field. */
++#define MWU_PREGION_SUBS_SR0_Exclude (0UL) /*!< Exclude */
++#define MWU_PREGION_SUBS_SR0_Include (1UL) /*!< Include */
++
++
++/* Peripheral: NFCT */
++/* Description: NFC-A compatible radio */
++
++/* Register: NFCT_TASKS_ACTIVATE */
++/* Description: Activate NFCT peripheral for incoming and outgoing frames, change state to activated */
++
++/* Bit 0 : Activate NFCT peripheral for incoming and outgoing frames, change state to activated */
++#define NFCT_TASKS_ACTIVATE_TASKS_ACTIVATE_Pos (0UL) /*!< Position of TASKS_ACTIVATE field. */
++#define NFCT_TASKS_ACTIVATE_TASKS_ACTIVATE_Msk (0x1UL << NFCT_TASKS_ACTIVATE_TASKS_ACTIVATE_Pos) /*!< Bit mask of TASKS_ACTIVATE field. */
++#define NFCT_TASKS_ACTIVATE_TASKS_ACTIVATE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: NFCT_TASKS_DISABLE */
++/* Description: Disable NFCT peripheral */
++
++/* Bit 0 : Disable NFCT peripheral */
++#define NFCT_TASKS_DISABLE_TASKS_DISABLE_Pos (0UL) /*!< Position of TASKS_DISABLE field. */
++#define NFCT_TASKS_DISABLE_TASKS_DISABLE_Msk (0x1UL << NFCT_TASKS_DISABLE_TASKS_DISABLE_Pos) /*!< Bit mask of TASKS_DISABLE field. */
++#define NFCT_TASKS_DISABLE_TASKS_DISABLE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: NFCT_TASKS_SENSE */
++/* Description: Enable NFC sense field mode, change state to sense mode */
++
++/* Bit 0 : Enable NFC sense field mode, change state to sense mode */
++#define NFCT_TASKS_SENSE_TASKS_SENSE_Pos (0UL) /*!< Position of TASKS_SENSE field. */
++#define NFCT_TASKS_SENSE_TASKS_SENSE_Msk (0x1UL << NFCT_TASKS_SENSE_TASKS_SENSE_Pos) /*!< Bit mask of TASKS_SENSE field. */
++#define NFCT_TASKS_SENSE_TASKS_SENSE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: NFCT_TASKS_STARTTX */
++/* Description: Start transmission of an outgoing frame, change state to transmit */
++
++/* Bit 0 : Start transmission of an outgoing frame, change state to transmit */
++#define NFCT_TASKS_STARTTX_TASKS_STARTTX_Pos (0UL) /*!< Position of TASKS_STARTTX field. */
++#define NFCT_TASKS_STARTTX_TASKS_STARTTX_Msk (0x1UL << NFCT_TASKS_STARTTX_TASKS_STARTTX_Pos) /*!< Bit mask of TASKS_STARTTX field. */
++#define NFCT_TASKS_STARTTX_TASKS_STARTTX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: NFCT_TASKS_ENABLERXDATA */
++/* Description: Initializes the EasyDMA for receive. */
++
++/* Bit 0 : Initializes the EasyDMA for receive. */
++#define NFCT_TASKS_ENABLERXDATA_TASKS_ENABLERXDATA_Pos (0UL) /*!< Position of TASKS_ENABLERXDATA field. */
++#define NFCT_TASKS_ENABLERXDATA_TASKS_ENABLERXDATA_Msk (0x1UL << NFCT_TASKS_ENABLERXDATA_TASKS_ENABLERXDATA_Pos) /*!< Bit mask of TASKS_ENABLERXDATA field. */
++#define NFCT_TASKS_ENABLERXDATA_TASKS_ENABLERXDATA_Trigger (1UL) /*!< Trigger task */
++
++/* Register: NFCT_TASKS_GOIDLE */
++/* Description: Force state machine to IDLE state */
++
++/* Bit 0 : Force state machine to IDLE state */
++#define NFCT_TASKS_GOIDLE_TASKS_GOIDLE_Pos (0UL) /*!< Position of TASKS_GOIDLE field. */
++#define NFCT_TASKS_GOIDLE_TASKS_GOIDLE_Msk (0x1UL << NFCT_TASKS_GOIDLE_TASKS_GOIDLE_Pos) /*!< Bit mask of TASKS_GOIDLE field. */
++#define NFCT_TASKS_GOIDLE_TASKS_GOIDLE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: NFCT_TASKS_GOSLEEP */
++/* Description: Force state machine to SLEEP_A state */
++
++/* Bit 0 : Force state machine to SLEEP_A state */
++#define NFCT_TASKS_GOSLEEP_TASKS_GOSLEEP_Pos (0UL) /*!< Position of TASKS_GOSLEEP field. */
++#define NFCT_TASKS_GOSLEEP_TASKS_GOSLEEP_Msk (0x1UL << NFCT_TASKS_GOSLEEP_TASKS_GOSLEEP_Pos) /*!< Bit mask of TASKS_GOSLEEP field. */
++#define NFCT_TASKS_GOSLEEP_TASKS_GOSLEEP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: NFCT_EVENTS_READY */
++/* Description: The NFCT peripheral is ready to receive and send frames */
++
++/* Bit 0 : The NFCT peripheral is ready to receive and send frames */
++#define NFCT_EVENTS_READY_EVENTS_READY_Pos (0UL) /*!< Position of EVENTS_READY field. */
++#define NFCT_EVENTS_READY_EVENTS_READY_Msk (0x1UL << NFCT_EVENTS_READY_EVENTS_READY_Pos) /*!< Bit mask of EVENTS_READY field. */
++#define NFCT_EVENTS_READY_EVENTS_READY_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_READY_EVENTS_READY_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_FIELDDETECTED */
++/* Description: Remote NFC field detected */
++
++/* Bit 0 : Remote NFC field detected */
++#define NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_Pos (0UL) /*!< Position of EVENTS_FIELDDETECTED field. */
++#define NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_Msk (0x1UL << NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_Pos) /*!< Bit mask of EVENTS_FIELDDETECTED field. */
++#define NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_FIELDDETECTED_EVENTS_FIELDDETECTED_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_FIELDLOST */
++/* Description: Remote NFC field lost */
++
++/* Bit 0 : Remote NFC field lost */
++#define NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_Pos (0UL) /*!< Position of EVENTS_FIELDLOST field. */
++#define NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_Msk (0x1UL << NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_Pos) /*!< Bit mask of EVENTS_FIELDLOST field. */
++#define NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_FIELDLOST_EVENTS_FIELDLOST_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_TXFRAMESTART */
++/* Description: Marks the start of the first symbol of a transmitted frame */
++
++/* Bit 0 : Marks the start of the first symbol of a transmitted frame */
++#define NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_Pos (0UL) /*!< Position of EVENTS_TXFRAMESTART field. */
++#define NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_Msk (0x1UL << NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_Pos) /*!< Bit mask of EVENTS_TXFRAMESTART field. */
++#define NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_TXFRAMESTART_EVENTS_TXFRAMESTART_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_TXFRAMEEND */
++/* Description: Marks the end of the last transmitted on-air symbol of a frame */
++
++/* Bit 0 : Marks the end of the last transmitted on-air symbol of a frame */
++#define NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_Pos (0UL) /*!< Position of EVENTS_TXFRAMEEND field. */
++#define NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_Msk (0x1UL << NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_Pos) /*!< Bit mask of EVENTS_TXFRAMEEND field. */
++#define NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_TXFRAMEEND_EVENTS_TXFRAMEEND_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_RXFRAMESTART */
++/* Description: Marks the end of the first symbol of a received frame */
++
++/* Bit 0 : Marks the end of the first symbol of a received frame */
++#define NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_Pos (0UL) /*!< Position of EVENTS_RXFRAMESTART field. */
++#define NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_Msk (0x1UL << NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_Pos) /*!< Bit mask of EVENTS_RXFRAMESTART field. */
++#define NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_RXFRAMESTART_EVENTS_RXFRAMESTART_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_RXFRAMEEND */
++/* Description: Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer */
++
++/* Bit 0 : Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer */
++#define NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_Pos (0UL) /*!< Position of EVENTS_RXFRAMEEND field. */
++#define NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_Msk (0x1UL << NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_Pos) /*!< Bit mask of EVENTS_RXFRAMEEND field. */
++#define NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_RXFRAMEEND_EVENTS_RXFRAMEEND_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_ERROR */
++/* Description: NFC error reported. The ERRORSTATUS register contains details on the source of the error. */
++
++/* Bit 0 : NFC error reported. The ERRORSTATUS register contains details on the source of the error. */
++#define NFCT_EVENTS_ERROR_EVENTS_ERROR_Pos (0UL) /*!< Position of EVENTS_ERROR field. */
++#define NFCT_EVENTS_ERROR_EVENTS_ERROR_Msk (0x1UL << NFCT_EVENTS_ERROR_EVENTS_ERROR_Pos) /*!< Bit mask of EVENTS_ERROR field. */
++#define NFCT_EVENTS_ERROR_EVENTS_ERROR_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_ERROR_EVENTS_ERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_RXERROR */
++/* Description: NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error. */
++
++/* Bit 0 : NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error. */
++#define NFCT_EVENTS_RXERROR_EVENTS_RXERROR_Pos (0UL) /*!< Position of EVENTS_RXERROR field. */
++#define NFCT_EVENTS_RXERROR_EVENTS_RXERROR_Msk (0x1UL << NFCT_EVENTS_RXERROR_EVENTS_RXERROR_Pos) /*!< Bit mask of EVENTS_RXERROR field. */
++#define NFCT_EVENTS_RXERROR_EVENTS_RXERROR_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_RXERROR_EVENTS_RXERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_ENDRX */
++/* Description: RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full. */
++
++/* Bit 0 : RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full. */
++#define NFCT_EVENTS_ENDRX_EVENTS_ENDRX_Pos (0UL) /*!< Position of EVENTS_ENDRX field. */
++#define NFCT_EVENTS_ENDRX_EVENTS_ENDRX_Msk (0x1UL << NFCT_EVENTS_ENDRX_EVENTS_ENDRX_Pos) /*!< Bit mask of EVENTS_ENDRX field. */
++#define NFCT_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_ENDRX_EVENTS_ENDRX_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_ENDTX */
++/* Description: Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer */
++
++/* Bit 0 : Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer */
++#define NFCT_EVENTS_ENDTX_EVENTS_ENDTX_Pos (0UL) /*!< Position of EVENTS_ENDTX field. */
++#define NFCT_EVENTS_ENDTX_EVENTS_ENDTX_Msk (0x1UL << NFCT_EVENTS_ENDTX_EVENTS_ENDTX_Pos) /*!< Bit mask of EVENTS_ENDTX field. */
++#define NFCT_EVENTS_ENDTX_EVENTS_ENDTX_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_ENDTX_EVENTS_ENDTX_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_AUTOCOLRESSTARTED */
++/* Description: Auto collision resolution process has started */
++
++/* Bit 0 : Auto collision resolution process has started */
++#define NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_Pos (0UL) /*!< Position of EVENTS_AUTOCOLRESSTARTED field. */
++#define NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of EVENTS_AUTOCOLRESSTARTED field. */
++#define NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_AUTOCOLRESSTARTED_EVENTS_AUTOCOLRESSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_COLLISION */
++/* Description: NFC auto collision resolution error reported. */
++
++/* Bit 0 : NFC auto collision resolution error reported. */
++#define NFCT_EVENTS_COLLISION_EVENTS_COLLISION_Pos (0UL) /*!< Position of EVENTS_COLLISION field. */
++#define NFCT_EVENTS_COLLISION_EVENTS_COLLISION_Msk (0x1UL << NFCT_EVENTS_COLLISION_EVENTS_COLLISION_Pos) /*!< Bit mask of EVENTS_COLLISION field. */
++#define NFCT_EVENTS_COLLISION_EVENTS_COLLISION_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_COLLISION_EVENTS_COLLISION_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_SELECTED */
++/* Description: NFC auto collision resolution successfully completed */
++
++/* Bit 0 : NFC auto collision resolution successfully completed */
++#define NFCT_EVENTS_SELECTED_EVENTS_SELECTED_Pos (0UL) /*!< Position of EVENTS_SELECTED field. */
++#define NFCT_EVENTS_SELECTED_EVENTS_SELECTED_Msk (0x1UL << NFCT_EVENTS_SELECTED_EVENTS_SELECTED_Pos) /*!< Bit mask of EVENTS_SELECTED field. */
++#define NFCT_EVENTS_SELECTED_EVENTS_SELECTED_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_SELECTED_EVENTS_SELECTED_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_EVENTS_STARTED */
++/* Description: EasyDMA is ready to receive or send frames. */
++
++/* Bit 0 : EasyDMA is ready to receive or send frames. */
++#define NFCT_EVENTS_STARTED_EVENTS_STARTED_Pos (0UL) /*!< Position of EVENTS_STARTED field. */
++#define NFCT_EVENTS_STARTED_EVENTS_STARTED_Msk (0x1UL << NFCT_EVENTS_STARTED_EVENTS_STARTED_Pos) /*!< Bit mask of EVENTS_STARTED field. */
++#define NFCT_EVENTS_STARTED_EVENTS_STARTED_NotGenerated (0UL) /*!< Event not generated */
++#define NFCT_EVENTS_STARTED_EVENTS_STARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: NFCT_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 5 : Shortcut between event TXFRAMEEND and task ENABLERXDATA */
++#define NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Pos (5UL) /*!< Position of TXFRAMEEND_ENABLERXDATA field. */
++#define NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Msk (0x1UL << NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Pos) /*!< Bit mask of TXFRAMEEND_ENABLERXDATA field. */
++#define NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Disabled (0UL) /*!< Disable shortcut */
++#define NFCT_SHORTS_TXFRAMEEND_ENABLERXDATA_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 1 : Shortcut between event FIELDLOST and task SENSE */
++#define NFCT_SHORTS_FIELDLOST_SENSE_Pos (1UL) /*!< Position of FIELDLOST_SENSE field. */
++#define NFCT_SHORTS_FIELDLOST_SENSE_Msk (0x1UL << NFCT_SHORTS_FIELDLOST_SENSE_Pos) /*!< Bit mask of FIELDLOST_SENSE field. */
++#define NFCT_SHORTS_FIELDLOST_SENSE_Disabled (0UL) /*!< Disable shortcut */
++#define NFCT_SHORTS_FIELDLOST_SENSE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event FIELDDETECTED and task ACTIVATE */
++#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos (0UL) /*!< Position of FIELDDETECTED_ACTIVATE field. */
++#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Msk (0x1UL << NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Pos) /*!< Bit mask of FIELDDETECTED_ACTIVATE field. */
++#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Disabled (0UL) /*!< Disable shortcut */
++#define NFCT_SHORTS_FIELDDETECTED_ACTIVATE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: NFCT_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 20 : Enable or disable interrupt for event STARTED */
++#define NFCT_INTEN_STARTED_Pos (20UL) /*!< Position of STARTED field. */
++#define NFCT_INTEN_STARTED_Msk (0x1UL << NFCT_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define NFCT_INTEN_STARTED_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_STARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 19 : Enable or disable interrupt for event SELECTED */
++#define NFCT_INTEN_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
++#define NFCT_INTEN_SELECTED_Msk (0x1UL << NFCT_INTEN_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
++#define NFCT_INTEN_SELECTED_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_SELECTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 18 : Enable or disable interrupt for event COLLISION */
++#define NFCT_INTEN_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
++#define NFCT_INTEN_COLLISION_Msk (0x1UL << NFCT_INTEN_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
++#define NFCT_INTEN_COLLISION_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_COLLISION_Enabled (1UL) /*!< Enable */
++
++/* Bit 14 : Enable or disable interrupt for event AUTOCOLRESSTARTED */
++#define NFCT_INTEN_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
++#define NFCT_INTEN_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTEN_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
++#define NFCT_INTEN_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 12 : Enable or disable interrupt for event ENDTX */
++#define NFCT_INTEN_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
++#define NFCT_INTEN_ENDTX_Msk (0x1UL << NFCT_INTEN_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
++#define NFCT_INTEN_ENDTX_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_ENDTX_Enabled (1UL) /*!< Enable */
++
++/* Bit 11 : Enable or disable interrupt for event ENDRX */
++#define NFCT_INTEN_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
++#define NFCT_INTEN_ENDRX_Msk (0x1UL << NFCT_INTEN_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define NFCT_INTEN_ENDRX_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_ENDRX_Enabled (1UL) /*!< Enable */
++
++/* Bit 10 : Enable or disable interrupt for event RXERROR */
++#define NFCT_INTEN_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
++#define NFCT_INTEN_RXERROR_Msk (0x1UL << NFCT_INTEN_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
++#define NFCT_INTEN_RXERROR_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_RXERROR_Enabled (1UL) /*!< Enable */
++
++/* Bit 7 : Enable or disable interrupt for event ERROR */
++#define NFCT_INTEN_ERROR_Pos (7UL) /*!< Position of ERROR field. */
++#define NFCT_INTEN_ERROR_Msk (0x1UL << NFCT_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define NFCT_INTEN_ERROR_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_ERROR_Enabled (1UL) /*!< Enable */
++
++/* Bit 6 : Enable or disable interrupt for event RXFRAMEEND */
++#define NFCT_INTEN_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
++#define NFCT_INTEN_RXFRAMEEND_Msk (0x1UL << NFCT_INTEN_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
++#define NFCT_INTEN_RXFRAMEEND_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_RXFRAMEEND_Enabled (1UL) /*!< Enable */
++
++/* Bit 5 : Enable or disable interrupt for event RXFRAMESTART */
++#define NFCT_INTEN_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
++#define NFCT_INTEN_RXFRAMESTART_Msk (0x1UL << NFCT_INTEN_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
++#define NFCT_INTEN_RXFRAMESTART_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_RXFRAMESTART_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable interrupt for event TXFRAMEEND */
++#define NFCT_INTEN_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
++#define NFCT_INTEN_TXFRAMEEND_Msk (0x1UL << NFCT_INTEN_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
++#define NFCT_INTEN_TXFRAMEEND_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_TXFRAMEEND_Enabled (1UL) /*!< Enable */
++
++/* Bit 3 : Enable or disable interrupt for event TXFRAMESTART */
++#define NFCT_INTEN_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
++#define NFCT_INTEN_TXFRAMESTART_Msk (0x1UL << NFCT_INTEN_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
++#define NFCT_INTEN_TXFRAMESTART_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_TXFRAMESTART_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event FIELDLOST */
++#define NFCT_INTEN_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
++#define NFCT_INTEN_FIELDLOST_Msk (0x1UL << NFCT_INTEN_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
++#define NFCT_INTEN_FIELDLOST_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_FIELDLOST_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event FIELDDETECTED */
++#define NFCT_INTEN_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
++#define NFCT_INTEN_FIELDDETECTED_Msk (0x1UL << NFCT_INTEN_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
++#define NFCT_INTEN_FIELDDETECTED_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_FIELDDETECTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event READY */
++#define NFCT_INTEN_READY_Pos (0UL) /*!< Position of READY field. */
++#define NFCT_INTEN_READY_Msk (0x1UL << NFCT_INTEN_READY_Pos) /*!< Bit mask of READY field. */
++#define NFCT_INTEN_READY_Disabled (0UL) /*!< Disable */
++#define NFCT_INTEN_READY_Enabled (1UL) /*!< Enable */
++
++/* Register: NFCT_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 20 : Write '1' to enable interrupt for event STARTED */
++#define NFCT_INTENSET_STARTED_Pos (20UL) /*!< Position of STARTED field. */
++#define NFCT_INTENSET_STARTED_Msk (0x1UL << NFCT_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define NFCT_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_STARTED_Set (1UL) /*!< Enable */
++
++/* Bit 19 : Write '1' to enable interrupt for event SELECTED */
++#define NFCT_INTENSET_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
++#define NFCT_INTENSET_SELECTED_Msk (0x1UL << NFCT_INTENSET_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
++#define NFCT_INTENSET_SELECTED_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_SELECTED_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_SELECTED_Set (1UL) /*!< Enable */
++
++/* Bit 18 : Write '1' to enable interrupt for event COLLISION */
++#define NFCT_INTENSET_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
++#define NFCT_INTENSET_COLLISION_Msk (0x1UL << NFCT_INTENSET_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
++#define NFCT_INTENSET_COLLISION_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_COLLISION_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_COLLISION_Set (1UL) /*!< Enable */
++
++/* Bit 14 : Write '1' to enable interrupt for event AUTOCOLRESSTARTED */
++#define NFCT_INTENSET_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
++#define NFCT_INTENSET_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTENSET_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
++#define NFCT_INTENSET_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_AUTOCOLRESSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 12 : Write '1' to enable interrupt for event ENDTX */
++#define NFCT_INTENSET_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
++#define NFCT_INTENSET_ENDTX_Msk (0x1UL << NFCT_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
++#define NFCT_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_ENDTX_Set (1UL) /*!< Enable */
++
++/* Bit 11 : Write '1' to enable interrupt for event ENDRX */
++#define NFCT_INTENSET_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
++#define NFCT_INTENSET_ENDRX_Msk (0x1UL << NFCT_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define NFCT_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_ENDRX_Set (1UL) /*!< Enable */
++
++/* Bit 10 : Write '1' to enable interrupt for event RXERROR */
++#define NFCT_INTENSET_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
++#define NFCT_INTENSET_RXERROR_Msk (0x1UL << NFCT_INTENSET_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
++#define NFCT_INTENSET_RXERROR_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_RXERROR_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_RXERROR_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event ERROR */
++#define NFCT_INTENSET_ERROR_Pos (7UL) /*!< Position of ERROR field. */
++#define NFCT_INTENSET_ERROR_Msk (0x1UL << NFCT_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define NFCT_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_ERROR_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event RXFRAMEEND */
++#define NFCT_INTENSET_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
++#define NFCT_INTENSET_RXFRAMEEND_Msk (0x1UL << NFCT_INTENSET_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
++#define NFCT_INTENSET_RXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_RXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_RXFRAMEEND_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event RXFRAMESTART */
++#define NFCT_INTENSET_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
++#define NFCT_INTENSET_RXFRAMESTART_Msk (0x1UL << NFCT_INTENSET_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
++#define NFCT_INTENSET_RXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_RXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_RXFRAMESTART_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event TXFRAMEEND */
++#define NFCT_INTENSET_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
++#define NFCT_INTENSET_TXFRAMEEND_Msk (0x1UL << NFCT_INTENSET_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
++#define NFCT_INTENSET_TXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_TXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_TXFRAMEEND_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event TXFRAMESTART */
++#define NFCT_INTENSET_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
++#define NFCT_INTENSET_TXFRAMESTART_Msk (0x1UL << NFCT_INTENSET_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
++#define NFCT_INTENSET_TXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_TXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_TXFRAMESTART_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event FIELDLOST */
++#define NFCT_INTENSET_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
++#define NFCT_INTENSET_FIELDLOST_Msk (0x1UL << NFCT_INTENSET_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
++#define NFCT_INTENSET_FIELDLOST_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_FIELDLOST_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_FIELDLOST_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event FIELDDETECTED */
++#define NFCT_INTENSET_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
++#define NFCT_INTENSET_FIELDDETECTED_Msk (0x1UL << NFCT_INTENSET_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
++#define NFCT_INTENSET_FIELDDETECTED_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_FIELDDETECTED_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_FIELDDETECTED_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event READY */
++#define NFCT_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
++#define NFCT_INTENSET_READY_Msk (0x1UL << NFCT_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
++#define NFCT_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENSET_READY_Set (1UL) /*!< Enable */
++
++/* Register: NFCT_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 20 : Write '1' to disable interrupt for event STARTED */
++#define NFCT_INTENCLR_STARTED_Pos (20UL) /*!< Position of STARTED field. */
++#define NFCT_INTENCLR_STARTED_Msk (0x1UL << NFCT_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define NFCT_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 19 : Write '1' to disable interrupt for event SELECTED */
++#define NFCT_INTENCLR_SELECTED_Pos (19UL) /*!< Position of SELECTED field. */
++#define NFCT_INTENCLR_SELECTED_Msk (0x1UL << NFCT_INTENCLR_SELECTED_Pos) /*!< Bit mask of SELECTED field. */
++#define NFCT_INTENCLR_SELECTED_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_SELECTED_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_SELECTED_Clear (1UL) /*!< Disable */
++
++/* Bit 18 : Write '1' to disable interrupt for event COLLISION */
++#define NFCT_INTENCLR_COLLISION_Pos (18UL) /*!< Position of COLLISION field. */
++#define NFCT_INTENCLR_COLLISION_Msk (0x1UL << NFCT_INTENCLR_COLLISION_Pos) /*!< Bit mask of COLLISION field. */
++#define NFCT_INTENCLR_COLLISION_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_COLLISION_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_COLLISION_Clear (1UL) /*!< Disable */
++
++/* Bit 14 : Write '1' to disable interrupt for event AUTOCOLRESSTARTED */
++#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Pos (14UL) /*!< Position of AUTOCOLRESSTARTED field. */
++#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Msk (0x1UL << NFCT_INTENCLR_AUTOCOLRESSTARTED_Pos) /*!< Bit mask of AUTOCOLRESSTARTED field. */
++#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_AUTOCOLRESSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 12 : Write '1' to disable interrupt for event ENDTX */
++#define NFCT_INTENCLR_ENDTX_Pos (12UL) /*!< Position of ENDTX field. */
++#define NFCT_INTENCLR_ENDTX_Msk (0x1UL << NFCT_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
++#define NFCT_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
++
++/* Bit 11 : Write '1' to disable interrupt for event ENDRX */
++#define NFCT_INTENCLR_ENDRX_Pos (11UL) /*!< Position of ENDRX field. */
++#define NFCT_INTENCLR_ENDRX_Msk (0x1UL << NFCT_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define NFCT_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
++
++/* Bit 10 : Write '1' to disable interrupt for event RXERROR */
++#define NFCT_INTENCLR_RXERROR_Pos (10UL) /*!< Position of RXERROR field. */
++#define NFCT_INTENCLR_RXERROR_Msk (0x1UL << NFCT_INTENCLR_RXERROR_Pos) /*!< Bit mask of RXERROR field. */
++#define NFCT_INTENCLR_RXERROR_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_RXERROR_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_RXERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event ERROR */
++#define NFCT_INTENCLR_ERROR_Pos (7UL) /*!< Position of ERROR field. */
++#define NFCT_INTENCLR_ERROR_Msk (0x1UL << NFCT_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define NFCT_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event RXFRAMEEND */
++#define NFCT_INTENCLR_RXFRAMEEND_Pos (6UL) /*!< Position of RXFRAMEEND field. */
++#define NFCT_INTENCLR_RXFRAMEEND_Msk (0x1UL << NFCT_INTENCLR_RXFRAMEEND_Pos) /*!< Bit mask of RXFRAMEEND field. */
++#define NFCT_INTENCLR_RXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_RXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_RXFRAMEEND_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event RXFRAMESTART */
++#define NFCT_INTENCLR_RXFRAMESTART_Pos (5UL) /*!< Position of RXFRAMESTART field. */
++#define NFCT_INTENCLR_RXFRAMESTART_Msk (0x1UL << NFCT_INTENCLR_RXFRAMESTART_Pos) /*!< Bit mask of RXFRAMESTART field. */
++#define NFCT_INTENCLR_RXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_RXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_RXFRAMESTART_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event TXFRAMEEND */
++#define NFCT_INTENCLR_TXFRAMEEND_Pos (4UL) /*!< Position of TXFRAMEEND field. */
++#define NFCT_INTENCLR_TXFRAMEEND_Msk (0x1UL << NFCT_INTENCLR_TXFRAMEEND_Pos) /*!< Bit mask of TXFRAMEEND field. */
++#define NFCT_INTENCLR_TXFRAMEEND_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_TXFRAMEEND_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_TXFRAMEEND_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event TXFRAMESTART */
++#define NFCT_INTENCLR_TXFRAMESTART_Pos (3UL) /*!< Position of TXFRAMESTART field. */
++#define NFCT_INTENCLR_TXFRAMESTART_Msk (0x1UL << NFCT_INTENCLR_TXFRAMESTART_Pos) /*!< Bit mask of TXFRAMESTART field. */
++#define NFCT_INTENCLR_TXFRAMESTART_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_TXFRAMESTART_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_TXFRAMESTART_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event FIELDLOST */
++#define NFCT_INTENCLR_FIELDLOST_Pos (2UL) /*!< Position of FIELDLOST field. */
++#define NFCT_INTENCLR_FIELDLOST_Msk (0x1UL << NFCT_INTENCLR_FIELDLOST_Pos) /*!< Bit mask of FIELDLOST field. */
++#define NFCT_INTENCLR_FIELDLOST_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_FIELDLOST_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_FIELDLOST_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event FIELDDETECTED */
++#define NFCT_INTENCLR_FIELDDETECTED_Pos (1UL) /*!< Position of FIELDDETECTED field. */
++#define NFCT_INTENCLR_FIELDDETECTED_Msk (0x1UL << NFCT_INTENCLR_FIELDDETECTED_Pos) /*!< Bit mask of FIELDDETECTED field. */
++#define NFCT_INTENCLR_FIELDDETECTED_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_FIELDDETECTED_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_FIELDDETECTED_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event READY */
++#define NFCT_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
++#define NFCT_INTENCLR_READY_Msk (0x1UL << NFCT_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
++#define NFCT_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
++#define NFCT_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
++#define NFCT_INTENCLR_READY_Clear (1UL) /*!< Disable */
++
++/* Register: NFCT_ERRORSTATUS */
++/* Description: NFC Error Status register */
++
++/* Bit 0 : No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX */
++#define NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Pos (0UL) /*!< Position of FRAMEDELAYTIMEOUT field. */
++#define NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Msk (0x1UL << NFCT_ERRORSTATUS_FRAMEDELAYTIMEOUT_Pos) /*!< Bit mask of FRAMEDELAYTIMEOUT field. */
++
++/* Register: NFCT_FRAMESTATUS_RX */
++/* Description: Result of last incoming frame */
++
++/* Bit 3 : Overrun detected */
++#define NFCT_FRAMESTATUS_RX_OVERRUN_Pos (3UL) /*!< Position of OVERRUN field. */
++#define NFCT_FRAMESTATUS_RX_OVERRUN_Msk (0x1UL << NFCT_FRAMESTATUS_RX_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
++#define NFCT_FRAMESTATUS_RX_OVERRUN_NoOverrun (0UL) /*!< No overrun detected */
++#define NFCT_FRAMESTATUS_RX_OVERRUN_Overrun (1UL) /*!< Overrun error */
++
++/* Bit 2 : Parity status of received frame */
++#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_Pos (2UL) /*!< Position of PARITYSTATUS field. */
++#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_Msk (0x1UL << NFCT_FRAMESTATUS_RX_PARITYSTATUS_Pos) /*!< Bit mask of PARITYSTATUS field. */
++#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityOK (0UL) /*!< Frame received with parity OK */
++#define NFCT_FRAMESTATUS_RX_PARITYSTATUS_ParityError (1UL) /*!< Frame received with parity error */
++
++/* Bit 0 : No valid end of frame (EoF) detected */
++#define NFCT_FRAMESTATUS_RX_CRCERROR_Pos (0UL) /*!< Position of CRCERROR field. */
++#define NFCT_FRAMESTATUS_RX_CRCERROR_Msk (0x1UL << NFCT_FRAMESTATUS_RX_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
++#define NFCT_FRAMESTATUS_RX_CRCERROR_CRCCorrect (0UL) /*!< Valid CRC detected */
++#define NFCT_FRAMESTATUS_RX_CRCERROR_CRCError (1UL) /*!< CRC received does not match local check */
++
++/* Register: NFCT_NFCTAGSTATE */
++/* Description: NfcTag state register */
++
++/* Bits 2..0 : NfcTag state */
++#define NFCT_NFCTAGSTATE_NFCTAGSTATE_Pos (0UL) /*!< Position of NFCTAGSTATE field. */
++#define NFCT_NFCTAGSTATE_NFCTAGSTATE_Msk (0x7UL << NFCT_NFCTAGSTATE_NFCTAGSTATE_Pos) /*!< Bit mask of NFCTAGSTATE field. */
++#define NFCT_NFCTAGSTATE_NFCTAGSTATE_Disabled (0UL) /*!< Disabled or sense */
++#define NFCT_NFCTAGSTATE_NFCTAGSTATE_RampUp (2UL) /*!< RampUp */
++#define NFCT_NFCTAGSTATE_NFCTAGSTATE_Idle (3UL) /*!< Idle */
++#define NFCT_NFCTAGSTATE_NFCTAGSTATE_Receive (4UL) /*!< Receive */
++#define NFCT_NFCTAGSTATE_NFCTAGSTATE_FrameDelay (5UL) /*!< FrameDelay */
++#define NFCT_NFCTAGSTATE_NFCTAGSTATE_Transmit (6UL) /*!< Transmit */
++
++/* Register: NFCT_SLEEPSTATE */
++/* Description: Sleep state during automatic collision resolution */
++
++/* Bit 0 : Reflects the sleep state during automatic collision resolution. Set to IDLE 
++        by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a 
++        GOSLEEP task. */
++#define NFCT_SLEEPSTATE_SLEEPSTATE_Pos (0UL) /*!< Position of SLEEPSTATE field. */
++#define NFCT_SLEEPSTATE_SLEEPSTATE_Msk (0x1UL << NFCT_SLEEPSTATE_SLEEPSTATE_Pos) /*!< Bit mask of SLEEPSTATE field. */
++#define NFCT_SLEEPSTATE_SLEEPSTATE_Idle (0UL) /*!< State is IDLE. */
++#define NFCT_SLEEPSTATE_SLEEPSTATE_SleepA (1UL) /*!< State is SLEEP_A. */
++
++/* Register: NFCT_FIELDPRESENT */
++/* Description: Indicates the presence or not of a valid field */
++
++/* Bit 1 : Indicates if the low level has locked to the field */
++#define NFCT_FIELDPRESENT_LOCKDETECT_Pos (1UL) /*!< Position of LOCKDETECT field. */
++#define NFCT_FIELDPRESENT_LOCKDETECT_Msk (0x1UL << NFCT_FIELDPRESENT_LOCKDETECT_Pos) /*!< Bit mask of LOCKDETECT field. */
++#define NFCT_FIELDPRESENT_LOCKDETECT_NotLocked (0UL) /*!< Not locked to field */
++#define NFCT_FIELDPRESENT_LOCKDETECT_Locked (1UL) /*!< Locked to field */
++
++/* Bit 0 : Indicates if a valid field is present. Available only in the activated state. */
++#define NFCT_FIELDPRESENT_FIELDPRESENT_Pos (0UL) /*!< Position of FIELDPRESENT field. */
++#define NFCT_FIELDPRESENT_FIELDPRESENT_Msk (0x1UL << NFCT_FIELDPRESENT_FIELDPRESENT_Pos) /*!< Bit mask of FIELDPRESENT field. */
++#define NFCT_FIELDPRESENT_FIELDPRESENT_NoField (0UL) /*!< No valid field detected */
++#define NFCT_FIELDPRESENT_FIELDPRESENT_FieldPresent (1UL) /*!< Valid field detected */
++
++/* Register: NFCT_FRAMEDELAYMIN */
++/* Description: Minimum frame delay */
++
++/* Bits 15..0 : Minimum frame delay in number of 13.56 MHz clocks */
++#define NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos (0UL) /*!< Position of FRAMEDELAYMIN field. */
++#define NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Msk (0xFFFFUL << NFCT_FRAMEDELAYMIN_FRAMEDELAYMIN_Pos) /*!< Bit mask of FRAMEDELAYMIN field. */
++
++/* Register: NFCT_FRAMEDELAYMAX */
++/* Description: Maximum frame delay */
++
++/* Bits 19..0 : Maximum frame delay in number of 13.56 MHz clocks */
++#define NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos (0UL) /*!< Position of FRAMEDELAYMAX field. */
++#define NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Msk (0xFFFFFUL << NFCT_FRAMEDELAYMAX_FRAMEDELAYMAX_Pos) /*!< Bit mask of FRAMEDELAYMAX field. */
++
++/* Register: NFCT_FRAMEDELAYMODE */
++/* Description: Configuration register for the Frame Delay Timer */
++
++/* Bits 1..0 : Configuration register for the Frame Delay Timer */
++#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Pos (0UL) /*!< Position of FRAMEDELAYMODE field. */
++#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Msk (0x3UL << NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Pos) /*!< Bit mask of FRAMEDELAYMODE field. */
++#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_FreeRun (0UL) /*!< Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout. */
++#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_Window (1UL) /*!< Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX */
++#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_ExactVal (2UL) /*!< Frame is transmitted exactly at FRAMEDELAYMAX */
++#define NFCT_FRAMEDELAYMODE_FRAMEDELAYMODE_WindowGrid (3UL) /*!< Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX */
++
++/* Register: NFCT_PACKETPTR */
++/* Description: Packet pointer for TXD and RXD data storage in Data RAM */
++
++/* Bits 31..0 : Packet pointer for TXD and RXD data storage in Data RAM. This address is a byte-aligned RAM address. */
++#define NFCT_PACKETPTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define NFCT_PACKETPTR_PTR_Msk (0xFFFFFFFFUL << NFCT_PACKETPTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: NFCT_MAXLEN */
++/* Description: Size of the RAM buffer allocated to TXD and RXD data storage each */
++
++/* Bits 8..0 : Size of the RAM buffer allocated to TXD and RXD data storage each */
++#define NFCT_MAXLEN_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
++#define NFCT_MAXLEN_MAXLEN_Msk (0x1FFUL << NFCT_MAXLEN_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
++
++/* Register: NFCT_TXD_FRAMECONFIG */
++/* Description: Configuration of outgoing frames */
++
++/* Bit 4 : CRC mode for outgoing frames */
++#define NFCT_TXD_FRAMECONFIG_CRCMODETX_Pos (4UL) /*!< Position of CRCMODETX field. */
++#define NFCT_TXD_FRAMECONFIG_CRCMODETX_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_CRCMODETX_Pos) /*!< Bit mask of CRCMODETX field. */
++#define NFCT_TXD_FRAMECONFIG_CRCMODETX_NoCRCTX (0UL) /*!< CRC is not added to the frame */
++#define NFCT_TXD_FRAMECONFIG_CRCMODETX_CRC16TX (1UL) /*!< 16 bit CRC added to the frame based on all the data read from RAM that is used in the frame */
++
++/* Bit 2 : Adding SoF or not in TX frames */
++#define NFCT_TXD_FRAMECONFIG_SOF_Pos (2UL) /*!< Position of SOF field. */
++#define NFCT_TXD_FRAMECONFIG_SOF_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_SOF_Pos) /*!< Bit mask of SOF field. */
++#define NFCT_TXD_FRAMECONFIG_SOF_NoSoF (0UL) /*!< SoF symbol not added */
++#define NFCT_TXD_FRAMECONFIG_SOF_SoF (1UL) /*!< SoF symbol added */
++
++/* Bit 1 : Discarding unused bits at start or end of a frame */
++#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_Pos (1UL) /*!< Position of DISCARDMODE field. */
++#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_DISCARDMODE_Pos) /*!< Bit mask of DISCARDMODE field. */
++#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardEnd (0UL) /*!< Unused bits are discarded at end of frame (EoF) */
++#define NFCT_TXD_FRAMECONFIG_DISCARDMODE_DiscardStart (1UL) /*!< Unused bits are discarded at start of frame (SoF) */
++
++/* Bit 0 : Indicates if parity is added to the frame */
++#define NFCT_TXD_FRAMECONFIG_PARITY_Pos (0UL) /*!< Position of PARITY field. */
++#define NFCT_TXD_FRAMECONFIG_PARITY_Msk (0x1UL << NFCT_TXD_FRAMECONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
++#define NFCT_TXD_FRAMECONFIG_PARITY_NoParity (0UL) /*!< Parity is not added to TX frames */
++#define NFCT_TXD_FRAMECONFIG_PARITY_Parity (1UL) /*!< Parity is added to TX frames */
++
++/* Register: NFCT_TXD_AMOUNT */
++/* Description: Size of outgoing frame */
++
++/* Bits 11..3 : Number of complete bytes that shall be included in the frame, excluding CRC, parity and framing */
++#define NFCT_TXD_AMOUNT_TXDATABYTES_Pos (3UL) /*!< Position of TXDATABYTES field. */
++#define NFCT_TXD_AMOUNT_TXDATABYTES_Msk (0x1FFUL << NFCT_TXD_AMOUNT_TXDATABYTES_Pos) /*!< Bit mask of TXDATABYTES field. */
++
++/* Bits 2..0 : Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit). */
++#define NFCT_TXD_AMOUNT_TXDATABITS_Pos (0UL) /*!< Position of TXDATABITS field. */
++#define NFCT_TXD_AMOUNT_TXDATABITS_Msk (0x7UL << NFCT_TXD_AMOUNT_TXDATABITS_Pos) /*!< Bit mask of TXDATABITS field. */
++
++/* Register: NFCT_RXD_FRAMECONFIG */
++/* Description: Configuration of incoming frames */
++
++/* Bit 4 : CRC mode for incoming frames */
++#define NFCT_RXD_FRAMECONFIG_CRCMODERX_Pos (4UL) /*!< Position of CRCMODERX field. */
++#define NFCT_RXD_FRAMECONFIG_CRCMODERX_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_CRCMODERX_Pos) /*!< Bit mask of CRCMODERX field. */
++#define NFCT_RXD_FRAMECONFIG_CRCMODERX_NoCRCRX (0UL) /*!< CRC is not expected in RX frames */
++#define NFCT_RXD_FRAMECONFIG_CRCMODERX_CRC16RX (1UL) /*!< Last 16 bits in RX frame is CRC, CRC is checked and CRCSTATUS updated */
++
++/* Bit 2 : SoF expected or not in RX frames */
++#define NFCT_RXD_FRAMECONFIG_SOF_Pos (2UL) /*!< Position of SOF field. */
++#define NFCT_RXD_FRAMECONFIG_SOF_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_SOF_Pos) /*!< Bit mask of SOF field. */
++#define NFCT_RXD_FRAMECONFIG_SOF_NoSoF (0UL) /*!< SoF symbol is not expected in RX frames */
++#define NFCT_RXD_FRAMECONFIG_SOF_SoF (1UL) /*!< SoF symbol is expected in RX frames */
++
++/* Bit 0 : Indicates if parity expected in RX frame */
++#define NFCT_RXD_FRAMECONFIG_PARITY_Pos (0UL) /*!< Position of PARITY field. */
++#define NFCT_RXD_FRAMECONFIG_PARITY_Msk (0x1UL << NFCT_RXD_FRAMECONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
++#define NFCT_RXD_FRAMECONFIG_PARITY_NoParity (0UL) /*!< Parity is not expected in RX frames */
++#define NFCT_RXD_FRAMECONFIG_PARITY_Parity (1UL) /*!< Parity is expected in RX frames */
++
++/* Register: NFCT_RXD_AMOUNT */
++/* Description: Size of last incoming frame */
++
++/* Bits 11..3 : Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing) */
++#define NFCT_RXD_AMOUNT_RXDATABYTES_Pos (3UL) /*!< Position of RXDATABYTES field. */
++#define NFCT_RXD_AMOUNT_RXDATABYTES_Msk (0x1FFUL << NFCT_RXD_AMOUNT_RXDATABYTES_Pos) /*!< Bit mask of RXDATABYTES field. */
++
++/* Bits 2..0 : Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing). */
++#define NFCT_RXD_AMOUNT_RXDATABITS_Pos (0UL) /*!< Position of RXDATABITS field. */
++#define NFCT_RXD_AMOUNT_RXDATABITS_Msk (0x7UL << NFCT_RXD_AMOUNT_RXDATABITS_Pos) /*!< Bit mask of RXDATABITS field. */
++
++/* Register: NFCT_NFCID1_LAST */
++/* Description: Last NFCID1 part (4, 7 or 10 bytes ID) */
++
++/* Bits 31..24 : NFCID1 byte W */
++#define NFCT_NFCID1_LAST_NFCID1_W_Pos (24UL) /*!< Position of NFCID1_W field. */
++#define NFCT_NFCID1_LAST_NFCID1_W_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_W_Pos) /*!< Bit mask of NFCID1_W field. */
++
++/* Bits 23..16 : NFCID1 byte X */
++#define NFCT_NFCID1_LAST_NFCID1_X_Pos (16UL) /*!< Position of NFCID1_X field. */
++#define NFCT_NFCID1_LAST_NFCID1_X_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_X_Pos) /*!< Bit mask of NFCID1_X field. */
++
++/* Bits 15..8 : NFCID1 byte Y */
++#define NFCT_NFCID1_LAST_NFCID1_Y_Pos (8UL) /*!< Position of NFCID1_Y field. */
++#define NFCT_NFCID1_LAST_NFCID1_Y_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_Y_Pos) /*!< Bit mask of NFCID1_Y field. */
++
++/* Bits 7..0 : NFCID1 byte Z (very last byte sent) */
++#define NFCT_NFCID1_LAST_NFCID1_Z_Pos (0UL) /*!< Position of NFCID1_Z field. */
++#define NFCT_NFCID1_LAST_NFCID1_Z_Msk (0xFFUL << NFCT_NFCID1_LAST_NFCID1_Z_Pos) /*!< Bit mask of NFCID1_Z field. */
++
++/* Register: NFCT_NFCID1_2ND_LAST */
++/* Description: Second last NFCID1 part (7 or 10 bytes ID) */
++
++/* Bits 23..16 : NFCID1 byte T */
++#define NFCT_NFCID1_2ND_LAST_NFCID1_T_Pos (16UL) /*!< Position of NFCID1_T field. */
++#define NFCT_NFCID1_2ND_LAST_NFCID1_T_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_T_Pos) /*!< Bit mask of NFCID1_T field. */
++
++/* Bits 15..8 : NFCID1 byte U */
++#define NFCT_NFCID1_2ND_LAST_NFCID1_U_Pos (8UL) /*!< Position of NFCID1_U field. */
++#define NFCT_NFCID1_2ND_LAST_NFCID1_U_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_U_Pos) /*!< Bit mask of NFCID1_U field. */
++
++/* Bits 7..0 : NFCID1 byte V */
++#define NFCT_NFCID1_2ND_LAST_NFCID1_V_Pos (0UL) /*!< Position of NFCID1_V field. */
++#define NFCT_NFCID1_2ND_LAST_NFCID1_V_Msk (0xFFUL << NFCT_NFCID1_2ND_LAST_NFCID1_V_Pos) /*!< Bit mask of NFCID1_V field. */
++
++/* Register: NFCT_NFCID1_3RD_LAST */
++/* Description: Third last NFCID1 part (10 bytes ID) */
++
++/* Bits 23..16 : NFCID1 byte Q */
++#define NFCT_NFCID1_3RD_LAST_NFCID1_Q_Pos (16UL) /*!< Position of NFCID1_Q field. */
++#define NFCT_NFCID1_3RD_LAST_NFCID1_Q_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_Q_Pos) /*!< Bit mask of NFCID1_Q field. */
++
++/* Bits 15..8 : NFCID1 byte R */
++#define NFCT_NFCID1_3RD_LAST_NFCID1_R_Pos (8UL) /*!< Position of NFCID1_R field. */
++#define NFCT_NFCID1_3RD_LAST_NFCID1_R_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_R_Pos) /*!< Bit mask of NFCID1_R field. */
++
++/* Bits 7..0 : NFCID1 byte S */
++#define NFCT_NFCID1_3RD_LAST_NFCID1_S_Pos (0UL) /*!< Position of NFCID1_S field. */
++#define NFCT_NFCID1_3RD_LAST_NFCID1_S_Msk (0xFFUL << NFCT_NFCID1_3RD_LAST_NFCID1_S_Pos) /*!< Bit mask of NFCID1_S field. */
++
++/* Register: NFCT_AUTOCOLRESCONFIG */
++/* Description: Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated. */
++
++/* Bit 0 : Enables/disables auto collision resolution */
++#define NFCT_AUTOCOLRESCONFIG_MODE_Pos (0UL) /*!< Position of MODE field. */
++#define NFCT_AUTOCOLRESCONFIG_MODE_Msk (0x1UL << NFCT_AUTOCOLRESCONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
++#define NFCT_AUTOCOLRESCONFIG_MODE_Enabled (0UL) /*!< Auto collision resolution enabled */
++#define NFCT_AUTOCOLRESCONFIG_MODE_Disabled (1UL) /*!< Auto collision resolution disabled */
++
++/* Register: NFCT_SENSRES */
++/* Description: NFC-A SENS_RES auto-response settings */
++
++/* Bits 15..12 : Reserved for future use. Shall be 0. */
++#define NFCT_SENSRES_RFU74_Pos (12UL) /*!< Position of RFU74 field. */
++#define NFCT_SENSRES_RFU74_Msk (0xFUL << NFCT_SENSRES_RFU74_Pos) /*!< Bit mask of RFU74 field. */
++
++/* Bits 11..8 : Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
++#define NFCT_SENSRES_PLATFCONFIG_Pos (8UL) /*!< Position of PLATFCONFIG field. */
++#define NFCT_SENSRES_PLATFCONFIG_Msk (0xFUL << NFCT_SENSRES_PLATFCONFIG_Pos) /*!< Bit mask of PLATFCONFIG field. */
++
++/* Bits 7..6 : NFCID1 size. This value is used by the auto collision resolution engine. */
++#define NFCT_SENSRES_NFCIDSIZE_Pos (6UL) /*!< Position of NFCIDSIZE field. */
++#define NFCT_SENSRES_NFCIDSIZE_Msk (0x3UL << NFCT_SENSRES_NFCIDSIZE_Pos) /*!< Bit mask of NFCIDSIZE field. */
++#define NFCT_SENSRES_NFCIDSIZE_NFCID1Single (0UL) /*!< NFCID1 size: single (4 bytes) */
++#define NFCT_SENSRES_NFCIDSIZE_NFCID1Double (1UL) /*!< NFCID1 size: double (7 bytes) */
++#define NFCT_SENSRES_NFCIDSIZE_NFCID1Triple (2UL) /*!< NFCID1 size: triple (10 bytes) */
++
++/* Bit 5 : Reserved for future use. Shall be 0. */
++#define NFCT_SENSRES_RFU5_Pos (5UL) /*!< Position of RFU5 field. */
++#define NFCT_SENSRES_RFU5_Msk (0x1UL << NFCT_SENSRES_RFU5_Pos) /*!< Bit mask of RFU5 field. */
++
++/* Bits 4..0 : Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
++#define NFCT_SENSRES_BITFRAMESDD_Pos (0UL) /*!< Position of BITFRAMESDD field. */
++#define NFCT_SENSRES_BITFRAMESDD_Msk (0x1FUL << NFCT_SENSRES_BITFRAMESDD_Pos) /*!< Bit mask of BITFRAMESDD field. */
++#define NFCT_SENSRES_BITFRAMESDD_SDD00000 (0UL) /*!< SDD pattern 00000 */
++#define NFCT_SENSRES_BITFRAMESDD_SDD00001 (1UL) /*!< SDD pattern 00001 */
++#define NFCT_SENSRES_BITFRAMESDD_SDD00010 (2UL) /*!< SDD pattern 00010 */
++#define NFCT_SENSRES_BITFRAMESDD_SDD00100 (4UL) /*!< SDD pattern 00100 */
++#define NFCT_SENSRES_BITFRAMESDD_SDD01000 (8UL) /*!< SDD pattern 01000 */
++#define NFCT_SENSRES_BITFRAMESDD_SDD10000 (16UL) /*!< SDD pattern 10000 */
++
++/* Register: NFCT_SELRES */
++/* Description: NFC-A SEL_RES auto-response settings */
++
++/* Bit 7 : Reserved for future use. Shall be 0. */
++#define NFCT_SELRES_RFU7_Pos (7UL) /*!< Position of RFU7 field. */
++#define NFCT_SELRES_RFU7_Msk (0x1UL << NFCT_SELRES_RFU7_Pos) /*!< Bit mask of RFU7 field. */
++
++/* Bits 6..5 : Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification */
++#define NFCT_SELRES_PROTOCOL_Pos (5UL) /*!< Position of PROTOCOL field. */
++#define NFCT_SELRES_PROTOCOL_Msk (0x3UL << NFCT_SELRES_PROTOCOL_Pos) /*!< Bit mask of PROTOCOL field. */
++
++/* Bits 4..3 : Reserved for future use. Shall be 0. */
++#define NFCT_SELRES_RFU43_Pos (3UL) /*!< Position of RFU43 field. */
++#define NFCT_SELRES_RFU43_Msk (0x3UL << NFCT_SELRES_RFU43_Pos) /*!< Bit mask of RFU43 field. */
++
++/* Bit 2 : Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0) */
++#define NFCT_SELRES_CASCADE_Pos (2UL) /*!< Position of CASCADE field. */
++#define NFCT_SELRES_CASCADE_Msk (0x1UL << NFCT_SELRES_CASCADE_Pos) /*!< Bit mask of CASCADE field. */
++
++/* Bits 1..0 : Reserved for future use. Shall be 0. */
++#define NFCT_SELRES_RFU10_Pos (0UL) /*!< Position of RFU10 field. */
++#define NFCT_SELRES_RFU10_Msk (0x3UL << NFCT_SELRES_RFU10_Pos) /*!< Bit mask of RFU10 field. */
++
++
++/* Peripheral: NVMC */
++/* Description: Non Volatile Memory Controller */
++
++/* Register: NVMC_READY */
++/* Description: Ready flag */
++
++/* Bit 0 : NVMC is ready or busy */
++#define NVMC_READY_READY_Pos (0UL) /*!< Position of READY field. */
++#define NVMC_READY_READY_Msk (0x1UL << NVMC_READY_READY_Pos) /*!< Bit mask of READY field. */
++#define NVMC_READY_READY_Busy (0UL) /*!< NVMC is busy (on-going write or erase operation) */
++#define NVMC_READY_READY_Ready (1UL) /*!< NVMC is ready */
++
++/* Register: NVMC_READYNEXT */
++/* Description: Ready flag */
++
++/* Bit 0 : NVMC can accept a new write operation */
++#define NVMC_READYNEXT_READYNEXT_Pos (0UL) /*!< Position of READYNEXT field. */
++#define NVMC_READYNEXT_READYNEXT_Msk (0x1UL << NVMC_READYNEXT_READYNEXT_Pos) /*!< Bit mask of READYNEXT field. */
++#define NVMC_READYNEXT_READYNEXT_Busy (0UL) /*!< NVMC cannot accept any write operation */
++#define NVMC_READYNEXT_READYNEXT_Ready (1UL) /*!< NVMC is ready */
++
++/* Register: NVMC_CONFIG */
++/* Description: Configuration register */
++
++/* Bits 1..0 : Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated. */
++#define NVMC_CONFIG_WEN_Pos (0UL) /*!< Position of WEN field. */
++#define NVMC_CONFIG_WEN_Msk (0x3UL << NVMC_CONFIG_WEN_Pos) /*!< Bit mask of WEN field. */
++#define NVMC_CONFIG_WEN_Ren (0UL) /*!< Read only access */
++#define NVMC_CONFIG_WEN_Wen (1UL) /*!< Write enabled */
++#define NVMC_CONFIG_WEN_Een (2UL) /*!< Erase enabled */
++
++/* Register: NVMC_ERASEPAGE */
++/* Description: Register for erasing a page in code area */
++
++/* Bits 31..0 : Register for starting erase of a page in code area */
++#define NVMC_ERASEPAGE_ERASEPAGE_Pos (0UL) /*!< Position of ERASEPAGE field. */
++#define NVMC_ERASEPAGE_ERASEPAGE_Msk (0xFFFFFFFFUL << NVMC_ERASEPAGE_ERASEPAGE_Pos) /*!< Bit mask of ERASEPAGE field. */
++
++/* Register: NVMC_ERASEPCR1 */
++/* Description: Deprecated register - Register for erasing a page in code area, equivalent to ERASEPAGE */
++
++/* Bits 31..0 : Register for erasing a page in code area, equivalent to ERASEPAGE */
++#define NVMC_ERASEPCR1_ERASEPCR1_Pos (0UL) /*!< Position of ERASEPCR1 field. */
++#define NVMC_ERASEPCR1_ERASEPCR1_Msk (0xFFFFFFFFUL << NVMC_ERASEPCR1_ERASEPCR1_Pos) /*!< Bit mask of ERASEPCR1 field. */
++
++/* Register: NVMC_ERASEALL */
++/* Description: Register for erasing all non-volatile user memory */
++
++/* Bit 0 : Erase all non-volatile memory including UICR registers. The erase must be enabled using CONFIG.WEN before the non-volatile memory can be erased. */
++#define NVMC_ERASEALL_ERASEALL_Pos (0UL) /*!< Position of ERASEALL field. */
++#define NVMC_ERASEALL_ERASEALL_Msk (0x1UL << NVMC_ERASEALL_ERASEALL_Pos) /*!< Bit mask of ERASEALL field. */
++#define NVMC_ERASEALL_ERASEALL_NoOperation (0UL) /*!< No operation */
++#define NVMC_ERASEALL_ERASEALL_Erase (1UL) /*!< Start chip erase */
++
++/* Register: NVMC_ERASEPCR0 */
++/* Description: Deprecated register - Register for erasing a page in code area, equivalent to ERASEPAGE */
++
++/* Bits 31..0 : Register for starting erase of a page in code area, equivalent to ERASEPAGE */
++#define NVMC_ERASEPCR0_ERASEPCR0_Pos (0UL) /*!< Position of ERASEPCR0 field. */
++#define NVMC_ERASEPCR0_ERASEPCR0_Msk (0xFFFFFFFFUL << NVMC_ERASEPCR0_ERASEPCR0_Pos) /*!< Bit mask of ERASEPCR0 field. */
++
++/* Register: NVMC_ERASEUICR */
++/* Description: Register for erasing user information configuration registers */
++
++/* Bit 0 : Register starting erase of all user information configuration registers. The erase must be enabled using CONFIG.WEN before the UICR can be erased. */
++#define NVMC_ERASEUICR_ERASEUICR_Pos (0UL) /*!< Position of ERASEUICR field. */
++#define NVMC_ERASEUICR_ERASEUICR_Msk (0x1UL << NVMC_ERASEUICR_ERASEUICR_Pos) /*!< Bit mask of ERASEUICR field. */
++#define NVMC_ERASEUICR_ERASEUICR_NoOperation (0UL) /*!< No operation */
++#define NVMC_ERASEUICR_ERASEUICR_Erase (1UL) /*!< Start erase of UICR */
++
++/* Register: NVMC_ERASEPAGEPARTIAL */
++/* Description: Register for partial erase of a page in code area */
++
++/* Bits 31..0 : Register for starting partial erase of a page in code area */
++#define NVMC_ERASEPAGEPARTIAL_ERASEPAGEPARTIAL_Pos (0UL) /*!< Position of ERASEPAGEPARTIAL field. */
++#define NVMC_ERASEPAGEPARTIAL_ERASEPAGEPARTIAL_Msk (0xFFFFFFFFUL << NVMC_ERASEPAGEPARTIAL_ERASEPAGEPARTIAL_Pos) /*!< Bit mask of ERASEPAGEPARTIAL field. */
++
++/* Register: NVMC_ERASEPAGEPARTIALCFG */
++/* Description: Register for partial erase configuration */
++
++/* Bits 6..0 : Duration of the partial erase in milliseconds */
++#define NVMC_ERASEPAGEPARTIALCFG_DURATION_Pos (0UL) /*!< Position of DURATION field. */
++#define NVMC_ERASEPAGEPARTIALCFG_DURATION_Msk (0x7FUL << NVMC_ERASEPAGEPARTIALCFG_DURATION_Pos) /*!< Bit mask of DURATION field. */
++
++/* Register: NVMC_ICACHECNF */
++/* Description: I-code cache configuration register */
++
++/* Bit 8 : Cache profiling enable */
++#define NVMC_ICACHECNF_CACHEPROFEN_Pos (8UL) /*!< Position of CACHEPROFEN field. */
++#define NVMC_ICACHECNF_CACHEPROFEN_Msk (0x1UL << NVMC_ICACHECNF_CACHEPROFEN_Pos) /*!< Bit mask of CACHEPROFEN field. */
++#define NVMC_ICACHECNF_CACHEPROFEN_Disabled (0UL) /*!< Disable cache profiling */
++#define NVMC_ICACHECNF_CACHEPROFEN_Enabled (1UL) /*!< Enable cache profiling */
++
++/* Bit 0 : Cache enable */
++#define NVMC_ICACHECNF_CACHEEN_Pos (0UL) /*!< Position of CACHEEN field. */
++#define NVMC_ICACHECNF_CACHEEN_Msk (0x1UL << NVMC_ICACHECNF_CACHEEN_Pos) /*!< Bit mask of CACHEEN field. */
++#define NVMC_ICACHECNF_CACHEEN_Disabled (0UL) /*!< Disable cache. Invalidates all cache entries. */
++#define NVMC_ICACHECNF_CACHEEN_Enabled (1UL) /*!< Enable cache */
++
++/* Register: NVMC_IHIT */
++/* Description: I-code cache hit counter */
++
++/* Bits 31..0 : Number of cache hits. Register is writable, but only to '0'. */
++#define NVMC_IHIT_HITS_Pos (0UL) /*!< Position of HITS field. */
++#define NVMC_IHIT_HITS_Msk (0xFFFFFFFFUL << NVMC_IHIT_HITS_Pos) /*!< Bit mask of HITS field. */
++
++/* Register: NVMC_IMISS */
++/* Description: I-code cache miss counter */
++
++/* Bits 31..0 : Number of cache misses. Register is writable, but only to '0'. */
++#define NVMC_IMISS_MISSES_Pos (0UL) /*!< Position of MISSES field. */
++#define NVMC_IMISS_MISSES_Msk (0xFFFFFFFFUL << NVMC_IMISS_MISSES_Pos) /*!< Bit mask of MISSES field. */
++
++
++/* Peripheral: GPIO */
++/* Description: GPIO Port 1 */
++
++/* Register: GPIO_OUT */
++/* Description: Write GPIO port */
++
++/* Bit 31 : Pin 31 */
++#define GPIO_OUT_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
++#define GPIO_OUT_PIN31_Msk (0x1UL << GPIO_OUT_PIN31_Pos) /*!< Bit mask of PIN31 field. */
++#define GPIO_OUT_PIN31_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN31_High (1UL) /*!< Pin driver is high */
++
++/* Bit 30 : Pin 30 */
++#define GPIO_OUT_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
++#define GPIO_OUT_PIN30_Msk (0x1UL << GPIO_OUT_PIN30_Pos) /*!< Bit mask of PIN30 field. */
++#define GPIO_OUT_PIN30_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN30_High (1UL) /*!< Pin driver is high */
++
++/* Bit 29 : Pin 29 */
++#define GPIO_OUT_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
++#define GPIO_OUT_PIN29_Msk (0x1UL << GPIO_OUT_PIN29_Pos) /*!< Bit mask of PIN29 field. */
++#define GPIO_OUT_PIN29_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN29_High (1UL) /*!< Pin driver is high */
++
++/* Bit 28 : Pin 28 */
++#define GPIO_OUT_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
++#define GPIO_OUT_PIN28_Msk (0x1UL << GPIO_OUT_PIN28_Pos) /*!< Bit mask of PIN28 field. */
++#define GPIO_OUT_PIN28_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN28_High (1UL) /*!< Pin driver is high */
++
++/* Bit 27 : Pin 27 */
++#define GPIO_OUT_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
++#define GPIO_OUT_PIN27_Msk (0x1UL << GPIO_OUT_PIN27_Pos) /*!< Bit mask of PIN27 field. */
++#define GPIO_OUT_PIN27_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN27_High (1UL) /*!< Pin driver is high */
++
++/* Bit 26 : Pin 26 */
++#define GPIO_OUT_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
++#define GPIO_OUT_PIN26_Msk (0x1UL << GPIO_OUT_PIN26_Pos) /*!< Bit mask of PIN26 field. */
++#define GPIO_OUT_PIN26_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN26_High (1UL) /*!< Pin driver is high */
++
++/* Bit 25 : Pin 25 */
++#define GPIO_OUT_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
++#define GPIO_OUT_PIN25_Msk (0x1UL << GPIO_OUT_PIN25_Pos) /*!< Bit mask of PIN25 field. */
++#define GPIO_OUT_PIN25_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN25_High (1UL) /*!< Pin driver is high */
++
++/* Bit 24 : Pin 24 */
++#define GPIO_OUT_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
++#define GPIO_OUT_PIN24_Msk (0x1UL << GPIO_OUT_PIN24_Pos) /*!< Bit mask of PIN24 field. */
++#define GPIO_OUT_PIN24_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN24_High (1UL) /*!< Pin driver is high */
++
++/* Bit 23 : Pin 23 */
++#define GPIO_OUT_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
++#define GPIO_OUT_PIN23_Msk (0x1UL << GPIO_OUT_PIN23_Pos) /*!< Bit mask of PIN23 field. */
++#define GPIO_OUT_PIN23_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN23_High (1UL) /*!< Pin driver is high */
++
++/* Bit 22 : Pin 22 */
++#define GPIO_OUT_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
++#define GPIO_OUT_PIN22_Msk (0x1UL << GPIO_OUT_PIN22_Pos) /*!< Bit mask of PIN22 field. */
++#define GPIO_OUT_PIN22_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN22_High (1UL) /*!< Pin driver is high */
++
++/* Bit 21 : Pin 21 */
++#define GPIO_OUT_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
++#define GPIO_OUT_PIN21_Msk (0x1UL << GPIO_OUT_PIN21_Pos) /*!< Bit mask of PIN21 field. */
++#define GPIO_OUT_PIN21_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN21_High (1UL) /*!< Pin driver is high */
++
++/* Bit 20 : Pin 20 */
++#define GPIO_OUT_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
++#define GPIO_OUT_PIN20_Msk (0x1UL << GPIO_OUT_PIN20_Pos) /*!< Bit mask of PIN20 field. */
++#define GPIO_OUT_PIN20_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN20_High (1UL) /*!< Pin driver is high */
++
++/* Bit 19 : Pin 19 */
++#define GPIO_OUT_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
++#define GPIO_OUT_PIN19_Msk (0x1UL << GPIO_OUT_PIN19_Pos) /*!< Bit mask of PIN19 field. */
++#define GPIO_OUT_PIN19_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN19_High (1UL) /*!< Pin driver is high */
++
++/* Bit 18 : Pin 18 */
++#define GPIO_OUT_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
++#define GPIO_OUT_PIN18_Msk (0x1UL << GPIO_OUT_PIN18_Pos) /*!< Bit mask of PIN18 field. */
++#define GPIO_OUT_PIN18_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN18_High (1UL) /*!< Pin driver is high */
++
++/* Bit 17 : Pin 17 */
++#define GPIO_OUT_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
++#define GPIO_OUT_PIN17_Msk (0x1UL << GPIO_OUT_PIN17_Pos) /*!< Bit mask of PIN17 field. */
++#define GPIO_OUT_PIN17_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN17_High (1UL) /*!< Pin driver is high */
++
++/* Bit 16 : Pin 16 */
++#define GPIO_OUT_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
++#define GPIO_OUT_PIN16_Msk (0x1UL << GPIO_OUT_PIN16_Pos) /*!< Bit mask of PIN16 field. */
++#define GPIO_OUT_PIN16_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN16_High (1UL) /*!< Pin driver is high */
++
++/* Bit 15 : Pin 15 */
++#define GPIO_OUT_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
++#define GPIO_OUT_PIN15_Msk (0x1UL << GPIO_OUT_PIN15_Pos) /*!< Bit mask of PIN15 field. */
++#define GPIO_OUT_PIN15_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN15_High (1UL) /*!< Pin driver is high */
++
++/* Bit 14 : Pin 14 */
++#define GPIO_OUT_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
++#define GPIO_OUT_PIN14_Msk (0x1UL << GPIO_OUT_PIN14_Pos) /*!< Bit mask of PIN14 field. */
++#define GPIO_OUT_PIN14_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN14_High (1UL) /*!< Pin driver is high */
++
++/* Bit 13 : Pin 13 */
++#define GPIO_OUT_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
++#define GPIO_OUT_PIN13_Msk (0x1UL << GPIO_OUT_PIN13_Pos) /*!< Bit mask of PIN13 field. */
++#define GPIO_OUT_PIN13_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN13_High (1UL) /*!< Pin driver is high */
++
++/* Bit 12 : Pin 12 */
++#define GPIO_OUT_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
++#define GPIO_OUT_PIN12_Msk (0x1UL << GPIO_OUT_PIN12_Pos) /*!< Bit mask of PIN12 field. */
++#define GPIO_OUT_PIN12_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN12_High (1UL) /*!< Pin driver is high */
++
++/* Bit 11 : Pin 11 */
++#define GPIO_OUT_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
++#define GPIO_OUT_PIN11_Msk (0x1UL << GPIO_OUT_PIN11_Pos) /*!< Bit mask of PIN11 field. */
++#define GPIO_OUT_PIN11_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN11_High (1UL) /*!< Pin driver is high */
++
++/* Bit 10 : Pin 10 */
++#define GPIO_OUT_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
++#define GPIO_OUT_PIN10_Msk (0x1UL << GPIO_OUT_PIN10_Pos) /*!< Bit mask of PIN10 field. */
++#define GPIO_OUT_PIN10_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN10_High (1UL) /*!< Pin driver is high */
++
++/* Bit 9 : Pin 9 */
++#define GPIO_OUT_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
++#define GPIO_OUT_PIN9_Msk (0x1UL << GPIO_OUT_PIN9_Pos) /*!< Bit mask of PIN9 field. */
++#define GPIO_OUT_PIN9_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN9_High (1UL) /*!< Pin driver is high */
++
++/* Bit 8 : Pin 8 */
++#define GPIO_OUT_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
++#define GPIO_OUT_PIN8_Msk (0x1UL << GPIO_OUT_PIN8_Pos) /*!< Bit mask of PIN8 field. */
++#define GPIO_OUT_PIN8_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN8_High (1UL) /*!< Pin driver is high */
++
++/* Bit 7 : Pin 7 */
++#define GPIO_OUT_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
++#define GPIO_OUT_PIN7_Msk (0x1UL << GPIO_OUT_PIN7_Pos) /*!< Bit mask of PIN7 field. */
++#define GPIO_OUT_PIN7_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN7_High (1UL) /*!< Pin driver is high */
++
++/* Bit 6 : Pin 6 */
++#define GPIO_OUT_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
++#define GPIO_OUT_PIN6_Msk (0x1UL << GPIO_OUT_PIN6_Pos) /*!< Bit mask of PIN6 field. */
++#define GPIO_OUT_PIN6_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN6_High (1UL) /*!< Pin driver is high */
++
++/* Bit 5 : Pin 5 */
++#define GPIO_OUT_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
++#define GPIO_OUT_PIN5_Msk (0x1UL << GPIO_OUT_PIN5_Pos) /*!< Bit mask of PIN5 field. */
++#define GPIO_OUT_PIN5_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN5_High (1UL) /*!< Pin driver is high */
++
++/* Bit 4 : Pin 4 */
++#define GPIO_OUT_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
++#define GPIO_OUT_PIN4_Msk (0x1UL << GPIO_OUT_PIN4_Pos) /*!< Bit mask of PIN4 field. */
++#define GPIO_OUT_PIN4_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN4_High (1UL) /*!< Pin driver is high */
++
++/* Bit 3 : Pin 3 */
++#define GPIO_OUT_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
++#define GPIO_OUT_PIN3_Msk (0x1UL << GPIO_OUT_PIN3_Pos) /*!< Bit mask of PIN3 field. */
++#define GPIO_OUT_PIN3_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN3_High (1UL) /*!< Pin driver is high */
++
++/* Bit 2 : Pin 2 */
++#define GPIO_OUT_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
++#define GPIO_OUT_PIN2_Msk (0x1UL << GPIO_OUT_PIN2_Pos) /*!< Bit mask of PIN2 field. */
++#define GPIO_OUT_PIN2_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN2_High (1UL) /*!< Pin driver is high */
++
++/* Bit 1 : Pin 1 */
++#define GPIO_OUT_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
++#define GPIO_OUT_PIN1_Msk (0x1UL << GPIO_OUT_PIN1_Pos) /*!< Bit mask of PIN1 field. */
++#define GPIO_OUT_PIN1_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN1_High (1UL) /*!< Pin driver is high */
++
++/* Bit 0 : Pin 0 */
++#define GPIO_OUT_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
++#define GPIO_OUT_PIN0_Msk (0x1UL << GPIO_OUT_PIN0_Pos) /*!< Bit mask of PIN0 field. */
++#define GPIO_OUT_PIN0_Low (0UL) /*!< Pin driver is low */
++#define GPIO_OUT_PIN0_High (1UL) /*!< Pin driver is high */
++
++/* Register: GPIO_OUTSET */
++/* Description: Set individual bits in GPIO port */
++
++/* Bit 31 : Pin 31 */
++#define GPIO_OUTSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
++#define GPIO_OUTSET_PIN31_Msk (0x1UL << GPIO_OUTSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
++#define GPIO_OUTSET_PIN31_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN31_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN31_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 30 : Pin 30 */
++#define GPIO_OUTSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
++#define GPIO_OUTSET_PIN30_Msk (0x1UL << GPIO_OUTSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
++#define GPIO_OUTSET_PIN30_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN30_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN30_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 29 : Pin 29 */
++#define GPIO_OUTSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
++#define GPIO_OUTSET_PIN29_Msk (0x1UL << GPIO_OUTSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
++#define GPIO_OUTSET_PIN29_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN29_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN29_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 28 : Pin 28 */
++#define GPIO_OUTSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
++#define GPIO_OUTSET_PIN28_Msk (0x1UL << GPIO_OUTSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
++#define GPIO_OUTSET_PIN28_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN28_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN28_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 27 : Pin 27 */
++#define GPIO_OUTSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
++#define GPIO_OUTSET_PIN27_Msk (0x1UL << GPIO_OUTSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
++#define GPIO_OUTSET_PIN27_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN27_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN27_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 26 : Pin 26 */
++#define GPIO_OUTSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
++#define GPIO_OUTSET_PIN26_Msk (0x1UL << GPIO_OUTSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
++#define GPIO_OUTSET_PIN26_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN26_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN26_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 25 : Pin 25 */
++#define GPIO_OUTSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
++#define GPIO_OUTSET_PIN25_Msk (0x1UL << GPIO_OUTSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
++#define GPIO_OUTSET_PIN25_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN25_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN25_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 24 : Pin 24 */
++#define GPIO_OUTSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
++#define GPIO_OUTSET_PIN24_Msk (0x1UL << GPIO_OUTSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
++#define GPIO_OUTSET_PIN24_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN24_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN24_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 23 : Pin 23 */
++#define GPIO_OUTSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
++#define GPIO_OUTSET_PIN23_Msk (0x1UL << GPIO_OUTSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
++#define GPIO_OUTSET_PIN23_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN23_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN23_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 22 : Pin 22 */
++#define GPIO_OUTSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
++#define GPIO_OUTSET_PIN22_Msk (0x1UL << GPIO_OUTSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
++#define GPIO_OUTSET_PIN22_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN22_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN22_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 21 : Pin 21 */
++#define GPIO_OUTSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
++#define GPIO_OUTSET_PIN21_Msk (0x1UL << GPIO_OUTSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
++#define GPIO_OUTSET_PIN21_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN21_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN21_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 20 : Pin 20 */
++#define GPIO_OUTSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
++#define GPIO_OUTSET_PIN20_Msk (0x1UL << GPIO_OUTSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
++#define GPIO_OUTSET_PIN20_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN20_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN20_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 19 : Pin 19 */
++#define GPIO_OUTSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
++#define GPIO_OUTSET_PIN19_Msk (0x1UL << GPIO_OUTSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
++#define GPIO_OUTSET_PIN19_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN19_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN19_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 18 : Pin 18 */
++#define GPIO_OUTSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
++#define GPIO_OUTSET_PIN18_Msk (0x1UL << GPIO_OUTSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
++#define GPIO_OUTSET_PIN18_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN18_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN18_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 17 : Pin 17 */
++#define GPIO_OUTSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
++#define GPIO_OUTSET_PIN17_Msk (0x1UL << GPIO_OUTSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
++#define GPIO_OUTSET_PIN17_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN17_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN17_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 16 : Pin 16 */
++#define GPIO_OUTSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
++#define GPIO_OUTSET_PIN16_Msk (0x1UL << GPIO_OUTSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
++#define GPIO_OUTSET_PIN16_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN16_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN16_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 15 : Pin 15 */
++#define GPIO_OUTSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
++#define GPIO_OUTSET_PIN15_Msk (0x1UL << GPIO_OUTSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
++#define GPIO_OUTSET_PIN15_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN15_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN15_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 14 : Pin 14 */
++#define GPIO_OUTSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
++#define GPIO_OUTSET_PIN14_Msk (0x1UL << GPIO_OUTSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
++#define GPIO_OUTSET_PIN14_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN14_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN14_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 13 : Pin 13 */
++#define GPIO_OUTSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
++#define GPIO_OUTSET_PIN13_Msk (0x1UL << GPIO_OUTSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
++#define GPIO_OUTSET_PIN13_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN13_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN13_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 12 : Pin 12 */
++#define GPIO_OUTSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
++#define GPIO_OUTSET_PIN12_Msk (0x1UL << GPIO_OUTSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
++#define GPIO_OUTSET_PIN12_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN12_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN12_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 11 : Pin 11 */
++#define GPIO_OUTSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
++#define GPIO_OUTSET_PIN11_Msk (0x1UL << GPIO_OUTSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
++#define GPIO_OUTSET_PIN11_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN11_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN11_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 10 : Pin 10 */
++#define GPIO_OUTSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
++#define GPIO_OUTSET_PIN10_Msk (0x1UL << GPIO_OUTSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
++#define GPIO_OUTSET_PIN10_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN10_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN10_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 9 : Pin 9 */
++#define GPIO_OUTSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
++#define GPIO_OUTSET_PIN9_Msk (0x1UL << GPIO_OUTSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
++#define GPIO_OUTSET_PIN9_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN9_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN9_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 8 : Pin 8 */
++#define GPIO_OUTSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
++#define GPIO_OUTSET_PIN8_Msk (0x1UL << GPIO_OUTSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
++#define GPIO_OUTSET_PIN8_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN8_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN8_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 7 : Pin 7 */
++#define GPIO_OUTSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
++#define GPIO_OUTSET_PIN7_Msk (0x1UL << GPIO_OUTSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
++#define GPIO_OUTSET_PIN7_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN7_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN7_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 6 : Pin 6 */
++#define GPIO_OUTSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
++#define GPIO_OUTSET_PIN6_Msk (0x1UL << GPIO_OUTSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
++#define GPIO_OUTSET_PIN6_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN6_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN6_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 5 : Pin 5 */
++#define GPIO_OUTSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
++#define GPIO_OUTSET_PIN5_Msk (0x1UL << GPIO_OUTSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
++#define GPIO_OUTSET_PIN5_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN5_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN5_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 4 : Pin 4 */
++#define GPIO_OUTSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
++#define GPIO_OUTSET_PIN4_Msk (0x1UL << GPIO_OUTSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
++#define GPIO_OUTSET_PIN4_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN4_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN4_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 3 : Pin 3 */
++#define GPIO_OUTSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
++#define GPIO_OUTSET_PIN3_Msk (0x1UL << GPIO_OUTSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
++#define GPIO_OUTSET_PIN3_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN3_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN3_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 2 : Pin 2 */
++#define GPIO_OUTSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
++#define GPIO_OUTSET_PIN2_Msk (0x1UL << GPIO_OUTSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
++#define GPIO_OUTSET_PIN2_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN2_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN2_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 1 : Pin 1 */
++#define GPIO_OUTSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
++#define GPIO_OUTSET_PIN1_Msk (0x1UL << GPIO_OUTSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
++#define GPIO_OUTSET_PIN1_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN1_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN1_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Bit 0 : Pin 0 */
++#define GPIO_OUTSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
++#define GPIO_OUTSET_PIN0_Msk (0x1UL << GPIO_OUTSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
++#define GPIO_OUTSET_PIN0_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTSET_PIN0_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTSET_PIN0_Set (1UL) /*!< Write: a '1' sets the pin high; a '0' has no effect */
++
++/* Register: GPIO_OUTCLR */
++/* Description: Clear individual bits in GPIO port */
++
++/* Bit 31 : Pin 31 */
++#define GPIO_OUTCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
++#define GPIO_OUTCLR_PIN31_Msk (0x1UL << GPIO_OUTCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
++#define GPIO_OUTCLR_PIN31_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN31_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN31_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 30 : Pin 30 */
++#define GPIO_OUTCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
++#define GPIO_OUTCLR_PIN30_Msk (0x1UL << GPIO_OUTCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
++#define GPIO_OUTCLR_PIN30_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN30_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN30_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 29 : Pin 29 */
++#define GPIO_OUTCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
++#define GPIO_OUTCLR_PIN29_Msk (0x1UL << GPIO_OUTCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
++#define GPIO_OUTCLR_PIN29_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN29_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN29_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 28 : Pin 28 */
++#define GPIO_OUTCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
++#define GPIO_OUTCLR_PIN28_Msk (0x1UL << GPIO_OUTCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
++#define GPIO_OUTCLR_PIN28_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN28_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN28_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 27 : Pin 27 */
++#define GPIO_OUTCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
++#define GPIO_OUTCLR_PIN27_Msk (0x1UL << GPIO_OUTCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
++#define GPIO_OUTCLR_PIN27_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN27_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN27_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 26 : Pin 26 */
++#define GPIO_OUTCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
++#define GPIO_OUTCLR_PIN26_Msk (0x1UL << GPIO_OUTCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
++#define GPIO_OUTCLR_PIN26_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN26_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN26_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 25 : Pin 25 */
++#define GPIO_OUTCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
++#define GPIO_OUTCLR_PIN25_Msk (0x1UL << GPIO_OUTCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
++#define GPIO_OUTCLR_PIN25_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN25_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN25_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 24 : Pin 24 */
++#define GPIO_OUTCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
++#define GPIO_OUTCLR_PIN24_Msk (0x1UL << GPIO_OUTCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
++#define GPIO_OUTCLR_PIN24_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN24_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN24_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 23 : Pin 23 */
++#define GPIO_OUTCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
++#define GPIO_OUTCLR_PIN23_Msk (0x1UL << GPIO_OUTCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
++#define GPIO_OUTCLR_PIN23_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN23_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN23_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 22 : Pin 22 */
++#define GPIO_OUTCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
++#define GPIO_OUTCLR_PIN22_Msk (0x1UL << GPIO_OUTCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
++#define GPIO_OUTCLR_PIN22_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN22_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN22_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 21 : Pin 21 */
++#define GPIO_OUTCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
++#define GPIO_OUTCLR_PIN21_Msk (0x1UL << GPIO_OUTCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
++#define GPIO_OUTCLR_PIN21_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN21_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN21_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 20 : Pin 20 */
++#define GPIO_OUTCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
++#define GPIO_OUTCLR_PIN20_Msk (0x1UL << GPIO_OUTCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
++#define GPIO_OUTCLR_PIN20_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN20_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN20_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 19 : Pin 19 */
++#define GPIO_OUTCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
++#define GPIO_OUTCLR_PIN19_Msk (0x1UL << GPIO_OUTCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
++#define GPIO_OUTCLR_PIN19_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN19_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN19_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 18 : Pin 18 */
++#define GPIO_OUTCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
++#define GPIO_OUTCLR_PIN18_Msk (0x1UL << GPIO_OUTCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
++#define GPIO_OUTCLR_PIN18_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN18_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN18_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 17 : Pin 17 */
++#define GPIO_OUTCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
++#define GPIO_OUTCLR_PIN17_Msk (0x1UL << GPIO_OUTCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
++#define GPIO_OUTCLR_PIN17_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN17_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN17_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 16 : Pin 16 */
++#define GPIO_OUTCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
++#define GPIO_OUTCLR_PIN16_Msk (0x1UL << GPIO_OUTCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
++#define GPIO_OUTCLR_PIN16_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN16_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN16_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 15 : Pin 15 */
++#define GPIO_OUTCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
++#define GPIO_OUTCLR_PIN15_Msk (0x1UL << GPIO_OUTCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
++#define GPIO_OUTCLR_PIN15_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN15_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN15_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 14 : Pin 14 */
++#define GPIO_OUTCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
++#define GPIO_OUTCLR_PIN14_Msk (0x1UL << GPIO_OUTCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
++#define GPIO_OUTCLR_PIN14_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN14_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN14_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 13 : Pin 13 */
++#define GPIO_OUTCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
++#define GPIO_OUTCLR_PIN13_Msk (0x1UL << GPIO_OUTCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
++#define GPIO_OUTCLR_PIN13_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN13_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN13_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 12 : Pin 12 */
++#define GPIO_OUTCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
++#define GPIO_OUTCLR_PIN12_Msk (0x1UL << GPIO_OUTCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
++#define GPIO_OUTCLR_PIN12_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN12_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN12_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 11 : Pin 11 */
++#define GPIO_OUTCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
++#define GPIO_OUTCLR_PIN11_Msk (0x1UL << GPIO_OUTCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
++#define GPIO_OUTCLR_PIN11_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN11_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN11_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 10 : Pin 10 */
++#define GPIO_OUTCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
++#define GPIO_OUTCLR_PIN10_Msk (0x1UL << GPIO_OUTCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
++#define GPIO_OUTCLR_PIN10_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN10_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN10_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 9 : Pin 9 */
++#define GPIO_OUTCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
++#define GPIO_OUTCLR_PIN9_Msk (0x1UL << GPIO_OUTCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
++#define GPIO_OUTCLR_PIN9_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN9_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN9_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 8 : Pin 8 */
++#define GPIO_OUTCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
++#define GPIO_OUTCLR_PIN8_Msk (0x1UL << GPIO_OUTCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
++#define GPIO_OUTCLR_PIN8_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN8_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN8_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 7 : Pin 7 */
++#define GPIO_OUTCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
++#define GPIO_OUTCLR_PIN7_Msk (0x1UL << GPIO_OUTCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
++#define GPIO_OUTCLR_PIN7_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN7_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN7_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 6 : Pin 6 */
++#define GPIO_OUTCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
++#define GPIO_OUTCLR_PIN6_Msk (0x1UL << GPIO_OUTCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
++#define GPIO_OUTCLR_PIN6_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN6_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN6_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 5 : Pin 5 */
++#define GPIO_OUTCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
++#define GPIO_OUTCLR_PIN5_Msk (0x1UL << GPIO_OUTCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
++#define GPIO_OUTCLR_PIN5_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN5_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN5_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 4 : Pin 4 */
++#define GPIO_OUTCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
++#define GPIO_OUTCLR_PIN4_Msk (0x1UL << GPIO_OUTCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
++#define GPIO_OUTCLR_PIN4_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN4_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN4_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 3 : Pin 3 */
++#define GPIO_OUTCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
++#define GPIO_OUTCLR_PIN3_Msk (0x1UL << GPIO_OUTCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
++#define GPIO_OUTCLR_PIN3_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN3_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN3_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 2 : Pin 2 */
++#define GPIO_OUTCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
++#define GPIO_OUTCLR_PIN2_Msk (0x1UL << GPIO_OUTCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
++#define GPIO_OUTCLR_PIN2_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN2_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN2_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 1 : Pin 1 */
++#define GPIO_OUTCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
++#define GPIO_OUTCLR_PIN1_Msk (0x1UL << GPIO_OUTCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
++#define GPIO_OUTCLR_PIN1_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN1_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN1_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Bit 0 : Pin 0 */
++#define GPIO_OUTCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
++#define GPIO_OUTCLR_PIN0_Msk (0x1UL << GPIO_OUTCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
++#define GPIO_OUTCLR_PIN0_Low (0UL) /*!< Read: pin driver is low */
++#define GPIO_OUTCLR_PIN0_High (1UL) /*!< Read: pin driver is high */
++#define GPIO_OUTCLR_PIN0_Clear (1UL) /*!< Write: a '1' sets the pin low; a '0' has no effect */
++
++/* Register: GPIO_IN */
++/* Description: Read GPIO port */
++
++/* Bit 31 : Pin 31 */
++#define GPIO_IN_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
++#define GPIO_IN_PIN31_Msk (0x1UL << GPIO_IN_PIN31_Pos) /*!< Bit mask of PIN31 field. */
++#define GPIO_IN_PIN31_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN31_High (1UL) /*!< Pin input is high */
++
++/* Bit 30 : Pin 30 */
++#define GPIO_IN_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
++#define GPIO_IN_PIN30_Msk (0x1UL << GPIO_IN_PIN30_Pos) /*!< Bit mask of PIN30 field. */
++#define GPIO_IN_PIN30_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN30_High (1UL) /*!< Pin input is high */
++
++/* Bit 29 : Pin 29 */
++#define GPIO_IN_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
++#define GPIO_IN_PIN29_Msk (0x1UL << GPIO_IN_PIN29_Pos) /*!< Bit mask of PIN29 field. */
++#define GPIO_IN_PIN29_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN29_High (1UL) /*!< Pin input is high */
++
++/* Bit 28 : Pin 28 */
++#define GPIO_IN_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
++#define GPIO_IN_PIN28_Msk (0x1UL << GPIO_IN_PIN28_Pos) /*!< Bit mask of PIN28 field. */
++#define GPIO_IN_PIN28_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN28_High (1UL) /*!< Pin input is high */
++
++/* Bit 27 : Pin 27 */
++#define GPIO_IN_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
++#define GPIO_IN_PIN27_Msk (0x1UL << GPIO_IN_PIN27_Pos) /*!< Bit mask of PIN27 field. */
++#define GPIO_IN_PIN27_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN27_High (1UL) /*!< Pin input is high */
++
++/* Bit 26 : Pin 26 */
++#define GPIO_IN_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
++#define GPIO_IN_PIN26_Msk (0x1UL << GPIO_IN_PIN26_Pos) /*!< Bit mask of PIN26 field. */
++#define GPIO_IN_PIN26_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN26_High (1UL) /*!< Pin input is high */
++
++/* Bit 25 : Pin 25 */
++#define GPIO_IN_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
++#define GPIO_IN_PIN25_Msk (0x1UL << GPIO_IN_PIN25_Pos) /*!< Bit mask of PIN25 field. */
++#define GPIO_IN_PIN25_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN25_High (1UL) /*!< Pin input is high */
++
++/* Bit 24 : Pin 24 */
++#define GPIO_IN_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
++#define GPIO_IN_PIN24_Msk (0x1UL << GPIO_IN_PIN24_Pos) /*!< Bit mask of PIN24 field. */
++#define GPIO_IN_PIN24_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN24_High (1UL) /*!< Pin input is high */
++
++/* Bit 23 : Pin 23 */
++#define GPIO_IN_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
++#define GPIO_IN_PIN23_Msk (0x1UL << GPIO_IN_PIN23_Pos) /*!< Bit mask of PIN23 field. */
++#define GPIO_IN_PIN23_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN23_High (1UL) /*!< Pin input is high */
++
++/* Bit 22 : Pin 22 */
++#define GPIO_IN_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
++#define GPIO_IN_PIN22_Msk (0x1UL << GPIO_IN_PIN22_Pos) /*!< Bit mask of PIN22 field. */
++#define GPIO_IN_PIN22_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN22_High (1UL) /*!< Pin input is high */
++
++/* Bit 21 : Pin 21 */
++#define GPIO_IN_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
++#define GPIO_IN_PIN21_Msk (0x1UL << GPIO_IN_PIN21_Pos) /*!< Bit mask of PIN21 field. */
++#define GPIO_IN_PIN21_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN21_High (1UL) /*!< Pin input is high */
++
++/* Bit 20 : Pin 20 */
++#define GPIO_IN_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
++#define GPIO_IN_PIN20_Msk (0x1UL << GPIO_IN_PIN20_Pos) /*!< Bit mask of PIN20 field. */
++#define GPIO_IN_PIN20_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN20_High (1UL) /*!< Pin input is high */
++
++/* Bit 19 : Pin 19 */
++#define GPIO_IN_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
++#define GPIO_IN_PIN19_Msk (0x1UL << GPIO_IN_PIN19_Pos) /*!< Bit mask of PIN19 field. */
++#define GPIO_IN_PIN19_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN19_High (1UL) /*!< Pin input is high */
++
++/* Bit 18 : Pin 18 */
++#define GPIO_IN_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
++#define GPIO_IN_PIN18_Msk (0x1UL << GPIO_IN_PIN18_Pos) /*!< Bit mask of PIN18 field. */
++#define GPIO_IN_PIN18_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN18_High (1UL) /*!< Pin input is high */
++
++/* Bit 17 : Pin 17 */
++#define GPIO_IN_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
++#define GPIO_IN_PIN17_Msk (0x1UL << GPIO_IN_PIN17_Pos) /*!< Bit mask of PIN17 field. */
++#define GPIO_IN_PIN17_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN17_High (1UL) /*!< Pin input is high */
++
++/* Bit 16 : Pin 16 */
++#define GPIO_IN_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
++#define GPIO_IN_PIN16_Msk (0x1UL << GPIO_IN_PIN16_Pos) /*!< Bit mask of PIN16 field. */
++#define GPIO_IN_PIN16_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN16_High (1UL) /*!< Pin input is high */
++
++/* Bit 15 : Pin 15 */
++#define GPIO_IN_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
++#define GPIO_IN_PIN15_Msk (0x1UL << GPIO_IN_PIN15_Pos) /*!< Bit mask of PIN15 field. */
++#define GPIO_IN_PIN15_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN15_High (1UL) /*!< Pin input is high */
++
++/* Bit 14 : Pin 14 */
++#define GPIO_IN_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
++#define GPIO_IN_PIN14_Msk (0x1UL << GPIO_IN_PIN14_Pos) /*!< Bit mask of PIN14 field. */
++#define GPIO_IN_PIN14_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN14_High (1UL) /*!< Pin input is high */
++
++/* Bit 13 : Pin 13 */
++#define GPIO_IN_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
++#define GPIO_IN_PIN13_Msk (0x1UL << GPIO_IN_PIN13_Pos) /*!< Bit mask of PIN13 field. */
++#define GPIO_IN_PIN13_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN13_High (1UL) /*!< Pin input is high */
++
++/* Bit 12 : Pin 12 */
++#define GPIO_IN_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
++#define GPIO_IN_PIN12_Msk (0x1UL << GPIO_IN_PIN12_Pos) /*!< Bit mask of PIN12 field. */
++#define GPIO_IN_PIN12_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN12_High (1UL) /*!< Pin input is high */
++
++/* Bit 11 : Pin 11 */
++#define GPIO_IN_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
++#define GPIO_IN_PIN11_Msk (0x1UL << GPIO_IN_PIN11_Pos) /*!< Bit mask of PIN11 field. */
++#define GPIO_IN_PIN11_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN11_High (1UL) /*!< Pin input is high */
++
++/* Bit 10 : Pin 10 */
++#define GPIO_IN_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
++#define GPIO_IN_PIN10_Msk (0x1UL << GPIO_IN_PIN10_Pos) /*!< Bit mask of PIN10 field. */
++#define GPIO_IN_PIN10_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN10_High (1UL) /*!< Pin input is high */
++
++/* Bit 9 : Pin 9 */
++#define GPIO_IN_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
++#define GPIO_IN_PIN9_Msk (0x1UL << GPIO_IN_PIN9_Pos) /*!< Bit mask of PIN9 field. */
++#define GPIO_IN_PIN9_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN9_High (1UL) /*!< Pin input is high */
++
++/* Bit 8 : Pin 8 */
++#define GPIO_IN_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
++#define GPIO_IN_PIN8_Msk (0x1UL << GPIO_IN_PIN8_Pos) /*!< Bit mask of PIN8 field. */
++#define GPIO_IN_PIN8_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN8_High (1UL) /*!< Pin input is high */
++
++/* Bit 7 : Pin 7 */
++#define GPIO_IN_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
++#define GPIO_IN_PIN7_Msk (0x1UL << GPIO_IN_PIN7_Pos) /*!< Bit mask of PIN7 field. */
++#define GPIO_IN_PIN7_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN7_High (1UL) /*!< Pin input is high */
++
++/* Bit 6 : Pin 6 */
++#define GPIO_IN_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
++#define GPIO_IN_PIN6_Msk (0x1UL << GPIO_IN_PIN6_Pos) /*!< Bit mask of PIN6 field. */
++#define GPIO_IN_PIN6_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN6_High (1UL) /*!< Pin input is high */
++
++/* Bit 5 : Pin 5 */
++#define GPIO_IN_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
++#define GPIO_IN_PIN5_Msk (0x1UL << GPIO_IN_PIN5_Pos) /*!< Bit mask of PIN5 field. */
++#define GPIO_IN_PIN5_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN5_High (1UL) /*!< Pin input is high */
++
++/* Bit 4 : Pin 4 */
++#define GPIO_IN_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
++#define GPIO_IN_PIN4_Msk (0x1UL << GPIO_IN_PIN4_Pos) /*!< Bit mask of PIN4 field. */
++#define GPIO_IN_PIN4_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN4_High (1UL) /*!< Pin input is high */
++
++/* Bit 3 : Pin 3 */
++#define GPIO_IN_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
++#define GPIO_IN_PIN3_Msk (0x1UL << GPIO_IN_PIN3_Pos) /*!< Bit mask of PIN3 field. */
++#define GPIO_IN_PIN3_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN3_High (1UL) /*!< Pin input is high */
++
++/* Bit 2 : Pin 2 */
++#define GPIO_IN_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
++#define GPIO_IN_PIN2_Msk (0x1UL << GPIO_IN_PIN2_Pos) /*!< Bit mask of PIN2 field. */
++#define GPIO_IN_PIN2_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN2_High (1UL) /*!< Pin input is high */
++
++/* Bit 1 : Pin 1 */
++#define GPIO_IN_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
++#define GPIO_IN_PIN1_Msk (0x1UL << GPIO_IN_PIN1_Pos) /*!< Bit mask of PIN1 field. */
++#define GPIO_IN_PIN1_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN1_High (1UL) /*!< Pin input is high */
++
++/* Bit 0 : Pin 0 */
++#define GPIO_IN_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
++#define GPIO_IN_PIN0_Msk (0x1UL << GPIO_IN_PIN0_Pos) /*!< Bit mask of PIN0 field. */
++#define GPIO_IN_PIN0_Low (0UL) /*!< Pin input is low */
++#define GPIO_IN_PIN0_High (1UL) /*!< Pin input is high */
++
++/* Register: GPIO_DIR */
++/* Description: Direction of GPIO pins */
++
++/* Bit 31 : Pin 31 */
++#define GPIO_DIR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
++#define GPIO_DIR_PIN31_Msk (0x1UL << GPIO_DIR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
++#define GPIO_DIR_PIN31_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN31_Output (1UL) /*!< Pin set as output */
++
++/* Bit 30 : Pin 30 */
++#define GPIO_DIR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
++#define GPIO_DIR_PIN30_Msk (0x1UL << GPIO_DIR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
++#define GPIO_DIR_PIN30_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN30_Output (1UL) /*!< Pin set as output */
++
++/* Bit 29 : Pin 29 */
++#define GPIO_DIR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
++#define GPIO_DIR_PIN29_Msk (0x1UL << GPIO_DIR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
++#define GPIO_DIR_PIN29_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN29_Output (1UL) /*!< Pin set as output */
++
++/* Bit 28 : Pin 28 */
++#define GPIO_DIR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
++#define GPIO_DIR_PIN28_Msk (0x1UL << GPIO_DIR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
++#define GPIO_DIR_PIN28_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN28_Output (1UL) /*!< Pin set as output */
++
++/* Bit 27 : Pin 27 */
++#define GPIO_DIR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
++#define GPIO_DIR_PIN27_Msk (0x1UL << GPIO_DIR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
++#define GPIO_DIR_PIN27_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN27_Output (1UL) /*!< Pin set as output */
++
++/* Bit 26 : Pin 26 */
++#define GPIO_DIR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
++#define GPIO_DIR_PIN26_Msk (0x1UL << GPIO_DIR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
++#define GPIO_DIR_PIN26_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN26_Output (1UL) /*!< Pin set as output */
++
++/* Bit 25 : Pin 25 */
++#define GPIO_DIR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
++#define GPIO_DIR_PIN25_Msk (0x1UL << GPIO_DIR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
++#define GPIO_DIR_PIN25_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN25_Output (1UL) /*!< Pin set as output */
++
++/* Bit 24 : Pin 24 */
++#define GPIO_DIR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
++#define GPIO_DIR_PIN24_Msk (0x1UL << GPIO_DIR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
++#define GPIO_DIR_PIN24_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN24_Output (1UL) /*!< Pin set as output */
++
++/* Bit 23 : Pin 23 */
++#define GPIO_DIR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
++#define GPIO_DIR_PIN23_Msk (0x1UL << GPIO_DIR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
++#define GPIO_DIR_PIN23_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN23_Output (1UL) /*!< Pin set as output */
++
++/* Bit 22 : Pin 22 */
++#define GPIO_DIR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
++#define GPIO_DIR_PIN22_Msk (0x1UL << GPIO_DIR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
++#define GPIO_DIR_PIN22_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN22_Output (1UL) /*!< Pin set as output */
++
++/* Bit 21 : Pin 21 */
++#define GPIO_DIR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
++#define GPIO_DIR_PIN21_Msk (0x1UL << GPIO_DIR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
++#define GPIO_DIR_PIN21_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN21_Output (1UL) /*!< Pin set as output */
++
++/* Bit 20 : Pin 20 */
++#define GPIO_DIR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
++#define GPIO_DIR_PIN20_Msk (0x1UL << GPIO_DIR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
++#define GPIO_DIR_PIN20_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN20_Output (1UL) /*!< Pin set as output */
++
++/* Bit 19 : Pin 19 */
++#define GPIO_DIR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
++#define GPIO_DIR_PIN19_Msk (0x1UL << GPIO_DIR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
++#define GPIO_DIR_PIN19_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN19_Output (1UL) /*!< Pin set as output */
++
++/* Bit 18 : Pin 18 */
++#define GPIO_DIR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
++#define GPIO_DIR_PIN18_Msk (0x1UL << GPIO_DIR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
++#define GPIO_DIR_PIN18_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN18_Output (1UL) /*!< Pin set as output */
++
++/* Bit 17 : Pin 17 */
++#define GPIO_DIR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
++#define GPIO_DIR_PIN17_Msk (0x1UL << GPIO_DIR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
++#define GPIO_DIR_PIN17_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN17_Output (1UL) /*!< Pin set as output */
++
++/* Bit 16 : Pin 16 */
++#define GPIO_DIR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
++#define GPIO_DIR_PIN16_Msk (0x1UL << GPIO_DIR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
++#define GPIO_DIR_PIN16_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN16_Output (1UL) /*!< Pin set as output */
++
++/* Bit 15 : Pin 15 */
++#define GPIO_DIR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
++#define GPIO_DIR_PIN15_Msk (0x1UL << GPIO_DIR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
++#define GPIO_DIR_PIN15_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN15_Output (1UL) /*!< Pin set as output */
++
++/* Bit 14 : Pin 14 */
++#define GPIO_DIR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
++#define GPIO_DIR_PIN14_Msk (0x1UL << GPIO_DIR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
++#define GPIO_DIR_PIN14_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN14_Output (1UL) /*!< Pin set as output */
++
++/* Bit 13 : Pin 13 */
++#define GPIO_DIR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
++#define GPIO_DIR_PIN13_Msk (0x1UL << GPIO_DIR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
++#define GPIO_DIR_PIN13_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN13_Output (1UL) /*!< Pin set as output */
++
++/* Bit 12 : Pin 12 */
++#define GPIO_DIR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
++#define GPIO_DIR_PIN12_Msk (0x1UL << GPIO_DIR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
++#define GPIO_DIR_PIN12_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN12_Output (1UL) /*!< Pin set as output */
++
++/* Bit 11 : Pin 11 */
++#define GPIO_DIR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
++#define GPIO_DIR_PIN11_Msk (0x1UL << GPIO_DIR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
++#define GPIO_DIR_PIN11_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN11_Output (1UL) /*!< Pin set as output */
++
++/* Bit 10 : Pin 10 */
++#define GPIO_DIR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
++#define GPIO_DIR_PIN10_Msk (0x1UL << GPIO_DIR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
++#define GPIO_DIR_PIN10_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN10_Output (1UL) /*!< Pin set as output */
++
++/* Bit 9 : Pin 9 */
++#define GPIO_DIR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
++#define GPIO_DIR_PIN9_Msk (0x1UL << GPIO_DIR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
++#define GPIO_DIR_PIN9_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN9_Output (1UL) /*!< Pin set as output */
++
++/* Bit 8 : Pin 8 */
++#define GPIO_DIR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
++#define GPIO_DIR_PIN8_Msk (0x1UL << GPIO_DIR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
++#define GPIO_DIR_PIN8_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN8_Output (1UL) /*!< Pin set as output */
++
++/* Bit 7 : Pin 7 */
++#define GPIO_DIR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
++#define GPIO_DIR_PIN7_Msk (0x1UL << GPIO_DIR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
++#define GPIO_DIR_PIN7_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN7_Output (1UL) /*!< Pin set as output */
++
++/* Bit 6 : Pin 6 */
++#define GPIO_DIR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
++#define GPIO_DIR_PIN6_Msk (0x1UL << GPIO_DIR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
++#define GPIO_DIR_PIN6_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN6_Output (1UL) /*!< Pin set as output */
++
++/* Bit 5 : Pin 5 */
++#define GPIO_DIR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
++#define GPIO_DIR_PIN5_Msk (0x1UL << GPIO_DIR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
++#define GPIO_DIR_PIN5_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN5_Output (1UL) /*!< Pin set as output */
++
++/* Bit 4 : Pin 4 */
++#define GPIO_DIR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
++#define GPIO_DIR_PIN4_Msk (0x1UL << GPIO_DIR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
++#define GPIO_DIR_PIN4_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN4_Output (1UL) /*!< Pin set as output */
++
++/* Bit 3 : Pin 3 */
++#define GPIO_DIR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
++#define GPIO_DIR_PIN3_Msk (0x1UL << GPIO_DIR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
++#define GPIO_DIR_PIN3_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN3_Output (1UL) /*!< Pin set as output */
++
++/* Bit 2 : Pin 2 */
++#define GPIO_DIR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
++#define GPIO_DIR_PIN2_Msk (0x1UL << GPIO_DIR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
++#define GPIO_DIR_PIN2_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN2_Output (1UL) /*!< Pin set as output */
++
++/* Bit 1 : Pin 1 */
++#define GPIO_DIR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
++#define GPIO_DIR_PIN1_Msk (0x1UL << GPIO_DIR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
++#define GPIO_DIR_PIN1_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN1_Output (1UL) /*!< Pin set as output */
++
++/* Bit 0 : Pin 0 */
++#define GPIO_DIR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
++#define GPIO_DIR_PIN0_Msk (0x1UL << GPIO_DIR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
++#define GPIO_DIR_PIN0_Input (0UL) /*!< Pin set as input */
++#define GPIO_DIR_PIN0_Output (1UL) /*!< Pin set as output */
++
++/* Register: GPIO_DIRSET */
++/* Description: DIR set register */
++
++/* Bit 31 : Set as output pin 31 */
++#define GPIO_DIRSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
++#define GPIO_DIRSET_PIN31_Msk (0x1UL << GPIO_DIRSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
++#define GPIO_DIRSET_PIN31_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN31_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN31_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 30 : Set as output pin 30 */
++#define GPIO_DIRSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
++#define GPIO_DIRSET_PIN30_Msk (0x1UL << GPIO_DIRSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
++#define GPIO_DIRSET_PIN30_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN30_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN30_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 29 : Set as output pin 29 */
++#define GPIO_DIRSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
++#define GPIO_DIRSET_PIN29_Msk (0x1UL << GPIO_DIRSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
++#define GPIO_DIRSET_PIN29_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN29_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN29_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 28 : Set as output pin 28 */
++#define GPIO_DIRSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
++#define GPIO_DIRSET_PIN28_Msk (0x1UL << GPIO_DIRSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
++#define GPIO_DIRSET_PIN28_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN28_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN28_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 27 : Set as output pin 27 */
++#define GPIO_DIRSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
++#define GPIO_DIRSET_PIN27_Msk (0x1UL << GPIO_DIRSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
++#define GPIO_DIRSET_PIN27_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN27_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN27_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 26 : Set as output pin 26 */
++#define GPIO_DIRSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
++#define GPIO_DIRSET_PIN26_Msk (0x1UL << GPIO_DIRSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
++#define GPIO_DIRSET_PIN26_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN26_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN26_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 25 : Set as output pin 25 */
++#define GPIO_DIRSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
++#define GPIO_DIRSET_PIN25_Msk (0x1UL << GPIO_DIRSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
++#define GPIO_DIRSET_PIN25_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN25_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN25_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 24 : Set as output pin 24 */
++#define GPIO_DIRSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
++#define GPIO_DIRSET_PIN24_Msk (0x1UL << GPIO_DIRSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
++#define GPIO_DIRSET_PIN24_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN24_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN24_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 23 : Set as output pin 23 */
++#define GPIO_DIRSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
++#define GPIO_DIRSET_PIN23_Msk (0x1UL << GPIO_DIRSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
++#define GPIO_DIRSET_PIN23_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN23_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN23_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 22 : Set as output pin 22 */
++#define GPIO_DIRSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
++#define GPIO_DIRSET_PIN22_Msk (0x1UL << GPIO_DIRSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
++#define GPIO_DIRSET_PIN22_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN22_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN22_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 21 : Set as output pin 21 */
++#define GPIO_DIRSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
++#define GPIO_DIRSET_PIN21_Msk (0x1UL << GPIO_DIRSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
++#define GPIO_DIRSET_PIN21_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN21_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN21_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 20 : Set as output pin 20 */
++#define GPIO_DIRSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
++#define GPIO_DIRSET_PIN20_Msk (0x1UL << GPIO_DIRSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
++#define GPIO_DIRSET_PIN20_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN20_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN20_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 19 : Set as output pin 19 */
++#define GPIO_DIRSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
++#define GPIO_DIRSET_PIN19_Msk (0x1UL << GPIO_DIRSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
++#define GPIO_DIRSET_PIN19_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN19_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN19_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 18 : Set as output pin 18 */
++#define GPIO_DIRSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
++#define GPIO_DIRSET_PIN18_Msk (0x1UL << GPIO_DIRSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
++#define GPIO_DIRSET_PIN18_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN18_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN18_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 17 : Set as output pin 17 */
++#define GPIO_DIRSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
++#define GPIO_DIRSET_PIN17_Msk (0x1UL << GPIO_DIRSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
++#define GPIO_DIRSET_PIN17_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN17_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN17_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 16 : Set as output pin 16 */
++#define GPIO_DIRSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
++#define GPIO_DIRSET_PIN16_Msk (0x1UL << GPIO_DIRSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
++#define GPIO_DIRSET_PIN16_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN16_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN16_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 15 : Set as output pin 15 */
++#define GPIO_DIRSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
++#define GPIO_DIRSET_PIN15_Msk (0x1UL << GPIO_DIRSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
++#define GPIO_DIRSET_PIN15_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN15_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN15_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 14 : Set as output pin 14 */
++#define GPIO_DIRSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
++#define GPIO_DIRSET_PIN14_Msk (0x1UL << GPIO_DIRSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
++#define GPIO_DIRSET_PIN14_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN14_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN14_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 13 : Set as output pin 13 */
++#define GPIO_DIRSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
++#define GPIO_DIRSET_PIN13_Msk (0x1UL << GPIO_DIRSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
++#define GPIO_DIRSET_PIN13_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN13_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN13_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 12 : Set as output pin 12 */
++#define GPIO_DIRSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
++#define GPIO_DIRSET_PIN12_Msk (0x1UL << GPIO_DIRSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
++#define GPIO_DIRSET_PIN12_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN12_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN12_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 11 : Set as output pin 11 */
++#define GPIO_DIRSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
++#define GPIO_DIRSET_PIN11_Msk (0x1UL << GPIO_DIRSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
++#define GPIO_DIRSET_PIN11_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN11_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN11_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 10 : Set as output pin 10 */
++#define GPIO_DIRSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
++#define GPIO_DIRSET_PIN10_Msk (0x1UL << GPIO_DIRSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
++#define GPIO_DIRSET_PIN10_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN10_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN10_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 9 : Set as output pin 9 */
++#define GPIO_DIRSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
++#define GPIO_DIRSET_PIN9_Msk (0x1UL << GPIO_DIRSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
++#define GPIO_DIRSET_PIN9_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN9_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN9_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 8 : Set as output pin 8 */
++#define GPIO_DIRSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
++#define GPIO_DIRSET_PIN8_Msk (0x1UL << GPIO_DIRSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
++#define GPIO_DIRSET_PIN8_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN8_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN8_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 7 : Set as output pin 7 */
++#define GPIO_DIRSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
++#define GPIO_DIRSET_PIN7_Msk (0x1UL << GPIO_DIRSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
++#define GPIO_DIRSET_PIN7_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN7_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN7_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 6 : Set as output pin 6 */
++#define GPIO_DIRSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
++#define GPIO_DIRSET_PIN6_Msk (0x1UL << GPIO_DIRSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
++#define GPIO_DIRSET_PIN6_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN6_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN6_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 5 : Set as output pin 5 */
++#define GPIO_DIRSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
++#define GPIO_DIRSET_PIN5_Msk (0x1UL << GPIO_DIRSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
++#define GPIO_DIRSET_PIN5_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN5_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN5_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 4 : Set as output pin 4 */
++#define GPIO_DIRSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
++#define GPIO_DIRSET_PIN4_Msk (0x1UL << GPIO_DIRSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
++#define GPIO_DIRSET_PIN4_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN4_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN4_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 3 : Set as output pin 3 */
++#define GPIO_DIRSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
++#define GPIO_DIRSET_PIN3_Msk (0x1UL << GPIO_DIRSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
++#define GPIO_DIRSET_PIN3_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN3_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN3_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 2 : Set as output pin 2 */
++#define GPIO_DIRSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
++#define GPIO_DIRSET_PIN2_Msk (0x1UL << GPIO_DIRSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
++#define GPIO_DIRSET_PIN2_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN2_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN2_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 1 : Set as output pin 1 */
++#define GPIO_DIRSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
++#define GPIO_DIRSET_PIN1_Msk (0x1UL << GPIO_DIRSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
++#define GPIO_DIRSET_PIN1_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN1_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN1_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Bit 0 : Set as output pin 0 */
++#define GPIO_DIRSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
++#define GPIO_DIRSET_PIN0_Msk (0x1UL << GPIO_DIRSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
++#define GPIO_DIRSET_PIN0_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRSET_PIN0_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRSET_PIN0_Set (1UL) /*!< Write: a '1' sets pin to output; a '0' has no effect */
++
++/* Register: GPIO_DIRCLR */
++/* Description: DIR clear register */
++
++/* Bit 31 : Set as input pin 31 */
++#define GPIO_DIRCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
++#define GPIO_DIRCLR_PIN31_Msk (0x1UL << GPIO_DIRCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
++#define GPIO_DIRCLR_PIN31_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN31_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN31_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 30 : Set as input pin 30 */
++#define GPIO_DIRCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
++#define GPIO_DIRCLR_PIN30_Msk (0x1UL << GPIO_DIRCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
++#define GPIO_DIRCLR_PIN30_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN30_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN30_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 29 : Set as input pin 29 */
++#define GPIO_DIRCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
++#define GPIO_DIRCLR_PIN29_Msk (0x1UL << GPIO_DIRCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
++#define GPIO_DIRCLR_PIN29_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN29_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN29_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 28 : Set as input pin 28 */
++#define GPIO_DIRCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
++#define GPIO_DIRCLR_PIN28_Msk (0x1UL << GPIO_DIRCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
++#define GPIO_DIRCLR_PIN28_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN28_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN28_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 27 : Set as input pin 27 */
++#define GPIO_DIRCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
++#define GPIO_DIRCLR_PIN27_Msk (0x1UL << GPIO_DIRCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
++#define GPIO_DIRCLR_PIN27_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN27_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN27_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 26 : Set as input pin 26 */
++#define GPIO_DIRCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
++#define GPIO_DIRCLR_PIN26_Msk (0x1UL << GPIO_DIRCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
++#define GPIO_DIRCLR_PIN26_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN26_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN26_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 25 : Set as input pin 25 */
++#define GPIO_DIRCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
++#define GPIO_DIRCLR_PIN25_Msk (0x1UL << GPIO_DIRCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
++#define GPIO_DIRCLR_PIN25_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN25_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN25_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 24 : Set as input pin 24 */
++#define GPIO_DIRCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
++#define GPIO_DIRCLR_PIN24_Msk (0x1UL << GPIO_DIRCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
++#define GPIO_DIRCLR_PIN24_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN24_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN24_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 23 : Set as input pin 23 */
++#define GPIO_DIRCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
++#define GPIO_DIRCLR_PIN23_Msk (0x1UL << GPIO_DIRCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
++#define GPIO_DIRCLR_PIN23_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN23_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN23_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 22 : Set as input pin 22 */
++#define GPIO_DIRCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
++#define GPIO_DIRCLR_PIN22_Msk (0x1UL << GPIO_DIRCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
++#define GPIO_DIRCLR_PIN22_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN22_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN22_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 21 : Set as input pin 21 */
++#define GPIO_DIRCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
++#define GPIO_DIRCLR_PIN21_Msk (0x1UL << GPIO_DIRCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
++#define GPIO_DIRCLR_PIN21_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN21_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN21_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 20 : Set as input pin 20 */
++#define GPIO_DIRCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
++#define GPIO_DIRCLR_PIN20_Msk (0x1UL << GPIO_DIRCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
++#define GPIO_DIRCLR_PIN20_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN20_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN20_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 19 : Set as input pin 19 */
++#define GPIO_DIRCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
++#define GPIO_DIRCLR_PIN19_Msk (0x1UL << GPIO_DIRCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
++#define GPIO_DIRCLR_PIN19_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN19_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN19_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 18 : Set as input pin 18 */
++#define GPIO_DIRCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
++#define GPIO_DIRCLR_PIN18_Msk (0x1UL << GPIO_DIRCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
++#define GPIO_DIRCLR_PIN18_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN18_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN18_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 17 : Set as input pin 17 */
++#define GPIO_DIRCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
++#define GPIO_DIRCLR_PIN17_Msk (0x1UL << GPIO_DIRCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
++#define GPIO_DIRCLR_PIN17_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN17_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN17_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 16 : Set as input pin 16 */
++#define GPIO_DIRCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
++#define GPIO_DIRCLR_PIN16_Msk (0x1UL << GPIO_DIRCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
++#define GPIO_DIRCLR_PIN16_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN16_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN16_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 15 : Set as input pin 15 */
++#define GPIO_DIRCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
++#define GPIO_DIRCLR_PIN15_Msk (0x1UL << GPIO_DIRCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
++#define GPIO_DIRCLR_PIN15_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN15_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN15_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 14 : Set as input pin 14 */
++#define GPIO_DIRCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
++#define GPIO_DIRCLR_PIN14_Msk (0x1UL << GPIO_DIRCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
++#define GPIO_DIRCLR_PIN14_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN14_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN14_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 13 : Set as input pin 13 */
++#define GPIO_DIRCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
++#define GPIO_DIRCLR_PIN13_Msk (0x1UL << GPIO_DIRCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
++#define GPIO_DIRCLR_PIN13_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN13_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN13_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 12 : Set as input pin 12 */
++#define GPIO_DIRCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
++#define GPIO_DIRCLR_PIN12_Msk (0x1UL << GPIO_DIRCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
++#define GPIO_DIRCLR_PIN12_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN12_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN12_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 11 : Set as input pin 11 */
++#define GPIO_DIRCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
++#define GPIO_DIRCLR_PIN11_Msk (0x1UL << GPIO_DIRCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
++#define GPIO_DIRCLR_PIN11_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN11_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN11_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 10 : Set as input pin 10 */
++#define GPIO_DIRCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
++#define GPIO_DIRCLR_PIN10_Msk (0x1UL << GPIO_DIRCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
++#define GPIO_DIRCLR_PIN10_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN10_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN10_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 9 : Set as input pin 9 */
++#define GPIO_DIRCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
++#define GPIO_DIRCLR_PIN9_Msk (0x1UL << GPIO_DIRCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
++#define GPIO_DIRCLR_PIN9_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN9_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN9_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 8 : Set as input pin 8 */
++#define GPIO_DIRCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
++#define GPIO_DIRCLR_PIN8_Msk (0x1UL << GPIO_DIRCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
++#define GPIO_DIRCLR_PIN8_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN8_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN8_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 7 : Set as input pin 7 */
++#define GPIO_DIRCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
++#define GPIO_DIRCLR_PIN7_Msk (0x1UL << GPIO_DIRCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
++#define GPIO_DIRCLR_PIN7_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN7_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN7_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 6 : Set as input pin 6 */
++#define GPIO_DIRCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
++#define GPIO_DIRCLR_PIN6_Msk (0x1UL << GPIO_DIRCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
++#define GPIO_DIRCLR_PIN6_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN6_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN6_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 5 : Set as input pin 5 */
++#define GPIO_DIRCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
++#define GPIO_DIRCLR_PIN5_Msk (0x1UL << GPIO_DIRCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
++#define GPIO_DIRCLR_PIN5_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN5_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN5_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 4 : Set as input pin 4 */
++#define GPIO_DIRCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
++#define GPIO_DIRCLR_PIN4_Msk (0x1UL << GPIO_DIRCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
++#define GPIO_DIRCLR_PIN4_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN4_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN4_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 3 : Set as input pin 3 */
++#define GPIO_DIRCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
++#define GPIO_DIRCLR_PIN3_Msk (0x1UL << GPIO_DIRCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
++#define GPIO_DIRCLR_PIN3_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN3_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN3_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 2 : Set as input pin 2 */
++#define GPIO_DIRCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
++#define GPIO_DIRCLR_PIN2_Msk (0x1UL << GPIO_DIRCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
++#define GPIO_DIRCLR_PIN2_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN2_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN2_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 1 : Set as input pin 1 */
++#define GPIO_DIRCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
++#define GPIO_DIRCLR_PIN1_Msk (0x1UL << GPIO_DIRCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
++#define GPIO_DIRCLR_PIN1_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN1_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN1_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Bit 0 : Set as input pin 0 */
++#define GPIO_DIRCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
++#define GPIO_DIRCLR_PIN0_Msk (0x1UL << GPIO_DIRCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
++#define GPIO_DIRCLR_PIN0_Input (0UL) /*!< Read: pin set as input */
++#define GPIO_DIRCLR_PIN0_Output (1UL) /*!< Read: pin set as output */
++#define GPIO_DIRCLR_PIN0_Clear (1UL) /*!< Write: a '1' sets pin to input; a '0' has no effect */
++
++/* Register: GPIO_LATCH */
++/* Description: Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF[n].SENSE registers */
++
++/* Bit 31 : Status on whether PIN31 has met criteria set in PIN_CNF31.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
++#define GPIO_LATCH_PIN31_Msk (0x1UL << GPIO_LATCH_PIN31_Pos) /*!< Bit mask of PIN31 field. */
++#define GPIO_LATCH_PIN31_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN31_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 30 : Status on whether PIN30 has met criteria set in PIN_CNF30.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
++#define GPIO_LATCH_PIN30_Msk (0x1UL << GPIO_LATCH_PIN30_Pos) /*!< Bit mask of PIN30 field. */
++#define GPIO_LATCH_PIN30_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN30_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 29 : Status on whether PIN29 has met criteria set in PIN_CNF29.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
++#define GPIO_LATCH_PIN29_Msk (0x1UL << GPIO_LATCH_PIN29_Pos) /*!< Bit mask of PIN29 field. */
++#define GPIO_LATCH_PIN29_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN29_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 28 : Status on whether PIN28 has met criteria set in PIN_CNF28.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
++#define GPIO_LATCH_PIN28_Msk (0x1UL << GPIO_LATCH_PIN28_Pos) /*!< Bit mask of PIN28 field. */
++#define GPIO_LATCH_PIN28_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN28_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 27 : Status on whether PIN27 has met criteria set in PIN_CNF27.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
++#define GPIO_LATCH_PIN27_Msk (0x1UL << GPIO_LATCH_PIN27_Pos) /*!< Bit mask of PIN27 field. */
++#define GPIO_LATCH_PIN27_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN27_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 26 : Status on whether PIN26 has met criteria set in PIN_CNF26.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
++#define GPIO_LATCH_PIN26_Msk (0x1UL << GPIO_LATCH_PIN26_Pos) /*!< Bit mask of PIN26 field. */
++#define GPIO_LATCH_PIN26_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN26_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 25 : Status on whether PIN25 has met criteria set in PIN_CNF25.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
++#define GPIO_LATCH_PIN25_Msk (0x1UL << GPIO_LATCH_PIN25_Pos) /*!< Bit mask of PIN25 field. */
++#define GPIO_LATCH_PIN25_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN25_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 24 : Status on whether PIN24 has met criteria set in PIN_CNF24.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
++#define GPIO_LATCH_PIN24_Msk (0x1UL << GPIO_LATCH_PIN24_Pos) /*!< Bit mask of PIN24 field. */
++#define GPIO_LATCH_PIN24_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN24_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 23 : Status on whether PIN23 has met criteria set in PIN_CNF23.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
++#define GPIO_LATCH_PIN23_Msk (0x1UL << GPIO_LATCH_PIN23_Pos) /*!< Bit mask of PIN23 field. */
++#define GPIO_LATCH_PIN23_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN23_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 22 : Status on whether PIN22 has met criteria set in PIN_CNF22.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
++#define GPIO_LATCH_PIN22_Msk (0x1UL << GPIO_LATCH_PIN22_Pos) /*!< Bit mask of PIN22 field. */
++#define GPIO_LATCH_PIN22_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN22_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 21 : Status on whether PIN21 has met criteria set in PIN_CNF21.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
++#define GPIO_LATCH_PIN21_Msk (0x1UL << GPIO_LATCH_PIN21_Pos) /*!< Bit mask of PIN21 field. */
++#define GPIO_LATCH_PIN21_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN21_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 20 : Status on whether PIN20 has met criteria set in PIN_CNF20.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
++#define GPIO_LATCH_PIN20_Msk (0x1UL << GPIO_LATCH_PIN20_Pos) /*!< Bit mask of PIN20 field. */
++#define GPIO_LATCH_PIN20_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN20_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 19 : Status on whether PIN19 has met criteria set in PIN_CNF19.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
++#define GPIO_LATCH_PIN19_Msk (0x1UL << GPIO_LATCH_PIN19_Pos) /*!< Bit mask of PIN19 field. */
++#define GPIO_LATCH_PIN19_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN19_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 18 : Status on whether PIN18 has met criteria set in PIN_CNF18.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
++#define GPIO_LATCH_PIN18_Msk (0x1UL << GPIO_LATCH_PIN18_Pos) /*!< Bit mask of PIN18 field. */
++#define GPIO_LATCH_PIN18_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN18_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 17 : Status on whether PIN17 has met criteria set in PIN_CNF17.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
++#define GPIO_LATCH_PIN17_Msk (0x1UL << GPIO_LATCH_PIN17_Pos) /*!< Bit mask of PIN17 field. */
++#define GPIO_LATCH_PIN17_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN17_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 16 : Status on whether PIN16 has met criteria set in PIN_CNF16.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
++#define GPIO_LATCH_PIN16_Msk (0x1UL << GPIO_LATCH_PIN16_Pos) /*!< Bit mask of PIN16 field. */
++#define GPIO_LATCH_PIN16_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN16_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 15 : Status on whether PIN15 has met criteria set in PIN_CNF15.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
++#define GPIO_LATCH_PIN15_Msk (0x1UL << GPIO_LATCH_PIN15_Pos) /*!< Bit mask of PIN15 field. */
++#define GPIO_LATCH_PIN15_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN15_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 14 : Status on whether PIN14 has met criteria set in PIN_CNF14.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
++#define GPIO_LATCH_PIN14_Msk (0x1UL << GPIO_LATCH_PIN14_Pos) /*!< Bit mask of PIN14 field. */
++#define GPIO_LATCH_PIN14_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN14_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 13 : Status on whether PIN13 has met criteria set in PIN_CNF13.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
++#define GPIO_LATCH_PIN13_Msk (0x1UL << GPIO_LATCH_PIN13_Pos) /*!< Bit mask of PIN13 field. */
++#define GPIO_LATCH_PIN13_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN13_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 12 : Status on whether PIN12 has met criteria set in PIN_CNF12.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
++#define GPIO_LATCH_PIN12_Msk (0x1UL << GPIO_LATCH_PIN12_Pos) /*!< Bit mask of PIN12 field. */
++#define GPIO_LATCH_PIN12_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN12_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 11 : Status on whether PIN11 has met criteria set in PIN_CNF11.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
++#define GPIO_LATCH_PIN11_Msk (0x1UL << GPIO_LATCH_PIN11_Pos) /*!< Bit mask of PIN11 field. */
++#define GPIO_LATCH_PIN11_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN11_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 10 : Status on whether PIN10 has met criteria set in PIN_CNF10.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
++#define GPIO_LATCH_PIN10_Msk (0x1UL << GPIO_LATCH_PIN10_Pos) /*!< Bit mask of PIN10 field. */
++#define GPIO_LATCH_PIN10_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN10_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 9 : Status on whether PIN9 has met criteria set in PIN_CNF9.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
++#define GPIO_LATCH_PIN9_Msk (0x1UL << GPIO_LATCH_PIN9_Pos) /*!< Bit mask of PIN9 field. */
++#define GPIO_LATCH_PIN9_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN9_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 8 : Status on whether PIN8 has met criteria set in PIN_CNF8.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
++#define GPIO_LATCH_PIN8_Msk (0x1UL << GPIO_LATCH_PIN8_Pos) /*!< Bit mask of PIN8 field. */
++#define GPIO_LATCH_PIN8_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN8_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 7 : Status on whether PIN7 has met criteria set in PIN_CNF7.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
++#define GPIO_LATCH_PIN7_Msk (0x1UL << GPIO_LATCH_PIN7_Pos) /*!< Bit mask of PIN7 field. */
++#define GPIO_LATCH_PIN7_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN7_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 6 : Status on whether PIN6 has met criteria set in PIN_CNF6.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
++#define GPIO_LATCH_PIN6_Msk (0x1UL << GPIO_LATCH_PIN6_Pos) /*!< Bit mask of PIN6 field. */
++#define GPIO_LATCH_PIN6_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN6_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 5 : Status on whether PIN5 has met criteria set in PIN_CNF5.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
++#define GPIO_LATCH_PIN5_Msk (0x1UL << GPIO_LATCH_PIN5_Pos) /*!< Bit mask of PIN5 field. */
++#define GPIO_LATCH_PIN5_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN5_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 4 : Status on whether PIN4 has met criteria set in PIN_CNF4.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
++#define GPIO_LATCH_PIN4_Msk (0x1UL << GPIO_LATCH_PIN4_Pos) /*!< Bit mask of PIN4 field. */
++#define GPIO_LATCH_PIN4_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN4_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 3 : Status on whether PIN3 has met criteria set in PIN_CNF3.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
++#define GPIO_LATCH_PIN3_Msk (0x1UL << GPIO_LATCH_PIN3_Pos) /*!< Bit mask of PIN3 field. */
++#define GPIO_LATCH_PIN3_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN3_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 2 : Status on whether PIN2 has met criteria set in PIN_CNF2.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
++#define GPIO_LATCH_PIN2_Msk (0x1UL << GPIO_LATCH_PIN2_Pos) /*!< Bit mask of PIN2 field. */
++#define GPIO_LATCH_PIN2_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN2_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 1 : Status on whether PIN1 has met criteria set in PIN_CNF1.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
++#define GPIO_LATCH_PIN1_Msk (0x1UL << GPIO_LATCH_PIN1_Pos) /*!< Bit mask of PIN1 field. */
++#define GPIO_LATCH_PIN1_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN1_Latched (1UL) /*!< Criteria has been met */
++
++/* Bit 0 : Status on whether PIN0 has met criteria set in PIN_CNF0.SENSE register. Write '1' to clear. */
++#define GPIO_LATCH_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
++#define GPIO_LATCH_PIN0_Msk (0x1UL << GPIO_LATCH_PIN0_Pos) /*!< Bit mask of PIN0 field. */
++#define GPIO_LATCH_PIN0_NotLatched (0UL) /*!< Criteria has not been met */
++#define GPIO_LATCH_PIN0_Latched (1UL) /*!< Criteria has been met */
++
++/* Register: GPIO_DETECTMODE */
++/* Description: Select between default DETECT signal behavior and LDETECT mode */
++
++/* Bit 0 : Select between default DETECT signal behavior and LDETECT mode */
++#define GPIO_DETECTMODE_DETECTMODE_Pos (0UL) /*!< Position of DETECTMODE field. */
++#define GPIO_DETECTMODE_DETECTMODE_Msk (0x1UL << GPIO_DETECTMODE_DETECTMODE_Pos) /*!< Bit mask of DETECTMODE field. */
++#define GPIO_DETECTMODE_DETECTMODE_Default (0UL) /*!< DETECT directly connected to PIN DETECT signals */
++#define GPIO_DETECTMODE_DETECTMODE_LDETECT (1UL) /*!< Use the latched LDETECT behavior */
++
++/* Register: GPIO_PIN_CNF */
++/* Description: Description collection: Configuration of GPIO pins */
++
++/* Bits 17..16 : Pin sensing mechanism */
++#define GPIO_PIN_CNF_SENSE_Pos (16UL) /*!< Position of SENSE field. */
++#define GPIO_PIN_CNF_SENSE_Msk (0x3UL << GPIO_PIN_CNF_SENSE_Pos) /*!< Bit mask of SENSE field. */
++#define GPIO_PIN_CNF_SENSE_Disabled (0UL) /*!< Disabled */
++#define GPIO_PIN_CNF_SENSE_High (2UL) /*!< Sense for high level */
++#define GPIO_PIN_CNF_SENSE_Low (3UL) /*!< Sense for low level */
++
++/* Bits 10..8 : Drive configuration */
++#define GPIO_PIN_CNF_DRIVE_Pos (8UL) /*!< Position of DRIVE field. */
++#define GPIO_PIN_CNF_DRIVE_Msk (0x7UL << GPIO_PIN_CNF_DRIVE_Pos) /*!< Bit mask of DRIVE field. */
++#define GPIO_PIN_CNF_DRIVE_S0S1 (0UL) /*!< Standard '0', standard '1' */
++#define GPIO_PIN_CNF_DRIVE_H0S1 (1UL) /*!< High drive '0', standard '1' */
++#define GPIO_PIN_CNF_DRIVE_S0H1 (2UL) /*!< Standard '0', high drive '1' */
++#define GPIO_PIN_CNF_DRIVE_H0H1 (3UL) /*!< High drive '0', high 'drive '1'' */
++#define GPIO_PIN_CNF_DRIVE_D0S1 (4UL) /*!< Disconnect '0' standard '1' (normally used for wired-or connections) */
++#define GPIO_PIN_CNF_DRIVE_D0H1 (5UL) /*!< Disconnect '0', high drive '1' (normally used for wired-or connections) */
++#define GPIO_PIN_CNF_DRIVE_S0D1 (6UL) /*!< Standard '0'. disconnect '1' (normally used for wired-and connections) */
++#define GPIO_PIN_CNF_DRIVE_H0D1 (7UL) /*!< High drive '0', disconnect '1' (normally used for wired-and connections) */
++
++/* Bits 3..2 : Pull configuration */
++#define GPIO_PIN_CNF_PULL_Pos (2UL) /*!< Position of PULL field. */
++#define GPIO_PIN_CNF_PULL_Msk (0x3UL << GPIO_PIN_CNF_PULL_Pos) /*!< Bit mask of PULL field. */
++#define GPIO_PIN_CNF_PULL_Disabled (0UL) /*!< No pull */
++#define GPIO_PIN_CNF_PULL_Pulldown (1UL) /*!< Pull down on pin */
++#define GPIO_PIN_CNF_PULL_Pullup (3UL) /*!< Pull up on pin */
++
++/* Bit 1 : Connect or disconnect input buffer */
++#define GPIO_PIN_CNF_INPUT_Pos (1UL) /*!< Position of INPUT field. */
++#define GPIO_PIN_CNF_INPUT_Msk (0x1UL << GPIO_PIN_CNF_INPUT_Pos) /*!< Bit mask of INPUT field. */
++#define GPIO_PIN_CNF_INPUT_Connect (0UL) /*!< Connect input buffer */
++#define GPIO_PIN_CNF_INPUT_Disconnect (1UL) /*!< Disconnect input buffer */
++
++/* Bit 0 : Pin direction. Same physical register as DIR register */
++#define GPIO_PIN_CNF_DIR_Pos (0UL) /*!< Position of DIR field. */
++#define GPIO_PIN_CNF_DIR_Msk (0x1UL << GPIO_PIN_CNF_DIR_Pos) /*!< Bit mask of DIR field. */
++#define GPIO_PIN_CNF_DIR_Input (0UL) /*!< Configure pin as an input pin */
++#define GPIO_PIN_CNF_DIR_Output (1UL) /*!< Configure pin as an output pin */
++
++
++/* Peripheral: PDM */
++/* Description: Pulse Density Modulation (Digital Microphone) Interface */
++
++/* Register: PDM_TASKS_START */
++/* Description: Starts continuous PDM transfer */
++
++/* Bit 0 : Starts continuous PDM transfer */
++#define PDM_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define PDM_TASKS_START_TASKS_START_Msk (0x1UL << PDM_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define PDM_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: PDM_TASKS_STOP */
++/* Description: Stops PDM transfer */
++
++/* Bit 0 : Stops PDM transfer */
++#define PDM_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define PDM_TASKS_STOP_TASKS_STOP_Msk (0x1UL << PDM_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define PDM_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: PDM_EVENTS_STARTED */
++/* Description: PDM transfer has started */
++
++/* Bit 0 : PDM transfer has started */
++#define PDM_EVENTS_STARTED_EVENTS_STARTED_Pos (0UL) /*!< Position of EVENTS_STARTED field. */
++#define PDM_EVENTS_STARTED_EVENTS_STARTED_Msk (0x1UL << PDM_EVENTS_STARTED_EVENTS_STARTED_Pos) /*!< Bit mask of EVENTS_STARTED field. */
++#define PDM_EVENTS_STARTED_EVENTS_STARTED_NotGenerated (0UL) /*!< Event not generated */
++#define PDM_EVENTS_STARTED_EVENTS_STARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: PDM_EVENTS_STOPPED */
++/* Description: PDM transfer has finished */
++
++/* Bit 0 : PDM transfer has finished */
++#define PDM_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define PDM_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << PDM_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define PDM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define PDM_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: PDM_EVENTS_END */
++/* Description: The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM */
++
++/* Bit 0 : The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM */
++#define PDM_EVENTS_END_EVENTS_END_Pos (0UL) /*!< Position of EVENTS_END field. */
++#define PDM_EVENTS_END_EVENTS_END_Msk (0x1UL << PDM_EVENTS_END_EVENTS_END_Pos) /*!< Bit mask of EVENTS_END field. */
++#define PDM_EVENTS_END_EVENTS_END_NotGenerated (0UL) /*!< Event not generated */
++#define PDM_EVENTS_END_EVENTS_END_Generated (1UL) /*!< Event generated */
++
++/* Register: PDM_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 2 : Enable or disable interrupt for event END */
++#define PDM_INTEN_END_Pos (2UL) /*!< Position of END field. */
++#define PDM_INTEN_END_Msk (0x1UL << PDM_INTEN_END_Pos) /*!< Bit mask of END field. */
++#define PDM_INTEN_END_Disabled (0UL) /*!< Disable */
++#define PDM_INTEN_END_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event STOPPED */
++#define PDM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define PDM_INTEN_STOPPED_Msk (0x1UL << PDM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define PDM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
++#define PDM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event STARTED */
++#define PDM_INTEN_STARTED_Pos (0UL) /*!< Position of STARTED field. */
++#define PDM_INTEN_STARTED_Msk (0x1UL << PDM_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define PDM_INTEN_STARTED_Disabled (0UL) /*!< Disable */
++#define PDM_INTEN_STARTED_Enabled (1UL) /*!< Enable */
++
++/* Register: PDM_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 2 : Write '1' to enable interrupt for event END */
++#define PDM_INTENSET_END_Pos (2UL) /*!< Position of END field. */
++#define PDM_INTENSET_END_Msk (0x1UL << PDM_INTENSET_END_Pos) /*!< Bit mask of END field. */
++#define PDM_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
++#define PDM_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
++#define PDM_INTENSET_END_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event STOPPED */
++#define PDM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define PDM_INTENSET_STOPPED_Msk (0x1UL << PDM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define PDM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define PDM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define PDM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event STARTED */
++#define PDM_INTENSET_STARTED_Pos (0UL) /*!< Position of STARTED field. */
++#define PDM_INTENSET_STARTED_Msk (0x1UL << PDM_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define PDM_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define PDM_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define PDM_INTENSET_STARTED_Set (1UL) /*!< Enable */
++
++/* Register: PDM_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 2 : Write '1' to disable interrupt for event END */
++#define PDM_INTENCLR_END_Pos (2UL) /*!< Position of END field. */
++#define PDM_INTENCLR_END_Msk (0x1UL << PDM_INTENCLR_END_Pos) /*!< Bit mask of END field. */
++#define PDM_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
++#define PDM_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
++#define PDM_INTENCLR_END_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event STOPPED */
++#define PDM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define PDM_INTENCLR_STOPPED_Msk (0x1UL << PDM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define PDM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define PDM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define PDM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event STARTED */
++#define PDM_INTENCLR_STARTED_Pos (0UL) /*!< Position of STARTED field. */
++#define PDM_INTENCLR_STARTED_Msk (0x1UL << PDM_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define PDM_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define PDM_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define PDM_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
++
++/* Register: PDM_ENABLE */
++/* Description: PDM module enable register */
++
++/* Bit 0 : Enable or disable PDM module */
++#define PDM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define PDM_ENABLE_ENABLE_Msk (0x1UL << PDM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define PDM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
++#define PDM_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
++
++/* Register: PDM_PDMCLKCTRL */
++/* Description: PDM clock generator control */
++
++/* Bits 31..0 : PDM_CLK frequency configuration */
++#define PDM_PDMCLKCTRL_FREQ_Pos (0UL) /*!< Position of FREQ field. */
++#define PDM_PDMCLKCTRL_FREQ_Msk (0xFFFFFFFFUL << PDM_PDMCLKCTRL_FREQ_Pos) /*!< Bit mask of FREQ field. */
++#define PDM_PDMCLKCTRL_FREQ_1000K (0x08000000UL) /*!< PDM_CLK = 32 MHz / 32 = 1.000 MHz */
++#define PDM_PDMCLKCTRL_FREQ_Default (0x08400000UL) /*!< PDM_CLK = 32 MHz / 31 = 1.032 MHz. Nominal clock for RATIO=Ratio64. */
++#define PDM_PDMCLKCTRL_FREQ_1067K (0x08800000UL) /*!< PDM_CLK = 32 MHz / 30 = 1.067 MHz */
++#define PDM_PDMCLKCTRL_FREQ_1231K (0x09800000UL) /*!< PDM_CLK = 32 MHz / 26 = 1.231 MHz */
++#define PDM_PDMCLKCTRL_FREQ_1280K (0x0A000000UL) /*!< PDM_CLK = 32 MHz / 25 = 1.280 MHz. Nominal clock for RATIO=Ratio80. */
++#define PDM_PDMCLKCTRL_FREQ_1333K (0x0A800000UL) /*!< PDM_CLK = 32 MHz / 24 = 1.333 MHz */
++
++/* Register: PDM_MODE */
++/* Description: Defines the routing of the connected PDM microphones' signals */
++
++/* Bit 1 : Defines on which PDM_CLK edge left (or mono) is sampled */
++#define PDM_MODE_EDGE_Pos (1UL) /*!< Position of EDGE field. */
++#define PDM_MODE_EDGE_Msk (0x1UL << PDM_MODE_EDGE_Pos) /*!< Bit mask of EDGE field. */
++#define PDM_MODE_EDGE_LeftFalling (0UL) /*!< Left (or mono) is sampled on falling edge of PDM_CLK */
++#define PDM_MODE_EDGE_LeftRising (1UL) /*!< Left (or mono) is sampled on rising edge of PDM_CLK */
++
++/* Bit 0 : Mono or stereo operation */
++#define PDM_MODE_OPERATION_Pos (0UL) /*!< Position of OPERATION field. */
++#define PDM_MODE_OPERATION_Msk (0x1UL << PDM_MODE_OPERATION_Pos) /*!< Bit mask of OPERATION field. */
++#define PDM_MODE_OPERATION_Stereo (0UL) /*!< Sample and store one pair (left + right) of 16-bit samples per RAM word R=[31:16]; L=[15:0] */
++#define PDM_MODE_OPERATION_Mono (1UL) /*!< Sample and store two successive left samples (16 bits each) per RAM word L1=[31:16]; L0=[15:0] */
++
++/* Register: PDM_GAINL */
++/* Description: Left output gain adjustment */
++
++/* Bits 6..0 : Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00    -20 dB gain adjust 0x01  -19.5 dB gain adjust (...) 0x27   -0.5 dB gain adjust 0x28      0 dB gain adjust 0x29   +0.5 dB gain adjust (...) 0x4F  +19.5 dB gain adjust 0x50    +20 dB gain adjust */
++#define PDM_GAINL_GAINL_Pos (0UL) /*!< Position of GAINL field. */
++#define PDM_GAINL_GAINL_Msk (0x7FUL << PDM_GAINL_GAINL_Pos) /*!< Bit mask of GAINL field. */
++#define PDM_GAINL_GAINL_MinGain (0x00UL) /*!< -20 dB gain adjustment (minimum) */
++#define PDM_GAINL_GAINL_DefaultGain (0x28UL) /*!< 0 dB gain adjustment */
++#define PDM_GAINL_GAINL_MaxGain (0x50UL) /*!< +20 dB gain adjustment (maximum) */
++
++/* Register: PDM_GAINR */
++/* Description: Right output gain adjustment */
++
++/* Bits 6..0 : Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) */
++#define PDM_GAINR_GAINR_Pos (0UL) /*!< Position of GAINR field. */
++#define PDM_GAINR_GAINR_Msk (0x7FUL << PDM_GAINR_GAINR_Pos) /*!< Bit mask of GAINR field. */
++#define PDM_GAINR_GAINR_MinGain (0x00UL) /*!< -20 dB gain adjustment (minimum) */
++#define PDM_GAINR_GAINR_DefaultGain (0x28UL) /*!< 0 dB gain adjustment */
++#define PDM_GAINR_GAINR_MaxGain (0x50UL) /*!< +20 dB gain adjustment (maximum) */
++
++/* Register: PDM_RATIO */
++/* Description: Selects the ratio between PDM_CLK and output sample rate. Change PDMCLKCTRL accordingly. */
++
++/* Bit 0 : Selects the ratio between PDM_CLK and output sample rate */
++#define PDM_RATIO_RATIO_Pos (0UL) /*!< Position of RATIO field. */
++#define PDM_RATIO_RATIO_Msk (0x1UL << PDM_RATIO_RATIO_Pos) /*!< Bit mask of RATIO field. */
++#define PDM_RATIO_RATIO_Ratio64 (0UL) /*!< Ratio of 64 */
++#define PDM_RATIO_RATIO_Ratio80 (1UL) /*!< Ratio of 80 */
++
++/* Register: PDM_PSEL_CLK */
++/* Description: Pin number configuration for PDM CLK signal */
++
++/* Bit 31 : Connection */
++#define PDM_PSEL_CLK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define PDM_PSEL_CLK_CONNECT_Msk (0x1UL << PDM_PSEL_CLK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define PDM_PSEL_CLK_CONNECT_Connected (0UL) /*!< Connect */
++#define PDM_PSEL_CLK_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define PDM_PSEL_CLK_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define PDM_PSEL_CLK_PORT_Msk (0x1UL << PDM_PSEL_CLK_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define PDM_PSEL_CLK_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define PDM_PSEL_CLK_PIN_Msk (0x1FUL << PDM_PSEL_CLK_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: PDM_PSEL_DIN */
++/* Description: Pin number configuration for PDM DIN signal */
++
++/* Bit 31 : Connection */
++#define PDM_PSEL_DIN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define PDM_PSEL_DIN_CONNECT_Msk (0x1UL << PDM_PSEL_DIN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define PDM_PSEL_DIN_CONNECT_Connected (0UL) /*!< Connect */
++#define PDM_PSEL_DIN_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define PDM_PSEL_DIN_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define PDM_PSEL_DIN_PORT_Msk (0x1UL << PDM_PSEL_DIN_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define PDM_PSEL_DIN_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define PDM_PSEL_DIN_PIN_Msk (0x1FUL << PDM_PSEL_DIN_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: PDM_SAMPLE_PTR */
++/* Description: RAM address pointer to write samples to with EasyDMA */
++
++/* Bits 31..0 : Address to write PDM samples to over DMA */
++#define PDM_SAMPLE_PTR_SAMPLEPTR_Pos (0UL) /*!< Position of SAMPLEPTR field. */
++#define PDM_SAMPLE_PTR_SAMPLEPTR_Msk (0xFFFFFFFFUL << PDM_SAMPLE_PTR_SAMPLEPTR_Pos) /*!< Bit mask of SAMPLEPTR field. */
++
++/* Register: PDM_SAMPLE_MAXCNT */
++/* Description: Number of samples to allocate memory for in EasyDMA mode */
++
++/* Bits 14..0 : Length of DMA RAM allocation in number of samples */
++#define PDM_SAMPLE_MAXCNT_BUFFSIZE_Pos (0UL) /*!< Position of BUFFSIZE field. */
++#define PDM_SAMPLE_MAXCNT_BUFFSIZE_Msk (0x7FFFUL << PDM_SAMPLE_MAXCNT_BUFFSIZE_Pos) /*!< Bit mask of BUFFSIZE field. */
++
++
++/* Peripheral: POWER */
++/* Description: Power control */
++
++/* Register: POWER_TASKS_CONSTLAT */
++/* Description: Enable Constant Latency mode */
++
++/* Bit 0 : Enable Constant Latency mode */
++#define POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Pos (0UL) /*!< Position of TASKS_CONSTLAT field. */
++#define POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Msk (0x1UL << POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Pos) /*!< Bit mask of TASKS_CONSTLAT field. */
++#define POWER_TASKS_CONSTLAT_TASKS_CONSTLAT_Trigger (1UL) /*!< Trigger task */
++
++/* Register: POWER_TASKS_LOWPWR */
++/* Description: Enable Low-power mode (variable latency) */
++
++/* Bit 0 : Enable Low-power mode (variable latency) */
++#define POWER_TASKS_LOWPWR_TASKS_LOWPWR_Pos (0UL) /*!< Position of TASKS_LOWPWR field. */
++#define POWER_TASKS_LOWPWR_TASKS_LOWPWR_Msk (0x1UL << POWER_TASKS_LOWPWR_TASKS_LOWPWR_Pos) /*!< Bit mask of TASKS_LOWPWR field. */
++#define POWER_TASKS_LOWPWR_TASKS_LOWPWR_Trigger (1UL) /*!< Trigger task */
++
++/* Register: POWER_EVENTS_POFWARN */
++/* Description: Power failure warning */
++
++/* Bit 0 : Power failure warning */
++#define POWER_EVENTS_POFWARN_EVENTS_POFWARN_Pos (0UL) /*!< Position of EVENTS_POFWARN field. */
++#define POWER_EVENTS_POFWARN_EVENTS_POFWARN_Msk (0x1UL << POWER_EVENTS_POFWARN_EVENTS_POFWARN_Pos) /*!< Bit mask of EVENTS_POFWARN field. */
++#define POWER_EVENTS_POFWARN_EVENTS_POFWARN_NotGenerated (0UL) /*!< Event not generated */
++#define POWER_EVENTS_POFWARN_EVENTS_POFWARN_Generated (1UL) /*!< Event generated */
++
++/* Register: POWER_EVENTS_SLEEPENTER */
++/* Description: CPU entered WFI/WFE sleep */
++
++/* Bit 0 : CPU entered WFI/WFE sleep */
++#define POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Pos (0UL) /*!< Position of EVENTS_SLEEPENTER field. */
++#define POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Msk (0x1UL << POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Pos) /*!< Bit mask of EVENTS_SLEEPENTER field. */
++#define POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_NotGenerated (0UL) /*!< Event not generated */
++#define POWER_EVENTS_SLEEPENTER_EVENTS_SLEEPENTER_Generated (1UL) /*!< Event generated */
++
++/* Register: POWER_EVENTS_SLEEPEXIT */
++/* Description: CPU exited WFI/WFE sleep */
++
++/* Bit 0 : CPU exited WFI/WFE sleep */
++#define POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Pos (0UL) /*!< Position of EVENTS_SLEEPEXIT field. */
++#define POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Msk (0x1UL << POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Pos) /*!< Bit mask of EVENTS_SLEEPEXIT field. */
++#define POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_NotGenerated (0UL) /*!< Event not generated */
++#define POWER_EVENTS_SLEEPEXIT_EVENTS_SLEEPEXIT_Generated (1UL) /*!< Event generated */
++
++/* Register: POWER_EVENTS_USBDETECTED */
++/* Description: Voltage supply detected on VBUS */
++
++/* Bit 0 : Voltage supply detected on VBUS */
++#define POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Pos (0UL) /*!< Position of EVENTS_USBDETECTED field. */
++#define POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Msk (0x1UL << POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Pos) /*!< Bit mask of EVENTS_USBDETECTED field. */
++#define POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_NotGenerated (0UL) /*!< Event not generated */
++#define POWER_EVENTS_USBDETECTED_EVENTS_USBDETECTED_Generated (1UL) /*!< Event generated */
++
++/* Register: POWER_EVENTS_USBREMOVED */
++/* Description: Voltage supply removed from VBUS */
++
++/* Bit 0 : Voltage supply removed from VBUS */
++#define POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Pos (0UL) /*!< Position of EVENTS_USBREMOVED field. */
++#define POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Msk (0x1UL << POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Pos) /*!< Bit mask of EVENTS_USBREMOVED field. */
++#define POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_NotGenerated (0UL) /*!< Event not generated */
++#define POWER_EVENTS_USBREMOVED_EVENTS_USBREMOVED_Generated (1UL) /*!< Event generated */
++
++/* Register: POWER_EVENTS_USBPWRRDY */
++/* Description: USB 3.3 V supply ready */
++
++/* Bit 0 : USB 3.3 V supply ready */
++#define POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Pos (0UL) /*!< Position of EVENTS_USBPWRRDY field. */
++#define POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Msk (0x1UL << POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Pos) /*!< Bit mask of EVENTS_USBPWRRDY field. */
++#define POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_NotGenerated (0UL) /*!< Event not generated */
++#define POWER_EVENTS_USBPWRRDY_EVENTS_USBPWRRDY_Generated (1UL) /*!< Event generated */
++
++/* Register: POWER_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 9 : Write '1' to enable interrupt for event USBPWRRDY */
++#define POWER_INTENSET_USBPWRRDY_Pos (9UL) /*!< Position of USBPWRRDY field. */
++#define POWER_INTENSET_USBPWRRDY_Msk (0x1UL << POWER_INTENSET_USBPWRRDY_Pos) /*!< Bit mask of USBPWRRDY field. */
++#define POWER_INTENSET_USBPWRRDY_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENSET_USBPWRRDY_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENSET_USBPWRRDY_Set (1UL) /*!< Enable */
++
++/* Bit 8 : Write '1' to enable interrupt for event USBREMOVED */
++#define POWER_INTENSET_USBREMOVED_Pos (8UL) /*!< Position of USBREMOVED field. */
++#define POWER_INTENSET_USBREMOVED_Msk (0x1UL << POWER_INTENSET_USBREMOVED_Pos) /*!< Bit mask of USBREMOVED field. */
++#define POWER_INTENSET_USBREMOVED_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENSET_USBREMOVED_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENSET_USBREMOVED_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event USBDETECTED */
++#define POWER_INTENSET_USBDETECTED_Pos (7UL) /*!< Position of USBDETECTED field. */
++#define POWER_INTENSET_USBDETECTED_Msk (0x1UL << POWER_INTENSET_USBDETECTED_Pos) /*!< Bit mask of USBDETECTED field. */
++#define POWER_INTENSET_USBDETECTED_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENSET_USBDETECTED_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENSET_USBDETECTED_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event SLEEPEXIT */
++#define POWER_INTENSET_SLEEPEXIT_Pos (6UL) /*!< Position of SLEEPEXIT field. */
++#define POWER_INTENSET_SLEEPEXIT_Msk (0x1UL << POWER_INTENSET_SLEEPEXIT_Pos) /*!< Bit mask of SLEEPEXIT field. */
++#define POWER_INTENSET_SLEEPEXIT_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENSET_SLEEPEXIT_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENSET_SLEEPEXIT_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event SLEEPENTER */
++#define POWER_INTENSET_SLEEPENTER_Pos (5UL) /*!< Position of SLEEPENTER field. */
++#define POWER_INTENSET_SLEEPENTER_Msk (0x1UL << POWER_INTENSET_SLEEPENTER_Pos) /*!< Bit mask of SLEEPENTER field. */
++#define POWER_INTENSET_SLEEPENTER_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENSET_SLEEPENTER_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENSET_SLEEPENTER_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event POFWARN */
++#define POWER_INTENSET_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
++#define POWER_INTENSET_POFWARN_Msk (0x1UL << POWER_INTENSET_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
++#define POWER_INTENSET_POFWARN_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENSET_POFWARN_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENSET_POFWARN_Set (1UL) /*!< Enable */
++
++/* Register: POWER_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 9 : Write '1' to disable interrupt for event USBPWRRDY */
++#define POWER_INTENCLR_USBPWRRDY_Pos (9UL) /*!< Position of USBPWRRDY field. */
++#define POWER_INTENCLR_USBPWRRDY_Msk (0x1UL << POWER_INTENCLR_USBPWRRDY_Pos) /*!< Bit mask of USBPWRRDY field. */
++#define POWER_INTENCLR_USBPWRRDY_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENCLR_USBPWRRDY_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENCLR_USBPWRRDY_Clear (1UL) /*!< Disable */
++
++/* Bit 8 : Write '1' to disable interrupt for event USBREMOVED */
++#define POWER_INTENCLR_USBREMOVED_Pos (8UL) /*!< Position of USBREMOVED field. */
++#define POWER_INTENCLR_USBREMOVED_Msk (0x1UL << POWER_INTENCLR_USBREMOVED_Pos) /*!< Bit mask of USBREMOVED field. */
++#define POWER_INTENCLR_USBREMOVED_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENCLR_USBREMOVED_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENCLR_USBREMOVED_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event USBDETECTED */
++#define POWER_INTENCLR_USBDETECTED_Pos (7UL) /*!< Position of USBDETECTED field. */
++#define POWER_INTENCLR_USBDETECTED_Msk (0x1UL << POWER_INTENCLR_USBDETECTED_Pos) /*!< Bit mask of USBDETECTED field. */
++#define POWER_INTENCLR_USBDETECTED_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENCLR_USBDETECTED_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENCLR_USBDETECTED_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event SLEEPEXIT */
++#define POWER_INTENCLR_SLEEPEXIT_Pos (6UL) /*!< Position of SLEEPEXIT field. */
++#define POWER_INTENCLR_SLEEPEXIT_Msk (0x1UL << POWER_INTENCLR_SLEEPEXIT_Pos) /*!< Bit mask of SLEEPEXIT field. */
++#define POWER_INTENCLR_SLEEPEXIT_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENCLR_SLEEPEXIT_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENCLR_SLEEPEXIT_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event SLEEPENTER */
++#define POWER_INTENCLR_SLEEPENTER_Pos (5UL) /*!< Position of SLEEPENTER field. */
++#define POWER_INTENCLR_SLEEPENTER_Msk (0x1UL << POWER_INTENCLR_SLEEPENTER_Pos) /*!< Bit mask of SLEEPENTER field. */
++#define POWER_INTENCLR_SLEEPENTER_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENCLR_SLEEPENTER_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENCLR_SLEEPENTER_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event POFWARN */
++#define POWER_INTENCLR_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
++#define POWER_INTENCLR_POFWARN_Msk (0x1UL << POWER_INTENCLR_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
++#define POWER_INTENCLR_POFWARN_Disabled (0UL) /*!< Read: Disabled */
++#define POWER_INTENCLR_POFWARN_Enabled (1UL) /*!< Read: Enabled */
++#define POWER_INTENCLR_POFWARN_Clear (1UL) /*!< Disable */
++
++/* Register: POWER_RESETREAS */
++/* Description: Reset reason */
++
++/* Bit 20 : Reset due to wake up from System OFF mode by VBUS rising into valid range */
++#define POWER_RESETREAS_VBUS_Pos (20UL) /*!< Position of VBUS field. */
++#define POWER_RESETREAS_VBUS_Msk (0x1UL << POWER_RESETREAS_VBUS_Pos) /*!< Bit mask of VBUS field. */
++#define POWER_RESETREAS_VBUS_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_VBUS_Detected (1UL) /*!< Detected */
++
++/* Bit 19 : Reset due to wake up from System OFF mode by NFC field detect */
++#define POWER_RESETREAS_NFC_Pos (19UL) /*!< Position of NFC field. */
++#define POWER_RESETREAS_NFC_Msk (0x1UL << POWER_RESETREAS_NFC_Pos) /*!< Bit mask of NFC field. */
++#define POWER_RESETREAS_NFC_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_NFC_Detected (1UL) /*!< Detected */
++
++/* Bit 18 : Reset due to wake up from System OFF mode when wakeup is triggered from entering into debug interface mode */
++#define POWER_RESETREAS_DIF_Pos (18UL) /*!< Position of DIF field. */
++#define POWER_RESETREAS_DIF_Msk (0x1UL << POWER_RESETREAS_DIF_Pos) /*!< Bit mask of DIF field. */
++#define POWER_RESETREAS_DIF_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_DIF_Detected (1UL) /*!< Detected */
++
++/* Bit 17 : Reset due to wake up from System OFF mode when wakeup is triggered from ANADETECT signal from LPCOMP */
++#define POWER_RESETREAS_LPCOMP_Pos (17UL) /*!< Position of LPCOMP field. */
++#define POWER_RESETREAS_LPCOMP_Msk (0x1UL << POWER_RESETREAS_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
++#define POWER_RESETREAS_LPCOMP_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_LPCOMP_Detected (1UL) /*!< Detected */
++
++/* Bit 16 : Reset due to wake up from System OFF mode when wakeup is triggered from DETECT signal from GPIO */
++#define POWER_RESETREAS_OFF_Pos (16UL) /*!< Position of OFF field. */
++#define POWER_RESETREAS_OFF_Msk (0x1UL << POWER_RESETREAS_OFF_Pos) /*!< Bit mask of OFF field. */
++#define POWER_RESETREAS_OFF_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_OFF_Detected (1UL) /*!< Detected */
++
++/* Bit 3 : Reset from CPU lock-up detected */
++#define POWER_RESETREAS_LOCKUP_Pos (3UL) /*!< Position of LOCKUP field. */
++#define POWER_RESETREAS_LOCKUP_Msk (0x1UL << POWER_RESETREAS_LOCKUP_Pos) /*!< Bit mask of LOCKUP field. */
++#define POWER_RESETREAS_LOCKUP_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_LOCKUP_Detected (1UL) /*!< Detected */
++
++/* Bit 2 : Reset from soft reset detected */
++#define POWER_RESETREAS_SREQ_Pos (2UL) /*!< Position of SREQ field. */
++#define POWER_RESETREAS_SREQ_Msk (0x1UL << POWER_RESETREAS_SREQ_Pos) /*!< Bit mask of SREQ field. */
++#define POWER_RESETREAS_SREQ_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_SREQ_Detected (1UL) /*!< Detected */
++
++/* Bit 1 : Reset from watchdog detected */
++#define POWER_RESETREAS_DOG_Pos (1UL) /*!< Position of DOG field. */
++#define POWER_RESETREAS_DOG_Msk (0x1UL << POWER_RESETREAS_DOG_Pos) /*!< Bit mask of DOG field. */
++#define POWER_RESETREAS_DOG_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_DOG_Detected (1UL) /*!< Detected */
++
++/* Bit 0 : Reset from pin-reset detected */
++#define POWER_RESETREAS_RESETPIN_Pos (0UL) /*!< Position of RESETPIN field. */
++#define POWER_RESETREAS_RESETPIN_Msk (0x1UL << POWER_RESETREAS_RESETPIN_Pos) /*!< Bit mask of RESETPIN field. */
++#define POWER_RESETREAS_RESETPIN_NotDetected (0UL) /*!< Not detected */
++#define POWER_RESETREAS_RESETPIN_Detected (1UL) /*!< Detected */
++
++/* Register: POWER_RAMSTATUS */
++/* Description: Deprecated register - RAM status register */
++
++/* Bit 3 : RAM block 3 is on or off/powering up */
++#define POWER_RAMSTATUS_RAMBLOCK3_Pos (3UL) /*!< Position of RAMBLOCK3 field. */
++#define POWER_RAMSTATUS_RAMBLOCK3_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK3_Pos) /*!< Bit mask of RAMBLOCK3 field. */
++#define POWER_RAMSTATUS_RAMBLOCK3_Off (0UL) /*!< Off */
++#define POWER_RAMSTATUS_RAMBLOCK3_On (1UL) /*!< On */
++
++/* Bit 2 : RAM block 2 is on or off/powering up */
++#define POWER_RAMSTATUS_RAMBLOCK2_Pos (2UL) /*!< Position of RAMBLOCK2 field. */
++#define POWER_RAMSTATUS_RAMBLOCK2_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK2_Pos) /*!< Bit mask of RAMBLOCK2 field. */
++#define POWER_RAMSTATUS_RAMBLOCK2_Off (0UL) /*!< Off */
++#define POWER_RAMSTATUS_RAMBLOCK2_On (1UL) /*!< On */
++
++/* Bit 1 : RAM block 1 is on or off/powering up */
++#define POWER_RAMSTATUS_RAMBLOCK1_Pos (1UL) /*!< Position of RAMBLOCK1 field. */
++#define POWER_RAMSTATUS_RAMBLOCK1_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK1_Pos) /*!< Bit mask of RAMBLOCK1 field. */
++#define POWER_RAMSTATUS_RAMBLOCK1_Off (0UL) /*!< Off */
++#define POWER_RAMSTATUS_RAMBLOCK1_On (1UL) /*!< On */
++
++/* Bit 0 : RAM block 0 is on or off/powering up */
++#define POWER_RAMSTATUS_RAMBLOCK0_Pos (0UL) /*!< Position of RAMBLOCK0 field. */
++#define POWER_RAMSTATUS_RAMBLOCK0_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK0_Pos) /*!< Bit mask of RAMBLOCK0 field. */
++#define POWER_RAMSTATUS_RAMBLOCK0_Off (0UL) /*!< Off */
++#define POWER_RAMSTATUS_RAMBLOCK0_On (1UL) /*!< On */
++
++/* Register: POWER_USBREGSTATUS */
++/* Description: USB supply status */
++
++/* Bit 1 : USB supply output settling time elapsed */
++#define POWER_USBREGSTATUS_OUTPUTRDY_Pos (1UL) /*!< Position of OUTPUTRDY field. */
++#define POWER_USBREGSTATUS_OUTPUTRDY_Msk (0x1UL << POWER_USBREGSTATUS_OUTPUTRDY_Pos) /*!< Bit mask of OUTPUTRDY field. */
++#define POWER_USBREGSTATUS_OUTPUTRDY_NotReady (0UL) /*!< USBREG output settling time not elapsed */
++#define POWER_USBREGSTATUS_OUTPUTRDY_Ready (1UL) /*!< USBREG output settling time elapsed (same information as USBPWRRDY event) */
++
++/* Bit 0 : VBUS input detection status (USBDETECTED and USBREMOVED events are derived from this information) */
++#define POWER_USBREGSTATUS_VBUSDETECT_Pos (0UL) /*!< Position of VBUSDETECT field. */
++#define POWER_USBREGSTATUS_VBUSDETECT_Msk (0x1UL << POWER_USBREGSTATUS_VBUSDETECT_Pos) /*!< Bit mask of VBUSDETECT field. */
++#define POWER_USBREGSTATUS_VBUSDETECT_NoVbus (0UL) /*!< VBUS voltage below valid threshold */
++#define POWER_USBREGSTATUS_VBUSDETECT_VbusPresent (1UL) /*!< VBUS voltage above valid threshold */
++
++/* Register: POWER_SYSTEMOFF */
++/* Description: System OFF register */
++
++/* Bit 0 : Enable System OFF mode */
++#define POWER_SYSTEMOFF_SYSTEMOFF_Pos (0UL) /*!< Position of SYSTEMOFF field. */
++#define POWER_SYSTEMOFF_SYSTEMOFF_Msk (0x1UL << POWER_SYSTEMOFF_SYSTEMOFF_Pos) /*!< Bit mask of SYSTEMOFF field. */
++#define POWER_SYSTEMOFF_SYSTEMOFF_Enter (1UL) /*!< Enable System OFF mode */
++
++/* Register: POWER_POFCON */
++/* Description: Power-fail comparator configuration */
++
++/* Bits 11..8 : Power-fail comparator threshold setting for high voltage mode (supply connected to VDDH only). This setting does not apply for normal voltage mode (supply connected to both VDD and VDDH). */
++#define POWER_POFCON_THRESHOLDVDDH_Pos (8UL) /*!< Position of THRESHOLDVDDH field. */
++#define POWER_POFCON_THRESHOLDVDDH_Msk (0xFUL << POWER_POFCON_THRESHOLDVDDH_Pos) /*!< Bit mask of THRESHOLDVDDH field. */
++#define POWER_POFCON_THRESHOLDVDDH_V27 (0UL) /*!< Set threshold to 2.7 V */
++#define POWER_POFCON_THRESHOLDVDDH_V28 (1UL) /*!< Set threshold to 2.8 V */
++#define POWER_POFCON_THRESHOLDVDDH_V29 (2UL) /*!< Set threshold to 2.9 V */
++#define POWER_POFCON_THRESHOLDVDDH_V30 (3UL) /*!< Set threshold to 3.0 V */
++#define POWER_POFCON_THRESHOLDVDDH_V31 (4UL) /*!< Set threshold to 3.1 V */
++#define POWER_POFCON_THRESHOLDVDDH_V32 (5UL) /*!< Set threshold to 3.2 V */
++#define POWER_POFCON_THRESHOLDVDDH_V33 (6UL) /*!< Set threshold to 3.3 V */
++#define POWER_POFCON_THRESHOLDVDDH_V34 (7UL) /*!< Set threshold to 3.4 V */
++#define POWER_POFCON_THRESHOLDVDDH_V35 (8UL) /*!< Set threshold to 3.5 V */
++#define POWER_POFCON_THRESHOLDVDDH_V36 (9UL) /*!< Set threshold to 3.6 V */
++#define POWER_POFCON_THRESHOLDVDDH_V37 (10UL) /*!< Set threshold to 3.7 V */
++#define POWER_POFCON_THRESHOLDVDDH_V38 (11UL) /*!< Set threshold to 3.8 V */
++#define POWER_POFCON_THRESHOLDVDDH_V39 (12UL) /*!< Set threshold to 3.9 V */
++#define POWER_POFCON_THRESHOLDVDDH_V40 (13UL) /*!< Set threshold to 4.0 V */
++#define POWER_POFCON_THRESHOLDVDDH_V41 (14UL) /*!< Set threshold to 4.1 V */
++#define POWER_POFCON_THRESHOLDVDDH_V42 (15UL) /*!< Set threshold to 4.2 V */
++
++/* Bits 4..1 : Power-fail comparator threshold setting. This setting applies both for normal voltage mode (supply connected to both VDD and VDDH) and high voltage mode (supply connected to VDDH only). Values 0-3 set threshold below 1.7 V and should not be used as brown out detection will be activated before power failure warning on such low voltages. */
++#define POWER_POFCON_THRESHOLD_Pos (1UL) /*!< Position of THRESHOLD field. */
++#define POWER_POFCON_THRESHOLD_Msk (0xFUL << POWER_POFCON_THRESHOLD_Pos) /*!< Bit mask of THRESHOLD field. */
++#define POWER_POFCON_THRESHOLD_V17 (4UL) /*!< Set threshold to 1.7 V */
++#define POWER_POFCON_THRESHOLD_V18 (5UL) /*!< Set threshold to 1.8 V */
++#define POWER_POFCON_THRESHOLD_V19 (6UL) /*!< Set threshold to 1.9 V */
++#define POWER_POFCON_THRESHOLD_V20 (7UL) /*!< Set threshold to 2.0 V */
++#define POWER_POFCON_THRESHOLD_V21 (8UL) /*!< Set threshold to 2.1 V */
++#define POWER_POFCON_THRESHOLD_V22 (9UL) /*!< Set threshold to 2.2 V */
++#define POWER_POFCON_THRESHOLD_V23 (10UL) /*!< Set threshold to 2.3 V */
++#define POWER_POFCON_THRESHOLD_V24 (11UL) /*!< Set threshold to 2.4 V */
++#define POWER_POFCON_THRESHOLD_V25 (12UL) /*!< Set threshold to 2.5 V */
++#define POWER_POFCON_THRESHOLD_V26 (13UL) /*!< Set threshold to 2.6 V */
++#define POWER_POFCON_THRESHOLD_V27 (14UL) /*!< Set threshold to 2.7 V */
++#define POWER_POFCON_THRESHOLD_V28 (15UL) /*!< Set threshold to 2.8 V */
++
++/* Bit 0 : Enable or disable power failure warning */
++#define POWER_POFCON_POF_Pos (0UL) /*!< Position of POF field. */
++#define POWER_POFCON_POF_Msk (0x1UL << POWER_POFCON_POF_Pos) /*!< Bit mask of POF field. */
++#define POWER_POFCON_POF_Disabled (0UL) /*!< Disable */
++#define POWER_POFCON_POF_Enabled (1UL) /*!< Enable */
++
++/* Register: POWER_GPREGRET */
++/* Description: General purpose retention register */
++
++/* Bits 7..0 : General purpose retention register */
++#define POWER_GPREGRET_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
++#define POWER_GPREGRET_GPREGRET_Msk (0xFFUL << POWER_GPREGRET_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
++
++/* Register: POWER_GPREGRET2 */
++/* Description: General purpose retention register */
++
++/* Bits 7..0 : General purpose retention register */
++#define POWER_GPREGRET2_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
++#define POWER_GPREGRET2_GPREGRET_Msk (0xFFUL << POWER_GPREGRET2_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
++
++/* Register: POWER_DCDCEN */
++/* Description: Enable DC/DC converter for REG1 stage */
++
++/* Bit 0 : Enable DC/DC converter for REG1 stage. */
++#define POWER_DCDCEN_DCDCEN_Pos (0UL) /*!< Position of DCDCEN field. */
++#define POWER_DCDCEN_DCDCEN_Msk (0x1UL << POWER_DCDCEN_DCDCEN_Pos) /*!< Bit mask of DCDCEN field. */
++#define POWER_DCDCEN_DCDCEN_Disabled (0UL) /*!< Disable */
++#define POWER_DCDCEN_DCDCEN_Enabled (1UL) /*!< Enable */
++
++/* Register: POWER_DCDCEN0 */
++/* Description: Enable DC/DC converter for REG0 stage */
++
++/* Bit 0 : Enable DC/DC converter for REG0 stage. */
++#define POWER_DCDCEN0_DCDCEN_Pos (0UL) /*!< Position of DCDCEN field. */
++#define POWER_DCDCEN0_DCDCEN_Msk (0x1UL << POWER_DCDCEN0_DCDCEN_Pos) /*!< Bit mask of DCDCEN field. */
++#define POWER_DCDCEN0_DCDCEN_Disabled (0UL) /*!< Disable */
++#define POWER_DCDCEN0_DCDCEN_Enabled (1UL) /*!< Enable */
++
++/* Register: POWER_MAINREGSTATUS */
++/* Description: Main supply status */
++
++/* Bit 0 : Main supply status */
++#define POWER_MAINREGSTATUS_MAINREGSTATUS_Pos (0UL) /*!< Position of MAINREGSTATUS field. */
++#define POWER_MAINREGSTATUS_MAINREGSTATUS_Msk (0x1UL << POWER_MAINREGSTATUS_MAINREGSTATUS_Pos) /*!< Bit mask of MAINREGSTATUS field. */
++#define POWER_MAINREGSTATUS_MAINREGSTATUS_Normal (0UL) /*!< Normal voltage mode. Voltage supplied on VDD. */
++#define POWER_MAINREGSTATUS_MAINREGSTATUS_High (1UL) /*!< High voltage mode. Voltage supplied on VDDH. */
++
++/* Register: POWER_RAM_POWER */
++/* Description: Description cluster: RAMn power control register */
++
++/* Bit 31 : Keep retention on RAM section S15 when RAM section is off */
++#define POWER_RAM_POWER_S15RETENTION_Pos (31UL) /*!< Position of S15RETENTION field. */
++#define POWER_RAM_POWER_S15RETENTION_Msk (0x1UL << POWER_RAM_POWER_S15RETENTION_Pos) /*!< Bit mask of S15RETENTION field. */
++#define POWER_RAM_POWER_S15RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S15RETENTION_On (1UL) /*!< On */
++
++/* Bit 30 : Keep retention on RAM section S14 when RAM section is off */
++#define POWER_RAM_POWER_S14RETENTION_Pos (30UL) /*!< Position of S14RETENTION field. */
++#define POWER_RAM_POWER_S14RETENTION_Msk (0x1UL << POWER_RAM_POWER_S14RETENTION_Pos) /*!< Bit mask of S14RETENTION field. */
++#define POWER_RAM_POWER_S14RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S14RETENTION_On (1UL) /*!< On */
++
++/* Bit 29 : Keep retention on RAM section S13 when RAM section is off */
++#define POWER_RAM_POWER_S13RETENTION_Pos (29UL) /*!< Position of S13RETENTION field. */
++#define POWER_RAM_POWER_S13RETENTION_Msk (0x1UL << POWER_RAM_POWER_S13RETENTION_Pos) /*!< Bit mask of S13RETENTION field. */
++#define POWER_RAM_POWER_S13RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S13RETENTION_On (1UL) /*!< On */
++
++/* Bit 28 : Keep retention on RAM section S12 when RAM section is off */
++#define POWER_RAM_POWER_S12RETENTION_Pos (28UL) /*!< Position of S12RETENTION field. */
++#define POWER_RAM_POWER_S12RETENTION_Msk (0x1UL << POWER_RAM_POWER_S12RETENTION_Pos) /*!< Bit mask of S12RETENTION field. */
++#define POWER_RAM_POWER_S12RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S12RETENTION_On (1UL) /*!< On */
++
++/* Bit 27 : Keep retention on RAM section S11 when RAM section is off */
++#define POWER_RAM_POWER_S11RETENTION_Pos (27UL) /*!< Position of S11RETENTION field. */
++#define POWER_RAM_POWER_S11RETENTION_Msk (0x1UL << POWER_RAM_POWER_S11RETENTION_Pos) /*!< Bit mask of S11RETENTION field. */
++#define POWER_RAM_POWER_S11RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S11RETENTION_On (1UL) /*!< On */
++
++/* Bit 26 : Keep retention on RAM section S10 when RAM section is off */
++#define POWER_RAM_POWER_S10RETENTION_Pos (26UL) /*!< Position of S10RETENTION field. */
++#define POWER_RAM_POWER_S10RETENTION_Msk (0x1UL << POWER_RAM_POWER_S10RETENTION_Pos) /*!< Bit mask of S10RETENTION field. */
++#define POWER_RAM_POWER_S10RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S10RETENTION_On (1UL) /*!< On */
++
++/* Bit 25 : Keep retention on RAM section S9 when RAM section is off */
++#define POWER_RAM_POWER_S9RETENTION_Pos (25UL) /*!< Position of S9RETENTION field. */
++#define POWER_RAM_POWER_S9RETENTION_Msk (0x1UL << POWER_RAM_POWER_S9RETENTION_Pos) /*!< Bit mask of S9RETENTION field. */
++#define POWER_RAM_POWER_S9RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S9RETENTION_On (1UL) /*!< On */
++
++/* Bit 24 : Keep retention on RAM section S8 when RAM section is off */
++#define POWER_RAM_POWER_S8RETENTION_Pos (24UL) /*!< Position of S8RETENTION field. */
++#define POWER_RAM_POWER_S8RETENTION_Msk (0x1UL << POWER_RAM_POWER_S8RETENTION_Pos) /*!< Bit mask of S8RETENTION field. */
++#define POWER_RAM_POWER_S8RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S8RETENTION_On (1UL) /*!< On */
++
++/* Bit 23 : Keep retention on RAM section S7 when RAM section is off */
++#define POWER_RAM_POWER_S7RETENTION_Pos (23UL) /*!< Position of S7RETENTION field. */
++#define POWER_RAM_POWER_S7RETENTION_Msk (0x1UL << POWER_RAM_POWER_S7RETENTION_Pos) /*!< Bit mask of S7RETENTION field. */
++#define POWER_RAM_POWER_S7RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S7RETENTION_On (1UL) /*!< On */
++
++/* Bit 22 : Keep retention on RAM section S6 when RAM section is off */
++#define POWER_RAM_POWER_S6RETENTION_Pos (22UL) /*!< Position of S6RETENTION field. */
++#define POWER_RAM_POWER_S6RETENTION_Msk (0x1UL << POWER_RAM_POWER_S6RETENTION_Pos) /*!< Bit mask of S6RETENTION field. */
++#define POWER_RAM_POWER_S6RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S6RETENTION_On (1UL) /*!< On */
++
++/* Bit 21 : Keep retention on RAM section S5 when RAM section is off */
++#define POWER_RAM_POWER_S5RETENTION_Pos (21UL) /*!< Position of S5RETENTION field. */
++#define POWER_RAM_POWER_S5RETENTION_Msk (0x1UL << POWER_RAM_POWER_S5RETENTION_Pos) /*!< Bit mask of S5RETENTION field. */
++#define POWER_RAM_POWER_S5RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S5RETENTION_On (1UL) /*!< On */
++
++/* Bit 20 : Keep retention on RAM section S4 when RAM section is off */
++#define POWER_RAM_POWER_S4RETENTION_Pos (20UL) /*!< Position of S4RETENTION field. */
++#define POWER_RAM_POWER_S4RETENTION_Msk (0x1UL << POWER_RAM_POWER_S4RETENTION_Pos) /*!< Bit mask of S4RETENTION field. */
++#define POWER_RAM_POWER_S4RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S4RETENTION_On (1UL) /*!< On */
++
++/* Bit 19 : Keep retention on RAM section S3 when RAM section is off */
++#define POWER_RAM_POWER_S3RETENTION_Pos (19UL) /*!< Position of S3RETENTION field. */
++#define POWER_RAM_POWER_S3RETENTION_Msk (0x1UL << POWER_RAM_POWER_S3RETENTION_Pos) /*!< Bit mask of S3RETENTION field. */
++#define POWER_RAM_POWER_S3RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S3RETENTION_On (1UL) /*!< On */
++
++/* Bit 18 : Keep retention on RAM section S2 when RAM section is off */
++#define POWER_RAM_POWER_S2RETENTION_Pos (18UL) /*!< Position of S2RETENTION field. */
++#define POWER_RAM_POWER_S2RETENTION_Msk (0x1UL << POWER_RAM_POWER_S2RETENTION_Pos) /*!< Bit mask of S2RETENTION field. */
++#define POWER_RAM_POWER_S2RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S2RETENTION_On (1UL) /*!< On */
++
++/* Bit 17 : Keep retention on RAM section S1 when RAM section is off */
++#define POWER_RAM_POWER_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
++#define POWER_RAM_POWER_S1RETENTION_Msk (0x1UL << POWER_RAM_POWER_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
++#define POWER_RAM_POWER_S1RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S1RETENTION_On (1UL) /*!< On */
++
++/* Bit 16 : Keep retention on RAM section S0 when RAM section is off */
++#define POWER_RAM_POWER_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
++#define POWER_RAM_POWER_S0RETENTION_Msk (0x1UL << POWER_RAM_POWER_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
++#define POWER_RAM_POWER_S0RETENTION_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S0RETENTION_On (1UL) /*!< On */
++
++/* Bit 15 : Keep RAM section S15 on or off in System ON mode. */
++#define POWER_RAM_POWER_S15POWER_Pos (15UL) /*!< Position of S15POWER field. */
++#define POWER_RAM_POWER_S15POWER_Msk (0x1UL << POWER_RAM_POWER_S15POWER_Pos) /*!< Bit mask of S15POWER field. */
++#define POWER_RAM_POWER_S15POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S15POWER_On (1UL) /*!< On */
++
++/* Bit 14 : Keep RAM section S14 on or off in System ON mode. */
++#define POWER_RAM_POWER_S14POWER_Pos (14UL) /*!< Position of S14POWER field. */
++#define POWER_RAM_POWER_S14POWER_Msk (0x1UL << POWER_RAM_POWER_S14POWER_Pos) /*!< Bit mask of S14POWER field. */
++#define POWER_RAM_POWER_S14POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S14POWER_On (1UL) /*!< On */
++
++/* Bit 13 : Keep RAM section S13 on or off in System ON mode. */
++#define POWER_RAM_POWER_S13POWER_Pos (13UL) /*!< Position of S13POWER field. */
++#define POWER_RAM_POWER_S13POWER_Msk (0x1UL << POWER_RAM_POWER_S13POWER_Pos) /*!< Bit mask of S13POWER field. */
++#define POWER_RAM_POWER_S13POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S13POWER_On (1UL) /*!< On */
++
++/* Bit 12 : Keep RAM section S12 on or off in System ON mode. */
++#define POWER_RAM_POWER_S12POWER_Pos (12UL) /*!< Position of S12POWER field. */
++#define POWER_RAM_POWER_S12POWER_Msk (0x1UL << POWER_RAM_POWER_S12POWER_Pos) /*!< Bit mask of S12POWER field. */
++#define POWER_RAM_POWER_S12POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S12POWER_On (1UL) /*!< On */
++
++/* Bit 11 : Keep RAM section S11 on or off in System ON mode. */
++#define POWER_RAM_POWER_S11POWER_Pos (11UL) /*!< Position of S11POWER field. */
++#define POWER_RAM_POWER_S11POWER_Msk (0x1UL << POWER_RAM_POWER_S11POWER_Pos) /*!< Bit mask of S11POWER field. */
++#define POWER_RAM_POWER_S11POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S11POWER_On (1UL) /*!< On */
++
++/* Bit 10 : Keep RAM section S10 on or off in System ON mode. */
++#define POWER_RAM_POWER_S10POWER_Pos (10UL) /*!< Position of S10POWER field. */
++#define POWER_RAM_POWER_S10POWER_Msk (0x1UL << POWER_RAM_POWER_S10POWER_Pos) /*!< Bit mask of S10POWER field. */
++#define POWER_RAM_POWER_S10POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S10POWER_On (1UL) /*!< On */
++
++/* Bit 9 : Keep RAM section S9 on or off in System ON mode. */
++#define POWER_RAM_POWER_S9POWER_Pos (9UL) /*!< Position of S9POWER field. */
++#define POWER_RAM_POWER_S9POWER_Msk (0x1UL << POWER_RAM_POWER_S9POWER_Pos) /*!< Bit mask of S9POWER field. */
++#define POWER_RAM_POWER_S9POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S9POWER_On (1UL) /*!< On */
++
++/* Bit 8 : Keep RAM section S8 on or off in System ON mode. */
++#define POWER_RAM_POWER_S8POWER_Pos (8UL) /*!< Position of S8POWER field. */
++#define POWER_RAM_POWER_S8POWER_Msk (0x1UL << POWER_RAM_POWER_S8POWER_Pos) /*!< Bit mask of S8POWER field. */
++#define POWER_RAM_POWER_S8POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S8POWER_On (1UL) /*!< On */
++
++/* Bit 7 : Keep RAM section S7 on or off in System ON mode. */
++#define POWER_RAM_POWER_S7POWER_Pos (7UL) /*!< Position of S7POWER field. */
++#define POWER_RAM_POWER_S7POWER_Msk (0x1UL << POWER_RAM_POWER_S7POWER_Pos) /*!< Bit mask of S7POWER field. */
++#define POWER_RAM_POWER_S7POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S7POWER_On (1UL) /*!< On */
++
++/* Bit 6 : Keep RAM section S6 on or off in System ON mode. */
++#define POWER_RAM_POWER_S6POWER_Pos (6UL) /*!< Position of S6POWER field. */
++#define POWER_RAM_POWER_S6POWER_Msk (0x1UL << POWER_RAM_POWER_S6POWER_Pos) /*!< Bit mask of S6POWER field. */
++#define POWER_RAM_POWER_S6POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S6POWER_On (1UL) /*!< On */
++
++/* Bit 5 : Keep RAM section S5 on or off in System ON mode. */
++#define POWER_RAM_POWER_S5POWER_Pos (5UL) /*!< Position of S5POWER field. */
++#define POWER_RAM_POWER_S5POWER_Msk (0x1UL << POWER_RAM_POWER_S5POWER_Pos) /*!< Bit mask of S5POWER field. */
++#define POWER_RAM_POWER_S5POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S5POWER_On (1UL) /*!< On */
++
++/* Bit 4 : Keep RAM section S4 on or off in System ON mode. */
++#define POWER_RAM_POWER_S4POWER_Pos (4UL) /*!< Position of S4POWER field. */
++#define POWER_RAM_POWER_S4POWER_Msk (0x1UL << POWER_RAM_POWER_S4POWER_Pos) /*!< Bit mask of S4POWER field. */
++#define POWER_RAM_POWER_S4POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S4POWER_On (1UL) /*!< On */
++
++/* Bit 3 : Keep RAM section S3 on or off in System ON mode. */
++#define POWER_RAM_POWER_S3POWER_Pos (3UL) /*!< Position of S3POWER field. */
++#define POWER_RAM_POWER_S3POWER_Msk (0x1UL << POWER_RAM_POWER_S3POWER_Pos) /*!< Bit mask of S3POWER field. */
++#define POWER_RAM_POWER_S3POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S3POWER_On (1UL) /*!< On */
++
++/* Bit 2 : Keep RAM section S2 on or off in System ON mode. */
++#define POWER_RAM_POWER_S2POWER_Pos (2UL) /*!< Position of S2POWER field. */
++#define POWER_RAM_POWER_S2POWER_Msk (0x1UL << POWER_RAM_POWER_S2POWER_Pos) /*!< Bit mask of S2POWER field. */
++#define POWER_RAM_POWER_S2POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S2POWER_On (1UL) /*!< On */
++
++/* Bit 1 : Keep RAM section S1 on or off in System ON mode. */
++#define POWER_RAM_POWER_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
++#define POWER_RAM_POWER_S1POWER_Msk (0x1UL << POWER_RAM_POWER_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
++#define POWER_RAM_POWER_S1POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S1POWER_On (1UL) /*!< On */
++
++/* Bit 0 : Keep RAM section S0 on or off in System ON mode. */
++#define POWER_RAM_POWER_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
++#define POWER_RAM_POWER_S0POWER_Msk (0x1UL << POWER_RAM_POWER_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
++#define POWER_RAM_POWER_S0POWER_Off (0UL) /*!< Off */
++#define POWER_RAM_POWER_S0POWER_On (1UL) /*!< On */
++
++/* Register: POWER_RAM_POWERSET */
++/* Description: Description cluster: RAMn power control set register */
++
++/* Bit 31 : Keep retention on RAM section S15 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S15RETENTION_Pos (31UL) /*!< Position of S15RETENTION field. */
++#define POWER_RAM_POWERSET_S15RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S15RETENTION_Pos) /*!< Bit mask of S15RETENTION field. */
++#define POWER_RAM_POWERSET_S15RETENTION_On (1UL) /*!< On */
++
++/* Bit 30 : Keep retention on RAM section S14 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S14RETENTION_Pos (30UL) /*!< Position of S14RETENTION field. */
++#define POWER_RAM_POWERSET_S14RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S14RETENTION_Pos) /*!< Bit mask of S14RETENTION field. */
++#define POWER_RAM_POWERSET_S14RETENTION_On (1UL) /*!< On */
++
++/* Bit 29 : Keep retention on RAM section S13 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S13RETENTION_Pos (29UL) /*!< Position of S13RETENTION field. */
++#define POWER_RAM_POWERSET_S13RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S13RETENTION_Pos) /*!< Bit mask of S13RETENTION field. */
++#define POWER_RAM_POWERSET_S13RETENTION_On (1UL) /*!< On */
++
++/* Bit 28 : Keep retention on RAM section S12 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S12RETENTION_Pos (28UL) /*!< Position of S12RETENTION field. */
++#define POWER_RAM_POWERSET_S12RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S12RETENTION_Pos) /*!< Bit mask of S12RETENTION field. */
++#define POWER_RAM_POWERSET_S12RETENTION_On (1UL) /*!< On */
++
++/* Bit 27 : Keep retention on RAM section S11 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S11RETENTION_Pos (27UL) /*!< Position of S11RETENTION field. */
++#define POWER_RAM_POWERSET_S11RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S11RETENTION_Pos) /*!< Bit mask of S11RETENTION field. */
++#define POWER_RAM_POWERSET_S11RETENTION_On (1UL) /*!< On */
++
++/* Bit 26 : Keep retention on RAM section S10 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S10RETENTION_Pos (26UL) /*!< Position of S10RETENTION field. */
++#define POWER_RAM_POWERSET_S10RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S10RETENTION_Pos) /*!< Bit mask of S10RETENTION field. */
++#define POWER_RAM_POWERSET_S10RETENTION_On (1UL) /*!< On */
++
++/* Bit 25 : Keep retention on RAM section S9 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S9RETENTION_Pos (25UL) /*!< Position of S9RETENTION field. */
++#define POWER_RAM_POWERSET_S9RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S9RETENTION_Pos) /*!< Bit mask of S9RETENTION field. */
++#define POWER_RAM_POWERSET_S9RETENTION_On (1UL) /*!< On */
++
++/* Bit 24 : Keep retention on RAM section S8 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S8RETENTION_Pos (24UL) /*!< Position of S8RETENTION field. */
++#define POWER_RAM_POWERSET_S8RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S8RETENTION_Pos) /*!< Bit mask of S8RETENTION field. */
++#define POWER_RAM_POWERSET_S8RETENTION_On (1UL) /*!< On */
++
++/* Bit 23 : Keep retention on RAM section S7 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S7RETENTION_Pos (23UL) /*!< Position of S7RETENTION field. */
++#define POWER_RAM_POWERSET_S7RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S7RETENTION_Pos) /*!< Bit mask of S7RETENTION field. */
++#define POWER_RAM_POWERSET_S7RETENTION_On (1UL) /*!< On */
++
++/* Bit 22 : Keep retention on RAM section S6 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S6RETENTION_Pos (22UL) /*!< Position of S6RETENTION field. */
++#define POWER_RAM_POWERSET_S6RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S6RETENTION_Pos) /*!< Bit mask of S6RETENTION field. */
++#define POWER_RAM_POWERSET_S6RETENTION_On (1UL) /*!< On */
++
++/* Bit 21 : Keep retention on RAM section S5 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S5RETENTION_Pos (21UL) /*!< Position of S5RETENTION field. */
++#define POWER_RAM_POWERSET_S5RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S5RETENTION_Pos) /*!< Bit mask of S5RETENTION field. */
++#define POWER_RAM_POWERSET_S5RETENTION_On (1UL) /*!< On */
++
++/* Bit 20 : Keep retention on RAM section S4 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S4RETENTION_Pos (20UL) /*!< Position of S4RETENTION field. */
++#define POWER_RAM_POWERSET_S4RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S4RETENTION_Pos) /*!< Bit mask of S4RETENTION field. */
++#define POWER_RAM_POWERSET_S4RETENTION_On (1UL) /*!< On */
++
++/* Bit 19 : Keep retention on RAM section S3 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S3RETENTION_Pos (19UL) /*!< Position of S3RETENTION field. */
++#define POWER_RAM_POWERSET_S3RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S3RETENTION_Pos) /*!< Bit mask of S3RETENTION field. */
++#define POWER_RAM_POWERSET_S3RETENTION_On (1UL) /*!< On */
++
++/* Bit 18 : Keep retention on RAM section S2 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S2RETENTION_Pos (18UL) /*!< Position of S2RETENTION field. */
++#define POWER_RAM_POWERSET_S2RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S2RETENTION_Pos) /*!< Bit mask of S2RETENTION field. */
++#define POWER_RAM_POWERSET_S2RETENTION_On (1UL) /*!< On */
++
++/* Bit 17 : Keep retention on RAM section S1 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
++#define POWER_RAM_POWERSET_S1RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
++#define POWER_RAM_POWERSET_S1RETENTION_On (1UL) /*!< On */
++
++/* Bit 16 : Keep retention on RAM section S0 when RAM section is switched off */
++#define POWER_RAM_POWERSET_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
++#define POWER_RAM_POWERSET_S0RETENTION_Msk (0x1UL << POWER_RAM_POWERSET_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
++#define POWER_RAM_POWERSET_S0RETENTION_On (1UL) /*!< On */
++
++/* Bit 15 : Keep RAM section S15 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S15POWER_Pos (15UL) /*!< Position of S15POWER field. */
++#define POWER_RAM_POWERSET_S15POWER_Msk (0x1UL << POWER_RAM_POWERSET_S15POWER_Pos) /*!< Bit mask of S15POWER field. */
++#define POWER_RAM_POWERSET_S15POWER_On (1UL) /*!< On */
++
++/* Bit 14 : Keep RAM section S14 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S14POWER_Pos (14UL) /*!< Position of S14POWER field. */
++#define POWER_RAM_POWERSET_S14POWER_Msk (0x1UL << POWER_RAM_POWERSET_S14POWER_Pos) /*!< Bit mask of S14POWER field. */
++#define POWER_RAM_POWERSET_S14POWER_On (1UL) /*!< On */
++
++/* Bit 13 : Keep RAM section S13 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S13POWER_Pos (13UL) /*!< Position of S13POWER field. */
++#define POWER_RAM_POWERSET_S13POWER_Msk (0x1UL << POWER_RAM_POWERSET_S13POWER_Pos) /*!< Bit mask of S13POWER field. */
++#define POWER_RAM_POWERSET_S13POWER_On (1UL) /*!< On */
++
++/* Bit 12 : Keep RAM section S12 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S12POWER_Pos (12UL) /*!< Position of S12POWER field. */
++#define POWER_RAM_POWERSET_S12POWER_Msk (0x1UL << POWER_RAM_POWERSET_S12POWER_Pos) /*!< Bit mask of S12POWER field. */
++#define POWER_RAM_POWERSET_S12POWER_On (1UL) /*!< On */
++
++/* Bit 11 : Keep RAM section S11 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S11POWER_Pos (11UL) /*!< Position of S11POWER field. */
++#define POWER_RAM_POWERSET_S11POWER_Msk (0x1UL << POWER_RAM_POWERSET_S11POWER_Pos) /*!< Bit mask of S11POWER field. */
++#define POWER_RAM_POWERSET_S11POWER_On (1UL) /*!< On */
++
++/* Bit 10 : Keep RAM section S10 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S10POWER_Pos (10UL) /*!< Position of S10POWER field. */
++#define POWER_RAM_POWERSET_S10POWER_Msk (0x1UL << POWER_RAM_POWERSET_S10POWER_Pos) /*!< Bit mask of S10POWER field. */
++#define POWER_RAM_POWERSET_S10POWER_On (1UL) /*!< On */
++
++/* Bit 9 : Keep RAM section S9 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S9POWER_Pos (9UL) /*!< Position of S9POWER field. */
++#define POWER_RAM_POWERSET_S9POWER_Msk (0x1UL << POWER_RAM_POWERSET_S9POWER_Pos) /*!< Bit mask of S9POWER field. */
++#define POWER_RAM_POWERSET_S9POWER_On (1UL) /*!< On */
++
++/* Bit 8 : Keep RAM section S8 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S8POWER_Pos (8UL) /*!< Position of S8POWER field. */
++#define POWER_RAM_POWERSET_S8POWER_Msk (0x1UL << POWER_RAM_POWERSET_S8POWER_Pos) /*!< Bit mask of S8POWER field. */
++#define POWER_RAM_POWERSET_S8POWER_On (1UL) /*!< On */
++
++/* Bit 7 : Keep RAM section S7 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S7POWER_Pos (7UL) /*!< Position of S7POWER field. */
++#define POWER_RAM_POWERSET_S7POWER_Msk (0x1UL << POWER_RAM_POWERSET_S7POWER_Pos) /*!< Bit mask of S7POWER field. */
++#define POWER_RAM_POWERSET_S7POWER_On (1UL) /*!< On */
++
++/* Bit 6 : Keep RAM section S6 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S6POWER_Pos (6UL) /*!< Position of S6POWER field. */
++#define POWER_RAM_POWERSET_S6POWER_Msk (0x1UL << POWER_RAM_POWERSET_S6POWER_Pos) /*!< Bit mask of S6POWER field. */
++#define POWER_RAM_POWERSET_S6POWER_On (1UL) /*!< On */
++
++/* Bit 5 : Keep RAM section S5 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S5POWER_Pos (5UL) /*!< Position of S5POWER field. */
++#define POWER_RAM_POWERSET_S5POWER_Msk (0x1UL << POWER_RAM_POWERSET_S5POWER_Pos) /*!< Bit mask of S5POWER field. */
++#define POWER_RAM_POWERSET_S5POWER_On (1UL) /*!< On */
++
++/* Bit 4 : Keep RAM section S4 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S4POWER_Pos (4UL) /*!< Position of S4POWER field. */
++#define POWER_RAM_POWERSET_S4POWER_Msk (0x1UL << POWER_RAM_POWERSET_S4POWER_Pos) /*!< Bit mask of S4POWER field. */
++#define POWER_RAM_POWERSET_S4POWER_On (1UL) /*!< On */
++
++/* Bit 3 : Keep RAM section S3 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S3POWER_Pos (3UL) /*!< Position of S3POWER field. */
++#define POWER_RAM_POWERSET_S3POWER_Msk (0x1UL << POWER_RAM_POWERSET_S3POWER_Pos) /*!< Bit mask of S3POWER field. */
++#define POWER_RAM_POWERSET_S3POWER_On (1UL) /*!< On */
++
++/* Bit 2 : Keep RAM section S2 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S2POWER_Pos (2UL) /*!< Position of S2POWER field. */
++#define POWER_RAM_POWERSET_S2POWER_Msk (0x1UL << POWER_RAM_POWERSET_S2POWER_Pos) /*!< Bit mask of S2POWER field. */
++#define POWER_RAM_POWERSET_S2POWER_On (1UL) /*!< On */
++
++/* Bit 1 : Keep RAM section S1 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
++#define POWER_RAM_POWERSET_S1POWER_Msk (0x1UL << POWER_RAM_POWERSET_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
++#define POWER_RAM_POWERSET_S1POWER_On (1UL) /*!< On */
++
++/* Bit 0 : Keep RAM section S0 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERSET_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
++#define POWER_RAM_POWERSET_S0POWER_Msk (0x1UL << POWER_RAM_POWERSET_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
++#define POWER_RAM_POWERSET_S0POWER_On (1UL) /*!< On */
++
++/* Register: POWER_RAM_POWERCLR */
++/* Description: Description cluster: RAMn power control clear register */
++
++/* Bit 31 : Keep retention on RAM section S15 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S15RETENTION_Pos (31UL) /*!< Position of S15RETENTION field. */
++#define POWER_RAM_POWERCLR_S15RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S15RETENTION_Pos) /*!< Bit mask of S15RETENTION field. */
++#define POWER_RAM_POWERCLR_S15RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 30 : Keep retention on RAM section S14 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S14RETENTION_Pos (30UL) /*!< Position of S14RETENTION field. */
++#define POWER_RAM_POWERCLR_S14RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S14RETENTION_Pos) /*!< Bit mask of S14RETENTION field. */
++#define POWER_RAM_POWERCLR_S14RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 29 : Keep retention on RAM section S13 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S13RETENTION_Pos (29UL) /*!< Position of S13RETENTION field. */
++#define POWER_RAM_POWERCLR_S13RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S13RETENTION_Pos) /*!< Bit mask of S13RETENTION field. */
++#define POWER_RAM_POWERCLR_S13RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 28 : Keep retention on RAM section S12 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S12RETENTION_Pos (28UL) /*!< Position of S12RETENTION field. */
++#define POWER_RAM_POWERCLR_S12RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S12RETENTION_Pos) /*!< Bit mask of S12RETENTION field. */
++#define POWER_RAM_POWERCLR_S12RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 27 : Keep retention on RAM section S11 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S11RETENTION_Pos (27UL) /*!< Position of S11RETENTION field. */
++#define POWER_RAM_POWERCLR_S11RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S11RETENTION_Pos) /*!< Bit mask of S11RETENTION field. */
++#define POWER_RAM_POWERCLR_S11RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 26 : Keep retention on RAM section S10 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S10RETENTION_Pos (26UL) /*!< Position of S10RETENTION field. */
++#define POWER_RAM_POWERCLR_S10RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S10RETENTION_Pos) /*!< Bit mask of S10RETENTION field. */
++#define POWER_RAM_POWERCLR_S10RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 25 : Keep retention on RAM section S9 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S9RETENTION_Pos (25UL) /*!< Position of S9RETENTION field. */
++#define POWER_RAM_POWERCLR_S9RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S9RETENTION_Pos) /*!< Bit mask of S9RETENTION field. */
++#define POWER_RAM_POWERCLR_S9RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 24 : Keep retention on RAM section S8 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S8RETENTION_Pos (24UL) /*!< Position of S8RETENTION field. */
++#define POWER_RAM_POWERCLR_S8RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S8RETENTION_Pos) /*!< Bit mask of S8RETENTION field. */
++#define POWER_RAM_POWERCLR_S8RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 23 : Keep retention on RAM section S7 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S7RETENTION_Pos (23UL) /*!< Position of S7RETENTION field. */
++#define POWER_RAM_POWERCLR_S7RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S7RETENTION_Pos) /*!< Bit mask of S7RETENTION field. */
++#define POWER_RAM_POWERCLR_S7RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 22 : Keep retention on RAM section S6 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S6RETENTION_Pos (22UL) /*!< Position of S6RETENTION field. */
++#define POWER_RAM_POWERCLR_S6RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S6RETENTION_Pos) /*!< Bit mask of S6RETENTION field. */
++#define POWER_RAM_POWERCLR_S6RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 21 : Keep retention on RAM section S5 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S5RETENTION_Pos (21UL) /*!< Position of S5RETENTION field. */
++#define POWER_RAM_POWERCLR_S5RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S5RETENTION_Pos) /*!< Bit mask of S5RETENTION field. */
++#define POWER_RAM_POWERCLR_S5RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 20 : Keep retention on RAM section S4 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S4RETENTION_Pos (20UL) /*!< Position of S4RETENTION field. */
++#define POWER_RAM_POWERCLR_S4RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S4RETENTION_Pos) /*!< Bit mask of S4RETENTION field. */
++#define POWER_RAM_POWERCLR_S4RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 19 : Keep retention on RAM section S3 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S3RETENTION_Pos (19UL) /*!< Position of S3RETENTION field. */
++#define POWER_RAM_POWERCLR_S3RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S3RETENTION_Pos) /*!< Bit mask of S3RETENTION field. */
++#define POWER_RAM_POWERCLR_S3RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 18 : Keep retention on RAM section S2 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S2RETENTION_Pos (18UL) /*!< Position of S2RETENTION field. */
++#define POWER_RAM_POWERCLR_S2RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S2RETENTION_Pos) /*!< Bit mask of S2RETENTION field. */
++#define POWER_RAM_POWERCLR_S2RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 17 : Keep retention on RAM section S1 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S1RETENTION_Pos (17UL) /*!< Position of S1RETENTION field. */
++#define POWER_RAM_POWERCLR_S1RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S1RETENTION_Pos) /*!< Bit mask of S1RETENTION field. */
++#define POWER_RAM_POWERCLR_S1RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 16 : Keep retention on RAM section S0 when RAM section is switched off */
++#define POWER_RAM_POWERCLR_S0RETENTION_Pos (16UL) /*!< Position of S0RETENTION field. */
++#define POWER_RAM_POWERCLR_S0RETENTION_Msk (0x1UL << POWER_RAM_POWERCLR_S0RETENTION_Pos) /*!< Bit mask of S0RETENTION field. */
++#define POWER_RAM_POWERCLR_S0RETENTION_Off (1UL) /*!< Off */
++
++/* Bit 15 : Keep RAM section S15 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S15POWER_Pos (15UL) /*!< Position of S15POWER field. */
++#define POWER_RAM_POWERCLR_S15POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S15POWER_Pos) /*!< Bit mask of S15POWER field. */
++#define POWER_RAM_POWERCLR_S15POWER_Off (1UL) /*!< Off */
++
++/* Bit 14 : Keep RAM section S14 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S14POWER_Pos (14UL) /*!< Position of S14POWER field. */
++#define POWER_RAM_POWERCLR_S14POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S14POWER_Pos) /*!< Bit mask of S14POWER field. */
++#define POWER_RAM_POWERCLR_S14POWER_Off (1UL) /*!< Off */
++
++/* Bit 13 : Keep RAM section S13 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S13POWER_Pos (13UL) /*!< Position of S13POWER field. */
++#define POWER_RAM_POWERCLR_S13POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S13POWER_Pos) /*!< Bit mask of S13POWER field. */
++#define POWER_RAM_POWERCLR_S13POWER_Off (1UL) /*!< Off */
++
++/* Bit 12 : Keep RAM section S12 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S12POWER_Pos (12UL) /*!< Position of S12POWER field. */
++#define POWER_RAM_POWERCLR_S12POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S12POWER_Pos) /*!< Bit mask of S12POWER field. */
++#define POWER_RAM_POWERCLR_S12POWER_Off (1UL) /*!< Off */
++
++/* Bit 11 : Keep RAM section S11 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S11POWER_Pos (11UL) /*!< Position of S11POWER field. */
++#define POWER_RAM_POWERCLR_S11POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S11POWER_Pos) /*!< Bit mask of S11POWER field. */
++#define POWER_RAM_POWERCLR_S11POWER_Off (1UL) /*!< Off */
++
++/* Bit 10 : Keep RAM section S10 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S10POWER_Pos (10UL) /*!< Position of S10POWER field. */
++#define POWER_RAM_POWERCLR_S10POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S10POWER_Pos) /*!< Bit mask of S10POWER field. */
++#define POWER_RAM_POWERCLR_S10POWER_Off (1UL) /*!< Off */
++
++/* Bit 9 : Keep RAM section S9 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S9POWER_Pos (9UL) /*!< Position of S9POWER field. */
++#define POWER_RAM_POWERCLR_S9POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S9POWER_Pos) /*!< Bit mask of S9POWER field. */
++#define POWER_RAM_POWERCLR_S9POWER_Off (1UL) /*!< Off */
++
++/* Bit 8 : Keep RAM section S8 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S8POWER_Pos (8UL) /*!< Position of S8POWER field. */
++#define POWER_RAM_POWERCLR_S8POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S8POWER_Pos) /*!< Bit mask of S8POWER field. */
++#define POWER_RAM_POWERCLR_S8POWER_Off (1UL) /*!< Off */
++
++/* Bit 7 : Keep RAM section S7 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S7POWER_Pos (7UL) /*!< Position of S7POWER field. */
++#define POWER_RAM_POWERCLR_S7POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S7POWER_Pos) /*!< Bit mask of S7POWER field. */
++#define POWER_RAM_POWERCLR_S7POWER_Off (1UL) /*!< Off */
++
++/* Bit 6 : Keep RAM section S6 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S6POWER_Pos (6UL) /*!< Position of S6POWER field. */
++#define POWER_RAM_POWERCLR_S6POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S6POWER_Pos) /*!< Bit mask of S6POWER field. */
++#define POWER_RAM_POWERCLR_S6POWER_Off (1UL) /*!< Off */
++
++/* Bit 5 : Keep RAM section S5 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S5POWER_Pos (5UL) /*!< Position of S5POWER field. */
++#define POWER_RAM_POWERCLR_S5POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S5POWER_Pos) /*!< Bit mask of S5POWER field. */
++#define POWER_RAM_POWERCLR_S5POWER_Off (1UL) /*!< Off */
++
++/* Bit 4 : Keep RAM section S4 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S4POWER_Pos (4UL) /*!< Position of S4POWER field. */
++#define POWER_RAM_POWERCLR_S4POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S4POWER_Pos) /*!< Bit mask of S4POWER field. */
++#define POWER_RAM_POWERCLR_S4POWER_Off (1UL) /*!< Off */
++
++/* Bit 3 : Keep RAM section S3 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S3POWER_Pos (3UL) /*!< Position of S3POWER field. */
++#define POWER_RAM_POWERCLR_S3POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S3POWER_Pos) /*!< Bit mask of S3POWER field. */
++#define POWER_RAM_POWERCLR_S3POWER_Off (1UL) /*!< Off */
++
++/* Bit 2 : Keep RAM section S2 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S2POWER_Pos (2UL) /*!< Position of S2POWER field. */
++#define POWER_RAM_POWERCLR_S2POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S2POWER_Pos) /*!< Bit mask of S2POWER field. */
++#define POWER_RAM_POWERCLR_S2POWER_Off (1UL) /*!< Off */
++
++/* Bit 1 : Keep RAM section S1 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S1POWER_Pos (1UL) /*!< Position of S1POWER field. */
++#define POWER_RAM_POWERCLR_S1POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S1POWER_Pos) /*!< Bit mask of S1POWER field. */
++#define POWER_RAM_POWERCLR_S1POWER_Off (1UL) /*!< Off */
++
++/* Bit 0 : Keep RAM section S0 of RAMn on or off in System ON mode */
++#define POWER_RAM_POWERCLR_S0POWER_Pos (0UL) /*!< Position of S0POWER field. */
++#define POWER_RAM_POWERCLR_S0POWER_Msk (0x1UL << POWER_RAM_POWERCLR_S0POWER_Pos) /*!< Bit mask of S0POWER field. */
++#define POWER_RAM_POWERCLR_S0POWER_Off (1UL) /*!< Off */
++
++
++/* Peripheral: PPI */
++/* Description: Programmable Peripheral Interconnect */
++
++/* Register: PPI_TASKS_CHG_EN */
++/* Description: Description cluster: Enable channel group n */
++
++/* Bit 0 : Enable channel group n */
++#define PPI_TASKS_CHG_EN_EN_Pos (0UL) /*!< Position of EN field. */
++#define PPI_TASKS_CHG_EN_EN_Msk (0x1UL << PPI_TASKS_CHG_EN_EN_Pos) /*!< Bit mask of EN field. */
++#define PPI_TASKS_CHG_EN_EN_Trigger (1UL) /*!< Trigger task */
++
++/* Register: PPI_TASKS_CHG_DIS */
++/* Description: Description cluster: Disable channel group n */
++
++/* Bit 0 : Disable channel group n */
++#define PPI_TASKS_CHG_DIS_DIS_Pos (0UL) /*!< Position of DIS field. */
++#define PPI_TASKS_CHG_DIS_DIS_Msk (0x1UL << PPI_TASKS_CHG_DIS_DIS_Pos) /*!< Bit mask of DIS field. */
++#define PPI_TASKS_CHG_DIS_DIS_Trigger (1UL) /*!< Trigger task */
++
++/* Register: PPI_CHEN */
++/* Description: Channel enable register */
++
++/* Bit 31 : Enable or disable channel 31 */
++#define PPI_CHEN_CH31_Pos (31UL) /*!< Position of CH31 field. */
++#define PPI_CHEN_CH31_Msk (0x1UL << PPI_CHEN_CH31_Pos) /*!< Bit mask of CH31 field. */
++#define PPI_CHEN_CH31_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH31_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 30 : Enable or disable channel 30 */
++#define PPI_CHEN_CH30_Pos (30UL) /*!< Position of CH30 field. */
++#define PPI_CHEN_CH30_Msk (0x1UL << PPI_CHEN_CH30_Pos) /*!< Bit mask of CH30 field. */
++#define PPI_CHEN_CH30_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH30_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 29 : Enable or disable channel 29 */
++#define PPI_CHEN_CH29_Pos (29UL) /*!< Position of CH29 field. */
++#define PPI_CHEN_CH29_Msk (0x1UL << PPI_CHEN_CH29_Pos) /*!< Bit mask of CH29 field. */
++#define PPI_CHEN_CH29_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH29_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 28 : Enable or disable channel 28 */
++#define PPI_CHEN_CH28_Pos (28UL) /*!< Position of CH28 field. */
++#define PPI_CHEN_CH28_Msk (0x1UL << PPI_CHEN_CH28_Pos) /*!< Bit mask of CH28 field. */
++#define PPI_CHEN_CH28_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH28_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 27 : Enable or disable channel 27 */
++#define PPI_CHEN_CH27_Pos (27UL) /*!< Position of CH27 field. */
++#define PPI_CHEN_CH27_Msk (0x1UL << PPI_CHEN_CH27_Pos) /*!< Bit mask of CH27 field. */
++#define PPI_CHEN_CH27_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH27_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 26 : Enable or disable channel 26 */
++#define PPI_CHEN_CH26_Pos (26UL) /*!< Position of CH26 field. */
++#define PPI_CHEN_CH26_Msk (0x1UL << PPI_CHEN_CH26_Pos) /*!< Bit mask of CH26 field. */
++#define PPI_CHEN_CH26_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH26_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 25 : Enable or disable channel 25 */
++#define PPI_CHEN_CH25_Pos (25UL) /*!< Position of CH25 field. */
++#define PPI_CHEN_CH25_Msk (0x1UL << PPI_CHEN_CH25_Pos) /*!< Bit mask of CH25 field. */
++#define PPI_CHEN_CH25_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH25_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 24 : Enable or disable channel 24 */
++#define PPI_CHEN_CH24_Pos (24UL) /*!< Position of CH24 field. */
++#define PPI_CHEN_CH24_Msk (0x1UL << PPI_CHEN_CH24_Pos) /*!< Bit mask of CH24 field. */
++#define PPI_CHEN_CH24_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH24_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 23 : Enable or disable channel 23 */
++#define PPI_CHEN_CH23_Pos (23UL) /*!< Position of CH23 field. */
++#define PPI_CHEN_CH23_Msk (0x1UL << PPI_CHEN_CH23_Pos) /*!< Bit mask of CH23 field. */
++#define PPI_CHEN_CH23_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH23_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 22 : Enable or disable channel 22 */
++#define PPI_CHEN_CH22_Pos (22UL) /*!< Position of CH22 field. */
++#define PPI_CHEN_CH22_Msk (0x1UL << PPI_CHEN_CH22_Pos) /*!< Bit mask of CH22 field. */
++#define PPI_CHEN_CH22_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH22_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 21 : Enable or disable channel 21 */
++#define PPI_CHEN_CH21_Pos (21UL) /*!< Position of CH21 field. */
++#define PPI_CHEN_CH21_Msk (0x1UL << PPI_CHEN_CH21_Pos) /*!< Bit mask of CH21 field. */
++#define PPI_CHEN_CH21_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH21_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 20 : Enable or disable channel 20 */
++#define PPI_CHEN_CH20_Pos (20UL) /*!< Position of CH20 field. */
++#define PPI_CHEN_CH20_Msk (0x1UL << PPI_CHEN_CH20_Pos) /*!< Bit mask of CH20 field. */
++#define PPI_CHEN_CH20_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH20_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 19 : Enable or disable channel 19 */
++#define PPI_CHEN_CH19_Pos (19UL) /*!< Position of CH19 field. */
++#define PPI_CHEN_CH19_Msk (0x1UL << PPI_CHEN_CH19_Pos) /*!< Bit mask of CH19 field. */
++#define PPI_CHEN_CH19_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH19_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 18 : Enable or disable channel 18 */
++#define PPI_CHEN_CH18_Pos (18UL) /*!< Position of CH18 field. */
++#define PPI_CHEN_CH18_Msk (0x1UL << PPI_CHEN_CH18_Pos) /*!< Bit mask of CH18 field. */
++#define PPI_CHEN_CH18_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH18_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 17 : Enable or disable channel 17 */
++#define PPI_CHEN_CH17_Pos (17UL) /*!< Position of CH17 field. */
++#define PPI_CHEN_CH17_Msk (0x1UL << PPI_CHEN_CH17_Pos) /*!< Bit mask of CH17 field. */
++#define PPI_CHEN_CH17_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH17_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 16 : Enable or disable channel 16 */
++#define PPI_CHEN_CH16_Pos (16UL) /*!< Position of CH16 field. */
++#define PPI_CHEN_CH16_Msk (0x1UL << PPI_CHEN_CH16_Pos) /*!< Bit mask of CH16 field. */
++#define PPI_CHEN_CH16_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH16_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 15 : Enable or disable channel 15 */
++#define PPI_CHEN_CH15_Pos (15UL) /*!< Position of CH15 field. */
++#define PPI_CHEN_CH15_Msk (0x1UL << PPI_CHEN_CH15_Pos) /*!< Bit mask of CH15 field. */
++#define PPI_CHEN_CH15_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH15_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 14 : Enable or disable channel 14 */
++#define PPI_CHEN_CH14_Pos (14UL) /*!< Position of CH14 field. */
++#define PPI_CHEN_CH14_Msk (0x1UL << PPI_CHEN_CH14_Pos) /*!< Bit mask of CH14 field. */
++#define PPI_CHEN_CH14_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH14_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 13 : Enable or disable channel 13 */
++#define PPI_CHEN_CH13_Pos (13UL) /*!< Position of CH13 field. */
++#define PPI_CHEN_CH13_Msk (0x1UL << PPI_CHEN_CH13_Pos) /*!< Bit mask of CH13 field. */
++#define PPI_CHEN_CH13_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH13_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 12 : Enable or disable channel 12 */
++#define PPI_CHEN_CH12_Pos (12UL) /*!< Position of CH12 field. */
++#define PPI_CHEN_CH12_Msk (0x1UL << PPI_CHEN_CH12_Pos) /*!< Bit mask of CH12 field. */
++#define PPI_CHEN_CH12_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH12_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 11 : Enable or disable channel 11 */
++#define PPI_CHEN_CH11_Pos (11UL) /*!< Position of CH11 field. */
++#define PPI_CHEN_CH11_Msk (0x1UL << PPI_CHEN_CH11_Pos) /*!< Bit mask of CH11 field. */
++#define PPI_CHEN_CH11_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH11_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 10 : Enable or disable channel 10 */
++#define PPI_CHEN_CH10_Pos (10UL) /*!< Position of CH10 field. */
++#define PPI_CHEN_CH10_Msk (0x1UL << PPI_CHEN_CH10_Pos) /*!< Bit mask of CH10 field. */
++#define PPI_CHEN_CH10_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH10_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 9 : Enable or disable channel 9 */
++#define PPI_CHEN_CH9_Pos (9UL) /*!< Position of CH9 field. */
++#define PPI_CHEN_CH9_Msk (0x1UL << PPI_CHEN_CH9_Pos) /*!< Bit mask of CH9 field. */
++#define PPI_CHEN_CH9_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH9_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 8 : Enable or disable channel 8 */
++#define PPI_CHEN_CH8_Pos (8UL) /*!< Position of CH8 field. */
++#define PPI_CHEN_CH8_Msk (0x1UL << PPI_CHEN_CH8_Pos) /*!< Bit mask of CH8 field. */
++#define PPI_CHEN_CH8_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH8_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 7 : Enable or disable channel 7 */
++#define PPI_CHEN_CH7_Pos (7UL) /*!< Position of CH7 field. */
++#define PPI_CHEN_CH7_Msk (0x1UL << PPI_CHEN_CH7_Pos) /*!< Bit mask of CH7 field. */
++#define PPI_CHEN_CH7_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH7_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 6 : Enable or disable channel 6 */
++#define PPI_CHEN_CH6_Pos (6UL) /*!< Position of CH6 field. */
++#define PPI_CHEN_CH6_Msk (0x1UL << PPI_CHEN_CH6_Pos) /*!< Bit mask of CH6 field. */
++#define PPI_CHEN_CH6_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH6_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 5 : Enable or disable channel 5 */
++#define PPI_CHEN_CH5_Pos (5UL) /*!< Position of CH5 field. */
++#define PPI_CHEN_CH5_Msk (0x1UL << PPI_CHEN_CH5_Pos) /*!< Bit mask of CH5 field. */
++#define PPI_CHEN_CH5_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH5_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 4 : Enable or disable channel 4 */
++#define PPI_CHEN_CH4_Pos (4UL) /*!< Position of CH4 field. */
++#define PPI_CHEN_CH4_Msk (0x1UL << PPI_CHEN_CH4_Pos) /*!< Bit mask of CH4 field. */
++#define PPI_CHEN_CH4_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH4_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 3 : Enable or disable channel 3 */
++#define PPI_CHEN_CH3_Pos (3UL) /*!< Position of CH3 field. */
++#define PPI_CHEN_CH3_Msk (0x1UL << PPI_CHEN_CH3_Pos) /*!< Bit mask of CH3 field. */
++#define PPI_CHEN_CH3_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH3_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 2 : Enable or disable channel 2 */
++#define PPI_CHEN_CH2_Pos (2UL) /*!< Position of CH2 field. */
++#define PPI_CHEN_CH2_Msk (0x1UL << PPI_CHEN_CH2_Pos) /*!< Bit mask of CH2 field. */
++#define PPI_CHEN_CH2_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH2_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 1 : Enable or disable channel 1 */
++#define PPI_CHEN_CH1_Pos (1UL) /*!< Position of CH1 field. */
++#define PPI_CHEN_CH1_Msk (0x1UL << PPI_CHEN_CH1_Pos) /*!< Bit mask of CH1 field. */
++#define PPI_CHEN_CH1_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH1_Enabled (1UL) /*!< Enable channel */
++
++/* Bit 0 : Enable or disable channel 0 */
++#define PPI_CHEN_CH0_Pos (0UL) /*!< Position of CH0 field. */
++#define PPI_CHEN_CH0_Msk (0x1UL << PPI_CHEN_CH0_Pos) /*!< Bit mask of CH0 field. */
++#define PPI_CHEN_CH0_Disabled (0UL) /*!< Disable channel */
++#define PPI_CHEN_CH0_Enabled (1UL) /*!< Enable channel */
++
++/* Register: PPI_CHENSET */
++/* Description: Channel enable set register */
++
++/* Bit 31 : Channel 31 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH31_Pos (31UL) /*!< Position of CH31 field. */
++#define PPI_CHENSET_CH31_Msk (0x1UL << PPI_CHENSET_CH31_Pos) /*!< Bit mask of CH31 field. */
++#define PPI_CHENSET_CH31_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH31_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH31_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 30 : Channel 30 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH30_Pos (30UL) /*!< Position of CH30 field. */
++#define PPI_CHENSET_CH30_Msk (0x1UL << PPI_CHENSET_CH30_Pos) /*!< Bit mask of CH30 field. */
++#define PPI_CHENSET_CH30_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH30_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH30_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 29 : Channel 29 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH29_Pos (29UL) /*!< Position of CH29 field. */
++#define PPI_CHENSET_CH29_Msk (0x1UL << PPI_CHENSET_CH29_Pos) /*!< Bit mask of CH29 field. */
++#define PPI_CHENSET_CH29_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH29_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH29_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 28 : Channel 28 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH28_Pos (28UL) /*!< Position of CH28 field. */
++#define PPI_CHENSET_CH28_Msk (0x1UL << PPI_CHENSET_CH28_Pos) /*!< Bit mask of CH28 field. */
++#define PPI_CHENSET_CH28_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH28_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH28_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 27 : Channel 27 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH27_Pos (27UL) /*!< Position of CH27 field. */
++#define PPI_CHENSET_CH27_Msk (0x1UL << PPI_CHENSET_CH27_Pos) /*!< Bit mask of CH27 field. */
++#define PPI_CHENSET_CH27_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH27_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH27_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 26 : Channel 26 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH26_Pos (26UL) /*!< Position of CH26 field. */
++#define PPI_CHENSET_CH26_Msk (0x1UL << PPI_CHENSET_CH26_Pos) /*!< Bit mask of CH26 field. */
++#define PPI_CHENSET_CH26_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH26_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH26_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 25 : Channel 25 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH25_Pos (25UL) /*!< Position of CH25 field. */
++#define PPI_CHENSET_CH25_Msk (0x1UL << PPI_CHENSET_CH25_Pos) /*!< Bit mask of CH25 field. */
++#define PPI_CHENSET_CH25_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH25_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH25_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 24 : Channel 24 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH24_Pos (24UL) /*!< Position of CH24 field. */
++#define PPI_CHENSET_CH24_Msk (0x1UL << PPI_CHENSET_CH24_Pos) /*!< Bit mask of CH24 field. */
++#define PPI_CHENSET_CH24_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH24_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH24_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 23 : Channel 23 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH23_Pos (23UL) /*!< Position of CH23 field. */
++#define PPI_CHENSET_CH23_Msk (0x1UL << PPI_CHENSET_CH23_Pos) /*!< Bit mask of CH23 field. */
++#define PPI_CHENSET_CH23_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH23_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH23_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 22 : Channel 22 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH22_Pos (22UL) /*!< Position of CH22 field. */
++#define PPI_CHENSET_CH22_Msk (0x1UL << PPI_CHENSET_CH22_Pos) /*!< Bit mask of CH22 field. */
++#define PPI_CHENSET_CH22_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH22_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH22_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 21 : Channel 21 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH21_Pos (21UL) /*!< Position of CH21 field. */
++#define PPI_CHENSET_CH21_Msk (0x1UL << PPI_CHENSET_CH21_Pos) /*!< Bit mask of CH21 field. */
++#define PPI_CHENSET_CH21_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH21_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH21_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 20 : Channel 20 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH20_Pos (20UL) /*!< Position of CH20 field. */
++#define PPI_CHENSET_CH20_Msk (0x1UL << PPI_CHENSET_CH20_Pos) /*!< Bit mask of CH20 field. */
++#define PPI_CHENSET_CH20_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH20_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH20_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 19 : Channel 19 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH19_Pos (19UL) /*!< Position of CH19 field. */
++#define PPI_CHENSET_CH19_Msk (0x1UL << PPI_CHENSET_CH19_Pos) /*!< Bit mask of CH19 field. */
++#define PPI_CHENSET_CH19_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH19_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH19_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 18 : Channel 18 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH18_Pos (18UL) /*!< Position of CH18 field. */
++#define PPI_CHENSET_CH18_Msk (0x1UL << PPI_CHENSET_CH18_Pos) /*!< Bit mask of CH18 field. */
++#define PPI_CHENSET_CH18_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH18_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH18_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 17 : Channel 17 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH17_Pos (17UL) /*!< Position of CH17 field. */
++#define PPI_CHENSET_CH17_Msk (0x1UL << PPI_CHENSET_CH17_Pos) /*!< Bit mask of CH17 field. */
++#define PPI_CHENSET_CH17_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH17_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH17_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 16 : Channel 16 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH16_Pos (16UL) /*!< Position of CH16 field. */
++#define PPI_CHENSET_CH16_Msk (0x1UL << PPI_CHENSET_CH16_Pos) /*!< Bit mask of CH16 field. */
++#define PPI_CHENSET_CH16_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH16_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH16_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 15 : Channel 15 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH15_Pos (15UL) /*!< Position of CH15 field. */
++#define PPI_CHENSET_CH15_Msk (0x1UL << PPI_CHENSET_CH15_Pos) /*!< Bit mask of CH15 field. */
++#define PPI_CHENSET_CH15_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH15_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH15_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 14 : Channel 14 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH14_Pos (14UL) /*!< Position of CH14 field. */
++#define PPI_CHENSET_CH14_Msk (0x1UL << PPI_CHENSET_CH14_Pos) /*!< Bit mask of CH14 field. */
++#define PPI_CHENSET_CH14_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH14_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH14_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 13 : Channel 13 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH13_Pos (13UL) /*!< Position of CH13 field. */
++#define PPI_CHENSET_CH13_Msk (0x1UL << PPI_CHENSET_CH13_Pos) /*!< Bit mask of CH13 field. */
++#define PPI_CHENSET_CH13_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH13_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH13_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 12 : Channel 12 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH12_Pos (12UL) /*!< Position of CH12 field. */
++#define PPI_CHENSET_CH12_Msk (0x1UL << PPI_CHENSET_CH12_Pos) /*!< Bit mask of CH12 field. */
++#define PPI_CHENSET_CH12_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH12_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH12_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 11 : Channel 11 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH11_Pos (11UL) /*!< Position of CH11 field. */
++#define PPI_CHENSET_CH11_Msk (0x1UL << PPI_CHENSET_CH11_Pos) /*!< Bit mask of CH11 field. */
++#define PPI_CHENSET_CH11_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH11_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH11_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 10 : Channel 10 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH10_Pos (10UL) /*!< Position of CH10 field. */
++#define PPI_CHENSET_CH10_Msk (0x1UL << PPI_CHENSET_CH10_Pos) /*!< Bit mask of CH10 field. */
++#define PPI_CHENSET_CH10_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH10_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH10_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 9 : Channel 9 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH9_Pos (9UL) /*!< Position of CH9 field. */
++#define PPI_CHENSET_CH9_Msk (0x1UL << PPI_CHENSET_CH9_Pos) /*!< Bit mask of CH9 field. */
++#define PPI_CHENSET_CH9_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH9_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH9_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 8 : Channel 8 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH8_Pos (8UL) /*!< Position of CH8 field. */
++#define PPI_CHENSET_CH8_Msk (0x1UL << PPI_CHENSET_CH8_Pos) /*!< Bit mask of CH8 field. */
++#define PPI_CHENSET_CH8_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH8_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH8_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 7 : Channel 7 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH7_Pos (7UL) /*!< Position of CH7 field. */
++#define PPI_CHENSET_CH7_Msk (0x1UL << PPI_CHENSET_CH7_Pos) /*!< Bit mask of CH7 field. */
++#define PPI_CHENSET_CH7_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH7_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH7_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 6 : Channel 6 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH6_Pos (6UL) /*!< Position of CH6 field. */
++#define PPI_CHENSET_CH6_Msk (0x1UL << PPI_CHENSET_CH6_Pos) /*!< Bit mask of CH6 field. */
++#define PPI_CHENSET_CH6_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH6_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH6_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 5 : Channel 5 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH5_Pos (5UL) /*!< Position of CH5 field. */
++#define PPI_CHENSET_CH5_Msk (0x1UL << PPI_CHENSET_CH5_Pos) /*!< Bit mask of CH5 field. */
++#define PPI_CHENSET_CH5_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH5_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH5_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 4 : Channel 4 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH4_Pos (4UL) /*!< Position of CH4 field. */
++#define PPI_CHENSET_CH4_Msk (0x1UL << PPI_CHENSET_CH4_Pos) /*!< Bit mask of CH4 field. */
++#define PPI_CHENSET_CH4_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH4_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH4_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 3 : Channel 3 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH3_Pos (3UL) /*!< Position of CH3 field. */
++#define PPI_CHENSET_CH3_Msk (0x1UL << PPI_CHENSET_CH3_Pos) /*!< Bit mask of CH3 field. */
++#define PPI_CHENSET_CH3_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH3_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH3_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 2 : Channel 2 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH2_Pos (2UL) /*!< Position of CH2 field. */
++#define PPI_CHENSET_CH2_Msk (0x1UL << PPI_CHENSET_CH2_Pos) /*!< Bit mask of CH2 field. */
++#define PPI_CHENSET_CH2_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH2_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH2_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 1 : Channel 1 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH1_Pos (1UL) /*!< Position of CH1 field. */
++#define PPI_CHENSET_CH1_Msk (0x1UL << PPI_CHENSET_CH1_Pos) /*!< Bit mask of CH1 field. */
++#define PPI_CHENSET_CH1_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH1_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH1_Set (1UL) /*!< Write: Enable channel */
++
++/* Bit 0 : Channel 0 enable set register.  Writing '0' has no effect. */
++#define PPI_CHENSET_CH0_Pos (0UL) /*!< Position of CH0 field. */
++#define PPI_CHENSET_CH0_Msk (0x1UL << PPI_CHENSET_CH0_Pos) /*!< Bit mask of CH0 field. */
++#define PPI_CHENSET_CH0_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENSET_CH0_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENSET_CH0_Set (1UL) /*!< Write: Enable channel */
++
++/* Register: PPI_CHENCLR */
++/* Description: Channel enable clear register */
++
++/* Bit 31 : Channel 31 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH31_Pos (31UL) /*!< Position of CH31 field. */
++#define PPI_CHENCLR_CH31_Msk (0x1UL << PPI_CHENCLR_CH31_Pos) /*!< Bit mask of CH31 field. */
++#define PPI_CHENCLR_CH31_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH31_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH31_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 30 : Channel 30 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH30_Pos (30UL) /*!< Position of CH30 field. */
++#define PPI_CHENCLR_CH30_Msk (0x1UL << PPI_CHENCLR_CH30_Pos) /*!< Bit mask of CH30 field. */
++#define PPI_CHENCLR_CH30_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH30_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH30_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 29 : Channel 29 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH29_Pos (29UL) /*!< Position of CH29 field. */
++#define PPI_CHENCLR_CH29_Msk (0x1UL << PPI_CHENCLR_CH29_Pos) /*!< Bit mask of CH29 field. */
++#define PPI_CHENCLR_CH29_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH29_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH29_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 28 : Channel 28 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH28_Pos (28UL) /*!< Position of CH28 field. */
++#define PPI_CHENCLR_CH28_Msk (0x1UL << PPI_CHENCLR_CH28_Pos) /*!< Bit mask of CH28 field. */
++#define PPI_CHENCLR_CH28_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH28_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH28_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 27 : Channel 27 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH27_Pos (27UL) /*!< Position of CH27 field. */
++#define PPI_CHENCLR_CH27_Msk (0x1UL << PPI_CHENCLR_CH27_Pos) /*!< Bit mask of CH27 field. */
++#define PPI_CHENCLR_CH27_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH27_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH27_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 26 : Channel 26 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH26_Pos (26UL) /*!< Position of CH26 field. */
++#define PPI_CHENCLR_CH26_Msk (0x1UL << PPI_CHENCLR_CH26_Pos) /*!< Bit mask of CH26 field. */
++#define PPI_CHENCLR_CH26_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH26_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH26_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 25 : Channel 25 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH25_Pos (25UL) /*!< Position of CH25 field. */
++#define PPI_CHENCLR_CH25_Msk (0x1UL << PPI_CHENCLR_CH25_Pos) /*!< Bit mask of CH25 field. */
++#define PPI_CHENCLR_CH25_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH25_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH25_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 24 : Channel 24 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH24_Pos (24UL) /*!< Position of CH24 field. */
++#define PPI_CHENCLR_CH24_Msk (0x1UL << PPI_CHENCLR_CH24_Pos) /*!< Bit mask of CH24 field. */
++#define PPI_CHENCLR_CH24_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH24_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH24_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 23 : Channel 23 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH23_Pos (23UL) /*!< Position of CH23 field. */
++#define PPI_CHENCLR_CH23_Msk (0x1UL << PPI_CHENCLR_CH23_Pos) /*!< Bit mask of CH23 field. */
++#define PPI_CHENCLR_CH23_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH23_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH23_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 22 : Channel 22 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH22_Pos (22UL) /*!< Position of CH22 field. */
++#define PPI_CHENCLR_CH22_Msk (0x1UL << PPI_CHENCLR_CH22_Pos) /*!< Bit mask of CH22 field. */
++#define PPI_CHENCLR_CH22_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH22_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH22_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 21 : Channel 21 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH21_Pos (21UL) /*!< Position of CH21 field. */
++#define PPI_CHENCLR_CH21_Msk (0x1UL << PPI_CHENCLR_CH21_Pos) /*!< Bit mask of CH21 field. */
++#define PPI_CHENCLR_CH21_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH21_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH21_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 20 : Channel 20 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH20_Pos (20UL) /*!< Position of CH20 field. */
++#define PPI_CHENCLR_CH20_Msk (0x1UL << PPI_CHENCLR_CH20_Pos) /*!< Bit mask of CH20 field. */
++#define PPI_CHENCLR_CH20_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH20_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH20_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 19 : Channel 19 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH19_Pos (19UL) /*!< Position of CH19 field. */
++#define PPI_CHENCLR_CH19_Msk (0x1UL << PPI_CHENCLR_CH19_Pos) /*!< Bit mask of CH19 field. */
++#define PPI_CHENCLR_CH19_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH19_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH19_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 18 : Channel 18 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH18_Pos (18UL) /*!< Position of CH18 field. */
++#define PPI_CHENCLR_CH18_Msk (0x1UL << PPI_CHENCLR_CH18_Pos) /*!< Bit mask of CH18 field. */
++#define PPI_CHENCLR_CH18_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH18_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH18_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 17 : Channel 17 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH17_Pos (17UL) /*!< Position of CH17 field. */
++#define PPI_CHENCLR_CH17_Msk (0x1UL << PPI_CHENCLR_CH17_Pos) /*!< Bit mask of CH17 field. */
++#define PPI_CHENCLR_CH17_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH17_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH17_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 16 : Channel 16 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH16_Pos (16UL) /*!< Position of CH16 field. */
++#define PPI_CHENCLR_CH16_Msk (0x1UL << PPI_CHENCLR_CH16_Pos) /*!< Bit mask of CH16 field. */
++#define PPI_CHENCLR_CH16_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH16_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH16_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 15 : Channel 15 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH15_Pos (15UL) /*!< Position of CH15 field. */
++#define PPI_CHENCLR_CH15_Msk (0x1UL << PPI_CHENCLR_CH15_Pos) /*!< Bit mask of CH15 field. */
++#define PPI_CHENCLR_CH15_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH15_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH15_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 14 : Channel 14 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH14_Pos (14UL) /*!< Position of CH14 field. */
++#define PPI_CHENCLR_CH14_Msk (0x1UL << PPI_CHENCLR_CH14_Pos) /*!< Bit mask of CH14 field. */
++#define PPI_CHENCLR_CH14_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH14_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH14_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 13 : Channel 13 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH13_Pos (13UL) /*!< Position of CH13 field. */
++#define PPI_CHENCLR_CH13_Msk (0x1UL << PPI_CHENCLR_CH13_Pos) /*!< Bit mask of CH13 field. */
++#define PPI_CHENCLR_CH13_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH13_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH13_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 12 : Channel 12 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH12_Pos (12UL) /*!< Position of CH12 field. */
++#define PPI_CHENCLR_CH12_Msk (0x1UL << PPI_CHENCLR_CH12_Pos) /*!< Bit mask of CH12 field. */
++#define PPI_CHENCLR_CH12_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH12_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH12_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 11 : Channel 11 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH11_Pos (11UL) /*!< Position of CH11 field. */
++#define PPI_CHENCLR_CH11_Msk (0x1UL << PPI_CHENCLR_CH11_Pos) /*!< Bit mask of CH11 field. */
++#define PPI_CHENCLR_CH11_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH11_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH11_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 10 : Channel 10 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH10_Pos (10UL) /*!< Position of CH10 field. */
++#define PPI_CHENCLR_CH10_Msk (0x1UL << PPI_CHENCLR_CH10_Pos) /*!< Bit mask of CH10 field. */
++#define PPI_CHENCLR_CH10_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH10_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH10_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 9 : Channel 9 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH9_Pos (9UL) /*!< Position of CH9 field. */
++#define PPI_CHENCLR_CH9_Msk (0x1UL << PPI_CHENCLR_CH9_Pos) /*!< Bit mask of CH9 field. */
++#define PPI_CHENCLR_CH9_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH9_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH9_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 8 : Channel 8 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH8_Pos (8UL) /*!< Position of CH8 field. */
++#define PPI_CHENCLR_CH8_Msk (0x1UL << PPI_CHENCLR_CH8_Pos) /*!< Bit mask of CH8 field. */
++#define PPI_CHENCLR_CH8_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH8_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH8_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 7 : Channel 7 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH7_Pos (7UL) /*!< Position of CH7 field. */
++#define PPI_CHENCLR_CH7_Msk (0x1UL << PPI_CHENCLR_CH7_Pos) /*!< Bit mask of CH7 field. */
++#define PPI_CHENCLR_CH7_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH7_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH7_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 6 : Channel 6 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH6_Pos (6UL) /*!< Position of CH6 field. */
++#define PPI_CHENCLR_CH6_Msk (0x1UL << PPI_CHENCLR_CH6_Pos) /*!< Bit mask of CH6 field. */
++#define PPI_CHENCLR_CH6_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH6_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH6_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 5 : Channel 5 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH5_Pos (5UL) /*!< Position of CH5 field. */
++#define PPI_CHENCLR_CH5_Msk (0x1UL << PPI_CHENCLR_CH5_Pos) /*!< Bit mask of CH5 field. */
++#define PPI_CHENCLR_CH5_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH5_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH5_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 4 : Channel 4 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH4_Pos (4UL) /*!< Position of CH4 field. */
++#define PPI_CHENCLR_CH4_Msk (0x1UL << PPI_CHENCLR_CH4_Pos) /*!< Bit mask of CH4 field. */
++#define PPI_CHENCLR_CH4_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH4_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH4_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 3 : Channel 3 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH3_Pos (3UL) /*!< Position of CH3 field. */
++#define PPI_CHENCLR_CH3_Msk (0x1UL << PPI_CHENCLR_CH3_Pos) /*!< Bit mask of CH3 field. */
++#define PPI_CHENCLR_CH3_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH3_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH3_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 2 : Channel 2 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH2_Pos (2UL) /*!< Position of CH2 field. */
++#define PPI_CHENCLR_CH2_Msk (0x1UL << PPI_CHENCLR_CH2_Pos) /*!< Bit mask of CH2 field. */
++#define PPI_CHENCLR_CH2_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH2_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH2_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 1 : Channel 1 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH1_Pos (1UL) /*!< Position of CH1 field. */
++#define PPI_CHENCLR_CH1_Msk (0x1UL << PPI_CHENCLR_CH1_Pos) /*!< Bit mask of CH1 field. */
++#define PPI_CHENCLR_CH1_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH1_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH1_Clear (1UL) /*!< Write: disable channel */
++
++/* Bit 0 : Channel 0 enable clear register.  Writing '0' has no effect. */
++#define PPI_CHENCLR_CH0_Pos (0UL) /*!< Position of CH0 field. */
++#define PPI_CHENCLR_CH0_Msk (0x1UL << PPI_CHENCLR_CH0_Pos) /*!< Bit mask of CH0 field. */
++#define PPI_CHENCLR_CH0_Disabled (0UL) /*!< Read: channel disabled */
++#define PPI_CHENCLR_CH0_Enabled (1UL) /*!< Read: channel enabled */
++#define PPI_CHENCLR_CH0_Clear (1UL) /*!< Write: disable channel */
++
++/* Register: PPI_CH_EEP */
++/* Description: Description cluster: Channel n event endpoint */
++
++/* Bits 31..0 : Pointer to event register. Accepts only addresses to registers from the Event group. */
++#define PPI_CH_EEP_EEP_Pos (0UL) /*!< Position of EEP field. */
++#define PPI_CH_EEP_EEP_Msk (0xFFFFFFFFUL << PPI_CH_EEP_EEP_Pos) /*!< Bit mask of EEP field. */
++
++/* Register: PPI_CH_TEP */
++/* Description: Description cluster: Channel n task endpoint */
++
++/* Bits 31..0 : Pointer to task register. Accepts only addresses to registers from the Task group. */
++#define PPI_CH_TEP_TEP_Pos (0UL) /*!< Position of TEP field. */
++#define PPI_CH_TEP_TEP_Msk (0xFFFFFFFFUL << PPI_CH_TEP_TEP_Pos) /*!< Bit mask of TEP field. */
++
++/* Register: PPI_CHG */
++/* Description: Description collection: Channel group n */
++
++/* Bit 31 : Include or exclude channel 31 */
++#define PPI_CHG_CH31_Pos (31UL) /*!< Position of CH31 field. */
++#define PPI_CHG_CH31_Msk (0x1UL << PPI_CHG_CH31_Pos) /*!< Bit mask of CH31 field. */
++#define PPI_CHG_CH31_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH31_Included (1UL) /*!< Include */
++
++/* Bit 30 : Include or exclude channel 30 */
++#define PPI_CHG_CH30_Pos (30UL) /*!< Position of CH30 field. */
++#define PPI_CHG_CH30_Msk (0x1UL << PPI_CHG_CH30_Pos) /*!< Bit mask of CH30 field. */
++#define PPI_CHG_CH30_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH30_Included (1UL) /*!< Include */
++
++/* Bit 29 : Include or exclude channel 29 */
++#define PPI_CHG_CH29_Pos (29UL) /*!< Position of CH29 field. */
++#define PPI_CHG_CH29_Msk (0x1UL << PPI_CHG_CH29_Pos) /*!< Bit mask of CH29 field. */
++#define PPI_CHG_CH29_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH29_Included (1UL) /*!< Include */
++
++/* Bit 28 : Include or exclude channel 28 */
++#define PPI_CHG_CH28_Pos (28UL) /*!< Position of CH28 field. */
++#define PPI_CHG_CH28_Msk (0x1UL << PPI_CHG_CH28_Pos) /*!< Bit mask of CH28 field. */
++#define PPI_CHG_CH28_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH28_Included (1UL) /*!< Include */
++
++/* Bit 27 : Include or exclude channel 27 */
++#define PPI_CHG_CH27_Pos (27UL) /*!< Position of CH27 field. */
++#define PPI_CHG_CH27_Msk (0x1UL << PPI_CHG_CH27_Pos) /*!< Bit mask of CH27 field. */
++#define PPI_CHG_CH27_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH27_Included (1UL) /*!< Include */
++
++/* Bit 26 : Include or exclude channel 26 */
++#define PPI_CHG_CH26_Pos (26UL) /*!< Position of CH26 field. */
++#define PPI_CHG_CH26_Msk (0x1UL << PPI_CHG_CH26_Pos) /*!< Bit mask of CH26 field. */
++#define PPI_CHG_CH26_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH26_Included (1UL) /*!< Include */
++
++/* Bit 25 : Include or exclude channel 25 */
++#define PPI_CHG_CH25_Pos (25UL) /*!< Position of CH25 field. */
++#define PPI_CHG_CH25_Msk (0x1UL << PPI_CHG_CH25_Pos) /*!< Bit mask of CH25 field. */
++#define PPI_CHG_CH25_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH25_Included (1UL) /*!< Include */
++
++/* Bit 24 : Include or exclude channel 24 */
++#define PPI_CHG_CH24_Pos (24UL) /*!< Position of CH24 field. */
++#define PPI_CHG_CH24_Msk (0x1UL << PPI_CHG_CH24_Pos) /*!< Bit mask of CH24 field. */
++#define PPI_CHG_CH24_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH24_Included (1UL) /*!< Include */
++
++/* Bit 23 : Include or exclude channel 23 */
++#define PPI_CHG_CH23_Pos (23UL) /*!< Position of CH23 field. */
++#define PPI_CHG_CH23_Msk (0x1UL << PPI_CHG_CH23_Pos) /*!< Bit mask of CH23 field. */
++#define PPI_CHG_CH23_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH23_Included (1UL) /*!< Include */
++
++/* Bit 22 : Include or exclude channel 22 */
++#define PPI_CHG_CH22_Pos (22UL) /*!< Position of CH22 field. */
++#define PPI_CHG_CH22_Msk (0x1UL << PPI_CHG_CH22_Pos) /*!< Bit mask of CH22 field. */
++#define PPI_CHG_CH22_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH22_Included (1UL) /*!< Include */
++
++/* Bit 21 : Include or exclude channel 21 */
++#define PPI_CHG_CH21_Pos (21UL) /*!< Position of CH21 field. */
++#define PPI_CHG_CH21_Msk (0x1UL << PPI_CHG_CH21_Pos) /*!< Bit mask of CH21 field. */
++#define PPI_CHG_CH21_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH21_Included (1UL) /*!< Include */
++
++/* Bit 20 : Include or exclude channel 20 */
++#define PPI_CHG_CH20_Pos (20UL) /*!< Position of CH20 field. */
++#define PPI_CHG_CH20_Msk (0x1UL << PPI_CHG_CH20_Pos) /*!< Bit mask of CH20 field. */
++#define PPI_CHG_CH20_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH20_Included (1UL) /*!< Include */
++
++/* Bit 19 : Include or exclude channel 19 */
++#define PPI_CHG_CH19_Pos (19UL) /*!< Position of CH19 field. */
++#define PPI_CHG_CH19_Msk (0x1UL << PPI_CHG_CH19_Pos) /*!< Bit mask of CH19 field. */
++#define PPI_CHG_CH19_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH19_Included (1UL) /*!< Include */
++
++/* Bit 18 : Include or exclude channel 18 */
++#define PPI_CHG_CH18_Pos (18UL) /*!< Position of CH18 field. */
++#define PPI_CHG_CH18_Msk (0x1UL << PPI_CHG_CH18_Pos) /*!< Bit mask of CH18 field. */
++#define PPI_CHG_CH18_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH18_Included (1UL) /*!< Include */
++
++/* Bit 17 : Include or exclude channel 17 */
++#define PPI_CHG_CH17_Pos (17UL) /*!< Position of CH17 field. */
++#define PPI_CHG_CH17_Msk (0x1UL << PPI_CHG_CH17_Pos) /*!< Bit mask of CH17 field. */
++#define PPI_CHG_CH17_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH17_Included (1UL) /*!< Include */
++
++/* Bit 16 : Include or exclude channel 16 */
++#define PPI_CHG_CH16_Pos (16UL) /*!< Position of CH16 field. */
++#define PPI_CHG_CH16_Msk (0x1UL << PPI_CHG_CH16_Pos) /*!< Bit mask of CH16 field. */
++#define PPI_CHG_CH16_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH16_Included (1UL) /*!< Include */
++
++/* Bit 15 : Include or exclude channel 15 */
++#define PPI_CHG_CH15_Pos (15UL) /*!< Position of CH15 field. */
++#define PPI_CHG_CH15_Msk (0x1UL << PPI_CHG_CH15_Pos) /*!< Bit mask of CH15 field. */
++#define PPI_CHG_CH15_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH15_Included (1UL) /*!< Include */
++
++/* Bit 14 : Include or exclude channel 14 */
++#define PPI_CHG_CH14_Pos (14UL) /*!< Position of CH14 field. */
++#define PPI_CHG_CH14_Msk (0x1UL << PPI_CHG_CH14_Pos) /*!< Bit mask of CH14 field. */
++#define PPI_CHG_CH14_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH14_Included (1UL) /*!< Include */
++
++/* Bit 13 : Include or exclude channel 13 */
++#define PPI_CHG_CH13_Pos (13UL) /*!< Position of CH13 field. */
++#define PPI_CHG_CH13_Msk (0x1UL << PPI_CHG_CH13_Pos) /*!< Bit mask of CH13 field. */
++#define PPI_CHG_CH13_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH13_Included (1UL) /*!< Include */
++
++/* Bit 12 : Include or exclude channel 12 */
++#define PPI_CHG_CH12_Pos (12UL) /*!< Position of CH12 field. */
++#define PPI_CHG_CH12_Msk (0x1UL << PPI_CHG_CH12_Pos) /*!< Bit mask of CH12 field. */
++#define PPI_CHG_CH12_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH12_Included (1UL) /*!< Include */
++
++/* Bit 11 : Include or exclude channel 11 */
++#define PPI_CHG_CH11_Pos (11UL) /*!< Position of CH11 field. */
++#define PPI_CHG_CH11_Msk (0x1UL << PPI_CHG_CH11_Pos) /*!< Bit mask of CH11 field. */
++#define PPI_CHG_CH11_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH11_Included (1UL) /*!< Include */
++
++/* Bit 10 : Include or exclude channel 10 */
++#define PPI_CHG_CH10_Pos (10UL) /*!< Position of CH10 field. */
++#define PPI_CHG_CH10_Msk (0x1UL << PPI_CHG_CH10_Pos) /*!< Bit mask of CH10 field. */
++#define PPI_CHG_CH10_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH10_Included (1UL) /*!< Include */
++
++/* Bit 9 : Include or exclude channel 9 */
++#define PPI_CHG_CH9_Pos (9UL) /*!< Position of CH9 field. */
++#define PPI_CHG_CH9_Msk (0x1UL << PPI_CHG_CH9_Pos) /*!< Bit mask of CH9 field. */
++#define PPI_CHG_CH9_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH9_Included (1UL) /*!< Include */
++
++/* Bit 8 : Include or exclude channel 8 */
++#define PPI_CHG_CH8_Pos (8UL) /*!< Position of CH8 field. */
++#define PPI_CHG_CH8_Msk (0x1UL << PPI_CHG_CH8_Pos) /*!< Bit mask of CH8 field. */
++#define PPI_CHG_CH8_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH8_Included (1UL) /*!< Include */
++
++/* Bit 7 : Include or exclude channel 7 */
++#define PPI_CHG_CH7_Pos (7UL) /*!< Position of CH7 field. */
++#define PPI_CHG_CH7_Msk (0x1UL << PPI_CHG_CH7_Pos) /*!< Bit mask of CH7 field. */
++#define PPI_CHG_CH7_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH7_Included (1UL) /*!< Include */
++
++/* Bit 6 : Include or exclude channel 6 */
++#define PPI_CHG_CH6_Pos (6UL) /*!< Position of CH6 field. */
++#define PPI_CHG_CH6_Msk (0x1UL << PPI_CHG_CH6_Pos) /*!< Bit mask of CH6 field. */
++#define PPI_CHG_CH6_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH6_Included (1UL) /*!< Include */
++
++/* Bit 5 : Include or exclude channel 5 */
++#define PPI_CHG_CH5_Pos (5UL) /*!< Position of CH5 field. */
++#define PPI_CHG_CH5_Msk (0x1UL << PPI_CHG_CH5_Pos) /*!< Bit mask of CH5 field. */
++#define PPI_CHG_CH5_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH5_Included (1UL) /*!< Include */
++
++/* Bit 4 : Include or exclude channel 4 */
++#define PPI_CHG_CH4_Pos (4UL) /*!< Position of CH4 field. */
++#define PPI_CHG_CH4_Msk (0x1UL << PPI_CHG_CH4_Pos) /*!< Bit mask of CH4 field. */
++#define PPI_CHG_CH4_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH4_Included (1UL) /*!< Include */
++
++/* Bit 3 : Include or exclude channel 3 */
++#define PPI_CHG_CH3_Pos (3UL) /*!< Position of CH3 field. */
++#define PPI_CHG_CH3_Msk (0x1UL << PPI_CHG_CH3_Pos) /*!< Bit mask of CH3 field. */
++#define PPI_CHG_CH3_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH3_Included (1UL) /*!< Include */
++
++/* Bit 2 : Include or exclude channel 2 */
++#define PPI_CHG_CH2_Pos (2UL) /*!< Position of CH2 field. */
++#define PPI_CHG_CH2_Msk (0x1UL << PPI_CHG_CH2_Pos) /*!< Bit mask of CH2 field. */
++#define PPI_CHG_CH2_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH2_Included (1UL) /*!< Include */
++
++/* Bit 1 : Include or exclude channel 1 */
++#define PPI_CHG_CH1_Pos (1UL) /*!< Position of CH1 field. */
++#define PPI_CHG_CH1_Msk (0x1UL << PPI_CHG_CH1_Pos) /*!< Bit mask of CH1 field. */
++#define PPI_CHG_CH1_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH1_Included (1UL) /*!< Include */
++
++/* Bit 0 : Include or exclude channel 0 */
++#define PPI_CHG_CH0_Pos (0UL) /*!< Position of CH0 field. */
++#define PPI_CHG_CH0_Msk (0x1UL << PPI_CHG_CH0_Pos) /*!< Bit mask of CH0 field. */
++#define PPI_CHG_CH0_Excluded (0UL) /*!< Exclude */
++#define PPI_CHG_CH0_Included (1UL) /*!< Include */
++
++/* Register: PPI_FORK_TEP */
++/* Description: Description cluster: Channel n task endpoint */
++
++/* Bits 31..0 : Pointer to task register */
++#define PPI_FORK_TEP_TEP_Pos (0UL) /*!< Position of TEP field. */
++#define PPI_FORK_TEP_TEP_Msk (0xFFFFFFFFUL << PPI_FORK_TEP_TEP_Pos) /*!< Bit mask of TEP field. */
++
++
++/* Peripheral: PWM */
++/* Description: Pulse width modulation unit 0 */
++
++/* Register: PWM_TASKS_STOP */
++/* Description: Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback */
++
++/* Bit 0 : Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback */
++#define PWM_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define PWM_TASKS_STOP_TASKS_STOP_Msk (0x1UL << PWM_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define PWM_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: PWM_TASKS_SEQSTART */
++/* Description: Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running. */
++
++/* Bit 0 : Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ[n]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running. */
++#define PWM_TASKS_SEQSTART_TASKS_SEQSTART_Pos (0UL) /*!< Position of TASKS_SEQSTART field. */
++#define PWM_TASKS_SEQSTART_TASKS_SEQSTART_Msk (0x1UL << PWM_TASKS_SEQSTART_TASKS_SEQSTART_Pos) /*!< Bit mask of TASKS_SEQSTART field. */
++#define PWM_TASKS_SEQSTART_TASKS_SEQSTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: PWM_TASKS_NEXTSTEP */
++/* Description: Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running. */
++
++/* Bit 0 : Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running. */
++#define PWM_TASKS_NEXTSTEP_TASKS_NEXTSTEP_Pos (0UL) /*!< Position of TASKS_NEXTSTEP field. */
++#define PWM_TASKS_NEXTSTEP_TASKS_NEXTSTEP_Msk (0x1UL << PWM_TASKS_NEXTSTEP_TASKS_NEXTSTEP_Pos) /*!< Bit mask of TASKS_NEXTSTEP field. */
++#define PWM_TASKS_NEXTSTEP_TASKS_NEXTSTEP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: PWM_EVENTS_STOPPED */
++/* Description: Response to STOP task, emitted when PWM pulses are no longer generated */
++
++/* Bit 0 : Response to STOP task, emitted when PWM pulses are no longer generated */
++#define PWM_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define PWM_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << PWM_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define PWM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define PWM_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: PWM_EVENTS_SEQSTARTED */
++/* Description: Description collection: First PWM period started on sequence n */
++
++/* Bit 0 : First PWM period started on sequence n */
++#define PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_Pos (0UL) /*!< Position of EVENTS_SEQSTARTED field. */
++#define PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_Msk (0x1UL << PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_Pos) /*!< Bit mask of EVENTS_SEQSTARTED field. */
++#define PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define PWM_EVENTS_SEQSTARTED_EVENTS_SEQSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: PWM_EVENTS_SEQEND */
++/* Description: Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter */
++
++/* Bit 0 : Emitted at end of every sequence n, when last value from RAM has been applied to wave counter */
++#define PWM_EVENTS_SEQEND_EVENTS_SEQEND_Pos (0UL) /*!< Position of EVENTS_SEQEND field. */
++#define PWM_EVENTS_SEQEND_EVENTS_SEQEND_Msk (0x1UL << PWM_EVENTS_SEQEND_EVENTS_SEQEND_Pos) /*!< Bit mask of EVENTS_SEQEND field. */
++#define PWM_EVENTS_SEQEND_EVENTS_SEQEND_NotGenerated (0UL) /*!< Event not generated */
++#define PWM_EVENTS_SEQEND_EVENTS_SEQEND_Generated (1UL) /*!< Event generated */
++
++/* Register: PWM_EVENTS_PWMPERIODEND */
++/* Description: Emitted at the end of each PWM period */
++
++/* Bit 0 : Emitted at the end of each PWM period */
++#define PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_Pos (0UL) /*!< Position of EVENTS_PWMPERIODEND field. */
++#define PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_Msk (0x1UL << PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_Pos) /*!< Bit mask of EVENTS_PWMPERIODEND field. */
++#define PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_NotGenerated (0UL) /*!< Event not generated */
++#define PWM_EVENTS_PWMPERIODEND_EVENTS_PWMPERIODEND_Generated (1UL) /*!< Event generated */
++
++/* Register: PWM_EVENTS_LOOPSDONE */
++/* Description: Concatenated sequences have been played the amount of times defined in LOOP.CNT */
++
++/* Bit 0 : Concatenated sequences have been played the amount of times defined in LOOP.CNT */
++#define PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_Pos (0UL) /*!< Position of EVENTS_LOOPSDONE field. */
++#define PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_Msk (0x1UL << PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_Pos) /*!< Bit mask of EVENTS_LOOPSDONE field. */
++#define PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_NotGenerated (0UL) /*!< Event not generated */
++#define PWM_EVENTS_LOOPSDONE_EVENTS_LOOPSDONE_Generated (1UL) /*!< Event generated */
++
++/* Register: PWM_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 4 : Shortcut between event LOOPSDONE and task STOP */
++#define PWM_SHORTS_LOOPSDONE_STOP_Pos (4UL) /*!< Position of LOOPSDONE_STOP field. */
++#define PWM_SHORTS_LOOPSDONE_STOP_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_STOP_Pos) /*!< Bit mask of LOOPSDONE_STOP field. */
++#define PWM_SHORTS_LOOPSDONE_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define PWM_SHORTS_LOOPSDONE_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 3 : Shortcut between event LOOPSDONE and task SEQSTART[1] */
++#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Pos (3UL) /*!< Position of LOOPSDONE_SEQSTART1 field. */
++#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_SEQSTART1_Pos) /*!< Bit mask of LOOPSDONE_SEQSTART1 field. */
++#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Disabled (0UL) /*!< Disable shortcut */
++#define PWM_SHORTS_LOOPSDONE_SEQSTART1_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 2 : Shortcut between event LOOPSDONE and task SEQSTART[0] */
++#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Pos (2UL) /*!< Position of LOOPSDONE_SEQSTART0 field. */
++#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Msk (0x1UL << PWM_SHORTS_LOOPSDONE_SEQSTART0_Pos) /*!< Bit mask of LOOPSDONE_SEQSTART0 field. */
++#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Disabled (0UL) /*!< Disable shortcut */
++#define PWM_SHORTS_LOOPSDONE_SEQSTART0_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 1 : Shortcut between event SEQEND[1] and task STOP */
++#define PWM_SHORTS_SEQEND1_STOP_Pos (1UL) /*!< Position of SEQEND1_STOP field. */
++#define PWM_SHORTS_SEQEND1_STOP_Msk (0x1UL << PWM_SHORTS_SEQEND1_STOP_Pos) /*!< Bit mask of SEQEND1_STOP field. */
++#define PWM_SHORTS_SEQEND1_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define PWM_SHORTS_SEQEND1_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event SEQEND[0] and task STOP */
++#define PWM_SHORTS_SEQEND0_STOP_Pos (0UL) /*!< Position of SEQEND0_STOP field. */
++#define PWM_SHORTS_SEQEND0_STOP_Msk (0x1UL << PWM_SHORTS_SEQEND0_STOP_Pos) /*!< Bit mask of SEQEND0_STOP field. */
++#define PWM_SHORTS_SEQEND0_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define PWM_SHORTS_SEQEND0_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: PWM_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 7 : Enable or disable interrupt for event LOOPSDONE */
++#define PWM_INTEN_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
++#define PWM_INTEN_LOOPSDONE_Msk (0x1UL << PWM_INTEN_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
++#define PWM_INTEN_LOOPSDONE_Disabled (0UL) /*!< Disable */
++#define PWM_INTEN_LOOPSDONE_Enabled (1UL) /*!< Enable */
++
++/* Bit 6 : Enable or disable interrupt for event PWMPERIODEND */
++#define PWM_INTEN_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
++#define PWM_INTEN_PWMPERIODEND_Msk (0x1UL << PWM_INTEN_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
++#define PWM_INTEN_PWMPERIODEND_Disabled (0UL) /*!< Disable */
++#define PWM_INTEN_PWMPERIODEND_Enabled (1UL) /*!< Enable */
++
++/* Bit 5 : Enable or disable interrupt for event SEQEND[1] */
++#define PWM_INTEN_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
++#define PWM_INTEN_SEQEND1_Msk (0x1UL << PWM_INTEN_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
++#define PWM_INTEN_SEQEND1_Disabled (0UL) /*!< Disable */
++#define PWM_INTEN_SEQEND1_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable interrupt for event SEQEND[0] */
++#define PWM_INTEN_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
++#define PWM_INTEN_SEQEND0_Msk (0x1UL << PWM_INTEN_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
++#define PWM_INTEN_SEQEND0_Disabled (0UL) /*!< Disable */
++#define PWM_INTEN_SEQEND0_Enabled (1UL) /*!< Enable */
++
++/* Bit 3 : Enable or disable interrupt for event SEQSTARTED[1] */
++#define PWM_INTEN_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
++#define PWM_INTEN_SEQSTARTED1_Msk (0x1UL << PWM_INTEN_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
++#define PWM_INTEN_SEQSTARTED1_Disabled (0UL) /*!< Disable */
++#define PWM_INTEN_SEQSTARTED1_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event SEQSTARTED[0] */
++#define PWM_INTEN_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
++#define PWM_INTEN_SEQSTARTED0_Msk (0x1UL << PWM_INTEN_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
++#define PWM_INTEN_SEQSTARTED0_Disabled (0UL) /*!< Disable */
++#define PWM_INTEN_SEQSTARTED0_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event STOPPED */
++#define PWM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define PWM_INTEN_STOPPED_Msk (0x1UL << PWM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define PWM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
++#define PWM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
++
++/* Register: PWM_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 7 : Write '1' to enable interrupt for event LOOPSDONE */
++#define PWM_INTENSET_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
++#define PWM_INTENSET_LOOPSDONE_Msk (0x1UL << PWM_INTENSET_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
++#define PWM_INTENSET_LOOPSDONE_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENSET_LOOPSDONE_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENSET_LOOPSDONE_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event PWMPERIODEND */
++#define PWM_INTENSET_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
++#define PWM_INTENSET_PWMPERIODEND_Msk (0x1UL << PWM_INTENSET_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
++#define PWM_INTENSET_PWMPERIODEND_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENSET_PWMPERIODEND_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENSET_PWMPERIODEND_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event SEQEND[1] */
++#define PWM_INTENSET_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
++#define PWM_INTENSET_SEQEND1_Msk (0x1UL << PWM_INTENSET_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
++#define PWM_INTENSET_SEQEND1_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENSET_SEQEND1_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENSET_SEQEND1_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event SEQEND[0] */
++#define PWM_INTENSET_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
++#define PWM_INTENSET_SEQEND0_Msk (0x1UL << PWM_INTENSET_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
++#define PWM_INTENSET_SEQEND0_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENSET_SEQEND0_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENSET_SEQEND0_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event SEQSTARTED[1] */
++#define PWM_INTENSET_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
++#define PWM_INTENSET_SEQSTARTED1_Msk (0x1UL << PWM_INTENSET_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
++#define PWM_INTENSET_SEQSTARTED1_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENSET_SEQSTARTED1_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENSET_SEQSTARTED1_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event SEQSTARTED[0] */
++#define PWM_INTENSET_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
++#define PWM_INTENSET_SEQSTARTED0_Msk (0x1UL << PWM_INTENSET_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
++#define PWM_INTENSET_SEQSTARTED0_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENSET_SEQSTARTED0_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENSET_SEQSTARTED0_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event STOPPED */
++#define PWM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define PWM_INTENSET_STOPPED_Msk (0x1UL << PWM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define PWM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Register: PWM_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 7 : Write '1' to disable interrupt for event LOOPSDONE */
++#define PWM_INTENCLR_LOOPSDONE_Pos (7UL) /*!< Position of LOOPSDONE field. */
++#define PWM_INTENCLR_LOOPSDONE_Msk (0x1UL << PWM_INTENCLR_LOOPSDONE_Pos) /*!< Bit mask of LOOPSDONE field. */
++#define PWM_INTENCLR_LOOPSDONE_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENCLR_LOOPSDONE_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENCLR_LOOPSDONE_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event PWMPERIODEND */
++#define PWM_INTENCLR_PWMPERIODEND_Pos (6UL) /*!< Position of PWMPERIODEND field. */
++#define PWM_INTENCLR_PWMPERIODEND_Msk (0x1UL << PWM_INTENCLR_PWMPERIODEND_Pos) /*!< Bit mask of PWMPERIODEND field. */
++#define PWM_INTENCLR_PWMPERIODEND_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENCLR_PWMPERIODEND_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENCLR_PWMPERIODEND_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event SEQEND[1] */
++#define PWM_INTENCLR_SEQEND1_Pos (5UL) /*!< Position of SEQEND1 field. */
++#define PWM_INTENCLR_SEQEND1_Msk (0x1UL << PWM_INTENCLR_SEQEND1_Pos) /*!< Bit mask of SEQEND1 field. */
++#define PWM_INTENCLR_SEQEND1_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENCLR_SEQEND1_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENCLR_SEQEND1_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event SEQEND[0] */
++#define PWM_INTENCLR_SEQEND0_Pos (4UL) /*!< Position of SEQEND0 field. */
++#define PWM_INTENCLR_SEQEND0_Msk (0x1UL << PWM_INTENCLR_SEQEND0_Pos) /*!< Bit mask of SEQEND0 field. */
++#define PWM_INTENCLR_SEQEND0_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENCLR_SEQEND0_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENCLR_SEQEND0_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event SEQSTARTED[1] */
++#define PWM_INTENCLR_SEQSTARTED1_Pos (3UL) /*!< Position of SEQSTARTED1 field. */
++#define PWM_INTENCLR_SEQSTARTED1_Msk (0x1UL << PWM_INTENCLR_SEQSTARTED1_Pos) /*!< Bit mask of SEQSTARTED1 field. */
++#define PWM_INTENCLR_SEQSTARTED1_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENCLR_SEQSTARTED1_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENCLR_SEQSTARTED1_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event SEQSTARTED[0] */
++#define PWM_INTENCLR_SEQSTARTED0_Pos (2UL) /*!< Position of SEQSTARTED0 field. */
++#define PWM_INTENCLR_SEQSTARTED0_Msk (0x1UL << PWM_INTENCLR_SEQSTARTED0_Pos) /*!< Bit mask of SEQSTARTED0 field. */
++#define PWM_INTENCLR_SEQSTARTED0_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENCLR_SEQSTARTED0_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENCLR_SEQSTARTED0_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event STOPPED */
++#define PWM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define PWM_INTENCLR_STOPPED_Msk (0x1UL << PWM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define PWM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define PWM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define PWM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Register: PWM_ENABLE */
++/* Description: PWM module enable register */
++
++/* Bit 0 : Enable or disable PWM module */
++#define PWM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define PWM_ENABLE_ENABLE_Msk (0x1UL << PWM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define PWM_ENABLE_ENABLE_Disabled (0UL) /*!< Disabled */
++#define PWM_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
++
++/* Register: PWM_MODE */
++/* Description: Selects operating mode of the wave counter */
++
++/* Bit 0 : Selects up mode or up-and-down mode for the counter */
++#define PWM_MODE_UPDOWN_Pos (0UL) /*!< Position of UPDOWN field. */
++#define PWM_MODE_UPDOWN_Msk (0x1UL << PWM_MODE_UPDOWN_Pos) /*!< Bit mask of UPDOWN field. */
++#define PWM_MODE_UPDOWN_Up (0UL) /*!< Up counter, edge-aligned PWM duty cycle */
++#define PWM_MODE_UPDOWN_UpAndDown (1UL) /*!< Up and down counter, center-aligned PWM duty cycle */
++
++/* Register: PWM_COUNTERTOP */
++/* Description: Value up to which the pulse generator counter counts */
++
++/* Bits 14..0 : Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used. */
++#define PWM_COUNTERTOP_COUNTERTOP_Pos (0UL) /*!< Position of COUNTERTOP field. */
++#define PWM_COUNTERTOP_COUNTERTOP_Msk (0x7FFFUL << PWM_COUNTERTOP_COUNTERTOP_Pos) /*!< Bit mask of COUNTERTOP field. */
++
++/* Register: PWM_PRESCALER */
++/* Description: Configuration for PWM_CLK */
++
++/* Bits 2..0 : Prescaler of PWM_CLK */
++#define PWM_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
++#define PWM_PRESCALER_PRESCALER_Msk (0x7UL << PWM_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
++#define PWM_PRESCALER_PRESCALER_DIV_1 (0UL) /*!< Divide by 1 (16 MHz) */
++#define PWM_PRESCALER_PRESCALER_DIV_2 (1UL) /*!< Divide by 2 (8 MHz) */
++#define PWM_PRESCALER_PRESCALER_DIV_4 (2UL) /*!< Divide by 4 (4 MHz) */
++#define PWM_PRESCALER_PRESCALER_DIV_8 (3UL) /*!< Divide by 8 (2 MHz) */
++#define PWM_PRESCALER_PRESCALER_DIV_16 (4UL) /*!< Divide by 16 (1 MHz) */
++#define PWM_PRESCALER_PRESCALER_DIV_32 (5UL) /*!< Divide by 32 (500 kHz) */
++#define PWM_PRESCALER_PRESCALER_DIV_64 (6UL) /*!< Divide by 64 (250 kHz) */
++#define PWM_PRESCALER_PRESCALER_DIV_128 (7UL) /*!< Divide by 128 (125 kHz) */
++
++/* Register: PWM_DECODER */
++/* Description: Configuration of the decoder */
++
++/* Bit 8 : Selects source for advancing the active sequence */
++#define PWM_DECODER_MODE_Pos (8UL) /*!< Position of MODE field. */
++#define PWM_DECODER_MODE_Msk (0x1UL << PWM_DECODER_MODE_Pos) /*!< Bit mask of MODE field. */
++#define PWM_DECODER_MODE_RefreshCount (0UL) /*!< SEQ[n].REFRESH is used to determine loading internal compare registers */
++#define PWM_DECODER_MODE_NextStep (1UL) /*!< NEXTSTEP task causes a new value to be loaded to internal compare registers */
++
++/* Bits 1..0 : How a sequence is read from RAM and spread to the compare register */
++#define PWM_DECODER_LOAD_Pos (0UL) /*!< Position of LOAD field. */
++#define PWM_DECODER_LOAD_Msk (0x3UL << PWM_DECODER_LOAD_Pos) /*!< Bit mask of LOAD field. */
++#define PWM_DECODER_LOAD_Common (0UL) /*!< 1st half word (16-bit) used in all PWM channels 0..3 */
++#define PWM_DECODER_LOAD_Grouped (1UL) /*!< 1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3 */
++#define PWM_DECODER_LOAD_Individual (2UL) /*!< 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3 */
++#define PWM_DECODER_LOAD_WaveForm (3UL) /*!< 1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP */
++
++/* Register: PWM_LOOP */
++/* Description: Number of playbacks of a loop */
++
++/* Bits 15..0 : Number of playbacks of pattern cycles */
++#define PWM_LOOP_CNT_Pos (0UL) /*!< Position of CNT field. */
++#define PWM_LOOP_CNT_Msk (0xFFFFUL << PWM_LOOP_CNT_Pos) /*!< Bit mask of CNT field. */
++#define PWM_LOOP_CNT_Disabled (0UL) /*!< Looping disabled (stop at the end of the sequence) */
++
++/* Register: PWM_SEQ_PTR */
++/* Description: Description cluster: Beginning address in RAM of this sequence */
++
++/* Bits 31..0 : Beginning address in RAM of this sequence */
++#define PWM_SEQ_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define PWM_SEQ_PTR_PTR_Msk (0xFFFFFFFFUL << PWM_SEQ_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: PWM_SEQ_CNT */
++/* Description: Description cluster: Number of values (duty cycles) in this sequence */
++
++/* Bits 14..0 : Number of values (duty cycles) in this sequence */
++#define PWM_SEQ_CNT_CNT_Pos (0UL) /*!< Position of CNT field. */
++#define PWM_SEQ_CNT_CNT_Msk (0x7FFFUL << PWM_SEQ_CNT_CNT_Pos) /*!< Bit mask of CNT field. */
++#define PWM_SEQ_CNT_CNT_Disabled (0UL) /*!< Sequence is disabled, and shall not be started as it is empty */
++
++/* Register: PWM_SEQ_REFRESH */
++/* Description: Description cluster: Number of additional PWM periods between samples loaded into compare register */
++
++/* Bits 23..0 : Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods) */
++#define PWM_SEQ_REFRESH_CNT_Pos (0UL) /*!< Position of CNT field. */
++#define PWM_SEQ_REFRESH_CNT_Msk (0xFFFFFFUL << PWM_SEQ_REFRESH_CNT_Pos) /*!< Bit mask of CNT field. */
++#define PWM_SEQ_REFRESH_CNT_Continuous (0UL) /*!< Update every PWM period */
++
++/* Register: PWM_SEQ_ENDDELAY */
++/* Description: Description cluster: Time added after the sequence */
++
++/* Bits 23..0 : Time added after the sequence in PWM periods */
++#define PWM_SEQ_ENDDELAY_CNT_Pos (0UL) /*!< Position of CNT field. */
++#define PWM_SEQ_ENDDELAY_CNT_Msk (0xFFFFFFUL << PWM_SEQ_ENDDELAY_CNT_Pos) /*!< Bit mask of CNT field. */
++
++/* Register: PWM_PSEL_OUT */
++/* Description: Description collection: Output pin select for PWM channel n */
++
++/* Bit 31 : Connection */
++#define PWM_PSEL_OUT_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define PWM_PSEL_OUT_CONNECT_Msk (0x1UL << PWM_PSEL_OUT_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define PWM_PSEL_OUT_CONNECT_Connected (0UL) /*!< Connect */
++#define PWM_PSEL_OUT_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define PWM_PSEL_OUT_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define PWM_PSEL_OUT_PORT_Msk (0x1UL << PWM_PSEL_OUT_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define PWM_PSEL_OUT_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define PWM_PSEL_OUT_PIN_Msk (0x1FUL << PWM_PSEL_OUT_PIN_Pos) /*!< Bit mask of PIN field. */
++
++
++/* Peripheral: QDEC */
++/* Description: Quadrature Decoder */
++
++/* Register: QDEC_TASKS_START */
++/* Description: Task starting the quadrature decoder */
++
++/* Bit 0 : Task starting the quadrature decoder */
++#define QDEC_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define QDEC_TASKS_START_TASKS_START_Msk (0x1UL << QDEC_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define QDEC_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QDEC_TASKS_STOP */
++/* Description: Task stopping the quadrature decoder */
++
++/* Bit 0 : Task stopping the quadrature decoder */
++#define QDEC_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define QDEC_TASKS_STOP_TASKS_STOP_Msk (0x1UL << QDEC_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define QDEC_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QDEC_TASKS_READCLRACC */
++/* Description: Read and clear ACC and ACCDBL */
++
++/* Bit 0 : Read and clear ACC and ACCDBL */
++#define QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Pos (0UL) /*!< Position of TASKS_READCLRACC field. */
++#define QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Msk (0x1UL << QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Pos) /*!< Bit mask of TASKS_READCLRACC field. */
++#define QDEC_TASKS_READCLRACC_TASKS_READCLRACC_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QDEC_TASKS_RDCLRACC */
++/* Description: Read and clear ACC */
++
++/* Bit 0 : Read and clear ACC */
++#define QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Pos (0UL) /*!< Position of TASKS_RDCLRACC field. */
++#define QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Msk (0x1UL << QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Pos) /*!< Bit mask of TASKS_RDCLRACC field. */
++#define QDEC_TASKS_RDCLRACC_TASKS_RDCLRACC_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QDEC_TASKS_RDCLRDBL */
++/* Description: Read and clear ACCDBL */
++
++/* Bit 0 : Read and clear ACCDBL */
++#define QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Pos (0UL) /*!< Position of TASKS_RDCLRDBL field. */
++#define QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Msk (0x1UL << QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Pos) /*!< Bit mask of TASKS_RDCLRDBL field. */
++#define QDEC_TASKS_RDCLRDBL_TASKS_RDCLRDBL_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QDEC_EVENTS_SAMPLERDY */
++/* Description: Event being generated for every new sample value written to the SAMPLE register */
++
++/* Bit 0 : Event being generated for every new sample value written to the SAMPLE register */
++#define QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Pos (0UL) /*!< Position of EVENTS_SAMPLERDY field. */
++#define QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Msk (0x1UL << QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Pos) /*!< Bit mask of EVENTS_SAMPLERDY field. */
++#define QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_NotGenerated (0UL) /*!< Event not generated */
++#define QDEC_EVENTS_SAMPLERDY_EVENTS_SAMPLERDY_Generated (1UL) /*!< Event generated */
++
++/* Register: QDEC_EVENTS_REPORTRDY */
++/* Description: Non-null report ready */
++
++/* Bit 0 : Non-null report ready */
++#define QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Pos (0UL) /*!< Position of EVENTS_REPORTRDY field. */
++#define QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Msk (0x1UL << QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Pos) /*!< Bit mask of EVENTS_REPORTRDY field. */
++#define QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_NotGenerated (0UL) /*!< Event not generated */
++#define QDEC_EVENTS_REPORTRDY_EVENTS_REPORTRDY_Generated (1UL) /*!< Event generated */
++
++/* Register: QDEC_EVENTS_ACCOF */
++/* Description: ACC or ACCDBL register overflow */
++
++/* Bit 0 : ACC or ACCDBL register overflow */
++#define QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Pos (0UL) /*!< Position of EVENTS_ACCOF field. */
++#define QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Msk (0x1UL << QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Pos) /*!< Bit mask of EVENTS_ACCOF field. */
++#define QDEC_EVENTS_ACCOF_EVENTS_ACCOF_NotGenerated (0UL) /*!< Event not generated */
++#define QDEC_EVENTS_ACCOF_EVENTS_ACCOF_Generated (1UL) /*!< Event generated */
++
++/* Register: QDEC_EVENTS_DBLRDY */
++/* Description: Double displacement(s) detected */
++
++/* Bit 0 : Double displacement(s) detected */
++#define QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Pos (0UL) /*!< Position of EVENTS_DBLRDY field. */
++#define QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Msk (0x1UL << QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Pos) /*!< Bit mask of EVENTS_DBLRDY field. */
++#define QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_NotGenerated (0UL) /*!< Event not generated */
++#define QDEC_EVENTS_DBLRDY_EVENTS_DBLRDY_Generated (1UL) /*!< Event generated */
++
++/* Register: QDEC_EVENTS_STOPPED */
++/* Description: QDEC has been stopped */
++
++/* Bit 0 : QDEC has been stopped */
++#define QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define QDEC_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define QDEC_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: QDEC_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 6 : Shortcut between event SAMPLERDY and task READCLRACC */
++#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos (6UL) /*!< Position of SAMPLERDY_READCLRACC field. */
++#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_READCLRACC_Pos) /*!< Bit mask of SAMPLERDY_READCLRACC field. */
++#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Disabled (0UL) /*!< Disable shortcut */
++#define QDEC_SHORTS_SAMPLERDY_READCLRACC_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 5 : Shortcut between event DBLRDY and task STOP */
++#define QDEC_SHORTS_DBLRDY_STOP_Pos (5UL) /*!< Position of DBLRDY_STOP field. */
++#define QDEC_SHORTS_DBLRDY_STOP_Msk (0x1UL << QDEC_SHORTS_DBLRDY_STOP_Pos) /*!< Bit mask of DBLRDY_STOP field. */
++#define QDEC_SHORTS_DBLRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define QDEC_SHORTS_DBLRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 4 : Shortcut between event DBLRDY and task RDCLRDBL */
++#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos (4UL) /*!< Position of DBLRDY_RDCLRDBL field. */
++#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Msk (0x1UL << QDEC_SHORTS_DBLRDY_RDCLRDBL_Pos) /*!< Bit mask of DBLRDY_RDCLRDBL field. */
++#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Disabled (0UL) /*!< Disable shortcut */
++#define QDEC_SHORTS_DBLRDY_RDCLRDBL_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 3 : Shortcut between event REPORTRDY and task STOP */
++#define QDEC_SHORTS_REPORTRDY_STOP_Pos (3UL) /*!< Position of REPORTRDY_STOP field. */
++#define QDEC_SHORTS_REPORTRDY_STOP_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_STOP_Pos) /*!< Bit mask of REPORTRDY_STOP field. */
++#define QDEC_SHORTS_REPORTRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define QDEC_SHORTS_REPORTRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 2 : Shortcut between event REPORTRDY and task RDCLRACC */
++#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos (2UL) /*!< Position of REPORTRDY_RDCLRACC field. */
++#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_RDCLRACC_Pos) /*!< Bit mask of REPORTRDY_RDCLRACC field. */
++#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Disabled (0UL) /*!< Disable shortcut */
++#define QDEC_SHORTS_REPORTRDY_RDCLRACC_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 1 : Shortcut between event SAMPLERDY and task STOP */
++#define QDEC_SHORTS_SAMPLERDY_STOP_Pos (1UL) /*!< Position of SAMPLERDY_STOP field. */
++#define QDEC_SHORTS_SAMPLERDY_STOP_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_STOP_Pos) /*!< Bit mask of SAMPLERDY_STOP field. */
++#define QDEC_SHORTS_SAMPLERDY_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define QDEC_SHORTS_SAMPLERDY_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event REPORTRDY and task READCLRACC */
++#define QDEC_SHORTS_REPORTRDY_READCLRACC_Pos (0UL) /*!< Position of REPORTRDY_READCLRACC field. */
++#define QDEC_SHORTS_REPORTRDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_READCLRACC_Pos) /*!< Bit mask of REPORTRDY_READCLRACC field. */
++#define QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled (0UL) /*!< Disable shortcut */
++#define QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: QDEC_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 4 : Write '1' to enable interrupt for event STOPPED */
++#define QDEC_INTENSET_STOPPED_Pos (4UL) /*!< Position of STOPPED field. */
++#define QDEC_INTENSET_STOPPED_Msk (0x1UL << QDEC_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define QDEC_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event DBLRDY */
++#define QDEC_INTENSET_DBLRDY_Pos (3UL) /*!< Position of DBLRDY field. */
++#define QDEC_INTENSET_DBLRDY_Msk (0x1UL << QDEC_INTENSET_DBLRDY_Pos) /*!< Bit mask of DBLRDY field. */
++#define QDEC_INTENSET_DBLRDY_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENSET_DBLRDY_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENSET_DBLRDY_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event ACCOF */
++#define QDEC_INTENSET_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
++#define QDEC_INTENSET_ACCOF_Msk (0x1UL << QDEC_INTENSET_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
++#define QDEC_INTENSET_ACCOF_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENSET_ACCOF_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENSET_ACCOF_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event REPORTRDY */
++#define QDEC_INTENSET_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
++#define QDEC_INTENSET_REPORTRDY_Msk (0x1UL << QDEC_INTENSET_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
++#define QDEC_INTENSET_REPORTRDY_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENSET_REPORTRDY_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENSET_REPORTRDY_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event SAMPLERDY */
++#define QDEC_INTENSET_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
++#define QDEC_INTENSET_SAMPLERDY_Msk (0x1UL << QDEC_INTENSET_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
++#define QDEC_INTENSET_SAMPLERDY_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENSET_SAMPLERDY_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENSET_SAMPLERDY_Set (1UL) /*!< Enable */
++
++/* Register: QDEC_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 4 : Write '1' to disable interrupt for event STOPPED */
++#define QDEC_INTENCLR_STOPPED_Pos (4UL) /*!< Position of STOPPED field. */
++#define QDEC_INTENCLR_STOPPED_Msk (0x1UL << QDEC_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define QDEC_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event DBLRDY */
++#define QDEC_INTENCLR_DBLRDY_Pos (3UL) /*!< Position of DBLRDY field. */
++#define QDEC_INTENCLR_DBLRDY_Msk (0x1UL << QDEC_INTENCLR_DBLRDY_Pos) /*!< Bit mask of DBLRDY field. */
++#define QDEC_INTENCLR_DBLRDY_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENCLR_DBLRDY_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENCLR_DBLRDY_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event ACCOF */
++#define QDEC_INTENCLR_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
++#define QDEC_INTENCLR_ACCOF_Msk (0x1UL << QDEC_INTENCLR_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
++#define QDEC_INTENCLR_ACCOF_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENCLR_ACCOF_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENCLR_ACCOF_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event REPORTRDY */
++#define QDEC_INTENCLR_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
++#define QDEC_INTENCLR_REPORTRDY_Msk (0x1UL << QDEC_INTENCLR_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
++#define QDEC_INTENCLR_REPORTRDY_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENCLR_REPORTRDY_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENCLR_REPORTRDY_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event SAMPLERDY */
++#define QDEC_INTENCLR_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
++#define QDEC_INTENCLR_SAMPLERDY_Msk (0x1UL << QDEC_INTENCLR_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
++#define QDEC_INTENCLR_SAMPLERDY_Disabled (0UL) /*!< Read: Disabled */
++#define QDEC_INTENCLR_SAMPLERDY_Enabled (1UL) /*!< Read: Enabled */
++#define QDEC_INTENCLR_SAMPLERDY_Clear (1UL) /*!< Disable */
++
++/* Register: QDEC_ENABLE */
++/* Description: Enable the quadrature decoder */
++
++/* Bit 0 : Enable or disable the quadrature decoder */
++#define QDEC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define QDEC_ENABLE_ENABLE_Msk (0x1UL << QDEC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define QDEC_ENABLE_ENABLE_Disabled (0UL) /*!< Disable */
++#define QDEC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable */
++
++/* Register: QDEC_LEDPOL */
++/* Description: LED output pin polarity */
++
++/* Bit 0 : LED output pin polarity */
++#define QDEC_LEDPOL_LEDPOL_Pos (0UL) /*!< Position of LEDPOL field. */
++#define QDEC_LEDPOL_LEDPOL_Msk (0x1UL << QDEC_LEDPOL_LEDPOL_Pos) /*!< Bit mask of LEDPOL field. */
++#define QDEC_LEDPOL_LEDPOL_ActiveLow (0UL) /*!< Led active on output pin low */
++#define QDEC_LEDPOL_LEDPOL_ActiveHigh (1UL) /*!< Led active on output pin high */
++
++/* Register: QDEC_SAMPLEPER */
++/* Description: Sample period */
++
++/* Bits 3..0 : Sample period. The SAMPLE register will be updated for every new sample */
++#define QDEC_SAMPLEPER_SAMPLEPER_Pos (0UL) /*!< Position of SAMPLEPER field. */
++#define QDEC_SAMPLEPER_SAMPLEPER_Msk (0xFUL << QDEC_SAMPLEPER_SAMPLEPER_Pos) /*!< Bit mask of SAMPLEPER field. */
++#define QDEC_SAMPLEPER_SAMPLEPER_128us (0UL) /*!< 128 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_256us (1UL) /*!< 256 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_512us (2UL) /*!< 512 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_1024us (3UL) /*!< 1024 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_2048us (4UL) /*!< 2048 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_4096us (5UL) /*!< 4096 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_8192us (6UL) /*!< 8192 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_16384us (7UL) /*!< 16384 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_32ms (8UL) /*!< 32768 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_65ms (9UL) /*!< 65536 us */
++#define QDEC_SAMPLEPER_SAMPLEPER_131ms (10UL) /*!< 131072 us */
++
++/* Register: QDEC_SAMPLE */
++/* Description: Motion sample value */
++
++/* Bits 31..0 : Last motion sample */
++#define QDEC_SAMPLE_SAMPLE_Pos (0UL) /*!< Position of SAMPLE field. */
++#define QDEC_SAMPLE_SAMPLE_Msk (0xFFFFFFFFUL << QDEC_SAMPLE_SAMPLE_Pos) /*!< Bit mask of SAMPLE field. */
++
++/* Register: QDEC_REPORTPER */
++/* Description: Number of samples to be taken before REPORTRDY and DBLRDY events can be generated */
++
++/* Bits 3..0 : Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated. */
++#define QDEC_REPORTPER_REPORTPER_Pos (0UL) /*!< Position of REPORTPER field. */
++#define QDEC_REPORTPER_REPORTPER_Msk (0xFUL << QDEC_REPORTPER_REPORTPER_Pos) /*!< Bit mask of REPORTPER field. */
++#define QDEC_REPORTPER_REPORTPER_10Smpl (0UL) /*!< 10 samples/report */
++#define QDEC_REPORTPER_REPORTPER_40Smpl (1UL) /*!< 40 samples/report */
++#define QDEC_REPORTPER_REPORTPER_80Smpl (2UL) /*!< 80 samples/report */
++#define QDEC_REPORTPER_REPORTPER_120Smpl (3UL) /*!< 120 samples/report */
++#define QDEC_REPORTPER_REPORTPER_160Smpl (4UL) /*!< 160 samples/report */
++#define QDEC_REPORTPER_REPORTPER_200Smpl (5UL) /*!< 200 samples/report */
++#define QDEC_REPORTPER_REPORTPER_240Smpl (6UL) /*!< 240 samples/report */
++#define QDEC_REPORTPER_REPORTPER_280Smpl (7UL) /*!< 280 samples/report */
++#define QDEC_REPORTPER_REPORTPER_1Smpl (8UL) /*!< 1 sample/report */
++
++/* Register: QDEC_ACC */
++/* Description: Register accumulating the valid transitions */
++
++/* Bits 31..0 : Register accumulating all valid samples (not double transition) read from the SAMPLE register. */
++#define QDEC_ACC_ACC_Pos (0UL) /*!< Position of ACC field. */
++#define QDEC_ACC_ACC_Msk (0xFFFFFFFFUL << QDEC_ACC_ACC_Pos) /*!< Bit mask of ACC field. */
++
++/* Register: QDEC_ACCREAD */
++/* Description: Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task */
++
++/* Bits 31..0 : Snapshot of the ACC register. */
++#define QDEC_ACCREAD_ACCREAD_Pos (0UL) /*!< Position of ACCREAD field. */
++#define QDEC_ACCREAD_ACCREAD_Msk (0xFFFFFFFFUL << QDEC_ACCREAD_ACCREAD_Pos) /*!< Bit mask of ACCREAD field. */
++
++/* Register: QDEC_PSEL_LED */
++/* Description: Pin select for LED signal */
++
++/* Bit 31 : Connection */
++#define QDEC_PSEL_LED_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QDEC_PSEL_LED_CONNECT_Msk (0x1UL << QDEC_PSEL_LED_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QDEC_PSEL_LED_CONNECT_Connected (0UL) /*!< Connect */
++#define QDEC_PSEL_LED_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QDEC_PSEL_LED_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QDEC_PSEL_LED_PORT_Msk (0x1UL << QDEC_PSEL_LED_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QDEC_PSEL_LED_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QDEC_PSEL_LED_PIN_Msk (0x1FUL << QDEC_PSEL_LED_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QDEC_PSEL_A */
++/* Description: Pin select for A signal */
++
++/* Bit 31 : Connection */
++#define QDEC_PSEL_A_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QDEC_PSEL_A_CONNECT_Msk (0x1UL << QDEC_PSEL_A_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QDEC_PSEL_A_CONNECT_Connected (0UL) /*!< Connect */
++#define QDEC_PSEL_A_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QDEC_PSEL_A_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QDEC_PSEL_A_PORT_Msk (0x1UL << QDEC_PSEL_A_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QDEC_PSEL_A_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QDEC_PSEL_A_PIN_Msk (0x1FUL << QDEC_PSEL_A_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QDEC_PSEL_B */
++/* Description: Pin select for B signal */
++
++/* Bit 31 : Connection */
++#define QDEC_PSEL_B_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QDEC_PSEL_B_CONNECT_Msk (0x1UL << QDEC_PSEL_B_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QDEC_PSEL_B_CONNECT_Connected (0UL) /*!< Connect */
++#define QDEC_PSEL_B_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QDEC_PSEL_B_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QDEC_PSEL_B_PORT_Msk (0x1UL << QDEC_PSEL_B_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QDEC_PSEL_B_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QDEC_PSEL_B_PIN_Msk (0x1FUL << QDEC_PSEL_B_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QDEC_DBFEN */
++/* Description: Enable input debounce filters */
++
++/* Bit 0 : Enable input debounce filters */
++#define QDEC_DBFEN_DBFEN_Pos (0UL) /*!< Position of DBFEN field. */
++#define QDEC_DBFEN_DBFEN_Msk (0x1UL << QDEC_DBFEN_DBFEN_Pos) /*!< Bit mask of DBFEN field. */
++#define QDEC_DBFEN_DBFEN_Disabled (0UL) /*!< Debounce input filters disabled */
++#define QDEC_DBFEN_DBFEN_Enabled (1UL) /*!< Debounce input filters enabled */
++
++/* Register: QDEC_LEDPRE */
++/* Description: Time period the LED is switched ON prior to sampling */
++
++/* Bits 8..0 : Period in us the LED is switched on prior to sampling */
++#define QDEC_LEDPRE_LEDPRE_Pos (0UL) /*!< Position of LEDPRE field. */
++#define QDEC_LEDPRE_LEDPRE_Msk (0x1FFUL << QDEC_LEDPRE_LEDPRE_Pos) /*!< Bit mask of LEDPRE field. */
++
++/* Register: QDEC_ACCDBL */
++/* Description: Register accumulating the number of detected double transitions */
++
++/* Bits 3..0 : Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 ). */
++#define QDEC_ACCDBL_ACCDBL_Pos (0UL) /*!< Position of ACCDBL field. */
++#define QDEC_ACCDBL_ACCDBL_Msk (0xFUL << QDEC_ACCDBL_ACCDBL_Pos) /*!< Bit mask of ACCDBL field. */
++
++/* Register: QDEC_ACCDBLREAD */
++/* Description: Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task */
++
++/* Bits 3..0 : Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered. */
++#define QDEC_ACCDBLREAD_ACCDBLREAD_Pos (0UL) /*!< Position of ACCDBLREAD field. */
++#define QDEC_ACCDBLREAD_ACCDBLREAD_Msk (0xFUL << QDEC_ACCDBLREAD_ACCDBLREAD_Pos) /*!< Bit mask of ACCDBLREAD field. */
++
++
++/* Peripheral: QSPI */
++/* Description: External flash interface */
++
++/* Register: QSPI_TASKS_ACTIVATE */
++/* Description: Activate QSPI interface */
++
++/* Bit 0 : Activate QSPI interface */
++#define QSPI_TASKS_ACTIVATE_TASKS_ACTIVATE_Pos (0UL) /*!< Position of TASKS_ACTIVATE field. */
++#define QSPI_TASKS_ACTIVATE_TASKS_ACTIVATE_Msk (0x1UL << QSPI_TASKS_ACTIVATE_TASKS_ACTIVATE_Pos) /*!< Bit mask of TASKS_ACTIVATE field. */
++#define QSPI_TASKS_ACTIVATE_TASKS_ACTIVATE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QSPI_TASKS_READSTART */
++/* Description: Start transfer from external flash memory to internal RAM */
++
++/* Bit 0 : Start transfer from external flash memory to internal RAM */
++#define QSPI_TASKS_READSTART_TASKS_READSTART_Pos (0UL) /*!< Position of TASKS_READSTART field. */
++#define QSPI_TASKS_READSTART_TASKS_READSTART_Msk (0x1UL << QSPI_TASKS_READSTART_TASKS_READSTART_Pos) /*!< Bit mask of TASKS_READSTART field. */
++#define QSPI_TASKS_READSTART_TASKS_READSTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QSPI_TASKS_WRITESTART */
++/* Description: Start transfer from internal RAM to external flash memory */
++
++/* Bit 0 : Start transfer from internal RAM to external flash memory */
++#define QSPI_TASKS_WRITESTART_TASKS_WRITESTART_Pos (0UL) /*!< Position of TASKS_WRITESTART field. */
++#define QSPI_TASKS_WRITESTART_TASKS_WRITESTART_Msk (0x1UL << QSPI_TASKS_WRITESTART_TASKS_WRITESTART_Pos) /*!< Bit mask of TASKS_WRITESTART field. */
++#define QSPI_TASKS_WRITESTART_TASKS_WRITESTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QSPI_TASKS_ERASESTART */
++/* Description: Start external flash memory erase operation */
++
++/* Bit 0 : Start external flash memory erase operation */
++#define QSPI_TASKS_ERASESTART_TASKS_ERASESTART_Pos (0UL) /*!< Position of TASKS_ERASESTART field. */
++#define QSPI_TASKS_ERASESTART_TASKS_ERASESTART_Msk (0x1UL << QSPI_TASKS_ERASESTART_TASKS_ERASESTART_Pos) /*!< Bit mask of TASKS_ERASESTART field. */
++#define QSPI_TASKS_ERASESTART_TASKS_ERASESTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QSPI_TASKS_DEACTIVATE */
++/* Description: Deactivate QSPI interface */
++
++/* Bit 0 : Deactivate QSPI interface */
++#define QSPI_TASKS_DEACTIVATE_TASKS_DEACTIVATE_Pos (0UL) /*!< Position of TASKS_DEACTIVATE field. */
++#define QSPI_TASKS_DEACTIVATE_TASKS_DEACTIVATE_Msk (0x1UL << QSPI_TASKS_DEACTIVATE_TASKS_DEACTIVATE_Pos) /*!< Bit mask of TASKS_DEACTIVATE field. */
++#define QSPI_TASKS_DEACTIVATE_TASKS_DEACTIVATE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: QSPI_EVENTS_READY */
++/* Description: QSPI peripheral is ready. This event will be generated as a response to any QSPI task. */
++
++/* Bit 0 : QSPI peripheral is ready. This event will be generated as a response to any QSPI task. */
++#define QSPI_EVENTS_READY_EVENTS_READY_Pos (0UL) /*!< Position of EVENTS_READY field. */
++#define QSPI_EVENTS_READY_EVENTS_READY_Msk (0x1UL << QSPI_EVENTS_READY_EVENTS_READY_Pos) /*!< Bit mask of EVENTS_READY field. */
++#define QSPI_EVENTS_READY_EVENTS_READY_NotGenerated (0UL) /*!< Event not generated */
++#define QSPI_EVENTS_READY_EVENTS_READY_Generated (1UL) /*!< Event generated */
++
++/* Register: QSPI_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 0 : Enable or disable interrupt for event READY */
++#define QSPI_INTEN_READY_Pos (0UL) /*!< Position of READY field. */
++#define QSPI_INTEN_READY_Msk (0x1UL << QSPI_INTEN_READY_Pos) /*!< Bit mask of READY field. */
++#define QSPI_INTEN_READY_Disabled (0UL) /*!< Disable */
++#define QSPI_INTEN_READY_Enabled (1UL) /*!< Enable */
++
++/* Register: QSPI_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 0 : Write '1' to enable interrupt for event READY */
++#define QSPI_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
++#define QSPI_INTENSET_READY_Msk (0x1UL << QSPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
++#define QSPI_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
++#define QSPI_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
++#define QSPI_INTENSET_READY_Set (1UL) /*!< Enable */
++
++/* Register: QSPI_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 0 : Write '1' to disable interrupt for event READY */
++#define QSPI_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
++#define QSPI_INTENCLR_READY_Msk (0x1UL << QSPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
++#define QSPI_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
++#define QSPI_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
++#define QSPI_INTENCLR_READY_Clear (1UL) /*!< Disable */
++
++/* Register: QSPI_ENABLE */
++/* Description: Enable QSPI peripheral and acquire the pins selected in PSELn registers */
++
++/* Bit 0 : Enable or disable QSPI */
++#define QSPI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define QSPI_ENABLE_ENABLE_Msk (0x1UL << QSPI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define QSPI_ENABLE_ENABLE_Disabled (0UL) /*!< Disable QSPI */
++#define QSPI_ENABLE_ENABLE_Enabled (1UL) /*!< Enable QSPI */
++
++/* Register: QSPI_READ_SRC */
++/* Description: Flash memory source address */
++
++/* Bits 31..0 : Word-aligned flash memory source address. */
++#define QSPI_READ_SRC_SRC_Pos (0UL) /*!< Position of SRC field. */
++#define QSPI_READ_SRC_SRC_Msk (0xFFFFFFFFUL << QSPI_READ_SRC_SRC_Pos) /*!< Bit mask of SRC field. */
++
++/* Register: QSPI_READ_DST */
++/* Description: RAM destination address */
++
++/* Bits 31..0 : Word-aligned RAM destination address. */
++#define QSPI_READ_DST_DST_Pos (0UL) /*!< Position of DST field. */
++#define QSPI_READ_DST_DST_Msk (0xFFFFFFFFUL << QSPI_READ_DST_DST_Pos) /*!< Bit mask of DST field. */
++
++/* Register: QSPI_READ_CNT */
++/* Description: Read transfer length */
++
++/* Bits 17..0 : Read transfer length in number of bytes. The length must be a multiple of 4 bytes. */
++#define QSPI_READ_CNT_CNT_Pos (0UL) /*!< Position of CNT field. */
++#define QSPI_READ_CNT_CNT_Msk (0x3FFFFUL << QSPI_READ_CNT_CNT_Pos) /*!< Bit mask of CNT field. */
++
++/* Register: QSPI_WRITE_DST */
++/* Description: Flash destination address */
++
++/* Bits 31..0 : Word-aligned flash destination address. */
++#define QSPI_WRITE_DST_DST_Pos (0UL) /*!< Position of DST field. */
++#define QSPI_WRITE_DST_DST_Msk (0xFFFFFFFFUL << QSPI_WRITE_DST_DST_Pos) /*!< Bit mask of DST field. */
++
++/* Register: QSPI_WRITE_SRC */
++/* Description: RAM source address */
++
++/* Bits 31..0 : Word-aligned RAM source address. */
++#define QSPI_WRITE_SRC_SRC_Pos (0UL) /*!< Position of SRC field. */
++#define QSPI_WRITE_SRC_SRC_Msk (0xFFFFFFFFUL << QSPI_WRITE_SRC_SRC_Pos) /*!< Bit mask of SRC field. */
++
++/* Register: QSPI_WRITE_CNT */
++/* Description: Write transfer length */
++
++/* Bits 17..0 : Write transfer length in number of bytes. The length must be a multiple of 4 bytes. */
++#define QSPI_WRITE_CNT_CNT_Pos (0UL) /*!< Position of CNT field. */
++#define QSPI_WRITE_CNT_CNT_Msk (0x3FFFFUL << QSPI_WRITE_CNT_CNT_Pos) /*!< Bit mask of CNT field. */
++
++/* Register: QSPI_ERASE_PTR */
++/* Description: Start address of flash block to be erased */
++
++/* Bits 31..0 : Word-aligned start address of block to be erased. */
++#define QSPI_ERASE_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define QSPI_ERASE_PTR_PTR_Msk (0xFFFFFFFFUL << QSPI_ERASE_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: QSPI_ERASE_LEN */
++/* Description: Size of block to be erased. */
++
++/* Bits 1..0 : LEN */
++#define QSPI_ERASE_LEN_LEN_Pos (0UL) /*!< Position of LEN field. */
++#define QSPI_ERASE_LEN_LEN_Msk (0x3UL << QSPI_ERASE_LEN_LEN_Pos) /*!< Bit mask of LEN field. */
++#define QSPI_ERASE_LEN_LEN_4KB (0UL) /*!< Erase 4 kB block (flash command 0x20) */
++#define QSPI_ERASE_LEN_LEN_64KB (1UL) /*!< Erase 64 kB block (flash command 0xD8) */
++#define QSPI_ERASE_LEN_LEN_All (2UL) /*!< Erase all (flash command 0xC7) */
++
++/* Register: QSPI_PSEL_SCK */
++/* Description: Pin select for serial clock SCK */
++
++/* Bit 31 : Connection */
++#define QSPI_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QSPI_PSEL_SCK_CONNECT_Msk (0x1UL << QSPI_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QSPI_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
++#define QSPI_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QSPI_PSEL_SCK_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QSPI_PSEL_SCK_PORT_Msk (0x1UL << QSPI_PSEL_SCK_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QSPI_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QSPI_PSEL_SCK_PIN_Msk (0x1FUL << QSPI_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QSPI_PSEL_CSN */
++/* Description: Pin select for chip select signal CSN. */
++
++/* Bit 31 : Connection */
++#define QSPI_PSEL_CSN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QSPI_PSEL_CSN_CONNECT_Msk (0x1UL << QSPI_PSEL_CSN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QSPI_PSEL_CSN_CONNECT_Connected (0UL) /*!< Connect */
++#define QSPI_PSEL_CSN_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QSPI_PSEL_CSN_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QSPI_PSEL_CSN_PORT_Msk (0x1UL << QSPI_PSEL_CSN_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QSPI_PSEL_CSN_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QSPI_PSEL_CSN_PIN_Msk (0x1FUL << QSPI_PSEL_CSN_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QSPI_PSEL_IO0 */
++/* Description: Pin select for serial data MOSI/IO0. */
++
++/* Bit 31 : Connection */
++#define QSPI_PSEL_IO0_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QSPI_PSEL_IO0_CONNECT_Msk (0x1UL << QSPI_PSEL_IO0_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QSPI_PSEL_IO0_CONNECT_Connected (0UL) /*!< Connect */
++#define QSPI_PSEL_IO0_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QSPI_PSEL_IO0_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QSPI_PSEL_IO0_PORT_Msk (0x1UL << QSPI_PSEL_IO0_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QSPI_PSEL_IO0_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QSPI_PSEL_IO0_PIN_Msk (0x1FUL << QSPI_PSEL_IO0_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QSPI_PSEL_IO1 */
++/* Description: Pin select for serial data MISO/IO1. */
++
++/* Bit 31 : Connection */
++#define QSPI_PSEL_IO1_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QSPI_PSEL_IO1_CONNECT_Msk (0x1UL << QSPI_PSEL_IO1_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QSPI_PSEL_IO1_CONNECT_Connected (0UL) /*!< Connect */
++#define QSPI_PSEL_IO1_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QSPI_PSEL_IO1_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QSPI_PSEL_IO1_PORT_Msk (0x1UL << QSPI_PSEL_IO1_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QSPI_PSEL_IO1_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QSPI_PSEL_IO1_PIN_Msk (0x1FUL << QSPI_PSEL_IO1_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QSPI_PSEL_IO2 */
++/* Description: Pin select for serial data IO2. */
++
++/* Bit 31 : Connection */
++#define QSPI_PSEL_IO2_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QSPI_PSEL_IO2_CONNECT_Msk (0x1UL << QSPI_PSEL_IO2_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QSPI_PSEL_IO2_CONNECT_Connected (0UL) /*!< Connect */
++#define QSPI_PSEL_IO2_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QSPI_PSEL_IO2_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QSPI_PSEL_IO2_PORT_Msk (0x1UL << QSPI_PSEL_IO2_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QSPI_PSEL_IO2_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QSPI_PSEL_IO2_PIN_Msk (0x1FUL << QSPI_PSEL_IO2_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QSPI_PSEL_IO3 */
++/* Description: Pin select for serial data IO3. */
++
++/* Bit 31 : Connection */
++#define QSPI_PSEL_IO3_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define QSPI_PSEL_IO3_CONNECT_Msk (0x1UL << QSPI_PSEL_IO3_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define QSPI_PSEL_IO3_CONNECT_Connected (0UL) /*!< Connect */
++#define QSPI_PSEL_IO3_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define QSPI_PSEL_IO3_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define QSPI_PSEL_IO3_PORT_Msk (0x1UL << QSPI_PSEL_IO3_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define QSPI_PSEL_IO3_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define QSPI_PSEL_IO3_PIN_Msk (0x1FUL << QSPI_PSEL_IO3_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: QSPI_XIPOFFSET */
++/* Description: Address offset into the external memory for Execute in Place operation. */
++
++/* Bits 31..0 : Address offset into the external memory for Execute in Place operation. Value must be a multiple of 4. */
++#define QSPI_XIPOFFSET_XIPOFFSET_Pos (0UL) /*!< Position of XIPOFFSET field. */
++#define QSPI_XIPOFFSET_XIPOFFSET_Msk (0xFFFFFFFFUL << QSPI_XIPOFFSET_XIPOFFSET_Pos) /*!< Bit mask of XIPOFFSET field. */
++
++/* Register: QSPI_IFCONFIG0 */
++/* Description: Interface configuration. */
++
++/* Bit 12 : Page size for commands PP, PP2O, PP4O and PP4IO. */
++#define QSPI_IFCONFIG0_PPSIZE_Pos (12UL) /*!< Position of PPSIZE field. */
++#define QSPI_IFCONFIG0_PPSIZE_Msk (0x1UL << QSPI_IFCONFIG0_PPSIZE_Pos) /*!< Bit mask of PPSIZE field. */
++#define QSPI_IFCONFIG0_PPSIZE_256Bytes (0UL) /*!< 256 bytes. */
++#define QSPI_IFCONFIG0_PPSIZE_512Bytes (1UL) /*!< 512 bytes. */
++
++/* Bit 7 : Enable deep power-down mode (DPM) feature. */
++#define QSPI_IFCONFIG0_DPMENABLE_Pos (7UL) /*!< Position of DPMENABLE field. */
++#define QSPI_IFCONFIG0_DPMENABLE_Msk (0x1UL << QSPI_IFCONFIG0_DPMENABLE_Pos) /*!< Bit mask of DPMENABLE field. */
++#define QSPI_IFCONFIG0_DPMENABLE_Disable (0UL) /*!< Disable DPM feature. */
++#define QSPI_IFCONFIG0_DPMENABLE_Enable (1UL) /*!< Enable DPM feature. */
++
++/* Bit 6 : Addressing mode. */
++#define QSPI_IFCONFIG0_ADDRMODE_Pos (6UL) /*!< Position of ADDRMODE field. */
++#define QSPI_IFCONFIG0_ADDRMODE_Msk (0x1UL << QSPI_IFCONFIG0_ADDRMODE_Pos) /*!< Bit mask of ADDRMODE field. */
++#define QSPI_IFCONFIG0_ADDRMODE_24BIT (0UL) /*!< 24-bit addressing. */
++#define QSPI_IFCONFIG0_ADDRMODE_32BIT (1UL) /*!< 32-bit addressing. */
++
++/* Bits 5..3 : Configure number of data lines and opcode used for writing. */
++#define QSPI_IFCONFIG0_WRITEOC_Pos (3UL) /*!< Position of WRITEOC field. */
++#define QSPI_IFCONFIG0_WRITEOC_Msk (0x7UL << QSPI_IFCONFIG0_WRITEOC_Pos) /*!< Bit mask of WRITEOC field. */
++#define QSPI_IFCONFIG0_WRITEOC_PP (0UL) /*!< Single data line SPI. PP (opcode 0x02). */
++#define QSPI_IFCONFIG0_WRITEOC_PP2O (1UL) /*!< Dual data line SPI. PP2O (opcode 0xA2). */
++#define QSPI_IFCONFIG0_WRITEOC_PP4O (2UL) /*!< Quad data line SPI. PP4O (opcode 0x32). */
++#define QSPI_IFCONFIG0_WRITEOC_PP4IO (3UL) /*!< Quad data line SPI. PP4IO (opcode 0x38). */
++
++/* Bits 2..0 : Configure number of data lines and opcode used for reading. */
++#define QSPI_IFCONFIG0_READOC_Pos (0UL) /*!< Position of READOC field. */
++#define QSPI_IFCONFIG0_READOC_Msk (0x7UL << QSPI_IFCONFIG0_READOC_Pos) /*!< Bit mask of READOC field. */
++#define QSPI_IFCONFIG0_READOC_FASTREAD (0UL) /*!< Single data line SPI. FAST_READ (opcode 0x0B). */
++#define QSPI_IFCONFIG0_READOC_READ2O (1UL) /*!< Dual data line SPI. READ2O (opcode 0x3B). */
++#define QSPI_IFCONFIG0_READOC_READ2IO (2UL) /*!< Dual data line SPI. READ2IO (opcode 0xBB). */
++#define QSPI_IFCONFIG0_READOC_READ4O (3UL) /*!< Quad data line SPI. READ4O (opcode 0x6B). */
++#define QSPI_IFCONFIG0_READOC_READ4IO (4UL) /*!< Quad data line SPI. READ4IO (opcode 0xEB). */
++
++/* Register: QSPI_IFCONFIG1 */
++/* Description: Interface configuration. */
++
++/* Bits 31..28 : SCK frequency is given as 32 MHz / (SCKFREQ + 1). */
++#define QSPI_IFCONFIG1_SCKFREQ_Pos (28UL) /*!< Position of SCKFREQ field. */
++#define QSPI_IFCONFIG1_SCKFREQ_Msk (0xFUL << QSPI_IFCONFIG1_SCKFREQ_Pos) /*!< Bit mask of SCKFREQ field. */
++
++/* Bit 25 : Select SPI mode. */
++#define QSPI_IFCONFIG1_SPIMODE_Pos (25UL) /*!< Position of SPIMODE field. */
++#define QSPI_IFCONFIG1_SPIMODE_Msk (0x1UL << QSPI_IFCONFIG1_SPIMODE_Pos) /*!< Bit mask of SPIMODE field. */
++#define QSPI_IFCONFIG1_SPIMODE_MODE0 (0UL) /*!< Mode 0: Data are captured on the clock rising edge and data is output on a falling edge. Base level of clock is 0 (CPOL=0, CPHA=0). */
++#define QSPI_IFCONFIG1_SPIMODE_MODE3 (1UL) /*!< Mode 3: Data are captured on the clock falling edge and data is output on a rising edge. Base level of clock is 1 (CPOL=1, CPHA=1). */
++
++/* Bit 24 : Enter/exit deep power-down mode (DPM) for external flash memory. */
++#define QSPI_IFCONFIG1_DPMEN_Pos (24UL) /*!< Position of DPMEN field. */
++#define QSPI_IFCONFIG1_DPMEN_Msk (0x1UL << QSPI_IFCONFIG1_DPMEN_Pos) /*!< Bit mask of DPMEN field. */
++#define QSPI_IFCONFIG1_DPMEN_Exit (0UL) /*!< Exit DPM. */
++#define QSPI_IFCONFIG1_DPMEN_Enter (1UL) /*!< Enter DPM. */
++
++/* Bits 7..0 : Minimum amount of time that the CSN pin must stay high before it can go low again. Value is specified in number of 16 MHz periods (62.5 ns). */
++#define QSPI_IFCONFIG1_SCKDELAY_Pos (0UL) /*!< Position of SCKDELAY field. */
++#define QSPI_IFCONFIG1_SCKDELAY_Msk (0xFFUL << QSPI_IFCONFIG1_SCKDELAY_Pos) /*!< Bit mask of SCKDELAY field. */
++
++/* Register: QSPI_STATUS */
++/* Description: Status register. */
++
++/* Bits 31..24 : Value of external flash device Status Register. When the external flash has two bytes status register this field includes the value of the low byte. */
++#define QSPI_STATUS_SREG_Pos (24UL) /*!< Position of SREG field. */
++#define QSPI_STATUS_SREG_Msk (0xFFUL << QSPI_STATUS_SREG_Pos) /*!< Bit mask of SREG field. */
++
++/* Bit 3 : Ready status. */
++#define QSPI_STATUS_READY_Pos (3UL) /*!< Position of READY field. */
++#define QSPI_STATUS_READY_Msk (0x1UL << QSPI_STATUS_READY_Pos) /*!< Bit mask of READY field. */
++#define QSPI_STATUS_READY_BUSY (0UL) /*!< QSPI peripheral is busy. It is not allowed to trigger any new tasks, writing custom instructions or enter/exit DPM. */
++#define QSPI_STATUS_READY_READY (1UL) /*!< QSPI peripheral is ready. It is allowed to trigger new tasks, writing custom instructions or enter/exit DPM. */
++
++/* Bit 2 : Deep power-down mode (DPM) status of external flash. */
++#define QSPI_STATUS_DPM_Pos (2UL) /*!< Position of DPM field. */
++#define QSPI_STATUS_DPM_Msk (0x1UL << QSPI_STATUS_DPM_Pos) /*!< Bit mask of DPM field. */
++#define QSPI_STATUS_DPM_Disabled (0UL) /*!< External flash is not in DPM. */
++#define QSPI_STATUS_DPM_Enabled (1UL) /*!< External flash is in DPM. */
++
++/* Register: QSPI_DPMDUR */
++/* Description: Set the duration required to enter/exit deep power-down mode (DPM). */
++
++/* Bits 31..16 : Duration needed by external flash to exit DPM. Duration is given as EXIT * 256 * 62.5 ns. */
++#define QSPI_DPMDUR_EXIT_Pos (16UL) /*!< Position of EXIT field. */
++#define QSPI_DPMDUR_EXIT_Msk (0xFFFFUL << QSPI_DPMDUR_EXIT_Pos) /*!< Bit mask of EXIT field. */
++
++/* Bits 15..0 : Duration needed by external flash to enter DPM. Duration is given as ENTER * 256 * 62.5 ns. */
++#define QSPI_DPMDUR_ENTER_Pos (0UL) /*!< Position of ENTER field. */
++#define QSPI_DPMDUR_ENTER_Msk (0xFFFFUL << QSPI_DPMDUR_ENTER_Pos) /*!< Bit mask of ENTER field. */
++
++/* Register: QSPI_ADDRCONF */
++/* Description: Extended address configuration. */
++
++/* Bit 27 : Send WREN (write enable opcode 0x06) before instruction. */
++#define QSPI_ADDRCONF_WREN_Pos (27UL) /*!< Position of WREN field. */
++#define QSPI_ADDRCONF_WREN_Msk (0x1UL << QSPI_ADDRCONF_WREN_Pos) /*!< Bit mask of WREN field. */
++#define QSPI_ADDRCONF_WREN_Disable (0UL) /*!< Do not send WREN. */
++#define QSPI_ADDRCONF_WREN_Enable (1UL) /*!< Send WREN. */
++
++/* Bit 26 : Wait for write complete before sending command. */
++#define QSPI_ADDRCONF_WIPWAIT_Pos (26UL) /*!< Position of WIPWAIT field. */
++#define QSPI_ADDRCONF_WIPWAIT_Msk (0x1UL << QSPI_ADDRCONF_WIPWAIT_Pos) /*!< Bit mask of WIPWAIT field. */
++#define QSPI_ADDRCONF_WIPWAIT_Disable (0UL) /*!< No wait. */
++#define QSPI_ADDRCONF_WIPWAIT_Enable (1UL) /*!< Wait. */
++
++/* Bits 25..24 : Extended addressing mode. */
++#define QSPI_ADDRCONF_MODE_Pos (24UL) /*!< Position of MODE field. */
++#define QSPI_ADDRCONF_MODE_Msk (0x3UL << QSPI_ADDRCONF_MODE_Pos) /*!< Bit mask of MODE field. */
++#define QSPI_ADDRCONF_MODE_NoInstr (0UL) /*!< Do not send any instruction. */
++#define QSPI_ADDRCONF_MODE_Opcode (1UL) /*!< Send opcode. */
++#define QSPI_ADDRCONF_MODE_OpByte0 (2UL) /*!< Send opcode, byte0. */
++#define QSPI_ADDRCONF_MODE_All (3UL) /*!< Send opcode, byte0, byte1. */
++
++/* Bits 23..16 : Byte 1 following byte 0. */
++#define QSPI_ADDRCONF_BYTE1_Pos (16UL) /*!< Position of BYTE1 field. */
++#define QSPI_ADDRCONF_BYTE1_Msk (0xFFUL << QSPI_ADDRCONF_BYTE1_Pos) /*!< Bit mask of BYTE1 field. */
++
++/* Bits 15..8 : Byte 0 following opcode. */
++#define QSPI_ADDRCONF_BYTE0_Pos (8UL) /*!< Position of BYTE0 field. */
++#define QSPI_ADDRCONF_BYTE0_Msk (0xFFUL << QSPI_ADDRCONF_BYTE0_Pos) /*!< Bit mask of BYTE0 field. */
++
++/* Bits 7..0 : Opcode that enters the 32-bit addressing mode. */
++#define QSPI_ADDRCONF_OPCODE_Pos (0UL) /*!< Position of OPCODE field. */
++#define QSPI_ADDRCONF_OPCODE_Msk (0xFFUL << QSPI_ADDRCONF_OPCODE_Pos) /*!< Bit mask of OPCODE field. */
++
++/* Register: QSPI_CINSTRCONF */
++/* Description: Custom instruction configuration register. */
++
++/* Bit 17 : Stop (finalize) long frame transaction */
++#define QSPI_CINSTRCONF_LFSTOP_Pos (17UL) /*!< Position of LFSTOP field. */
++#define QSPI_CINSTRCONF_LFSTOP_Msk (0x1UL << QSPI_CINSTRCONF_LFSTOP_Pos) /*!< Bit mask of LFSTOP field. */
++#define QSPI_CINSTRCONF_LFSTOP_Stop (1UL) /*!< Stop */
++
++/* Bit 16 : Enable long frame mode. When enabled, a custom instruction transaction has to be ended by writing the LFSTOP field. */
++#define QSPI_CINSTRCONF_LFEN_Pos (16UL) /*!< Position of LFEN field. */
++#define QSPI_CINSTRCONF_LFEN_Msk (0x1UL << QSPI_CINSTRCONF_LFEN_Pos) /*!< Bit mask of LFEN field. */
++#define QSPI_CINSTRCONF_LFEN_Disable (0UL) /*!< Long frame mode disabled */
++#define QSPI_CINSTRCONF_LFEN_Enable (1UL) /*!< Long frame mode enabled */
++
++/* Bit 15 : Send WREN (write enable opcode 0x06) before instruction. */
++#define QSPI_CINSTRCONF_WREN_Pos (15UL) /*!< Position of WREN field. */
++#define QSPI_CINSTRCONF_WREN_Msk (0x1UL << QSPI_CINSTRCONF_WREN_Pos) /*!< Bit mask of WREN field. */
++#define QSPI_CINSTRCONF_WREN_Disable (0UL) /*!< Do not send WREN. */
++#define QSPI_CINSTRCONF_WREN_Enable (1UL) /*!< Send WREN. */
++
++/* Bit 14 : Wait for write complete before sending command. */
++#define QSPI_CINSTRCONF_WIPWAIT_Pos (14UL) /*!< Position of WIPWAIT field. */
++#define QSPI_CINSTRCONF_WIPWAIT_Msk (0x1UL << QSPI_CINSTRCONF_WIPWAIT_Pos) /*!< Bit mask of WIPWAIT field. */
++#define QSPI_CINSTRCONF_WIPWAIT_Disable (0UL) /*!< No wait. */
++#define QSPI_CINSTRCONF_WIPWAIT_Enable (1UL) /*!< Wait. */
++
++/* Bit 13 : Level of the IO3 pin (if connected) during transmission of custom instruction. */
++#define QSPI_CINSTRCONF_LIO3_Pos (13UL) /*!< Position of LIO3 field. */
++#define QSPI_CINSTRCONF_LIO3_Msk (0x1UL << QSPI_CINSTRCONF_LIO3_Pos) /*!< Bit mask of LIO3 field. */
++
++/* Bit 12 : Level of the IO2 pin (if connected) during transmission of custom instruction. */
++#define QSPI_CINSTRCONF_LIO2_Pos (12UL) /*!< Position of LIO2 field. */
++#define QSPI_CINSTRCONF_LIO2_Msk (0x1UL << QSPI_CINSTRCONF_LIO2_Pos) /*!< Bit mask of LIO2 field. */
++
++/* Bits 11..8 : Length of custom instruction in number of bytes. */
++#define QSPI_CINSTRCONF_LENGTH_Pos (8UL) /*!< Position of LENGTH field. */
++#define QSPI_CINSTRCONF_LENGTH_Msk (0xFUL << QSPI_CINSTRCONF_LENGTH_Pos) /*!< Bit mask of LENGTH field. */
++#define QSPI_CINSTRCONF_LENGTH_1B (1UL) /*!< Send opcode only. */
++#define QSPI_CINSTRCONF_LENGTH_2B (2UL) /*!< Send opcode, CINSTRDAT0.BYTE0. */
++#define QSPI_CINSTRCONF_LENGTH_3B (3UL) /*!< Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT0.BYTE1. */
++#define QSPI_CINSTRCONF_LENGTH_4B (4UL) /*!< Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT0.BYTE2. */
++#define QSPI_CINSTRCONF_LENGTH_5B (5UL) /*!< Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT0.BYTE3. */
++#define QSPI_CINSTRCONF_LENGTH_6B (6UL) /*!< Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT1.BYTE4. */
++#define QSPI_CINSTRCONF_LENGTH_7B (7UL) /*!< Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT1.BYTE5. */
++#define QSPI_CINSTRCONF_LENGTH_8B (8UL) /*!< Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT1.BYTE6. */
++#define QSPI_CINSTRCONF_LENGTH_9B (9UL) /*!< Send opcode, CINSTRDAT0.BYTE0 -&gt; CINSTRDAT1.BYTE7. */
++
++/* Bits 7..0 : Opcode of Custom instruction. */
++#define QSPI_CINSTRCONF_OPCODE_Pos (0UL) /*!< Position of OPCODE field. */
++#define QSPI_CINSTRCONF_OPCODE_Msk (0xFFUL << QSPI_CINSTRCONF_OPCODE_Pos) /*!< Bit mask of OPCODE field. */
++
++/* Register: QSPI_CINSTRDAT0 */
++/* Description: Custom instruction data register 0. */
++
++/* Bits 31..24 : Data byte 3 */
++#define QSPI_CINSTRDAT0_BYTE3_Pos (24UL) /*!< Position of BYTE3 field. */
++#define QSPI_CINSTRDAT0_BYTE3_Msk (0xFFUL << QSPI_CINSTRDAT0_BYTE3_Pos) /*!< Bit mask of BYTE3 field. */
++
++/* Bits 23..16 : Data byte 2 */
++#define QSPI_CINSTRDAT0_BYTE2_Pos (16UL) /*!< Position of BYTE2 field. */
++#define QSPI_CINSTRDAT0_BYTE2_Msk (0xFFUL << QSPI_CINSTRDAT0_BYTE2_Pos) /*!< Bit mask of BYTE2 field. */
++
++/* Bits 15..8 : Data byte 1 */
++#define QSPI_CINSTRDAT0_BYTE1_Pos (8UL) /*!< Position of BYTE1 field. */
++#define QSPI_CINSTRDAT0_BYTE1_Msk (0xFFUL << QSPI_CINSTRDAT0_BYTE1_Pos) /*!< Bit mask of BYTE1 field. */
++
++/* Bits 7..0 : Data byte 0 */
++#define QSPI_CINSTRDAT0_BYTE0_Pos (0UL) /*!< Position of BYTE0 field. */
++#define QSPI_CINSTRDAT0_BYTE0_Msk (0xFFUL << QSPI_CINSTRDAT0_BYTE0_Pos) /*!< Bit mask of BYTE0 field. */
++
++/* Register: QSPI_CINSTRDAT1 */
++/* Description: Custom instruction data register 1. */
++
++/* Bits 31..24 : Data byte 7 */
++#define QSPI_CINSTRDAT1_BYTE7_Pos (24UL) /*!< Position of BYTE7 field. */
++#define QSPI_CINSTRDAT1_BYTE7_Msk (0xFFUL << QSPI_CINSTRDAT1_BYTE7_Pos) /*!< Bit mask of BYTE7 field. */
++
++/* Bits 23..16 : Data byte 6 */
++#define QSPI_CINSTRDAT1_BYTE6_Pos (16UL) /*!< Position of BYTE6 field. */
++#define QSPI_CINSTRDAT1_BYTE6_Msk (0xFFUL << QSPI_CINSTRDAT1_BYTE6_Pos) /*!< Bit mask of BYTE6 field. */
++
++/* Bits 15..8 : Data byte 5 */
++#define QSPI_CINSTRDAT1_BYTE5_Pos (8UL) /*!< Position of BYTE5 field. */
++#define QSPI_CINSTRDAT1_BYTE5_Msk (0xFFUL << QSPI_CINSTRDAT1_BYTE5_Pos) /*!< Bit mask of BYTE5 field. */
++
++/* Bits 7..0 : Data byte 4 */
++#define QSPI_CINSTRDAT1_BYTE4_Pos (0UL) /*!< Position of BYTE4 field. */
++#define QSPI_CINSTRDAT1_BYTE4_Msk (0xFFUL << QSPI_CINSTRDAT1_BYTE4_Pos) /*!< Bit mask of BYTE4 field. */
++
++/* Register: QSPI_IFTIMING */
++/* Description: SPI interface timing. */
++
++/* Bits 10..8 : Timing related to sampling of the input serial data. The value of RXDELAY specifies the number of 64 MHz cycles (15.625 ns) delay from the the rising edge of the SPI Clock (SCK) until the input serial data is sampled. As en example, if set to 0 the input serial data is sampled on the rising edge of SCK. */
++#define QSPI_IFTIMING_RXDELAY_Pos (8UL) /*!< Position of RXDELAY field. */
++#define QSPI_IFTIMING_RXDELAY_Msk (0x7UL << QSPI_IFTIMING_RXDELAY_Pos) /*!< Bit mask of RXDELAY field. */
++
++
++/* Peripheral: RADIO */
++/* Description: 2.4 GHz radio */
++
++/* Register: RADIO_TASKS_TXEN */
++/* Description: Enable RADIO in TX mode */
++
++/* Bit 0 : Enable RADIO in TX mode */
++#define RADIO_TASKS_TXEN_TASKS_TXEN_Pos (0UL) /*!< Position of TASKS_TXEN field. */
++#define RADIO_TASKS_TXEN_TASKS_TXEN_Msk (0x1UL << RADIO_TASKS_TXEN_TASKS_TXEN_Pos) /*!< Bit mask of TASKS_TXEN field. */
++#define RADIO_TASKS_TXEN_TASKS_TXEN_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_RXEN */
++/* Description: Enable RADIO in RX mode */
++
++/* Bit 0 : Enable RADIO in RX mode */
++#define RADIO_TASKS_RXEN_TASKS_RXEN_Pos (0UL) /*!< Position of TASKS_RXEN field. */
++#define RADIO_TASKS_RXEN_TASKS_RXEN_Msk (0x1UL << RADIO_TASKS_RXEN_TASKS_RXEN_Pos) /*!< Bit mask of TASKS_RXEN field. */
++#define RADIO_TASKS_RXEN_TASKS_RXEN_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_START */
++/* Description: Start RADIO */
++
++/* Bit 0 : Start RADIO */
++#define RADIO_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define RADIO_TASKS_START_TASKS_START_Msk (0x1UL << RADIO_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define RADIO_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_STOP */
++/* Description: Stop RADIO */
++
++/* Bit 0 : Stop RADIO */
++#define RADIO_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define RADIO_TASKS_STOP_TASKS_STOP_Msk (0x1UL << RADIO_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define RADIO_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_DISABLE */
++/* Description: Disable RADIO */
++
++/* Bit 0 : Disable RADIO */
++#define RADIO_TASKS_DISABLE_TASKS_DISABLE_Pos (0UL) /*!< Position of TASKS_DISABLE field. */
++#define RADIO_TASKS_DISABLE_TASKS_DISABLE_Msk (0x1UL << RADIO_TASKS_DISABLE_TASKS_DISABLE_Pos) /*!< Bit mask of TASKS_DISABLE field. */
++#define RADIO_TASKS_DISABLE_TASKS_DISABLE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_RSSISTART */
++/* Description: Start the RSSI and take one single sample of the receive signal strength */
++
++/* Bit 0 : Start the RSSI and take one single sample of the receive signal strength */
++#define RADIO_TASKS_RSSISTART_TASKS_RSSISTART_Pos (0UL) /*!< Position of TASKS_RSSISTART field. */
++#define RADIO_TASKS_RSSISTART_TASKS_RSSISTART_Msk (0x1UL << RADIO_TASKS_RSSISTART_TASKS_RSSISTART_Pos) /*!< Bit mask of TASKS_RSSISTART field. */
++#define RADIO_TASKS_RSSISTART_TASKS_RSSISTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_RSSISTOP */
++/* Description: Stop the RSSI measurement */
++
++/* Bit 0 : Stop the RSSI measurement */
++#define RADIO_TASKS_RSSISTOP_TASKS_RSSISTOP_Pos (0UL) /*!< Position of TASKS_RSSISTOP field. */
++#define RADIO_TASKS_RSSISTOP_TASKS_RSSISTOP_Msk (0x1UL << RADIO_TASKS_RSSISTOP_TASKS_RSSISTOP_Pos) /*!< Bit mask of TASKS_RSSISTOP field. */
++#define RADIO_TASKS_RSSISTOP_TASKS_RSSISTOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_BCSTART */
++/* Description: Start the bit counter */
++
++/* Bit 0 : Start the bit counter */
++#define RADIO_TASKS_BCSTART_TASKS_BCSTART_Pos (0UL) /*!< Position of TASKS_BCSTART field. */
++#define RADIO_TASKS_BCSTART_TASKS_BCSTART_Msk (0x1UL << RADIO_TASKS_BCSTART_TASKS_BCSTART_Pos) /*!< Bit mask of TASKS_BCSTART field. */
++#define RADIO_TASKS_BCSTART_TASKS_BCSTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_BCSTOP */
++/* Description: Stop the bit counter */
++
++/* Bit 0 : Stop the bit counter */
++#define RADIO_TASKS_BCSTOP_TASKS_BCSTOP_Pos (0UL) /*!< Position of TASKS_BCSTOP field. */
++#define RADIO_TASKS_BCSTOP_TASKS_BCSTOP_Msk (0x1UL << RADIO_TASKS_BCSTOP_TASKS_BCSTOP_Pos) /*!< Bit mask of TASKS_BCSTOP field. */
++#define RADIO_TASKS_BCSTOP_TASKS_BCSTOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_EDSTART */
++/* Description: Start the energy detect measurement used in IEEE 802.15.4 mode */
++
++/* Bit 0 : Start the energy detect measurement used in IEEE 802.15.4 mode */
++#define RADIO_TASKS_EDSTART_TASKS_EDSTART_Pos (0UL) /*!< Position of TASKS_EDSTART field. */
++#define RADIO_TASKS_EDSTART_TASKS_EDSTART_Msk (0x1UL << RADIO_TASKS_EDSTART_TASKS_EDSTART_Pos) /*!< Bit mask of TASKS_EDSTART field. */
++#define RADIO_TASKS_EDSTART_TASKS_EDSTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_EDSTOP */
++/* Description: Stop the energy detect measurement */
++
++/* Bit 0 : Stop the energy detect measurement */
++#define RADIO_TASKS_EDSTOP_TASKS_EDSTOP_Pos (0UL) /*!< Position of TASKS_EDSTOP field. */
++#define RADIO_TASKS_EDSTOP_TASKS_EDSTOP_Msk (0x1UL << RADIO_TASKS_EDSTOP_TASKS_EDSTOP_Pos) /*!< Bit mask of TASKS_EDSTOP field. */
++#define RADIO_TASKS_EDSTOP_TASKS_EDSTOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_CCASTART */
++/* Description: Start the clear channel assessment used in IEEE 802.15.4 mode */
++
++/* Bit 0 : Start the clear channel assessment used in IEEE 802.15.4 mode */
++#define RADIO_TASKS_CCASTART_TASKS_CCASTART_Pos (0UL) /*!< Position of TASKS_CCASTART field. */
++#define RADIO_TASKS_CCASTART_TASKS_CCASTART_Msk (0x1UL << RADIO_TASKS_CCASTART_TASKS_CCASTART_Pos) /*!< Bit mask of TASKS_CCASTART field. */
++#define RADIO_TASKS_CCASTART_TASKS_CCASTART_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_TASKS_CCASTOP */
++/* Description: Stop the clear channel assessment */
++
++/* Bit 0 : Stop the clear channel assessment */
++#define RADIO_TASKS_CCASTOP_TASKS_CCASTOP_Pos (0UL) /*!< Position of TASKS_CCASTOP field. */
++#define RADIO_TASKS_CCASTOP_TASKS_CCASTOP_Msk (0x1UL << RADIO_TASKS_CCASTOP_TASKS_CCASTOP_Pos) /*!< Bit mask of TASKS_CCASTOP field. */
++#define RADIO_TASKS_CCASTOP_TASKS_CCASTOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RADIO_EVENTS_READY */
++/* Description: RADIO has ramped up and is ready to be started */
++
++/* Bit 0 : RADIO has ramped up and is ready to be started */
++#define RADIO_EVENTS_READY_EVENTS_READY_Pos (0UL) /*!< Position of EVENTS_READY field. */
++#define RADIO_EVENTS_READY_EVENTS_READY_Msk (0x1UL << RADIO_EVENTS_READY_EVENTS_READY_Pos) /*!< Bit mask of EVENTS_READY field. */
++#define RADIO_EVENTS_READY_EVENTS_READY_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_READY_EVENTS_READY_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_ADDRESS */
++/* Description: Address sent or received */
++
++/* Bit 0 : Address sent or received */
++#define RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_Pos (0UL) /*!< Position of EVENTS_ADDRESS field. */
++#define RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_Msk (0x1UL << RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_Pos) /*!< Bit mask of EVENTS_ADDRESS field. */
++#define RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_ADDRESS_EVENTS_ADDRESS_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_PAYLOAD */
++/* Description: Packet payload sent or received */
++
++/* Bit 0 : Packet payload sent or received */
++#define RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_Pos (0UL) /*!< Position of EVENTS_PAYLOAD field. */
++#define RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_Msk (0x1UL << RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_Pos) /*!< Bit mask of EVENTS_PAYLOAD field. */
++#define RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_PAYLOAD_EVENTS_PAYLOAD_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_END */
++/* Description: Packet sent or received */
++
++/* Bit 0 : Packet sent or received */
++#define RADIO_EVENTS_END_EVENTS_END_Pos (0UL) /*!< Position of EVENTS_END field. */
++#define RADIO_EVENTS_END_EVENTS_END_Msk (0x1UL << RADIO_EVENTS_END_EVENTS_END_Pos) /*!< Bit mask of EVENTS_END field. */
++#define RADIO_EVENTS_END_EVENTS_END_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_END_EVENTS_END_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_DISABLED */
++/* Description: RADIO has been disabled */
++
++/* Bit 0 : RADIO has been disabled */
++#define RADIO_EVENTS_DISABLED_EVENTS_DISABLED_Pos (0UL) /*!< Position of EVENTS_DISABLED field. */
++#define RADIO_EVENTS_DISABLED_EVENTS_DISABLED_Msk (0x1UL << RADIO_EVENTS_DISABLED_EVENTS_DISABLED_Pos) /*!< Bit mask of EVENTS_DISABLED field. */
++#define RADIO_EVENTS_DISABLED_EVENTS_DISABLED_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_DISABLED_EVENTS_DISABLED_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_DEVMATCH */
++/* Description: A device address match occurred on the last received packet */
++
++/* Bit 0 : A device address match occurred on the last received packet */
++#define RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_Pos (0UL) /*!< Position of EVENTS_DEVMATCH field. */
++#define RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_Msk (0x1UL << RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_Pos) /*!< Bit mask of EVENTS_DEVMATCH field. */
++#define RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_DEVMATCH_EVENTS_DEVMATCH_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_DEVMISS */
++/* Description: No device address match occurred on the last received packet */
++
++/* Bit 0 : No device address match occurred on the last received packet */
++#define RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_Pos (0UL) /*!< Position of EVENTS_DEVMISS field. */
++#define RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_Msk (0x1UL << RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_Pos) /*!< Bit mask of EVENTS_DEVMISS field. */
++#define RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_DEVMISS_EVENTS_DEVMISS_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_RSSIEND */
++/* Description: Sampling of receive signal strength complete */
++
++/* Bit 0 : Sampling of receive signal strength complete */
++#define RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_Pos (0UL) /*!< Position of EVENTS_RSSIEND field. */
++#define RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_Msk (0x1UL << RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_Pos) /*!< Bit mask of EVENTS_RSSIEND field. */
++#define RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_RSSIEND_EVENTS_RSSIEND_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_BCMATCH */
++/* Description: Bit counter reached bit count value */
++
++/* Bit 0 : Bit counter reached bit count value */
++#define RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_Pos (0UL) /*!< Position of EVENTS_BCMATCH field. */
++#define RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_Msk (0x1UL << RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_Pos) /*!< Bit mask of EVENTS_BCMATCH field. */
++#define RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_BCMATCH_EVENTS_BCMATCH_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_CRCOK */
++/* Description: Packet received with CRC ok */
++
++/* Bit 0 : Packet received with CRC ok */
++#define RADIO_EVENTS_CRCOK_EVENTS_CRCOK_Pos (0UL) /*!< Position of EVENTS_CRCOK field. */
++#define RADIO_EVENTS_CRCOK_EVENTS_CRCOK_Msk (0x1UL << RADIO_EVENTS_CRCOK_EVENTS_CRCOK_Pos) /*!< Bit mask of EVENTS_CRCOK field. */
++#define RADIO_EVENTS_CRCOK_EVENTS_CRCOK_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_CRCOK_EVENTS_CRCOK_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_CRCERROR */
++/* Description: Packet received with CRC error */
++
++/* Bit 0 : Packet received with CRC error */
++#define RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_Pos (0UL) /*!< Position of EVENTS_CRCERROR field. */
++#define RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_Msk (0x1UL << RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_Pos) /*!< Bit mask of EVENTS_CRCERROR field. */
++#define RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_CRCERROR_EVENTS_CRCERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_FRAMESTART */
++/* Description: IEEE 802.15.4 length field received */
++
++/* Bit 0 : IEEE 802.15.4 length field received */
++#define RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Pos (0UL) /*!< Position of EVENTS_FRAMESTART field. */
++#define RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Msk (0x1UL << RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Pos) /*!< Bit mask of EVENTS_FRAMESTART field. */
++#define RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_FRAMESTART_EVENTS_FRAMESTART_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_EDEND */
++/* Description: Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register. */
++
++/* Bit 0 : Sampling of energy detection complete. A new ED sample is ready for readout from the RADIO.EDSAMPLE register. */
++#define RADIO_EVENTS_EDEND_EVENTS_EDEND_Pos (0UL) /*!< Position of EVENTS_EDEND field. */
++#define RADIO_EVENTS_EDEND_EVENTS_EDEND_Msk (0x1UL << RADIO_EVENTS_EDEND_EVENTS_EDEND_Pos) /*!< Bit mask of EVENTS_EDEND field. */
++#define RADIO_EVENTS_EDEND_EVENTS_EDEND_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_EDEND_EVENTS_EDEND_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_EDSTOPPED */
++/* Description: The sampling of energy detection has stopped */
++
++/* Bit 0 : The sampling of energy detection has stopped */
++#define RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_Pos (0UL) /*!< Position of EVENTS_EDSTOPPED field. */
++#define RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_Msk (0x1UL << RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_Pos) /*!< Bit mask of EVENTS_EDSTOPPED field. */
++#define RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_EDSTOPPED_EVENTS_EDSTOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_CCAIDLE */
++/* Description: Wireless medium in idle - clear to send */
++
++/* Bit 0 : Wireless medium in idle - clear to send */
++#define RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_Pos (0UL) /*!< Position of EVENTS_CCAIDLE field. */
++#define RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_Msk (0x1UL << RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_Pos) /*!< Bit mask of EVENTS_CCAIDLE field. */
++#define RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_CCAIDLE_EVENTS_CCAIDLE_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_CCABUSY */
++/* Description: Wireless medium busy - do not send */
++
++/* Bit 0 : Wireless medium busy - do not send */
++#define RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_Pos (0UL) /*!< Position of EVENTS_CCABUSY field. */
++#define RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_Msk (0x1UL << RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_Pos) /*!< Bit mask of EVENTS_CCABUSY field. */
++#define RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_CCABUSY_EVENTS_CCABUSY_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_CCASTOPPED */
++/* Description: The CCA has stopped */
++
++/* Bit 0 : The CCA has stopped */
++#define RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_Pos (0UL) /*!< Position of EVENTS_CCASTOPPED field. */
++#define RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_Msk (0x1UL << RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_Pos) /*!< Bit mask of EVENTS_CCASTOPPED field. */
++#define RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_CCASTOPPED_EVENTS_CCASTOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_RATEBOOST */
++/* Description: Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit. */
++
++/* Bit 0 : Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit. */
++#define RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_Pos (0UL) /*!< Position of EVENTS_RATEBOOST field. */
++#define RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_Msk (0x1UL << RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_Pos) /*!< Bit mask of EVENTS_RATEBOOST field. */
++#define RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_RATEBOOST_EVENTS_RATEBOOST_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_TXREADY */
++/* Description: RADIO has ramped up and is ready to be started TX path */
++
++/* Bit 0 : RADIO has ramped up and is ready to be started TX path */
++#define RADIO_EVENTS_TXREADY_EVENTS_TXREADY_Pos (0UL) /*!< Position of EVENTS_TXREADY field. */
++#define RADIO_EVENTS_TXREADY_EVENTS_TXREADY_Msk (0x1UL << RADIO_EVENTS_TXREADY_EVENTS_TXREADY_Pos) /*!< Bit mask of EVENTS_TXREADY field. */
++#define RADIO_EVENTS_TXREADY_EVENTS_TXREADY_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_TXREADY_EVENTS_TXREADY_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_RXREADY */
++/* Description: RADIO has ramped up and is ready to be started RX path */
++
++/* Bit 0 : RADIO has ramped up and is ready to be started RX path */
++#define RADIO_EVENTS_RXREADY_EVENTS_RXREADY_Pos (0UL) /*!< Position of EVENTS_RXREADY field. */
++#define RADIO_EVENTS_RXREADY_EVENTS_RXREADY_Msk (0x1UL << RADIO_EVENTS_RXREADY_EVENTS_RXREADY_Pos) /*!< Bit mask of EVENTS_RXREADY field. */
++#define RADIO_EVENTS_RXREADY_EVENTS_RXREADY_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_RXREADY_EVENTS_RXREADY_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_MHRMATCH */
++/* Description: MAC header match found */
++
++/* Bit 0 : MAC header match found */
++#define RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_Pos (0UL) /*!< Position of EVENTS_MHRMATCH field. */
++#define RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_Msk (0x1UL << RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_Pos) /*!< Bit mask of EVENTS_MHRMATCH field. */
++#define RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_MHRMATCH_EVENTS_MHRMATCH_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_SYNC */
++/* Description: Preamble indicator. */
++
++/* Bit 0 : Preamble indicator. */
++#define RADIO_EVENTS_SYNC_EVENTS_SYNC_Pos (0UL) /*!< Position of EVENTS_SYNC field. */
++#define RADIO_EVENTS_SYNC_EVENTS_SYNC_Msk (0x1UL << RADIO_EVENTS_SYNC_EVENTS_SYNC_Pos) /*!< Bit mask of EVENTS_SYNC field. */
++#define RADIO_EVENTS_SYNC_EVENTS_SYNC_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_SYNC_EVENTS_SYNC_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_EVENTS_PHYEND */
++/* Description: Generated in Ble_LR125Kbit, Ble_LR500Kbit and Ieee802154_250Kbit modes when last bit is sent on air. */
++
++/* Bit 0 : Generated in Ble_LR125Kbit, Ble_LR500Kbit and Ieee802154_250Kbit modes when last bit is sent on air. */
++#define RADIO_EVENTS_PHYEND_EVENTS_PHYEND_Pos (0UL) /*!< Position of EVENTS_PHYEND field. */
++#define RADIO_EVENTS_PHYEND_EVENTS_PHYEND_Msk (0x1UL << RADIO_EVENTS_PHYEND_EVENTS_PHYEND_Pos) /*!< Bit mask of EVENTS_PHYEND field. */
++#define RADIO_EVENTS_PHYEND_EVENTS_PHYEND_NotGenerated (0UL) /*!< Event not generated */
++#define RADIO_EVENTS_PHYEND_EVENTS_PHYEND_Generated (1UL) /*!< Event generated */
++
++/* Register: RADIO_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 21 : Shortcut between event PHYEND and task START */
++#define RADIO_SHORTS_PHYEND_START_Pos (21UL) /*!< Position of PHYEND_START field. */
++#define RADIO_SHORTS_PHYEND_START_Msk (0x1UL << RADIO_SHORTS_PHYEND_START_Pos) /*!< Bit mask of PHYEND_START field. */
++#define RADIO_SHORTS_PHYEND_START_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_PHYEND_START_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 20 : Shortcut between event PHYEND and task DISABLE */
++#define RADIO_SHORTS_PHYEND_DISABLE_Pos (20UL) /*!< Position of PHYEND_DISABLE field. */
++#define RADIO_SHORTS_PHYEND_DISABLE_Msk (0x1UL << RADIO_SHORTS_PHYEND_DISABLE_Pos) /*!< Bit mask of PHYEND_DISABLE field. */
++#define RADIO_SHORTS_PHYEND_DISABLE_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_PHYEND_DISABLE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 19 : Shortcut between event RXREADY and task START */
++#define RADIO_SHORTS_RXREADY_START_Pos (19UL) /*!< Position of RXREADY_START field. */
++#define RADIO_SHORTS_RXREADY_START_Msk (0x1UL << RADIO_SHORTS_RXREADY_START_Pos) /*!< Bit mask of RXREADY_START field. */
++#define RADIO_SHORTS_RXREADY_START_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_RXREADY_START_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 18 : Shortcut between event TXREADY and task START */
++#define RADIO_SHORTS_TXREADY_START_Pos (18UL) /*!< Position of TXREADY_START field. */
++#define RADIO_SHORTS_TXREADY_START_Msk (0x1UL << RADIO_SHORTS_TXREADY_START_Pos) /*!< Bit mask of TXREADY_START field. */
++#define RADIO_SHORTS_TXREADY_START_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_TXREADY_START_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 17 : Shortcut between event CCAIDLE and task STOP */
++#define RADIO_SHORTS_CCAIDLE_STOP_Pos (17UL) /*!< Position of CCAIDLE_STOP field. */
++#define RADIO_SHORTS_CCAIDLE_STOP_Msk (0x1UL << RADIO_SHORTS_CCAIDLE_STOP_Pos) /*!< Bit mask of CCAIDLE_STOP field. */
++#define RADIO_SHORTS_CCAIDLE_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_CCAIDLE_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 16 : Shortcut between event EDEND and task DISABLE */
++#define RADIO_SHORTS_EDEND_DISABLE_Pos (16UL) /*!< Position of EDEND_DISABLE field. */
++#define RADIO_SHORTS_EDEND_DISABLE_Msk (0x1UL << RADIO_SHORTS_EDEND_DISABLE_Pos) /*!< Bit mask of EDEND_DISABLE field. */
++#define RADIO_SHORTS_EDEND_DISABLE_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_EDEND_DISABLE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 15 : Shortcut between event READY and task EDSTART */
++#define RADIO_SHORTS_READY_EDSTART_Pos (15UL) /*!< Position of READY_EDSTART field. */
++#define RADIO_SHORTS_READY_EDSTART_Msk (0x1UL << RADIO_SHORTS_READY_EDSTART_Pos) /*!< Bit mask of READY_EDSTART field. */
++#define RADIO_SHORTS_READY_EDSTART_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_READY_EDSTART_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 14 : Shortcut between event FRAMESTART and task BCSTART */
++#define RADIO_SHORTS_FRAMESTART_BCSTART_Pos (14UL) /*!< Position of FRAMESTART_BCSTART field. */
++#define RADIO_SHORTS_FRAMESTART_BCSTART_Msk (0x1UL << RADIO_SHORTS_FRAMESTART_BCSTART_Pos) /*!< Bit mask of FRAMESTART_BCSTART field. */
++#define RADIO_SHORTS_FRAMESTART_BCSTART_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_FRAMESTART_BCSTART_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 13 : Shortcut between event CCABUSY and task DISABLE */
++#define RADIO_SHORTS_CCABUSY_DISABLE_Pos (13UL) /*!< Position of CCABUSY_DISABLE field. */
++#define RADIO_SHORTS_CCABUSY_DISABLE_Msk (0x1UL << RADIO_SHORTS_CCABUSY_DISABLE_Pos) /*!< Bit mask of CCABUSY_DISABLE field. */
++#define RADIO_SHORTS_CCABUSY_DISABLE_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_CCABUSY_DISABLE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 12 : Shortcut between event CCAIDLE and task TXEN */
++#define RADIO_SHORTS_CCAIDLE_TXEN_Pos (12UL) /*!< Position of CCAIDLE_TXEN field. */
++#define RADIO_SHORTS_CCAIDLE_TXEN_Msk (0x1UL << RADIO_SHORTS_CCAIDLE_TXEN_Pos) /*!< Bit mask of CCAIDLE_TXEN field. */
++#define RADIO_SHORTS_CCAIDLE_TXEN_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_CCAIDLE_TXEN_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 11 : Shortcut between event RXREADY and task CCASTART */
++#define RADIO_SHORTS_RXREADY_CCASTART_Pos (11UL) /*!< Position of RXREADY_CCASTART field. */
++#define RADIO_SHORTS_RXREADY_CCASTART_Msk (0x1UL << RADIO_SHORTS_RXREADY_CCASTART_Pos) /*!< Bit mask of RXREADY_CCASTART field. */
++#define RADIO_SHORTS_RXREADY_CCASTART_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_RXREADY_CCASTART_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 8 : Shortcut between event DISABLED and task RSSISTOP */
++#define RADIO_SHORTS_DISABLED_RSSISTOP_Pos (8UL) /*!< Position of DISABLED_RSSISTOP field. */
++#define RADIO_SHORTS_DISABLED_RSSISTOP_Msk (0x1UL << RADIO_SHORTS_DISABLED_RSSISTOP_Pos) /*!< Bit mask of DISABLED_RSSISTOP field. */
++#define RADIO_SHORTS_DISABLED_RSSISTOP_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_DISABLED_RSSISTOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 6 : Shortcut between event ADDRESS and task BCSTART */
++#define RADIO_SHORTS_ADDRESS_BCSTART_Pos (6UL) /*!< Position of ADDRESS_BCSTART field. */
++#define RADIO_SHORTS_ADDRESS_BCSTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_BCSTART_Pos) /*!< Bit mask of ADDRESS_BCSTART field. */
++#define RADIO_SHORTS_ADDRESS_BCSTART_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_ADDRESS_BCSTART_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 5 : Shortcut between event END and task START */
++#define RADIO_SHORTS_END_START_Pos (5UL) /*!< Position of END_START field. */
++#define RADIO_SHORTS_END_START_Msk (0x1UL << RADIO_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
++#define RADIO_SHORTS_END_START_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_END_START_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 4 : Shortcut between event ADDRESS and task RSSISTART */
++#define RADIO_SHORTS_ADDRESS_RSSISTART_Pos (4UL) /*!< Position of ADDRESS_RSSISTART field. */
++#define RADIO_SHORTS_ADDRESS_RSSISTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_RSSISTART_Pos) /*!< Bit mask of ADDRESS_RSSISTART field. */
++#define RADIO_SHORTS_ADDRESS_RSSISTART_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_ADDRESS_RSSISTART_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 3 : Shortcut between event DISABLED and task RXEN */
++#define RADIO_SHORTS_DISABLED_RXEN_Pos (3UL) /*!< Position of DISABLED_RXEN field. */
++#define RADIO_SHORTS_DISABLED_RXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_RXEN_Pos) /*!< Bit mask of DISABLED_RXEN field. */
++#define RADIO_SHORTS_DISABLED_RXEN_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_DISABLED_RXEN_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 2 : Shortcut between event DISABLED and task TXEN */
++#define RADIO_SHORTS_DISABLED_TXEN_Pos (2UL) /*!< Position of DISABLED_TXEN field. */
++#define RADIO_SHORTS_DISABLED_TXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_TXEN_Pos) /*!< Bit mask of DISABLED_TXEN field. */
++#define RADIO_SHORTS_DISABLED_TXEN_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_DISABLED_TXEN_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 1 : Shortcut between event END and task DISABLE */
++#define RADIO_SHORTS_END_DISABLE_Pos (1UL) /*!< Position of END_DISABLE field. */
++#define RADIO_SHORTS_END_DISABLE_Msk (0x1UL << RADIO_SHORTS_END_DISABLE_Pos) /*!< Bit mask of END_DISABLE field. */
++#define RADIO_SHORTS_END_DISABLE_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_END_DISABLE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event READY and task START */
++#define RADIO_SHORTS_READY_START_Pos (0UL) /*!< Position of READY_START field. */
++#define RADIO_SHORTS_READY_START_Msk (0x1UL << RADIO_SHORTS_READY_START_Pos) /*!< Bit mask of READY_START field. */
++#define RADIO_SHORTS_READY_START_Disabled (0UL) /*!< Disable shortcut */
++#define RADIO_SHORTS_READY_START_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: RADIO_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 27 : Write '1' to enable interrupt for event PHYEND */
++#define RADIO_INTENSET_PHYEND_Pos (27UL) /*!< Position of PHYEND field. */
++#define RADIO_INTENSET_PHYEND_Msk (0x1UL << RADIO_INTENSET_PHYEND_Pos) /*!< Bit mask of PHYEND field. */
++#define RADIO_INTENSET_PHYEND_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_PHYEND_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_PHYEND_Set (1UL) /*!< Enable */
++
++/* Bit 26 : Write '1' to enable interrupt for event SYNC */
++#define RADIO_INTENSET_SYNC_Pos (26UL) /*!< Position of SYNC field. */
++#define RADIO_INTENSET_SYNC_Msk (0x1UL << RADIO_INTENSET_SYNC_Pos) /*!< Bit mask of SYNC field. */
++#define RADIO_INTENSET_SYNC_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_SYNC_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_SYNC_Set (1UL) /*!< Enable */
++
++/* Bit 23 : Write '1' to enable interrupt for event MHRMATCH */
++#define RADIO_INTENSET_MHRMATCH_Pos (23UL) /*!< Position of MHRMATCH field. */
++#define RADIO_INTENSET_MHRMATCH_Msk (0x1UL << RADIO_INTENSET_MHRMATCH_Pos) /*!< Bit mask of MHRMATCH field. */
++#define RADIO_INTENSET_MHRMATCH_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_MHRMATCH_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_MHRMATCH_Set (1UL) /*!< Enable */
++
++/* Bit 22 : Write '1' to enable interrupt for event RXREADY */
++#define RADIO_INTENSET_RXREADY_Pos (22UL) /*!< Position of RXREADY field. */
++#define RADIO_INTENSET_RXREADY_Msk (0x1UL << RADIO_INTENSET_RXREADY_Pos) /*!< Bit mask of RXREADY field. */
++#define RADIO_INTENSET_RXREADY_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_RXREADY_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_RXREADY_Set (1UL) /*!< Enable */
++
++/* Bit 21 : Write '1' to enable interrupt for event TXREADY */
++#define RADIO_INTENSET_TXREADY_Pos (21UL) /*!< Position of TXREADY field. */
++#define RADIO_INTENSET_TXREADY_Msk (0x1UL << RADIO_INTENSET_TXREADY_Pos) /*!< Bit mask of TXREADY field. */
++#define RADIO_INTENSET_TXREADY_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_TXREADY_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_TXREADY_Set (1UL) /*!< Enable */
++
++/* Bit 20 : Write '1' to enable interrupt for event RATEBOOST */
++#define RADIO_INTENSET_RATEBOOST_Pos (20UL) /*!< Position of RATEBOOST field. */
++#define RADIO_INTENSET_RATEBOOST_Msk (0x1UL << RADIO_INTENSET_RATEBOOST_Pos) /*!< Bit mask of RATEBOOST field. */
++#define RADIO_INTENSET_RATEBOOST_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_RATEBOOST_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_RATEBOOST_Set (1UL) /*!< Enable */
++
++/* Bit 19 : Write '1' to enable interrupt for event CCASTOPPED */
++#define RADIO_INTENSET_CCASTOPPED_Pos (19UL) /*!< Position of CCASTOPPED field. */
++#define RADIO_INTENSET_CCASTOPPED_Msk (0x1UL << RADIO_INTENSET_CCASTOPPED_Pos) /*!< Bit mask of CCASTOPPED field. */
++#define RADIO_INTENSET_CCASTOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_CCASTOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_CCASTOPPED_Set (1UL) /*!< Enable */
++
++/* Bit 18 : Write '1' to enable interrupt for event CCABUSY */
++#define RADIO_INTENSET_CCABUSY_Pos (18UL) /*!< Position of CCABUSY field. */
++#define RADIO_INTENSET_CCABUSY_Msk (0x1UL << RADIO_INTENSET_CCABUSY_Pos) /*!< Bit mask of CCABUSY field. */
++#define RADIO_INTENSET_CCABUSY_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_CCABUSY_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_CCABUSY_Set (1UL) /*!< Enable */
++
++/* Bit 17 : Write '1' to enable interrupt for event CCAIDLE */
++#define RADIO_INTENSET_CCAIDLE_Pos (17UL) /*!< Position of CCAIDLE field. */
++#define RADIO_INTENSET_CCAIDLE_Msk (0x1UL << RADIO_INTENSET_CCAIDLE_Pos) /*!< Bit mask of CCAIDLE field. */
++#define RADIO_INTENSET_CCAIDLE_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_CCAIDLE_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_CCAIDLE_Set (1UL) /*!< Enable */
++
++/* Bit 16 : Write '1' to enable interrupt for event EDSTOPPED */
++#define RADIO_INTENSET_EDSTOPPED_Pos (16UL) /*!< Position of EDSTOPPED field. */
++#define RADIO_INTENSET_EDSTOPPED_Msk (0x1UL << RADIO_INTENSET_EDSTOPPED_Pos) /*!< Bit mask of EDSTOPPED field. */
++#define RADIO_INTENSET_EDSTOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_EDSTOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_EDSTOPPED_Set (1UL) /*!< Enable */
++
++/* Bit 15 : Write '1' to enable interrupt for event EDEND */
++#define RADIO_INTENSET_EDEND_Pos (15UL) /*!< Position of EDEND field. */
++#define RADIO_INTENSET_EDEND_Msk (0x1UL << RADIO_INTENSET_EDEND_Pos) /*!< Bit mask of EDEND field. */
++#define RADIO_INTENSET_EDEND_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_EDEND_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_EDEND_Set (1UL) /*!< Enable */
++
++/* Bit 14 : Write '1' to enable interrupt for event FRAMESTART */
++#define RADIO_INTENSET_FRAMESTART_Pos (14UL) /*!< Position of FRAMESTART field. */
++#define RADIO_INTENSET_FRAMESTART_Msk (0x1UL << RADIO_INTENSET_FRAMESTART_Pos) /*!< Bit mask of FRAMESTART field. */
++#define RADIO_INTENSET_FRAMESTART_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_FRAMESTART_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_FRAMESTART_Set (1UL) /*!< Enable */
++
++/* Bit 13 : Write '1' to enable interrupt for event CRCERROR */
++#define RADIO_INTENSET_CRCERROR_Pos (13UL) /*!< Position of CRCERROR field. */
++#define RADIO_INTENSET_CRCERROR_Msk (0x1UL << RADIO_INTENSET_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
++#define RADIO_INTENSET_CRCERROR_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_CRCERROR_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_CRCERROR_Set (1UL) /*!< Enable */
++
++/* Bit 12 : Write '1' to enable interrupt for event CRCOK */
++#define RADIO_INTENSET_CRCOK_Pos (12UL) /*!< Position of CRCOK field. */
++#define RADIO_INTENSET_CRCOK_Msk (0x1UL << RADIO_INTENSET_CRCOK_Pos) /*!< Bit mask of CRCOK field. */
++#define RADIO_INTENSET_CRCOK_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_CRCOK_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_CRCOK_Set (1UL) /*!< Enable */
++
++/* Bit 10 : Write '1' to enable interrupt for event BCMATCH */
++#define RADIO_INTENSET_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
++#define RADIO_INTENSET_BCMATCH_Msk (0x1UL << RADIO_INTENSET_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
++#define RADIO_INTENSET_BCMATCH_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_BCMATCH_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_BCMATCH_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event RSSIEND */
++#define RADIO_INTENSET_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
++#define RADIO_INTENSET_RSSIEND_Msk (0x1UL << RADIO_INTENSET_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
++#define RADIO_INTENSET_RSSIEND_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_RSSIEND_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_RSSIEND_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event DEVMISS */
++#define RADIO_INTENSET_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
++#define RADIO_INTENSET_DEVMISS_Msk (0x1UL << RADIO_INTENSET_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
++#define RADIO_INTENSET_DEVMISS_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_DEVMISS_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_DEVMISS_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event DEVMATCH */
++#define RADIO_INTENSET_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
++#define RADIO_INTENSET_DEVMATCH_Msk (0x1UL << RADIO_INTENSET_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
++#define RADIO_INTENSET_DEVMATCH_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_DEVMATCH_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_DEVMATCH_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event DISABLED */
++#define RADIO_INTENSET_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
++#define RADIO_INTENSET_DISABLED_Msk (0x1UL << RADIO_INTENSET_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
++#define RADIO_INTENSET_DISABLED_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_DISABLED_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_DISABLED_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event END */
++#define RADIO_INTENSET_END_Pos (3UL) /*!< Position of END field. */
++#define RADIO_INTENSET_END_Msk (0x1UL << RADIO_INTENSET_END_Pos) /*!< Bit mask of END field. */
++#define RADIO_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_END_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event PAYLOAD */
++#define RADIO_INTENSET_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
++#define RADIO_INTENSET_PAYLOAD_Msk (0x1UL << RADIO_INTENSET_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
++#define RADIO_INTENSET_PAYLOAD_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_PAYLOAD_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_PAYLOAD_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event ADDRESS */
++#define RADIO_INTENSET_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
++#define RADIO_INTENSET_ADDRESS_Msk (0x1UL << RADIO_INTENSET_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
++#define RADIO_INTENSET_ADDRESS_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_ADDRESS_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_ADDRESS_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event READY */
++#define RADIO_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
++#define RADIO_INTENSET_READY_Msk (0x1UL << RADIO_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
++#define RADIO_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENSET_READY_Set (1UL) /*!< Enable */
++
++/* Register: RADIO_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 27 : Write '1' to disable interrupt for event PHYEND */
++#define RADIO_INTENCLR_PHYEND_Pos (27UL) /*!< Position of PHYEND field. */
++#define RADIO_INTENCLR_PHYEND_Msk (0x1UL << RADIO_INTENCLR_PHYEND_Pos) /*!< Bit mask of PHYEND field. */
++#define RADIO_INTENCLR_PHYEND_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_PHYEND_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_PHYEND_Clear (1UL) /*!< Disable */
++
++/* Bit 26 : Write '1' to disable interrupt for event SYNC */
++#define RADIO_INTENCLR_SYNC_Pos (26UL) /*!< Position of SYNC field. */
++#define RADIO_INTENCLR_SYNC_Msk (0x1UL << RADIO_INTENCLR_SYNC_Pos) /*!< Bit mask of SYNC field. */
++#define RADIO_INTENCLR_SYNC_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_SYNC_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_SYNC_Clear (1UL) /*!< Disable */
++
++/* Bit 23 : Write '1' to disable interrupt for event MHRMATCH */
++#define RADIO_INTENCLR_MHRMATCH_Pos (23UL) /*!< Position of MHRMATCH field. */
++#define RADIO_INTENCLR_MHRMATCH_Msk (0x1UL << RADIO_INTENCLR_MHRMATCH_Pos) /*!< Bit mask of MHRMATCH field. */
++#define RADIO_INTENCLR_MHRMATCH_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_MHRMATCH_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_MHRMATCH_Clear (1UL) /*!< Disable */
++
++/* Bit 22 : Write '1' to disable interrupt for event RXREADY */
++#define RADIO_INTENCLR_RXREADY_Pos (22UL) /*!< Position of RXREADY field. */
++#define RADIO_INTENCLR_RXREADY_Msk (0x1UL << RADIO_INTENCLR_RXREADY_Pos) /*!< Bit mask of RXREADY field. */
++#define RADIO_INTENCLR_RXREADY_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_RXREADY_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_RXREADY_Clear (1UL) /*!< Disable */
++
++/* Bit 21 : Write '1' to disable interrupt for event TXREADY */
++#define RADIO_INTENCLR_TXREADY_Pos (21UL) /*!< Position of TXREADY field. */
++#define RADIO_INTENCLR_TXREADY_Msk (0x1UL << RADIO_INTENCLR_TXREADY_Pos) /*!< Bit mask of TXREADY field. */
++#define RADIO_INTENCLR_TXREADY_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_TXREADY_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_TXREADY_Clear (1UL) /*!< Disable */
++
++/* Bit 20 : Write '1' to disable interrupt for event RATEBOOST */
++#define RADIO_INTENCLR_RATEBOOST_Pos (20UL) /*!< Position of RATEBOOST field. */
++#define RADIO_INTENCLR_RATEBOOST_Msk (0x1UL << RADIO_INTENCLR_RATEBOOST_Pos) /*!< Bit mask of RATEBOOST field. */
++#define RADIO_INTENCLR_RATEBOOST_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_RATEBOOST_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_RATEBOOST_Clear (1UL) /*!< Disable */
++
++/* Bit 19 : Write '1' to disable interrupt for event CCASTOPPED */
++#define RADIO_INTENCLR_CCASTOPPED_Pos (19UL) /*!< Position of CCASTOPPED field. */
++#define RADIO_INTENCLR_CCASTOPPED_Msk (0x1UL << RADIO_INTENCLR_CCASTOPPED_Pos) /*!< Bit mask of CCASTOPPED field. */
++#define RADIO_INTENCLR_CCASTOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_CCASTOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_CCASTOPPED_Clear (1UL) /*!< Disable */
++
++/* Bit 18 : Write '1' to disable interrupt for event CCABUSY */
++#define RADIO_INTENCLR_CCABUSY_Pos (18UL) /*!< Position of CCABUSY field. */
++#define RADIO_INTENCLR_CCABUSY_Msk (0x1UL << RADIO_INTENCLR_CCABUSY_Pos) /*!< Bit mask of CCABUSY field. */
++#define RADIO_INTENCLR_CCABUSY_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_CCABUSY_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_CCABUSY_Clear (1UL) /*!< Disable */
++
++/* Bit 17 : Write '1' to disable interrupt for event CCAIDLE */
++#define RADIO_INTENCLR_CCAIDLE_Pos (17UL) /*!< Position of CCAIDLE field. */
++#define RADIO_INTENCLR_CCAIDLE_Msk (0x1UL << RADIO_INTENCLR_CCAIDLE_Pos) /*!< Bit mask of CCAIDLE field. */
++#define RADIO_INTENCLR_CCAIDLE_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_CCAIDLE_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_CCAIDLE_Clear (1UL) /*!< Disable */
++
++/* Bit 16 : Write '1' to disable interrupt for event EDSTOPPED */
++#define RADIO_INTENCLR_EDSTOPPED_Pos (16UL) /*!< Position of EDSTOPPED field. */
++#define RADIO_INTENCLR_EDSTOPPED_Msk (0x1UL << RADIO_INTENCLR_EDSTOPPED_Pos) /*!< Bit mask of EDSTOPPED field. */
++#define RADIO_INTENCLR_EDSTOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_EDSTOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_EDSTOPPED_Clear (1UL) /*!< Disable */
++
++/* Bit 15 : Write '1' to disable interrupt for event EDEND */
++#define RADIO_INTENCLR_EDEND_Pos (15UL) /*!< Position of EDEND field. */
++#define RADIO_INTENCLR_EDEND_Msk (0x1UL << RADIO_INTENCLR_EDEND_Pos) /*!< Bit mask of EDEND field. */
++#define RADIO_INTENCLR_EDEND_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_EDEND_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_EDEND_Clear (1UL) /*!< Disable */
++
++/* Bit 14 : Write '1' to disable interrupt for event FRAMESTART */
++#define RADIO_INTENCLR_FRAMESTART_Pos (14UL) /*!< Position of FRAMESTART field. */
++#define RADIO_INTENCLR_FRAMESTART_Msk (0x1UL << RADIO_INTENCLR_FRAMESTART_Pos) /*!< Bit mask of FRAMESTART field. */
++#define RADIO_INTENCLR_FRAMESTART_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_FRAMESTART_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_FRAMESTART_Clear (1UL) /*!< Disable */
++
++/* Bit 13 : Write '1' to disable interrupt for event CRCERROR */
++#define RADIO_INTENCLR_CRCERROR_Pos (13UL) /*!< Position of CRCERROR field. */
++#define RADIO_INTENCLR_CRCERROR_Msk (0x1UL << RADIO_INTENCLR_CRCERROR_Pos) /*!< Bit mask of CRCERROR field. */
++#define RADIO_INTENCLR_CRCERROR_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_CRCERROR_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_CRCERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 12 : Write '1' to disable interrupt for event CRCOK */
++#define RADIO_INTENCLR_CRCOK_Pos (12UL) /*!< Position of CRCOK field. */
++#define RADIO_INTENCLR_CRCOK_Msk (0x1UL << RADIO_INTENCLR_CRCOK_Pos) /*!< Bit mask of CRCOK field. */
++#define RADIO_INTENCLR_CRCOK_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_CRCOK_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_CRCOK_Clear (1UL) /*!< Disable */
++
++/* Bit 10 : Write '1' to disable interrupt for event BCMATCH */
++#define RADIO_INTENCLR_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
++#define RADIO_INTENCLR_BCMATCH_Msk (0x1UL << RADIO_INTENCLR_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
++#define RADIO_INTENCLR_BCMATCH_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_BCMATCH_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_BCMATCH_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event RSSIEND */
++#define RADIO_INTENCLR_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
++#define RADIO_INTENCLR_RSSIEND_Msk (0x1UL << RADIO_INTENCLR_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
++#define RADIO_INTENCLR_RSSIEND_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_RSSIEND_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_RSSIEND_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event DEVMISS */
++#define RADIO_INTENCLR_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
++#define RADIO_INTENCLR_DEVMISS_Msk (0x1UL << RADIO_INTENCLR_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
++#define RADIO_INTENCLR_DEVMISS_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_DEVMISS_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_DEVMISS_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event DEVMATCH */
++#define RADIO_INTENCLR_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
++#define RADIO_INTENCLR_DEVMATCH_Msk (0x1UL << RADIO_INTENCLR_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
++#define RADIO_INTENCLR_DEVMATCH_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_DEVMATCH_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_DEVMATCH_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event DISABLED */
++#define RADIO_INTENCLR_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
++#define RADIO_INTENCLR_DISABLED_Msk (0x1UL << RADIO_INTENCLR_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
++#define RADIO_INTENCLR_DISABLED_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_DISABLED_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_DISABLED_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event END */
++#define RADIO_INTENCLR_END_Pos (3UL) /*!< Position of END field. */
++#define RADIO_INTENCLR_END_Msk (0x1UL << RADIO_INTENCLR_END_Pos) /*!< Bit mask of END field. */
++#define RADIO_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_END_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event PAYLOAD */
++#define RADIO_INTENCLR_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
++#define RADIO_INTENCLR_PAYLOAD_Msk (0x1UL << RADIO_INTENCLR_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
++#define RADIO_INTENCLR_PAYLOAD_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_PAYLOAD_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_PAYLOAD_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event ADDRESS */
++#define RADIO_INTENCLR_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
++#define RADIO_INTENCLR_ADDRESS_Msk (0x1UL << RADIO_INTENCLR_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
++#define RADIO_INTENCLR_ADDRESS_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_ADDRESS_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_ADDRESS_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event READY */
++#define RADIO_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
++#define RADIO_INTENCLR_READY_Msk (0x1UL << RADIO_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
++#define RADIO_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
++#define RADIO_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
++#define RADIO_INTENCLR_READY_Clear (1UL) /*!< Disable */
++
++/* Register: RADIO_CRCSTATUS */
++/* Description: CRC status */
++
++/* Bit 0 : CRC status of packet received */
++#define RADIO_CRCSTATUS_CRCSTATUS_Pos (0UL) /*!< Position of CRCSTATUS field. */
++#define RADIO_CRCSTATUS_CRCSTATUS_Msk (0x1UL << RADIO_CRCSTATUS_CRCSTATUS_Pos) /*!< Bit mask of CRCSTATUS field. */
++#define RADIO_CRCSTATUS_CRCSTATUS_CRCError (0UL) /*!< Packet received with CRC error */
++#define RADIO_CRCSTATUS_CRCSTATUS_CRCOk (1UL) /*!< Packet received with CRC ok */
++
++/* Register: RADIO_RXMATCH */
++/* Description: Received address */
++
++/* Bits 2..0 : Received address */
++#define RADIO_RXMATCH_RXMATCH_Pos (0UL) /*!< Position of RXMATCH field. */
++#define RADIO_RXMATCH_RXMATCH_Msk (0x7UL << RADIO_RXMATCH_RXMATCH_Pos) /*!< Bit mask of RXMATCH field. */
++
++/* Register: RADIO_RXCRC */
++/* Description: CRC field of previously received packet */
++
++/* Bits 23..0 : CRC field of previously received packet */
++#define RADIO_RXCRC_RXCRC_Pos (0UL) /*!< Position of RXCRC field. */
++#define RADIO_RXCRC_RXCRC_Msk (0xFFFFFFUL << RADIO_RXCRC_RXCRC_Pos) /*!< Bit mask of RXCRC field. */
++
++/* Register: RADIO_DAI */
++/* Description: Device address match index */
++
++/* Bits 2..0 : Device address match index */
++#define RADIO_DAI_DAI_Pos (0UL) /*!< Position of DAI field. */
++#define RADIO_DAI_DAI_Msk (0x7UL << RADIO_DAI_DAI_Pos) /*!< Bit mask of DAI field. */
++
++/* Register: RADIO_PDUSTAT */
++/* Description: Payload status */
++
++/* Bits 2..1 : Status on what rate packet is received with in Long Range */
++#define RADIO_PDUSTAT_CISTAT_Pos (1UL) /*!< Position of CISTAT field. */
++#define RADIO_PDUSTAT_CISTAT_Msk (0x3UL << RADIO_PDUSTAT_CISTAT_Pos) /*!< Bit mask of CISTAT field. */
++#define RADIO_PDUSTAT_CISTAT_LR125kbit (0UL) /*!< Frame is received at 125kbps */
++#define RADIO_PDUSTAT_CISTAT_LR500kbit (1UL) /*!< Frame is received at 500kbps */
++
++/* Bit 0 : Status on payload length vs. PCNF1.MAXLEN */
++#define RADIO_PDUSTAT_PDUSTAT_Pos (0UL) /*!< Position of PDUSTAT field. */
++#define RADIO_PDUSTAT_PDUSTAT_Msk (0x1UL << RADIO_PDUSTAT_PDUSTAT_Pos) /*!< Bit mask of PDUSTAT field. */
++#define RADIO_PDUSTAT_PDUSTAT_LessThan (0UL) /*!< Payload less than PCNF1.MAXLEN */
++#define RADIO_PDUSTAT_PDUSTAT_GreaterThan (1UL) /*!< Payload greater than PCNF1.MAXLEN */
++
++/* Register: RADIO_PACKETPTR */
++/* Description: Packet pointer */
++
++/* Bits 31..0 : Packet pointer */
++#define RADIO_PACKETPTR_PACKETPTR_Pos (0UL) /*!< Position of PACKETPTR field. */
++#define RADIO_PACKETPTR_PACKETPTR_Msk (0xFFFFFFFFUL << RADIO_PACKETPTR_PACKETPTR_Pos) /*!< Bit mask of PACKETPTR field. */
++
++/* Register: RADIO_FREQUENCY */
++/* Description: Frequency */
++
++/* Bit 8 : Channel map selection. */
++#define RADIO_FREQUENCY_MAP_Pos (8UL) /*!< Position of MAP field. */
++#define RADIO_FREQUENCY_MAP_Msk (0x1UL << RADIO_FREQUENCY_MAP_Pos) /*!< Bit mask of MAP field. */
++#define RADIO_FREQUENCY_MAP_Default (0UL) /*!< Channel map between 2400 MHZ .. 2500 MHz */
++#define RADIO_FREQUENCY_MAP_Low (1UL) /*!< Channel map between 2360 MHZ .. 2460 MHz */
++
++/* Bits 6..0 : Radio channel frequency */
++#define RADIO_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
++#define RADIO_FREQUENCY_FREQUENCY_Msk (0x7FUL << RADIO_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
++
++/* Register: RADIO_TXPOWER */
++/* Description: Output power */
++
++/* Bits 7..0 : RADIO output power */
++#define RADIO_TXPOWER_TXPOWER_Pos (0UL) /*!< Position of TXPOWER field. */
++#define RADIO_TXPOWER_TXPOWER_Msk (0xFFUL << RADIO_TXPOWER_TXPOWER_Pos) /*!< Bit mask of TXPOWER field. */
++#define RADIO_TXPOWER_TXPOWER_0dBm (0x0UL) /*!< 0 dBm */
++#define RADIO_TXPOWER_TXPOWER_Pos2dBm (0x2UL) /*!< +2 dBm */
++#define RADIO_TXPOWER_TXPOWER_Pos3dBm (0x3UL) /*!< +3 dBm */
++#define RADIO_TXPOWER_TXPOWER_Pos4dBm (0x4UL) /*!< +4 dBm */
++#define RADIO_TXPOWER_TXPOWER_Pos5dBm (0x5UL) /*!< +5 dBm */
++#define RADIO_TXPOWER_TXPOWER_Pos6dBm (0x6UL) /*!< +6 dBm */
++#define RADIO_TXPOWER_TXPOWER_Pos7dBm (0x7UL) /*!< +7 dBm */
++#define RADIO_TXPOWER_TXPOWER_Pos8dBm (0x8UL) /*!< +8 dBm */
++#define RADIO_TXPOWER_TXPOWER_Neg40dBm (0xD8UL) /*!< -40 dBm */
++#define RADIO_TXPOWER_TXPOWER_Neg30dBm (0xE2UL) /*!< Deprecated enumerator -  -40 dBm */
++#define RADIO_TXPOWER_TXPOWER_Neg20dBm (0xECUL) /*!< -20 dBm */
++#define RADIO_TXPOWER_TXPOWER_Neg16dBm (0xF0UL) /*!< -16 dBm */
++#define RADIO_TXPOWER_TXPOWER_Neg12dBm (0xF4UL) /*!< -12 dBm */
++#define RADIO_TXPOWER_TXPOWER_Neg8dBm (0xF8UL) /*!< -8 dBm */
++#define RADIO_TXPOWER_TXPOWER_Neg4dBm (0xFCUL) /*!< -4 dBm */
++
++/* Register: RADIO_MODE */
++/* Description: Data rate and modulation */
++
++/* Bits 3..0 : Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation. */
++#define RADIO_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
++#define RADIO_MODE_MODE_Msk (0xFUL << RADIO_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
++#define RADIO_MODE_MODE_Nrf_1Mbit (0UL) /*!< 1 Mbit/s Nordic proprietary radio mode */
++#define RADIO_MODE_MODE_Nrf_2Mbit (1UL) /*!< 2 Mbit/s Nordic proprietary radio mode */
++#define RADIO_MODE_MODE_Ble_1Mbit (3UL) /*!< 1 Mbit/s BLE */
++#define RADIO_MODE_MODE_Ble_2Mbit (4UL) /*!< 2 Mbit/s BLE */
++#define RADIO_MODE_MODE_Ble_LR125Kbit (5UL) /*!< Long range 125 kbit/s TX, 125 kbit/s and 500 kbit/s RX */
++#define RADIO_MODE_MODE_Ble_LR500Kbit (6UL) /*!< Long range 500 kbit/s TX, 125 kbit/s and 500 kbit/s RX */
++#define RADIO_MODE_MODE_Ieee802154_250Kbit (15UL) /*!< IEEE 802.15.4-2006 250 kbit/s */
++
++/* Register: RADIO_PCNF0 */
++/* Description: Packet configuration register 0 */
++
++/* Bits 30..29 : Length of TERM field in Long Range operation */
++#define RADIO_PCNF0_TERMLEN_Pos (29UL) /*!< Position of TERMLEN field. */
++#define RADIO_PCNF0_TERMLEN_Msk (0x3UL << RADIO_PCNF0_TERMLEN_Pos) /*!< Bit mask of TERMLEN field. */
++
++/* Bit 26 : Indicates if LENGTH field contains CRC or not */
++#define RADIO_PCNF0_CRCINC_Pos (26UL) /*!< Position of CRCINC field. */
++#define RADIO_PCNF0_CRCINC_Msk (0x1UL << RADIO_PCNF0_CRCINC_Pos) /*!< Bit mask of CRCINC field. */
++#define RADIO_PCNF0_CRCINC_Exclude (0UL) /*!< LENGTH does not contain CRC */
++#define RADIO_PCNF0_CRCINC_Include (1UL) /*!< LENGTH includes CRC */
++
++/* Bits 25..24 : Length of preamble on air. Decision point: TASKS_START task */
++#define RADIO_PCNF0_PLEN_Pos (24UL) /*!< Position of PLEN field. */
++#define RADIO_PCNF0_PLEN_Msk (0x3UL << RADIO_PCNF0_PLEN_Pos) /*!< Bit mask of PLEN field. */
++#define RADIO_PCNF0_PLEN_8bit (0UL) /*!< 8-bit preamble */
++#define RADIO_PCNF0_PLEN_16bit (1UL) /*!< 16-bit preamble */
++#define RADIO_PCNF0_PLEN_32bitZero (2UL) /*!< 32-bit zero preamble - used for IEEE 802.15.4 */
++#define RADIO_PCNF0_PLEN_LongRange (3UL) /*!< Preamble - used for BLE long range */
++
++/* Bits 23..22 : Length of code indicator - long range */
++#define RADIO_PCNF0_CILEN_Pos (22UL) /*!< Position of CILEN field. */
++#define RADIO_PCNF0_CILEN_Msk (0x3UL << RADIO_PCNF0_CILEN_Pos) /*!< Bit mask of CILEN field. */
++
++/* Bit 20 : Include or exclude S1 field in RAM */
++#define RADIO_PCNF0_S1INCL_Pos (20UL) /*!< Position of S1INCL field. */
++#define RADIO_PCNF0_S1INCL_Msk (0x1UL << RADIO_PCNF0_S1INCL_Pos) /*!< Bit mask of S1INCL field. */
++#define RADIO_PCNF0_S1INCL_Automatic (0UL) /*!< Include S1 field in RAM only if S1LEN &gt; 0 */
++#define RADIO_PCNF0_S1INCL_Include (1UL) /*!< Always include S1 field in RAM independent of S1LEN */
++
++/* Bits 19..16 : Length on air of S1 field in number of bits. */
++#define RADIO_PCNF0_S1LEN_Pos (16UL) /*!< Position of S1LEN field. */
++#define RADIO_PCNF0_S1LEN_Msk (0xFUL << RADIO_PCNF0_S1LEN_Pos) /*!< Bit mask of S1LEN field. */
++
++/* Bit 8 : Length on air of S0 field in number of bytes. */
++#define RADIO_PCNF0_S0LEN_Pos (8UL) /*!< Position of S0LEN field. */
++#define RADIO_PCNF0_S0LEN_Msk (0x1UL << RADIO_PCNF0_S0LEN_Pos) /*!< Bit mask of S0LEN field. */
++
++/* Bits 3..0 : Length on air of LENGTH field in number of bits. */
++#define RADIO_PCNF0_LFLEN_Pos (0UL) /*!< Position of LFLEN field. */
++#define RADIO_PCNF0_LFLEN_Msk (0xFUL << RADIO_PCNF0_LFLEN_Pos) /*!< Bit mask of LFLEN field. */
++
++/* Register: RADIO_PCNF1 */
++/* Description: Packet configuration register 1 */
++
++/* Bit 25 : Enable or disable packet whitening */
++#define RADIO_PCNF1_WHITEEN_Pos (25UL) /*!< Position of WHITEEN field. */
++#define RADIO_PCNF1_WHITEEN_Msk (0x1UL << RADIO_PCNF1_WHITEEN_Pos) /*!< Bit mask of WHITEEN field. */
++#define RADIO_PCNF1_WHITEEN_Disabled (0UL) /*!< Disable */
++#define RADIO_PCNF1_WHITEEN_Enabled (1UL) /*!< Enable */
++
++/* Bit 24 : On air endianness of packet, this applies to the S0, LENGTH, S1 and the PAYLOAD fields. */
++#define RADIO_PCNF1_ENDIAN_Pos (24UL) /*!< Position of ENDIAN field. */
++#define RADIO_PCNF1_ENDIAN_Msk (0x1UL << RADIO_PCNF1_ENDIAN_Pos) /*!< Bit mask of ENDIAN field. */
++#define RADIO_PCNF1_ENDIAN_Little (0UL) /*!< Least significant bit on air first */
++#define RADIO_PCNF1_ENDIAN_Big (1UL) /*!< Most significant bit on air first */
++
++/* Bits 18..16 : Base address length in number of bytes */
++#define RADIO_PCNF1_BALEN_Pos (16UL) /*!< Position of BALEN field. */
++#define RADIO_PCNF1_BALEN_Msk (0x7UL << RADIO_PCNF1_BALEN_Pos) /*!< Bit mask of BALEN field. */
++
++/* Bits 15..8 : Static length in number of bytes */
++#define RADIO_PCNF1_STATLEN_Pos (8UL) /*!< Position of STATLEN field. */
++#define RADIO_PCNF1_STATLEN_Msk (0xFFUL << RADIO_PCNF1_STATLEN_Pos) /*!< Bit mask of STATLEN field. */
++
++/* Bits 7..0 : Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN. */
++#define RADIO_PCNF1_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
++#define RADIO_PCNF1_MAXLEN_Msk (0xFFUL << RADIO_PCNF1_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
++
++/* Register: RADIO_BASE0 */
++/* Description: Base address 0 */
++
++/* Bits 31..0 : Base address 0 */
++#define RADIO_BASE0_BASE0_Pos (0UL) /*!< Position of BASE0 field. */
++#define RADIO_BASE0_BASE0_Msk (0xFFFFFFFFUL << RADIO_BASE0_BASE0_Pos) /*!< Bit mask of BASE0 field. */
++
++/* Register: RADIO_BASE1 */
++/* Description: Base address 1 */
++
++/* Bits 31..0 : Base address 1 */
++#define RADIO_BASE1_BASE1_Pos (0UL) /*!< Position of BASE1 field. */
++#define RADIO_BASE1_BASE1_Msk (0xFFFFFFFFUL << RADIO_BASE1_BASE1_Pos) /*!< Bit mask of BASE1 field. */
++
++/* Register: RADIO_PREFIX0 */
++/* Description: Prefixes bytes for logical addresses 0-3 */
++
++/* Bits 31..24 : Address prefix 3. */
++#define RADIO_PREFIX0_AP3_Pos (24UL) /*!< Position of AP3 field. */
++#define RADIO_PREFIX0_AP3_Msk (0xFFUL << RADIO_PREFIX0_AP3_Pos) /*!< Bit mask of AP3 field. */
++
++/* Bits 23..16 : Address prefix 2. */
++#define RADIO_PREFIX0_AP2_Pos (16UL) /*!< Position of AP2 field. */
++#define RADIO_PREFIX0_AP2_Msk (0xFFUL << RADIO_PREFIX0_AP2_Pos) /*!< Bit mask of AP2 field. */
++
++/* Bits 15..8 : Address prefix 1. */
++#define RADIO_PREFIX0_AP1_Pos (8UL) /*!< Position of AP1 field. */
++#define RADIO_PREFIX0_AP1_Msk (0xFFUL << RADIO_PREFIX0_AP1_Pos) /*!< Bit mask of AP1 field. */
++
++/* Bits 7..0 : Address prefix 0. */
++#define RADIO_PREFIX0_AP0_Pos (0UL) /*!< Position of AP0 field. */
++#define RADIO_PREFIX0_AP0_Msk (0xFFUL << RADIO_PREFIX0_AP0_Pos) /*!< Bit mask of AP0 field. */
++
++/* Register: RADIO_PREFIX1 */
++/* Description: Prefixes bytes for logical addresses 4-7 */
++
++/* Bits 31..24 : Address prefix 7. */
++#define RADIO_PREFIX1_AP7_Pos (24UL) /*!< Position of AP7 field. */
++#define RADIO_PREFIX1_AP7_Msk (0xFFUL << RADIO_PREFIX1_AP7_Pos) /*!< Bit mask of AP7 field. */
++
++/* Bits 23..16 : Address prefix 6. */
++#define RADIO_PREFIX1_AP6_Pos (16UL) /*!< Position of AP6 field. */
++#define RADIO_PREFIX1_AP6_Msk (0xFFUL << RADIO_PREFIX1_AP6_Pos) /*!< Bit mask of AP6 field. */
++
++/* Bits 15..8 : Address prefix 5. */
++#define RADIO_PREFIX1_AP5_Pos (8UL) /*!< Position of AP5 field. */
++#define RADIO_PREFIX1_AP5_Msk (0xFFUL << RADIO_PREFIX1_AP5_Pos) /*!< Bit mask of AP5 field. */
++
++/* Bits 7..0 : Address prefix 4. */
++#define RADIO_PREFIX1_AP4_Pos (0UL) /*!< Position of AP4 field. */
++#define RADIO_PREFIX1_AP4_Msk (0xFFUL << RADIO_PREFIX1_AP4_Pos) /*!< Bit mask of AP4 field. */
++
++/* Register: RADIO_TXADDRESS */
++/* Description: Transmit address select */
++
++/* Bits 2..0 : Transmit address select */
++#define RADIO_TXADDRESS_TXADDRESS_Pos (0UL) /*!< Position of TXADDRESS field. */
++#define RADIO_TXADDRESS_TXADDRESS_Msk (0x7UL << RADIO_TXADDRESS_TXADDRESS_Pos) /*!< Bit mask of TXADDRESS field. */
++
++/* Register: RADIO_RXADDRESSES */
++/* Description: Receive address select */
++
++/* Bit 7 : Enable or disable reception on logical address 7. */
++#define RADIO_RXADDRESSES_ADDR7_Pos (7UL) /*!< Position of ADDR7 field. */
++#define RADIO_RXADDRESSES_ADDR7_Msk (0x1UL << RADIO_RXADDRESSES_ADDR7_Pos) /*!< Bit mask of ADDR7 field. */
++#define RADIO_RXADDRESSES_ADDR7_Disabled (0UL) /*!< Disable */
++#define RADIO_RXADDRESSES_ADDR7_Enabled (1UL) /*!< Enable */
++
++/* Bit 6 : Enable or disable reception on logical address 6. */
++#define RADIO_RXADDRESSES_ADDR6_Pos (6UL) /*!< Position of ADDR6 field. */
++#define RADIO_RXADDRESSES_ADDR6_Msk (0x1UL << RADIO_RXADDRESSES_ADDR6_Pos) /*!< Bit mask of ADDR6 field. */
++#define RADIO_RXADDRESSES_ADDR6_Disabled (0UL) /*!< Disable */
++#define RADIO_RXADDRESSES_ADDR6_Enabled (1UL) /*!< Enable */
++
++/* Bit 5 : Enable or disable reception on logical address 5. */
++#define RADIO_RXADDRESSES_ADDR5_Pos (5UL) /*!< Position of ADDR5 field. */
++#define RADIO_RXADDRESSES_ADDR5_Msk (0x1UL << RADIO_RXADDRESSES_ADDR5_Pos) /*!< Bit mask of ADDR5 field. */
++#define RADIO_RXADDRESSES_ADDR5_Disabled (0UL) /*!< Disable */
++#define RADIO_RXADDRESSES_ADDR5_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable reception on logical address 4. */
++#define RADIO_RXADDRESSES_ADDR4_Pos (4UL) /*!< Position of ADDR4 field. */
++#define RADIO_RXADDRESSES_ADDR4_Msk (0x1UL << RADIO_RXADDRESSES_ADDR4_Pos) /*!< Bit mask of ADDR4 field. */
++#define RADIO_RXADDRESSES_ADDR4_Disabled (0UL) /*!< Disable */
++#define RADIO_RXADDRESSES_ADDR4_Enabled (1UL) /*!< Enable */
++
++/* Bit 3 : Enable or disable reception on logical address 3. */
++#define RADIO_RXADDRESSES_ADDR3_Pos (3UL) /*!< Position of ADDR3 field. */
++#define RADIO_RXADDRESSES_ADDR3_Msk (0x1UL << RADIO_RXADDRESSES_ADDR3_Pos) /*!< Bit mask of ADDR3 field. */
++#define RADIO_RXADDRESSES_ADDR3_Disabled (0UL) /*!< Disable */
++#define RADIO_RXADDRESSES_ADDR3_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable reception on logical address 2. */
++#define RADIO_RXADDRESSES_ADDR2_Pos (2UL) /*!< Position of ADDR2 field. */
++#define RADIO_RXADDRESSES_ADDR2_Msk (0x1UL << RADIO_RXADDRESSES_ADDR2_Pos) /*!< Bit mask of ADDR2 field. */
++#define RADIO_RXADDRESSES_ADDR2_Disabled (0UL) /*!< Disable */
++#define RADIO_RXADDRESSES_ADDR2_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable reception on logical address 1. */
++#define RADIO_RXADDRESSES_ADDR1_Pos (1UL) /*!< Position of ADDR1 field. */
++#define RADIO_RXADDRESSES_ADDR1_Msk (0x1UL << RADIO_RXADDRESSES_ADDR1_Pos) /*!< Bit mask of ADDR1 field. */
++#define RADIO_RXADDRESSES_ADDR1_Disabled (0UL) /*!< Disable */
++#define RADIO_RXADDRESSES_ADDR1_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable reception on logical address 0. */
++#define RADIO_RXADDRESSES_ADDR0_Pos (0UL) /*!< Position of ADDR0 field. */
++#define RADIO_RXADDRESSES_ADDR0_Msk (0x1UL << RADIO_RXADDRESSES_ADDR0_Pos) /*!< Bit mask of ADDR0 field. */
++#define RADIO_RXADDRESSES_ADDR0_Disabled (0UL) /*!< Disable */
++#define RADIO_RXADDRESSES_ADDR0_Enabled (1UL) /*!< Enable */
++
++/* Register: RADIO_CRCCNF */
++/* Description: CRC configuration */
++
++/* Bits 9..8 : Include or exclude packet address field out of CRC calculation. */
++#define RADIO_CRCCNF_SKIPADDR_Pos (8UL) /*!< Position of SKIPADDR field. */
++#define RADIO_CRCCNF_SKIPADDR_Msk (0x3UL << RADIO_CRCCNF_SKIPADDR_Pos) /*!< Bit mask of SKIPADDR field. */
++#define RADIO_CRCCNF_SKIPADDR_Include (0UL) /*!< CRC calculation includes address field */
++#define RADIO_CRCCNF_SKIPADDR_Skip (1UL) /*!< CRC calculation does not include address field. The CRC calculation will start at the first byte after the address. */
++#define RADIO_CRCCNF_SKIPADDR_Ieee802154 (2UL) /*!< CRC calculation as per 802.15.4 standard. Starting at first byte after length field. */
++
++/* Bits 1..0 : CRC length in number of bytes. */
++#define RADIO_CRCCNF_LEN_Pos (0UL) /*!< Position of LEN field. */
++#define RADIO_CRCCNF_LEN_Msk (0x3UL << RADIO_CRCCNF_LEN_Pos) /*!< Bit mask of LEN field. */
++#define RADIO_CRCCNF_LEN_Disabled (0UL) /*!< CRC length is zero and CRC calculation is disabled */
++#define RADIO_CRCCNF_LEN_One (1UL) /*!< CRC length is one byte and CRC calculation is enabled */
++#define RADIO_CRCCNF_LEN_Two (2UL) /*!< CRC length is two bytes and CRC calculation is enabled */
++#define RADIO_CRCCNF_LEN_Three (3UL) /*!< CRC length is three bytes and CRC calculation is enabled */
++
++/* Register: RADIO_CRCPOLY */
++/* Description: CRC polynomial */
++
++/* Bits 23..0 : CRC polynomial */
++#define RADIO_CRCPOLY_CRCPOLY_Pos (0UL) /*!< Position of CRCPOLY field. */
++#define RADIO_CRCPOLY_CRCPOLY_Msk (0xFFFFFFUL << RADIO_CRCPOLY_CRCPOLY_Pos) /*!< Bit mask of CRCPOLY field. */
++
++/* Register: RADIO_CRCINIT */
++/* Description: CRC initial value */
++
++/* Bits 23..0 : CRC initial value */
++#define RADIO_CRCINIT_CRCINIT_Pos (0UL) /*!< Position of CRCINIT field. */
++#define RADIO_CRCINIT_CRCINIT_Msk (0xFFFFFFUL << RADIO_CRCINIT_CRCINIT_Pos) /*!< Bit mask of CRCINIT field. */
++
++/* Register: RADIO_TIFS */
++/* Description: Interframe spacing in us */
++
++/* Bits 9..0 : Interframe spacing in us */
++#define RADIO_TIFS_TIFS_Pos (0UL) /*!< Position of TIFS field. */
++#define RADIO_TIFS_TIFS_Msk (0x3FFUL << RADIO_TIFS_TIFS_Pos) /*!< Bit mask of TIFS field. */
++
++/* Register: RADIO_RSSISAMPLE */
++/* Description: RSSI sample */
++
++/* Bits 6..0 : RSSI sample */
++#define RADIO_RSSISAMPLE_RSSISAMPLE_Pos (0UL) /*!< Position of RSSISAMPLE field. */
++#define RADIO_RSSISAMPLE_RSSISAMPLE_Msk (0x7FUL << RADIO_RSSISAMPLE_RSSISAMPLE_Pos) /*!< Bit mask of RSSISAMPLE field. */
++
++/* Register: RADIO_STATE */
++/* Description: Current radio state */
++
++/* Bits 3..0 : Current radio state */
++#define RADIO_STATE_STATE_Pos (0UL) /*!< Position of STATE field. */
++#define RADIO_STATE_STATE_Msk (0xFUL << RADIO_STATE_STATE_Pos) /*!< Bit mask of STATE field. */
++#define RADIO_STATE_STATE_Disabled (0UL) /*!< RADIO is in the Disabled state */
++#define RADIO_STATE_STATE_RxRu (1UL) /*!< RADIO is in the RXRU state */
++#define RADIO_STATE_STATE_RxIdle (2UL) /*!< RADIO is in the RXIDLE state */
++#define RADIO_STATE_STATE_Rx (3UL) /*!< RADIO is in the RX state */
++#define RADIO_STATE_STATE_RxDisable (4UL) /*!< RADIO is in the RXDISABLED state */
++#define RADIO_STATE_STATE_TxRu (9UL) /*!< RADIO is in the TXRU state */
++#define RADIO_STATE_STATE_TxIdle (10UL) /*!< RADIO is in the TXIDLE state */
++#define RADIO_STATE_STATE_Tx (11UL) /*!< RADIO is in the TX state */
++#define RADIO_STATE_STATE_TxDisable (12UL) /*!< RADIO is in the TXDISABLED state */
++
++/* Register: RADIO_DATAWHITEIV */
++/* Description: Data whitening initial value */
++
++/* Bits 6..0 : Data whitening initial value. Bit 6 is hard-wired to '1', writing '0' to it has no effect, and it will always be read back and used by the device as '1'. */
++#define RADIO_DATAWHITEIV_DATAWHITEIV_Pos (0UL) /*!< Position of DATAWHITEIV field. */
++#define RADIO_DATAWHITEIV_DATAWHITEIV_Msk (0x7FUL << RADIO_DATAWHITEIV_DATAWHITEIV_Pos) /*!< Bit mask of DATAWHITEIV field. */
++
++/* Register: RADIO_BCC */
++/* Description: Bit counter compare */
++
++/* Bits 31..0 : Bit counter compare */
++#define RADIO_BCC_BCC_Pos (0UL) /*!< Position of BCC field. */
++#define RADIO_BCC_BCC_Msk (0xFFFFFFFFUL << RADIO_BCC_BCC_Pos) /*!< Bit mask of BCC field. */
++
++/* Register: RADIO_DAB */
++/* Description: Description collection: Device address base segment n */
++
++/* Bits 31..0 : Device address base segment n */
++#define RADIO_DAB_DAB_Pos (0UL) /*!< Position of DAB field. */
++#define RADIO_DAB_DAB_Msk (0xFFFFFFFFUL << RADIO_DAB_DAB_Pos) /*!< Bit mask of DAB field. */
++
++/* Register: RADIO_DAP */
++/* Description: Description collection: Device address prefix n */
++
++/* Bits 15..0 : Device address prefix n */
++#define RADIO_DAP_DAP_Pos (0UL) /*!< Position of DAP field. */
++#define RADIO_DAP_DAP_Msk (0xFFFFUL << RADIO_DAP_DAP_Pos) /*!< Bit mask of DAP field. */
++
++/* Register: RADIO_DACNF */
++/* Description: Device address match configuration */
++
++/* Bit 15 : TxAdd for device address 7 */
++#define RADIO_DACNF_TXADD7_Pos (15UL) /*!< Position of TXADD7 field. */
++#define RADIO_DACNF_TXADD7_Msk (0x1UL << RADIO_DACNF_TXADD7_Pos) /*!< Bit mask of TXADD7 field. */
++
++/* Bit 14 : TxAdd for device address 6 */
++#define RADIO_DACNF_TXADD6_Pos (14UL) /*!< Position of TXADD6 field. */
++#define RADIO_DACNF_TXADD6_Msk (0x1UL << RADIO_DACNF_TXADD6_Pos) /*!< Bit mask of TXADD6 field. */
++
++/* Bit 13 : TxAdd for device address 5 */
++#define RADIO_DACNF_TXADD5_Pos (13UL) /*!< Position of TXADD5 field. */
++#define RADIO_DACNF_TXADD5_Msk (0x1UL << RADIO_DACNF_TXADD5_Pos) /*!< Bit mask of TXADD5 field. */
++
++/* Bit 12 : TxAdd for device address 4 */
++#define RADIO_DACNF_TXADD4_Pos (12UL) /*!< Position of TXADD4 field. */
++#define RADIO_DACNF_TXADD4_Msk (0x1UL << RADIO_DACNF_TXADD4_Pos) /*!< Bit mask of TXADD4 field. */
++
++/* Bit 11 : TxAdd for device address 3 */
++#define RADIO_DACNF_TXADD3_Pos (11UL) /*!< Position of TXADD3 field. */
++#define RADIO_DACNF_TXADD3_Msk (0x1UL << RADIO_DACNF_TXADD3_Pos) /*!< Bit mask of TXADD3 field. */
++
++/* Bit 10 : TxAdd for device address 2 */
++#define RADIO_DACNF_TXADD2_Pos (10UL) /*!< Position of TXADD2 field. */
++#define RADIO_DACNF_TXADD2_Msk (0x1UL << RADIO_DACNF_TXADD2_Pos) /*!< Bit mask of TXADD2 field. */
++
++/* Bit 9 : TxAdd for device address 1 */
++#define RADIO_DACNF_TXADD1_Pos (9UL) /*!< Position of TXADD1 field. */
++#define RADIO_DACNF_TXADD1_Msk (0x1UL << RADIO_DACNF_TXADD1_Pos) /*!< Bit mask of TXADD1 field. */
++
++/* Bit 8 : TxAdd for device address 0 */
++#define RADIO_DACNF_TXADD0_Pos (8UL) /*!< Position of TXADD0 field. */
++#define RADIO_DACNF_TXADD0_Msk (0x1UL << RADIO_DACNF_TXADD0_Pos) /*!< Bit mask of TXADD0 field. */
++
++/* Bit 7 : Enable or disable device address matching using device address 7 */
++#define RADIO_DACNF_ENA7_Pos (7UL) /*!< Position of ENA7 field. */
++#define RADIO_DACNF_ENA7_Msk (0x1UL << RADIO_DACNF_ENA7_Pos) /*!< Bit mask of ENA7 field. */
++#define RADIO_DACNF_ENA7_Disabled (0UL) /*!< Disabled */
++#define RADIO_DACNF_ENA7_Enabled (1UL) /*!< Enabled */
++
++/* Bit 6 : Enable or disable device address matching using device address 6 */
++#define RADIO_DACNF_ENA6_Pos (6UL) /*!< Position of ENA6 field. */
++#define RADIO_DACNF_ENA6_Msk (0x1UL << RADIO_DACNF_ENA6_Pos) /*!< Bit mask of ENA6 field. */
++#define RADIO_DACNF_ENA6_Disabled (0UL) /*!< Disabled */
++#define RADIO_DACNF_ENA6_Enabled (1UL) /*!< Enabled */
++
++/* Bit 5 : Enable or disable device address matching using device address 5 */
++#define RADIO_DACNF_ENA5_Pos (5UL) /*!< Position of ENA5 field. */
++#define RADIO_DACNF_ENA5_Msk (0x1UL << RADIO_DACNF_ENA5_Pos) /*!< Bit mask of ENA5 field. */
++#define RADIO_DACNF_ENA5_Disabled (0UL) /*!< Disabled */
++#define RADIO_DACNF_ENA5_Enabled (1UL) /*!< Enabled */
++
++/* Bit 4 : Enable or disable device address matching using device address 4 */
++#define RADIO_DACNF_ENA4_Pos (4UL) /*!< Position of ENA4 field. */
++#define RADIO_DACNF_ENA4_Msk (0x1UL << RADIO_DACNF_ENA4_Pos) /*!< Bit mask of ENA4 field. */
++#define RADIO_DACNF_ENA4_Disabled (0UL) /*!< Disabled */
++#define RADIO_DACNF_ENA4_Enabled (1UL) /*!< Enabled */
++
++/* Bit 3 : Enable or disable device address matching using device address 3 */
++#define RADIO_DACNF_ENA3_Pos (3UL) /*!< Position of ENA3 field. */
++#define RADIO_DACNF_ENA3_Msk (0x1UL << RADIO_DACNF_ENA3_Pos) /*!< Bit mask of ENA3 field. */
++#define RADIO_DACNF_ENA3_Disabled (0UL) /*!< Disabled */
++#define RADIO_DACNF_ENA3_Enabled (1UL) /*!< Enabled */
++
++/* Bit 2 : Enable or disable device address matching using device address 2 */
++#define RADIO_DACNF_ENA2_Pos (2UL) /*!< Position of ENA2 field. */
++#define RADIO_DACNF_ENA2_Msk (0x1UL << RADIO_DACNF_ENA2_Pos) /*!< Bit mask of ENA2 field. */
++#define RADIO_DACNF_ENA2_Disabled (0UL) /*!< Disabled */
++#define RADIO_DACNF_ENA2_Enabled (1UL) /*!< Enabled */
++
++/* Bit 1 : Enable or disable device address matching using device address 1 */
++#define RADIO_DACNF_ENA1_Pos (1UL) /*!< Position of ENA1 field. */
++#define RADIO_DACNF_ENA1_Msk (0x1UL << RADIO_DACNF_ENA1_Pos) /*!< Bit mask of ENA1 field. */
++#define RADIO_DACNF_ENA1_Disabled (0UL) /*!< Disabled */
++#define RADIO_DACNF_ENA1_Enabled (1UL) /*!< Enabled */
++
++/* Bit 0 : Enable or disable device address matching using device address 0 */
++#define RADIO_DACNF_ENA0_Pos (0UL) /*!< Position of ENA0 field. */
++#define RADIO_DACNF_ENA0_Msk (0x1UL << RADIO_DACNF_ENA0_Pos) /*!< Bit mask of ENA0 field. */
++#define RADIO_DACNF_ENA0_Disabled (0UL) /*!< Disabled */
++#define RADIO_DACNF_ENA0_Enabled (1UL) /*!< Enabled */
++
++/* Register: RADIO_MHRMATCHCONF */
++/* Description: Search pattern configuration */
++
++/* Bits 31..0 : Search pattern configuration */
++#define RADIO_MHRMATCHCONF_MHRMATCHCONF_Pos (0UL) /*!< Position of MHRMATCHCONF field. */
++#define RADIO_MHRMATCHCONF_MHRMATCHCONF_Msk (0xFFFFFFFFUL << RADIO_MHRMATCHCONF_MHRMATCHCONF_Pos) /*!< Bit mask of MHRMATCHCONF field. */
++
++/* Register: RADIO_MHRMATCHMAS */
++/* Description: Pattern mask */
++
++/* Bits 31..0 : Pattern mask */
++#define RADIO_MHRMATCHMAS_MHRMATCHMAS_Pos (0UL) /*!< Position of MHRMATCHMAS field. */
++#define RADIO_MHRMATCHMAS_MHRMATCHMAS_Msk (0xFFFFFFFFUL << RADIO_MHRMATCHMAS_MHRMATCHMAS_Pos) /*!< Bit mask of MHRMATCHMAS field. */
++
++/* Register: RADIO_MODECNF0 */
++/* Description: Radio mode configuration register 0 */
++
++/* Bits 9..8 : Default TX value */
++#define RADIO_MODECNF0_DTX_Pos (8UL) /*!< Position of DTX field. */
++#define RADIO_MODECNF0_DTX_Msk (0x3UL << RADIO_MODECNF0_DTX_Pos) /*!< Bit mask of DTX field. */
++#define RADIO_MODECNF0_DTX_B1 (0UL) /*!< Transmit '1' */
++#define RADIO_MODECNF0_DTX_B0 (1UL) /*!< Transmit '0' */
++#define RADIO_MODECNF0_DTX_Center (2UL) /*!< Transmit center frequency */
++
++/* Bit 0 : Radio ramp-up time */
++#define RADIO_MODECNF0_RU_Pos (0UL) /*!< Position of RU field. */
++#define RADIO_MODECNF0_RU_Msk (0x1UL << RADIO_MODECNF0_RU_Pos) /*!< Bit mask of RU field. */
++#define RADIO_MODECNF0_RU_Default (0UL) /*!< Default ramp-up time (tRXEN and tTXEN), compatible with firmware written for nRF51 */
++#define RADIO_MODECNF0_RU_Fast (1UL) /*!< Fast ramp-up (tRXEN,FAST and tTXEN,FAST), see electrical specification for more information */
++
++/* Register: RADIO_SFD */
++/* Description: IEEE 802.15.4 start of frame delimiter */
++
++/* Bits 7..0 : IEEE 802.15.4 start of frame delimiter */
++#define RADIO_SFD_SFD_Pos (0UL) /*!< Position of SFD field. */
++#define RADIO_SFD_SFD_Msk (0xFFUL << RADIO_SFD_SFD_Pos) /*!< Bit mask of SFD field. */
++
++/* Register: RADIO_EDCNT */
++/* Description: IEEE 802.15.4 energy detect loop count */
++
++/* Bits 20..0 : IEEE 802.15.4 energy detect loop count */
++#define RADIO_EDCNT_EDCNT_Pos (0UL) /*!< Position of EDCNT field. */
++#define RADIO_EDCNT_EDCNT_Msk (0x1FFFFFUL << RADIO_EDCNT_EDCNT_Pos) /*!< Bit mask of EDCNT field. */
++
++/* Register: RADIO_EDSAMPLE */
++/* Description: IEEE 802.15.4 energy detect level */
++
++/* Bits 7..0 : IEEE 802.15.4 energy detect level */
++#define RADIO_EDSAMPLE_EDLVL_Pos (0UL) /*!< Position of EDLVL field. */
++#define RADIO_EDSAMPLE_EDLVL_Msk (0xFFUL << RADIO_EDSAMPLE_EDLVL_Pos) /*!< Bit mask of EDLVL field. */
++
++/* Register: RADIO_CCACTRL */
++/* Description: IEEE 802.15.4 clear channel assessment control */
++
++/* Bits 31..24 : Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled. */
++#define RADIO_CCACTRL_CCACORRCNT_Pos (24UL) /*!< Position of CCACORRCNT field. */
++#define RADIO_CCACTRL_CCACORRCNT_Msk (0xFFUL << RADIO_CCACTRL_CCACORRCNT_Pos) /*!< Bit mask of CCACORRCNT field. */
++
++/* Bits 23..16 : CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode and CarrierOrEdMode. */
++#define RADIO_CCACTRL_CCACORRTHRES_Pos (16UL) /*!< Position of CCACORRTHRES field. */
++#define RADIO_CCACTRL_CCACORRTHRES_Msk (0xFFUL << RADIO_CCACTRL_CCACORRTHRES_Pos) /*!< Bit mask of CCACORRTHRES field. */
++
++/* Bits 15..8 : CCA energy busy threshold. Used in all the CCA modes except CarrierMode. */
++#define RADIO_CCACTRL_CCAEDTHRES_Pos (8UL) /*!< Position of CCAEDTHRES field. */
++#define RADIO_CCACTRL_CCAEDTHRES_Msk (0xFFUL << RADIO_CCACTRL_CCAEDTHRES_Pos) /*!< Bit mask of CCAEDTHRES field. */
++
++/* Bits 2..0 : CCA mode of operation */
++#define RADIO_CCACTRL_CCAMODE_Pos (0UL) /*!< Position of CCAMODE field. */
++#define RADIO_CCACTRL_CCAMODE_Msk (0x7UL << RADIO_CCACTRL_CCAMODE_Pos) /*!< Bit mask of CCAMODE field. */
++#define RADIO_CCACTRL_CCAMODE_EdMode (0UL) /*!< Energy above threshold */
++#define RADIO_CCACTRL_CCAMODE_CarrierMode (1UL) /*!< Carrier seen */
++#define RADIO_CCACTRL_CCAMODE_CarrierAndEdMode (2UL) /*!< Energy above threshold AND carrier seen */
++#define RADIO_CCACTRL_CCAMODE_CarrierOrEdMode (3UL) /*!< Energy above threshold OR carrier seen */
++#define RADIO_CCACTRL_CCAMODE_EdModeTest1 (4UL) /*!< Energy above threshold test mode that will abort when first ED measurement over threshold is seen. No averaging. */
++
++/* Register: RADIO_POWER */
++/* Description: Peripheral power control */
++
++/* Bit 0 : Peripheral power control. The peripheral and its registers will be reset to its initial state by switching the peripheral off and then back on again. */
++#define RADIO_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
++#define RADIO_POWER_POWER_Msk (0x1UL << RADIO_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
++#define RADIO_POWER_POWER_Disabled (0UL) /*!< Peripheral is powered off */
++#define RADIO_POWER_POWER_Enabled (1UL) /*!< Peripheral is powered on */
++
++
++/* Peripheral: RNG */
++/* Description: Random Number Generator */
++
++/* Register: RNG_TASKS_START */
++/* Description: Task starting the random number generator */
++
++/* Bit 0 : Task starting the random number generator */
++#define RNG_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define RNG_TASKS_START_TASKS_START_Msk (0x1UL << RNG_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define RNG_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RNG_TASKS_STOP */
++/* Description: Task stopping the random number generator */
++
++/* Bit 0 : Task stopping the random number generator */
++#define RNG_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define RNG_TASKS_STOP_TASKS_STOP_Msk (0x1UL << RNG_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define RNG_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RNG_EVENTS_VALRDY */
++/* Description: Event being generated for every new random number written to the VALUE register */
++
++/* Bit 0 : Event being generated for every new random number written to the VALUE register */
++#define RNG_EVENTS_VALRDY_EVENTS_VALRDY_Pos (0UL) /*!< Position of EVENTS_VALRDY field. */
++#define RNG_EVENTS_VALRDY_EVENTS_VALRDY_Msk (0x1UL << RNG_EVENTS_VALRDY_EVENTS_VALRDY_Pos) /*!< Bit mask of EVENTS_VALRDY field. */
++#define RNG_EVENTS_VALRDY_EVENTS_VALRDY_NotGenerated (0UL) /*!< Event not generated */
++#define RNG_EVENTS_VALRDY_EVENTS_VALRDY_Generated (1UL) /*!< Event generated */
++
++/* Register: RNG_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 0 : Shortcut between event VALRDY and task STOP */
++#define RNG_SHORTS_VALRDY_STOP_Pos (0UL) /*!< Position of VALRDY_STOP field. */
++#define RNG_SHORTS_VALRDY_STOP_Msk (0x1UL << RNG_SHORTS_VALRDY_STOP_Pos) /*!< Bit mask of VALRDY_STOP field. */
++#define RNG_SHORTS_VALRDY_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define RNG_SHORTS_VALRDY_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: RNG_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 0 : Write '1' to enable interrupt for event VALRDY */
++#define RNG_INTENSET_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
++#define RNG_INTENSET_VALRDY_Msk (0x1UL << RNG_INTENSET_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
++#define RNG_INTENSET_VALRDY_Disabled (0UL) /*!< Read: Disabled */
++#define RNG_INTENSET_VALRDY_Enabled (1UL) /*!< Read: Enabled */
++#define RNG_INTENSET_VALRDY_Set (1UL) /*!< Enable */
++
++/* Register: RNG_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 0 : Write '1' to disable interrupt for event VALRDY */
++#define RNG_INTENCLR_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
++#define RNG_INTENCLR_VALRDY_Msk (0x1UL << RNG_INTENCLR_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
++#define RNG_INTENCLR_VALRDY_Disabled (0UL) /*!< Read: Disabled */
++#define RNG_INTENCLR_VALRDY_Enabled (1UL) /*!< Read: Enabled */
++#define RNG_INTENCLR_VALRDY_Clear (1UL) /*!< Disable */
++
++/* Register: RNG_CONFIG */
++/* Description: Configuration register */
++
++/* Bit 0 : Bias correction */
++#define RNG_CONFIG_DERCEN_Pos (0UL) /*!< Position of DERCEN field. */
++#define RNG_CONFIG_DERCEN_Msk (0x1UL << RNG_CONFIG_DERCEN_Pos) /*!< Bit mask of DERCEN field. */
++#define RNG_CONFIG_DERCEN_Disabled (0UL) /*!< Disabled */
++#define RNG_CONFIG_DERCEN_Enabled (1UL) /*!< Enabled */
++
++/* Register: RNG_VALUE */
++/* Description: Output random number */
++
++/* Bits 7..0 : Generated random number */
++#define RNG_VALUE_VALUE_Pos (0UL) /*!< Position of VALUE field. */
++#define RNG_VALUE_VALUE_Msk (0xFFUL << RNG_VALUE_VALUE_Pos) /*!< Bit mask of VALUE field. */
++
++
++/* Peripheral: RTC */
++/* Description: Real time counter 0 */
++
++/* Register: RTC_TASKS_START */
++/* Description: Start RTC COUNTER */
++
++/* Bit 0 : Start RTC COUNTER */
++#define RTC_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define RTC_TASKS_START_TASKS_START_Msk (0x1UL << RTC_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define RTC_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RTC_TASKS_STOP */
++/* Description: Stop RTC COUNTER */
++
++/* Bit 0 : Stop RTC COUNTER */
++#define RTC_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define RTC_TASKS_STOP_TASKS_STOP_Msk (0x1UL << RTC_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define RTC_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RTC_TASKS_CLEAR */
++/* Description: Clear RTC COUNTER */
++
++/* Bit 0 : Clear RTC COUNTER */
++#define RTC_TASKS_CLEAR_TASKS_CLEAR_Pos (0UL) /*!< Position of TASKS_CLEAR field. */
++#define RTC_TASKS_CLEAR_TASKS_CLEAR_Msk (0x1UL << RTC_TASKS_CLEAR_TASKS_CLEAR_Pos) /*!< Bit mask of TASKS_CLEAR field. */
++#define RTC_TASKS_CLEAR_TASKS_CLEAR_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RTC_TASKS_TRIGOVRFLW */
++/* Description: Set COUNTER to 0xFFFFF0 */
++
++/* Bit 0 : Set COUNTER to 0xFFFFF0 */
++#define RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Pos (0UL) /*!< Position of TASKS_TRIGOVRFLW field. */
++#define RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Msk (0x1UL << RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Pos) /*!< Bit mask of TASKS_TRIGOVRFLW field. */
++#define RTC_TASKS_TRIGOVRFLW_TASKS_TRIGOVRFLW_Trigger (1UL) /*!< Trigger task */
++
++/* Register: RTC_EVENTS_TICK */
++/* Description: Event on COUNTER increment */
++
++/* Bit 0 : Event on COUNTER increment */
++#define RTC_EVENTS_TICK_EVENTS_TICK_Pos (0UL) /*!< Position of EVENTS_TICK field. */
++#define RTC_EVENTS_TICK_EVENTS_TICK_Msk (0x1UL << RTC_EVENTS_TICK_EVENTS_TICK_Pos) /*!< Bit mask of EVENTS_TICK field. */
++#define RTC_EVENTS_TICK_EVENTS_TICK_NotGenerated (0UL) /*!< Event not generated */
++#define RTC_EVENTS_TICK_EVENTS_TICK_Generated (1UL) /*!< Event generated */
++
++/* Register: RTC_EVENTS_OVRFLW */
++/* Description: Event on COUNTER overflow */
++
++/* Bit 0 : Event on COUNTER overflow */
++#define RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Pos (0UL) /*!< Position of EVENTS_OVRFLW field. */
++#define RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Msk (0x1UL << RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Pos) /*!< Bit mask of EVENTS_OVRFLW field. */
++#define RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_NotGenerated (0UL) /*!< Event not generated */
++#define RTC_EVENTS_OVRFLW_EVENTS_OVRFLW_Generated (1UL) /*!< Event generated */
++
++/* Register: RTC_EVENTS_COMPARE */
++/* Description: Description collection: Compare event on CC[n] match */
++
++/* Bit 0 : Compare event on CC[n] match */
++#define RTC_EVENTS_COMPARE_EVENTS_COMPARE_Pos (0UL) /*!< Position of EVENTS_COMPARE field. */
++#define RTC_EVENTS_COMPARE_EVENTS_COMPARE_Msk (0x1UL << RTC_EVENTS_COMPARE_EVENTS_COMPARE_Pos) /*!< Bit mask of EVENTS_COMPARE field. */
++#define RTC_EVENTS_COMPARE_EVENTS_COMPARE_NotGenerated (0UL) /*!< Event not generated */
++#define RTC_EVENTS_COMPARE_EVENTS_COMPARE_Generated (1UL) /*!< Event generated */
++
++/* Register: RTC_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 19 : Write '1' to enable interrupt for event COMPARE[3] */
++#define RTC_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
++#define RTC_INTENSET_COMPARE3_Msk (0x1UL << RTC_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
++#define RTC_INTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENSET_COMPARE3_Set (1UL) /*!< Enable */
++
++/* Bit 18 : Write '1' to enable interrupt for event COMPARE[2] */
++#define RTC_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
++#define RTC_INTENSET_COMPARE2_Msk (0x1UL << RTC_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
++#define RTC_INTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENSET_COMPARE2_Set (1UL) /*!< Enable */
++
++/* Bit 17 : Write '1' to enable interrupt for event COMPARE[1] */
++#define RTC_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
++#define RTC_INTENSET_COMPARE1_Msk (0x1UL << RTC_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
++#define RTC_INTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENSET_COMPARE1_Set (1UL) /*!< Enable */
++
++/* Bit 16 : Write '1' to enable interrupt for event COMPARE[0] */
++#define RTC_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
++#define RTC_INTENSET_COMPARE0_Msk (0x1UL << RTC_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
++#define RTC_INTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENSET_COMPARE0_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event OVRFLW */
++#define RTC_INTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
++#define RTC_INTENSET_OVRFLW_Msk (0x1UL << RTC_INTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
++#define RTC_INTENSET_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENSET_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENSET_OVRFLW_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event TICK */
++#define RTC_INTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
++#define RTC_INTENSET_TICK_Msk (0x1UL << RTC_INTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
++#define RTC_INTENSET_TICK_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENSET_TICK_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENSET_TICK_Set (1UL) /*!< Enable */
++
++/* Register: RTC_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 19 : Write '1' to disable interrupt for event COMPARE[3] */
++#define RTC_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
++#define RTC_INTENCLR_COMPARE3_Msk (0x1UL << RTC_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
++#define RTC_INTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
++
++/* Bit 18 : Write '1' to disable interrupt for event COMPARE[2] */
++#define RTC_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
++#define RTC_INTENCLR_COMPARE2_Msk (0x1UL << RTC_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
++#define RTC_INTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
++
++/* Bit 17 : Write '1' to disable interrupt for event COMPARE[1] */
++#define RTC_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
++#define RTC_INTENCLR_COMPARE1_Msk (0x1UL << RTC_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
++#define RTC_INTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
++
++/* Bit 16 : Write '1' to disable interrupt for event COMPARE[0] */
++#define RTC_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
++#define RTC_INTENCLR_COMPARE0_Msk (0x1UL << RTC_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
++#define RTC_INTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event OVRFLW */
++#define RTC_INTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
++#define RTC_INTENCLR_OVRFLW_Msk (0x1UL << RTC_INTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
++#define RTC_INTENCLR_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENCLR_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENCLR_OVRFLW_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event TICK */
++#define RTC_INTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
++#define RTC_INTENCLR_TICK_Msk (0x1UL << RTC_INTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
++#define RTC_INTENCLR_TICK_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_INTENCLR_TICK_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_INTENCLR_TICK_Clear (1UL) /*!< Disable */
++
++/* Register: RTC_EVTEN */
++/* Description: Enable or disable event routing */
++
++/* Bit 19 : Enable or disable event routing for event COMPARE[3] */
++#define RTC_EVTEN_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
++#define RTC_EVTEN_COMPARE3_Msk (0x1UL << RTC_EVTEN_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
++#define RTC_EVTEN_COMPARE3_Disabled (0UL) /*!< Disable */
++#define RTC_EVTEN_COMPARE3_Enabled (1UL) /*!< Disable */
++
++/* Bit 18 : Enable or disable event routing for event COMPARE[2] */
++#define RTC_EVTEN_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
++#define RTC_EVTEN_COMPARE2_Msk (0x1UL << RTC_EVTEN_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
++#define RTC_EVTEN_COMPARE2_Disabled (0UL) /*!< Disable */
++#define RTC_EVTEN_COMPARE2_Enabled (1UL) /*!< Disable */
++
++/* Bit 17 : Enable or disable event routing for event COMPARE[1] */
++#define RTC_EVTEN_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
++#define RTC_EVTEN_COMPARE1_Msk (0x1UL << RTC_EVTEN_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
++#define RTC_EVTEN_COMPARE1_Disabled (0UL) /*!< Disable */
++#define RTC_EVTEN_COMPARE1_Enabled (1UL) /*!< Disable */
++
++/* Bit 16 : Enable or disable event routing for event COMPARE[0] */
++#define RTC_EVTEN_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
++#define RTC_EVTEN_COMPARE0_Msk (0x1UL << RTC_EVTEN_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
++#define RTC_EVTEN_COMPARE0_Disabled (0UL) /*!< Disable */
++#define RTC_EVTEN_COMPARE0_Enabled (1UL) /*!< Disable */
++
++/* Bit 1 : Enable or disable event routing for event OVRFLW */
++#define RTC_EVTEN_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
++#define RTC_EVTEN_OVRFLW_Msk (0x1UL << RTC_EVTEN_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
++#define RTC_EVTEN_OVRFLW_Disabled (0UL) /*!< Disable */
++#define RTC_EVTEN_OVRFLW_Enabled (1UL) /*!< Disable */
++
++/* Bit 0 : Enable or disable event routing for event TICK */
++#define RTC_EVTEN_TICK_Pos (0UL) /*!< Position of TICK field. */
++#define RTC_EVTEN_TICK_Msk (0x1UL << RTC_EVTEN_TICK_Pos) /*!< Bit mask of TICK field. */
++#define RTC_EVTEN_TICK_Disabled (0UL) /*!< Disable */
++#define RTC_EVTEN_TICK_Enabled (1UL) /*!< Disable */
++
++/* Register: RTC_EVTENSET */
++/* Description: Enable event routing */
++
++/* Bit 19 : Write '1' to enable event routing for event COMPARE[3] */
++#define RTC_EVTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
++#define RTC_EVTENSET_COMPARE3_Msk (0x1UL << RTC_EVTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
++#define RTC_EVTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENSET_COMPARE3_Set (1UL) /*!< Enable */
++
++/* Bit 18 : Write '1' to enable event routing for event COMPARE[2] */
++#define RTC_EVTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
++#define RTC_EVTENSET_COMPARE2_Msk (0x1UL << RTC_EVTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
++#define RTC_EVTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENSET_COMPARE2_Set (1UL) /*!< Enable */
++
++/* Bit 17 : Write '1' to enable event routing for event COMPARE[1] */
++#define RTC_EVTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
++#define RTC_EVTENSET_COMPARE1_Msk (0x1UL << RTC_EVTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
++#define RTC_EVTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENSET_COMPARE1_Set (1UL) /*!< Enable */
++
++/* Bit 16 : Write '1' to enable event routing for event COMPARE[0] */
++#define RTC_EVTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
++#define RTC_EVTENSET_COMPARE0_Msk (0x1UL << RTC_EVTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
++#define RTC_EVTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENSET_COMPARE0_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable event routing for event OVRFLW */
++#define RTC_EVTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
++#define RTC_EVTENSET_OVRFLW_Msk (0x1UL << RTC_EVTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
++#define RTC_EVTENSET_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENSET_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENSET_OVRFLW_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable event routing for event TICK */
++#define RTC_EVTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
++#define RTC_EVTENSET_TICK_Msk (0x1UL << RTC_EVTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
++#define RTC_EVTENSET_TICK_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENSET_TICK_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENSET_TICK_Set (1UL) /*!< Enable */
++
++/* Register: RTC_EVTENCLR */
++/* Description: Disable event routing */
++
++/* Bit 19 : Write '1' to disable event routing for event COMPARE[3] */
++#define RTC_EVTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
++#define RTC_EVTENCLR_COMPARE3_Msk (0x1UL << RTC_EVTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
++#define RTC_EVTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
++
++/* Bit 18 : Write '1' to disable event routing for event COMPARE[2] */
++#define RTC_EVTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
++#define RTC_EVTENCLR_COMPARE2_Msk (0x1UL << RTC_EVTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
++#define RTC_EVTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
++
++/* Bit 17 : Write '1' to disable event routing for event COMPARE[1] */
++#define RTC_EVTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
++#define RTC_EVTENCLR_COMPARE1_Msk (0x1UL << RTC_EVTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
++#define RTC_EVTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
++
++/* Bit 16 : Write '1' to disable event routing for event COMPARE[0] */
++#define RTC_EVTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
++#define RTC_EVTENCLR_COMPARE0_Msk (0x1UL << RTC_EVTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
++#define RTC_EVTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable event routing for event OVRFLW */
++#define RTC_EVTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
++#define RTC_EVTENCLR_OVRFLW_Msk (0x1UL << RTC_EVTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
++#define RTC_EVTENCLR_OVRFLW_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENCLR_OVRFLW_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENCLR_OVRFLW_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable event routing for event TICK */
++#define RTC_EVTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
++#define RTC_EVTENCLR_TICK_Msk (0x1UL << RTC_EVTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
++#define RTC_EVTENCLR_TICK_Disabled (0UL) /*!< Read: Disabled */
++#define RTC_EVTENCLR_TICK_Enabled (1UL) /*!< Read: Enabled */
++#define RTC_EVTENCLR_TICK_Clear (1UL) /*!< Disable */
++
++/* Register: RTC_COUNTER */
++/* Description: Current COUNTER value */
++
++/* Bits 23..0 : Counter value */
++#define RTC_COUNTER_COUNTER_Pos (0UL) /*!< Position of COUNTER field. */
++#define RTC_COUNTER_COUNTER_Msk (0xFFFFFFUL << RTC_COUNTER_COUNTER_Pos) /*!< Bit mask of COUNTER field. */
++
++/* Register: RTC_PRESCALER */
++/* Description: 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is stopped. */
++
++/* Bits 11..0 : Prescaler value */
++#define RTC_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
++#define RTC_PRESCALER_PRESCALER_Msk (0xFFFUL << RTC_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
++
++/* Register: RTC_CC */
++/* Description: Description collection: Compare register n */
++
++/* Bits 23..0 : Compare value */
++#define RTC_CC_COMPARE_Pos (0UL) /*!< Position of COMPARE field. */
++#define RTC_CC_COMPARE_Msk (0xFFFFFFUL << RTC_CC_COMPARE_Pos) /*!< Bit mask of COMPARE field. */
++
++
++/* Peripheral: SAADC */
++/* Description: Successive approximation register (SAR) analog-to-digital converter */
++
++/* Register: SAADC_TASKS_START */
++/* Description: Starts the SAADC and prepares the result buffer in RAM */
++
++/* Bit 0 : Starts the SAADC and prepares the result buffer in RAM */
++#define SAADC_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define SAADC_TASKS_START_TASKS_START_Msk (0x1UL << SAADC_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define SAADC_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SAADC_TASKS_SAMPLE */
++/* Description: Takes one SAADC sample */
++
++/* Bit 0 : Takes one SAADC sample */
++#define SAADC_TASKS_SAMPLE_TASKS_SAMPLE_Pos (0UL) /*!< Position of TASKS_SAMPLE field. */
++#define SAADC_TASKS_SAMPLE_TASKS_SAMPLE_Msk (0x1UL << SAADC_TASKS_SAMPLE_TASKS_SAMPLE_Pos) /*!< Bit mask of TASKS_SAMPLE field. */
++#define SAADC_TASKS_SAMPLE_TASKS_SAMPLE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SAADC_TASKS_STOP */
++/* Description: Stops the SAADC and terminates all on-going conversions */
++
++/* Bit 0 : Stops the SAADC and terminates all on-going conversions */
++#define SAADC_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define SAADC_TASKS_STOP_TASKS_STOP_Msk (0x1UL << SAADC_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define SAADC_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SAADC_TASKS_CALIBRATEOFFSET */
++/* Description: Starts offset auto-calibration */
++
++/* Bit 0 : Starts offset auto-calibration */
++#define SAADC_TASKS_CALIBRATEOFFSET_TASKS_CALIBRATEOFFSET_Pos (0UL) /*!< Position of TASKS_CALIBRATEOFFSET field. */
++#define SAADC_TASKS_CALIBRATEOFFSET_TASKS_CALIBRATEOFFSET_Msk (0x1UL << SAADC_TASKS_CALIBRATEOFFSET_TASKS_CALIBRATEOFFSET_Pos) /*!< Bit mask of TASKS_CALIBRATEOFFSET field. */
++#define SAADC_TASKS_CALIBRATEOFFSET_TASKS_CALIBRATEOFFSET_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SAADC_EVENTS_STARTED */
++/* Description: The SAADC has started */
++
++/* Bit 0 : The SAADC has started */
++#define SAADC_EVENTS_STARTED_EVENTS_STARTED_Pos (0UL) /*!< Position of EVENTS_STARTED field. */
++#define SAADC_EVENTS_STARTED_EVENTS_STARTED_Msk (0x1UL << SAADC_EVENTS_STARTED_EVENTS_STARTED_Pos) /*!< Bit mask of EVENTS_STARTED field. */
++#define SAADC_EVENTS_STARTED_EVENTS_STARTED_NotGenerated (0UL) /*!< Event not generated */
++#define SAADC_EVENTS_STARTED_EVENTS_STARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: SAADC_EVENTS_END */
++/* Description: The SAADC has filled up the result buffer */
++
++/* Bit 0 : The SAADC has filled up the result buffer */
++#define SAADC_EVENTS_END_EVENTS_END_Pos (0UL) /*!< Position of EVENTS_END field. */
++#define SAADC_EVENTS_END_EVENTS_END_Msk (0x1UL << SAADC_EVENTS_END_EVENTS_END_Pos) /*!< Bit mask of EVENTS_END field. */
++#define SAADC_EVENTS_END_EVENTS_END_NotGenerated (0UL) /*!< Event not generated */
++#define SAADC_EVENTS_END_EVENTS_END_Generated (1UL) /*!< Event generated */
++
++/* Register: SAADC_EVENTS_DONE */
++/* Description: A conversion task has been completed. Depending on the configuration, multiple conversions might be needed for a result to be transferred to RAM. */
++
++/* Bit 0 : A conversion task has been completed. Depending on the configuration, multiple conversions might be needed for a result to be transferred to RAM. */
++#define SAADC_EVENTS_DONE_EVENTS_DONE_Pos (0UL) /*!< Position of EVENTS_DONE field. */
++#define SAADC_EVENTS_DONE_EVENTS_DONE_Msk (0x1UL << SAADC_EVENTS_DONE_EVENTS_DONE_Pos) /*!< Bit mask of EVENTS_DONE field. */
++#define SAADC_EVENTS_DONE_EVENTS_DONE_NotGenerated (0UL) /*!< Event not generated */
++#define SAADC_EVENTS_DONE_EVENTS_DONE_Generated (1UL) /*!< Event generated */
++
++/* Register: SAADC_EVENTS_RESULTDONE */
++/* Description: Result ready for transfer to RAM */
++
++/* Bit 0 : Result ready for transfer to RAM */
++#define SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_Pos (0UL) /*!< Position of EVENTS_RESULTDONE field. */
++#define SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_Msk (0x1UL << SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_Pos) /*!< Bit mask of EVENTS_RESULTDONE field. */
++#define SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_NotGenerated (0UL) /*!< Event not generated */
++#define SAADC_EVENTS_RESULTDONE_EVENTS_RESULTDONE_Generated (1UL) /*!< Event generated */
++
++/* Register: SAADC_EVENTS_CALIBRATEDONE */
++/* Description: Calibration is complete */
++
++/* Bit 0 : Calibration is complete */
++#define SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_Pos (0UL) /*!< Position of EVENTS_CALIBRATEDONE field. */
++#define SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_Msk (0x1UL << SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_Pos) /*!< Bit mask of EVENTS_CALIBRATEDONE field. */
++#define SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_NotGenerated (0UL) /*!< Event not generated */
++#define SAADC_EVENTS_CALIBRATEDONE_EVENTS_CALIBRATEDONE_Generated (1UL) /*!< Event generated */
++
++/* Register: SAADC_EVENTS_STOPPED */
++/* Description: The SAADC has stopped */
++
++/* Bit 0 : The SAADC has stopped */
++#define SAADC_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define SAADC_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << SAADC_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define SAADC_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define SAADC_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: SAADC_EVENTS_CH_LIMITH */
++/* Description: Description cluster: Last result is equal or above CH[n].LIMIT.HIGH */
++
++/* Bit 0 : Last result is equal or above CH[n].LIMIT.HIGH */
++#define SAADC_EVENTS_CH_LIMITH_LIMITH_Pos (0UL) /*!< Position of LIMITH field. */
++#define SAADC_EVENTS_CH_LIMITH_LIMITH_Msk (0x1UL << SAADC_EVENTS_CH_LIMITH_LIMITH_Pos) /*!< Bit mask of LIMITH field. */
++#define SAADC_EVENTS_CH_LIMITH_LIMITH_NotGenerated (0UL) /*!< Event not generated */
++#define SAADC_EVENTS_CH_LIMITH_LIMITH_Generated (1UL) /*!< Event generated */
++
++/* Register: SAADC_EVENTS_CH_LIMITL */
++/* Description: Description cluster: Last result is equal or below CH[n].LIMIT.LOW */
++
++/* Bit 0 : Last result is equal or below CH[n].LIMIT.LOW */
++#define SAADC_EVENTS_CH_LIMITL_LIMITL_Pos (0UL) /*!< Position of LIMITL field. */
++#define SAADC_EVENTS_CH_LIMITL_LIMITL_Msk (0x1UL << SAADC_EVENTS_CH_LIMITL_LIMITL_Pos) /*!< Bit mask of LIMITL field. */
++#define SAADC_EVENTS_CH_LIMITL_LIMITL_NotGenerated (0UL) /*!< Event not generated */
++#define SAADC_EVENTS_CH_LIMITL_LIMITL_Generated (1UL) /*!< Event generated */
++
++/* Register: SAADC_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 21 : Enable or disable interrupt for event CH7LIMITL */
++#define SAADC_INTEN_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
++#define SAADC_INTEN_CH7LIMITL_Msk (0x1UL << SAADC_INTEN_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
++#define SAADC_INTEN_CH7LIMITL_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH7LIMITL_Enabled (1UL) /*!< Enable */
++
++/* Bit 20 : Enable or disable interrupt for event CH7LIMITH */
++#define SAADC_INTEN_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
++#define SAADC_INTEN_CH7LIMITH_Msk (0x1UL << SAADC_INTEN_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
++#define SAADC_INTEN_CH7LIMITH_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH7LIMITH_Enabled (1UL) /*!< Enable */
++
++/* Bit 19 : Enable or disable interrupt for event CH6LIMITL */
++#define SAADC_INTEN_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
++#define SAADC_INTEN_CH6LIMITL_Msk (0x1UL << SAADC_INTEN_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
++#define SAADC_INTEN_CH6LIMITL_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH6LIMITL_Enabled (1UL) /*!< Enable */
++
++/* Bit 18 : Enable or disable interrupt for event CH6LIMITH */
++#define SAADC_INTEN_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
++#define SAADC_INTEN_CH6LIMITH_Msk (0x1UL << SAADC_INTEN_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
++#define SAADC_INTEN_CH6LIMITH_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH6LIMITH_Enabled (1UL) /*!< Enable */
++
++/* Bit 17 : Enable or disable interrupt for event CH5LIMITL */
++#define SAADC_INTEN_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
++#define SAADC_INTEN_CH5LIMITL_Msk (0x1UL << SAADC_INTEN_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
++#define SAADC_INTEN_CH5LIMITL_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH5LIMITL_Enabled (1UL) /*!< Enable */
++
++/* Bit 16 : Enable or disable interrupt for event CH5LIMITH */
++#define SAADC_INTEN_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
++#define SAADC_INTEN_CH5LIMITH_Msk (0x1UL << SAADC_INTEN_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
++#define SAADC_INTEN_CH5LIMITH_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH5LIMITH_Enabled (1UL) /*!< Enable */
++
++/* Bit 15 : Enable or disable interrupt for event CH4LIMITL */
++#define SAADC_INTEN_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
++#define SAADC_INTEN_CH4LIMITL_Msk (0x1UL << SAADC_INTEN_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
++#define SAADC_INTEN_CH4LIMITL_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH4LIMITL_Enabled (1UL) /*!< Enable */
++
++/* Bit 14 : Enable or disable interrupt for event CH4LIMITH */
++#define SAADC_INTEN_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
++#define SAADC_INTEN_CH4LIMITH_Msk (0x1UL << SAADC_INTEN_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
++#define SAADC_INTEN_CH4LIMITH_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH4LIMITH_Enabled (1UL) /*!< Enable */
++
++/* Bit 13 : Enable or disable interrupt for event CH3LIMITL */
++#define SAADC_INTEN_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
++#define SAADC_INTEN_CH3LIMITL_Msk (0x1UL << SAADC_INTEN_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
++#define SAADC_INTEN_CH3LIMITL_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH3LIMITL_Enabled (1UL) /*!< Enable */
++
++/* Bit 12 : Enable or disable interrupt for event CH3LIMITH */
++#define SAADC_INTEN_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
++#define SAADC_INTEN_CH3LIMITH_Msk (0x1UL << SAADC_INTEN_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
++#define SAADC_INTEN_CH3LIMITH_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH3LIMITH_Enabled (1UL) /*!< Enable */
++
++/* Bit 11 : Enable or disable interrupt for event CH2LIMITL */
++#define SAADC_INTEN_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
++#define SAADC_INTEN_CH2LIMITL_Msk (0x1UL << SAADC_INTEN_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
++#define SAADC_INTEN_CH2LIMITL_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH2LIMITL_Enabled (1UL) /*!< Enable */
++
++/* Bit 10 : Enable or disable interrupt for event CH2LIMITH */
++#define SAADC_INTEN_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
++#define SAADC_INTEN_CH2LIMITH_Msk (0x1UL << SAADC_INTEN_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
++#define SAADC_INTEN_CH2LIMITH_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH2LIMITH_Enabled (1UL) /*!< Enable */
++
++/* Bit 9 : Enable or disable interrupt for event CH1LIMITL */
++#define SAADC_INTEN_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
++#define SAADC_INTEN_CH1LIMITL_Msk (0x1UL << SAADC_INTEN_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
++#define SAADC_INTEN_CH1LIMITL_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH1LIMITL_Enabled (1UL) /*!< Enable */
++
++/* Bit 8 : Enable or disable interrupt for event CH1LIMITH */
++#define SAADC_INTEN_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
++#define SAADC_INTEN_CH1LIMITH_Msk (0x1UL << SAADC_INTEN_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
++#define SAADC_INTEN_CH1LIMITH_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH1LIMITH_Enabled (1UL) /*!< Enable */
++
++/* Bit 7 : Enable or disable interrupt for event CH0LIMITL */
++#define SAADC_INTEN_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
++#define SAADC_INTEN_CH0LIMITL_Msk (0x1UL << SAADC_INTEN_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
++#define SAADC_INTEN_CH0LIMITL_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH0LIMITL_Enabled (1UL) /*!< Enable */
++
++/* Bit 6 : Enable or disable interrupt for event CH0LIMITH */
++#define SAADC_INTEN_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
++#define SAADC_INTEN_CH0LIMITH_Msk (0x1UL << SAADC_INTEN_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
++#define SAADC_INTEN_CH0LIMITH_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CH0LIMITH_Enabled (1UL) /*!< Enable */
++
++/* Bit 5 : Enable or disable interrupt for event STOPPED */
++#define SAADC_INTEN_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
++#define SAADC_INTEN_STOPPED_Msk (0x1UL << SAADC_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define SAADC_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable interrupt for event CALIBRATEDONE */
++#define SAADC_INTEN_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
++#define SAADC_INTEN_CALIBRATEDONE_Msk (0x1UL << SAADC_INTEN_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
++#define SAADC_INTEN_CALIBRATEDONE_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_CALIBRATEDONE_Enabled (1UL) /*!< Enable */
++
++/* Bit 3 : Enable or disable interrupt for event RESULTDONE */
++#define SAADC_INTEN_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
++#define SAADC_INTEN_RESULTDONE_Msk (0x1UL << SAADC_INTEN_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
++#define SAADC_INTEN_RESULTDONE_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_RESULTDONE_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event DONE */
++#define SAADC_INTEN_DONE_Pos (2UL) /*!< Position of DONE field. */
++#define SAADC_INTEN_DONE_Msk (0x1UL << SAADC_INTEN_DONE_Pos) /*!< Bit mask of DONE field. */
++#define SAADC_INTEN_DONE_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_DONE_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event END */
++#define SAADC_INTEN_END_Pos (1UL) /*!< Position of END field. */
++#define SAADC_INTEN_END_Msk (0x1UL << SAADC_INTEN_END_Pos) /*!< Bit mask of END field. */
++#define SAADC_INTEN_END_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_END_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event STARTED */
++#define SAADC_INTEN_STARTED_Pos (0UL) /*!< Position of STARTED field. */
++#define SAADC_INTEN_STARTED_Msk (0x1UL << SAADC_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define SAADC_INTEN_STARTED_Disabled (0UL) /*!< Disable */
++#define SAADC_INTEN_STARTED_Enabled (1UL) /*!< Enable */
++
++/* Register: SAADC_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 21 : Write '1' to enable interrupt for event CH7LIMITL */
++#define SAADC_INTENSET_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
++#define SAADC_INTENSET_CH7LIMITL_Msk (0x1UL << SAADC_INTENSET_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
++#define SAADC_INTENSET_CH7LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH7LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH7LIMITL_Set (1UL) /*!< Enable */
++
++/* Bit 20 : Write '1' to enable interrupt for event CH7LIMITH */
++#define SAADC_INTENSET_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
++#define SAADC_INTENSET_CH7LIMITH_Msk (0x1UL << SAADC_INTENSET_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
++#define SAADC_INTENSET_CH7LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH7LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH7LIMITH_Set (1UL) /*!< Enable */
++
++/* Bit 19 : Write '1' to enable interrupt for event CH6LIMITL */
++#define SAADC_INTENSET_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
++#define SAADC_INTENSET_CH6LIMITL_Msk (0x1UL << SAADC_INTENSET_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
++#define SAADC_INTENSET_CH6LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH6LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH6LIMITL_Set (1UL) /*!< Enable */
++
++/* Bit 18 : Write '1' to enable interrupt for event CH6LIMITH */
++#define SAADC_INTENSET_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
++#define SAADC_INTENSET_CH6LIMITH_Msk (0x1UL << SAADC_INTENSET_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
++#define SAADC_INTENSET_CH6LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH6LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH6LIMITH_Set (1UL) /*!< Enable */
++
++/* Bit 17 : Write '1' to enable interrupt for event CH5LIMITL */
++#define SAADC_INTENSET_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
++#define SAADC_INTENSET_CH5LIMITL_Msk (0x1UL << SAADC_INTENSET_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
++#define SAADC_INTENSET_CH5LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH5LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH5LIMITL_Set (1UL) /*!< Enable */
++
++/* Bit 16 : Write '1' to enable interrupt for event CH5LIMITH */
++#define SAADC_INTENSET_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
++#define SAADC_INTENSET_CH5LIMITH_Msk (0x1UL << SAADC_INTENSET_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
++#define SAADC_INTENSET_CH5LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH5LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH5LIMITH_Set (1UL) /*!< Enable */
++
++/* Bit 15 : Write '1' to enable interrupt for event CH4LIMITL */
++#define SAADC_INTENSET_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
++#define SAADC_INTENSET_CH4LIMITL_Msk (0x1UL << SAADC_INTENSET_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
++#define SAADC_INTENSET_CH4LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH4LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH4LIMITL_Set (1UL) /*!< Enable */
++
++/* Bit 14 : Write '1' to enable interrupt for event CH4LIMITH */
++#define SAADC_INTENSET_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
++#define SAADC_INTENSET_CH4LIMITH_Msk (0x1UL << SAADC_INTENSET_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
++#define SAADC_INTENSET_CH4LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH4LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH4LIMITH_Set (1UL) /*!< Enable */
++
++/* Bit 13 : Write '1' to enable interrupt for event CH3LIMITL */
++#define SAADC_INTENSET_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
++#define SAADC_INTENSET_CH3LIMITL_Msk (0x1UL << SAADC_INTENSET_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
++#define SAADC_INTENSET_CH3LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH3LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH3LIMITL_Set (1UL) /*!< Enable */
++
++/* Bit 12 : Write '1' to enable interrupt for event CH3LIMITH */
++#define SAADC_INTENSET_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
++#define SAADC_INTENSET_CH3LIMITH_Msk (0x1UL << SAADC_INTENSET_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
++#define SAADC_INTENSET_CH3LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH3LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH3LIMITH_Set (1UL) /*!< Enable */
++
++/* Bit 11 : Write '1' to enable interrupt for event CH2LIMITL */
++#define SAADC_INTENSET_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
++#define SAADC_INTENSET_CH2LIMITL_Msk (0x1UL << SAADC_INTENSET_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
++#define SAADC_INTENSET_CH2LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH2LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH2LIMITL_Set (1UL) /*!< Enable */
++
++/* Bit 10 : Write '1' to enable interrupt for event CH2LIMITH */
++#define SAADC_INTENSET_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
++#define SAADC_INTENSET_CH2LIMITH_Msk (0x1UL << SAADC_INTENSET_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
++#define SAADC_INTENSET_CH2LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH2LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH2LIMITH_Set (1UL) /*!< Enable */
++
++/* Bit 9 : Write '1' to enable interrupt for event CH1LIMITL */
++#define SAADC_INTENSET_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
++#define SAADC_INTENSET_CH1LIMITL_Msk (0x1UL << SAADC_INTENSET_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
++#define SAADC_INTENSET_CH1LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH1LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH1LIMITL_Set (1UL) /*!< Enable */
++
++/* Bit 8 : Write '1' to enable interrupt for event CH1LIMITH */
++#define SAADC_INTENSET_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
++#define SAADC_INTENSET_CH1LIMITH_Msk (0x1UL << SAADC_INTENSET_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
++#define SAADC_INTENSET_CH1LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH1LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH1LIMITH_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event CH0LIMITL */
++#define SAADC_INTENSET_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
++#define SAADC_INTENSET_CH0LIMITL_Msk (0x1UL << SAADC_INTENSET_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
++#define SAADC_INTENSET_CH0LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH0LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH0LIMITL_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event CH0LIMITH */
++#define SAADC_INTENSET_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
++#define SAADC_INTENSET_CH0LIMITH_Msk (0x1UL << SAADC_INTENSET_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
++#define SAADC_INTENSET_CH0LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CH0LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CH0LIMITH_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event STOPPED */
++#define SAADC_INTENSET_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
++#define SAADC_INTENSET_STOPPED_Msk (0x1UL << SAADC_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define SAADC_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event CALIBRATEDONE */
++#define SAADC_INTENSET_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
++#define SAADC_INTENSET_CALIBRATEDONE_Msk (0x1UL << SAADC_INTENSET_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
++#define SAADC_INTENSET_CALIBRATEDONE_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_CALIBRATEDONE_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_CALIBRATEDONE_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event RESULTDONE */
++#define SAADC_INTENSET_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
++#define SAADC_INTENSET_RESULTDONE_Msk (0x1UL << SAADC_INTENSET_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
++#define SAADC_INTENSET_RESULTDONE_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_RESULTDONE_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_RESULTDONE_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event DONE */
++#define SAADC_INTENSET_DONE_Pos (2UL) /*!< Position of DONE field. */
++#define SAADC_INTENSET_DONE_Msk (0x1UL << SAADC_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
++#define SAADC_INTENSET_DONE_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_DONE_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_DONE_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event END */
++#define SAADC_INTENSET_END_Pos (1UL) /*!< Position of END field. */
++#define SAADC_INTENSET_END_Msk (0x1UL << SAADC_INTENSET_END_Pos) /*!< Bit mask of END field. */
++#define SAADC_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_END_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event STARTED */
++#define SAADC_INTENSET_STARTED_Pos (0UL) /*!< Position of STARTED field. */
++#define SAADC_INTENSET_STARTED_Msk (0x1UL << SAADC_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define SAADC_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENSET_STARTED_Set (1UL) /*!< Enable */
++
++/* Register: SAADC_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 21 : Write '1' to disable interrupt for event CH7LIMITL */
++#define SAADC_INTENCLR_CH7LIMITL_Pos (21UL) /*!< Position of CH7LIMITL field. */
++#define SAADC_INTENCLR_CH7LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH7LIMITL_Pos) /*!< Bit mask of CH7LIMITL field. */
++#define SAADC_INTENCLR_CH7LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH7LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH7LIMITL_Clear (1UL) /*!< Disable */
++
++/* Bit 20 : Write '1' to disable interrupt for event CH7LIMITH */
++#define SAADC_INTENCLR_CH7LIMITH_Pos (20UL) /*!< Position of CH7LIMITH field. */
++#define SAADC_INTENCLR_CH7LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH7LIMITH_Pos) /*!< Bit mask of CH7LIMITH field. */
++#define SAADC_INTENCLR_CH7LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH7LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH7LIMITH_Clear (1UL) /*!< Disable */
++
++/* Bit 19 : Write '1' to disable interrupt for event CH6LIMITL */
++#define SAADC_INTENCLR_CH6LIMITL_Pos (19UL) /*!< Position of CH6LIMITL field. */
++#define SAADC_INTENCLR_CH6LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH6LIMITL_Pos) /*!< Bit mask of CH6LIMITL field. */
++#define SAADC_INTENCLR_CH6LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH6LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH6LIMITL_Clear (1UL) /*!< Disable */
++
++/* Bit 18 : Write '1' to disable interrupt for event CH6LIMITH */
++#define SAADC_INTENCLR_CH6LIMITH_Pos (18UL) /*!< Position of CH6LIMITH field. */
++#define SAADC_INTENCLR_CH6LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH6LIMITH_Pos) /*!< Bit mask of CH6LIMITH field. */
++#define SAADC_INTENCLR_CH6LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH6LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH6LIMITH_Clear (1UL) /*!< Disable */
++
++/* Bit 17 : Write '1' to disable interrupt for event CH5LIMITL */
++#define SAADC_INTENCLR_CH5LIMITL_Pos (17UL) /*!< Position of CH5LIMITL field. */
++#define SAADC_INTENCLR_CH5LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH5LIMITL_Pos) /*!< Bit mask of CH5LIMITL field. */
++#define SAADC_INTENCLR_CH5LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH5LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH5LIMITL_Clear (1UL) /*!< Disable */
++
++/* Bit 16 : Write '1' to disable interrupt for event CH5LIMITH */
++#define SAADC_INTENCLR_CH5LIMITH_Pos (16UL) /*!< Position of CH5LIMITH field. */
++#define SAADC_INTENCLR_CH5LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH5LIMITH_Pos) /*!< Bit mask of CH5LIMITH field. */
++#define SAADC_INTENCLR_CH5LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH5LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH5LIMITH_Clear (1UL) /*!< Disable */
++
++/* Bit 15 : Write '1' to disable interrupt for event CH4LIMITL */
++#define SAADC_INTENCLR_CH4LIMITL_Pos (15UL) /*!< Position of CH4LIMITL field. */
++#define SAADC_INTENCLR_CH4LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH4LIMITL_Pos) /*!< Bit mask of CH4LIMITL field. */
++#define SAADC_INTENCLR_CH4LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH4LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH4LIMITL_Clear (1UL) /*!< Disable */
++
++/* Bit 14 : Write '1' to disable interrupt for event CH4LIMITH */
++#define SAADC_INTENCLR_CH4LIMITH_Pos (14UL) /*!< Position of CH4LIMITH field. */
++#define SAADC_INTENCLR_CH4LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH4LIMITH_Pos) /*!< Bit mask of CH4LIMITH field. */
++#define SAADC_INTENCLR_CH4LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH4LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH4LIMITH_Clear (1UL) /*!< Disable */
++
++/* Bit 13 : Write '1' to disable interrupt for event CH3LIMITL */
++#define SAADC_INTENCLR_CH3LIMITL_Pos (13UL) /*!< Position of CH3LIMITL field. */
++#define SAADC_INTENCLR_CH3LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH3LIMITL_Pos) /*!< Bit mask of CH3LIMITL field. */
++#define SAADC_INTENCLR_CH3LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH3LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH3LIMITL_Clear (1UL) /*!< Disable */
++
++/* Bit 12 : Write '1' to disable interrupt for event CH3LIMITH */
++#define SAADC_INTENCLR_CH3LIMITH_Pos (12UL) /*!< Position of CH3LIMITH field. */
++#define SAADC_INTENCLR_CH3LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH3LIMITH_Pos) /*!< Bit mask of CH3LIMITH field. */
++#define SAADC_INTENCLR_CH3LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH3LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH3LIMITH_Clear (1UL) /*!< Disable */
++
++/* Bit 11 : Write '1' to disable interrupt for event CH2LIMITL */
++#define SAADC_INTENCLR_CH2LIMITL_Pos (11UL) /*!< Position of CH2LIMITL field. */
++#define SAADC_INTENCLR_CH2LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH2LIMITL_Pos) /*!< Bit mask of CH2LIMITL field. */
++#define SAADC_INTENCLR_CH2LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH2LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH2LIMITL_Clear (1UL) /*!< Disable */
++
++/* Bit 10 : Write '1' to disable interrupt for event CH2LIMITH */
++#define SAADC_INTENCLR_CH2LIMITH_Pos (10UL) /*!< Position of CH2LIMITH field. */
++#define SAADC_INTENCLR_CH2LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH2LIMITH_Pos) /*!< Bit mask of CH2LIMITH field. */
++#define SAADC_INTENCLR_CH2LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH2LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH2LIMITH_Clear (1UL) /*!< Disable */
++
++/* Bit 9 : Write '1' to disable interrupt for event CH1LIMITL */
++#define SAADC_INTENCLR_CH1LIMITL_Pos (9UL) /*!< Position of CH1LIMITL field. */
++#define SAADC_INTENCLR_CH1LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH1LIMITL_Pos) /*!< Bit mask of CH1LIMITL field. */
++#define SAADC_INTENCLR_CH1LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH1LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH1LIMITL_Clear (1UL) /*!< Disable */
++
++/* Bit 8 : Write '1' to disable interrupt for event CH1LIMITH */
++#define SAADC_INTENCLR_CH1LIMITH_Pos (8UL) /*!< Position of CH1LIMITH field. */
++#define SAADC_INTENCLR_CH1LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH1LIMITH_Pos) /*!< Bit mask of CH1LIMITH field. */
++#define SAADC_INTENCLR_CH1LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH1LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH1LIMITH_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event CH0LIMITL */
++#define SAADC_INTENCLR_CH0LIMITL_Pos (7UL) /*!< Position of CH0LIMITL field. */
++#define SAADC_INTENCLR_CH0LIMITL_Msk (0x1UL << SAADC_INTENCLR_CH0LIMITL_Pos) /*!< Bit mask of CH0LIMITL field. */
++#define SAADC_INTENCLR_CH0LIMITL_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH0LIMITL_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH0LIMITL_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event CH0LIMITH */
++#define SAADC_INTENCLR_CH0LIMITH_Pos (6UL) /*!< Position of CH0LIMITH field. */
++#define SAADC_INTENCLR_CH0LIMITH_Msk (0x1UL << SAADC_INTENCLR_CH0LIMITH_Pos) /*!< Bit mask of CH0LIMITH field. */
++#define SAADC_INTENCLR_CH0LIMITH_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CH0LIMITH_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CH0LIMITH_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event STOPPED */
++#define SAADC_INTENCLR_STOPPED_Pos (5UL) /*!< Position of STOPPED field. */
++#define SAADC_INTENCLR_STOPPED_Msk (0x1UL << SAADC_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define SAADC_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event CALIBRATEDONE */
++#define SAADC_INTENCLR_CALIBRATEDONE_Pos (4UL) /*!< Position of CALIBRATEDONE field. */
++#define SAADC_INTENCLR_CALIBRATEDONE_Msk (0x1UL << SAADC_INTENCLR_CALIBRATEDONE_Pos) /*!< Bit mask of CALIBRATEDONE field. */
++#define SAADC_INTENCLR_CALIBRATEDONE_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_CALIBRATEDONE_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_CALIBRATEDONE_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event RESULTDONE */
++#define SAADC_INTENCLR_RESULTDONE_Pos (3UL) /*!< Position of RESULTDONE field. */
++#define SAADC_INTENCLR_RESULTDONE_Msk (0x1UL << SAADC_INTENCLR_RESULTDONE_Pos) /*!< Bit mask of RESULTDONE field. */
++#define SAADC_INTENCLR_RESULTDONE_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_RESULTDONE_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_RESULTDONE_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event DONE */
++#define SAADC_INTENCLR_DONE_Pos (2UL) /*!< Position of DONE field. */
++#define SAADC_INTENCLR_DONE_Msk (0x1UL << SAADC_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
++#define SAADC_INTENCLR_DONE_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_DONE_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_DONE_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event END */
++#define SAADC_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
++#define SAADC_INTENCLR_END_Msk (0x1UL << SAADC_INTENCLR_END_Pos) /*!< Bit mask of END field. */
++#define SAADC_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_END_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event STARTED */
++#define SAADC_INTENCLR_STARTED_Pos (0UL) /*!< Position of STARTED field. */
++#define SAADC_INTENCLR_STARTED_Msk (0x1UL << SAADC_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define SAADC_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define SAADC_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define SAADC_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
++
++/* Register: SAADC_STATUS */
++/* Description: Status */
++
++/* Bit 0 : Status */
++#define SAADC_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
++#define SAADC_STATUS_STATUS_Msk (0x1UL << SAADC_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
++#define SAADC_STATUS_STATUS_Ready (0UL) /*!< SAADC is ready. No on-going conversions. */
++#define SAADC_STATUS_STATUS_Busy (1UL) /*!< SAADC is busy. Conversion in progress. */
++
++/* Register: SAADC_ENABLE */
++/* Description: Enable or disable SAADC */
++
++/* Bit 0 : Enable or disable SAADC */
++#define SAADC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define SAADC_ENABLE_ENABLE_Msk (0x1UL << SAADC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define SAADC_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SAADC */
++#define SAADC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable SAADC */
++
++/* Register: SAADC_CH_PSELP */
++/* Description: Description cluster: Input positive pin selection for CH[n] */
++
++/* Bits 4..0 : Analog positive input channel */
++#define SAADC_CH_PSELP_PSELP_Pos (0UL) /*!< Position of PSELP field. */
++#define SAADC_CH_PSELP_PSELP_Msk (0x1FUL << SAADC_CH_PSELP_PSELP_Pos) /*!< Bit mask of PSELP field. */
++#define SAADC_CH_PSELP_PSELP_NC (0UL) /*!< Not connected */
++#define SAADC_CH_PSELP_PSELP_AnalogInput0 (1UL) /*!< AIN0 */
++#define SAADC_CH_PSELP_PSELP_AnalogInput1 (2UL) /*!< AIN1 */
++#define SAADC_CH_PSELP_PSELP_AnalogInput2 (3UL) /*!< AIN2 */
++#define SAADC_CH_PSELP_PSELP_AnalogInput3 (4UL) /*!< AIN3 */
++#define SAADC_CH_PSELP_PSELP_AnalogInput4 (5UL) /*!< AIN4 */
++#define SAADC_CH_PSELP_PSELP_AnalogInput5 (6UL) /*!< AIN5 */
++#define SAADC_CH_PSELP_PSELP_AnalogInput6 (7UL) /*!< AIN6 */
++#define SAADC_CH_PSELP_PSELP_AnalogInput7 (8UL) /*!< AIN7 */
++#define SAADC_CH_PSELP_PSELP_VDD (9UL) /*!< VDD */
++#define SAADC_CH_PSELP_PSELP_VDDHDIV5 (0x0DUL) /*!< VDDH/5 */
++
++/* Register: SAADC_CH_PSELN */
++/* Description: Description cluster: Input negative pin selection for CH[n] */
++
++/* Bits 4..0 : Analog negative input, enables differential channel */
++#define SAADC_CH_PSELN_PSELN_Pos (0UL) /*!< Position of PSELN field. */
++#define SAADC_CH_PSELN_PSELN_Msk (0x1FUL << SAADC_CH_PSELN_PSELN_Pos) /*!< Bit mask of PSELN field. */
++#define SAADC_CH_PSELN_PSELN_NC (0UL) /*!< Not connected */
++#define SAADC_CH_PSELN_PSELN_AnalogInput0 (1UL) /*!< AIN0 */
++#define SAADC_CH_PSELN_PSELN_AnalogInput1 (2UL) /*!< AIN1 */
++#define SAADC_CH_PSELN_PSELN_AnalogInput2 (3UL) /*!< AIN2 */
++#define SAADC_CH_PSELN_PSELN_AnalogInput3 (4UL) /*!< AIN3 */
++#define SAADC_CH_PSELN_PSELN_AnalogInput4 (5UL) /*!< AIN4 */
++#define SAADC_CH_PSELN_PSELN_AnalogInput5 (6UL) /*!< AIN5 */
++#define SAADC_CH_PSELN_PSELN_AnalogInput6 (7UL) /*!< AIN6 */
++#define SAADC_CH_PSELN_PSELN_AnalogInput7 (8UL) /*!< AIN7 */
++#define SAADC_CH_PSELN_PSELN_VDD (9UL) /*!< VDD */
++#define SAADC_CH_PSELN_PSELN_VDDHDIV5 (0x0DUL) /*!< VDDH/5 */
++
++/* Register: SAADC_CH_CONFIG */
++/* Description: Description cluster: Input configuration for CH[n] */
++
++/* Bit 24 : Enable burst mode */
++#define SAADC_CH_CONFIG_BURST_Pos (24UL) /*!< Position of BURST field. */
++#define SAADC_CH_CONFIG_BURST_Msk (0x1UL << SAADC_CH_CONFIG_BURST_Pos) /*!< Bit mask of BURST field. */
++#define SAADC_CH_CONFIG_BURST_Disabled (0UL) /*!< Burst mode is disabled (normal operation) */
++#define SAADC_CH_CONFIG_BURST_Enabled (1UL) /*!< Burst mode is enabled. SAADC takes 2^OVERSAMPLE number of samples as fast as it can, and sends the average to Data RAM. */
++
++/* Bit 20 : Enable differential mode */
++#define SAADC_CH_CONFIG_MODE_Pos (20UL) /*!< Position of MODE field. */
++#define SAADC_CH_CONFIG_MODE_Msk (0x1UL << SAADC_CH_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
++#define SAADC_CH_CONFIG_MODE_SE (0UL) /*!< Single-ended, PSELN will be ignored, negative input to SAADC shorted to GND */
++#define SAADC_CH_CONFIG_MODE_Diff (1UL) /*!< Differential */
++
++/* Bits 18..16 : Acquisition time, the time the SAADC uses to sample the input voltage */
++#define SAADC_CH_CONFIG_TACQ_Pos (16UL) /*!< Position of TACQ field. */
++#define SAADC_CH_CONFIG_TACQ_Msk (0x7UL << SAADC_CH_CONFIG_TACQ_Pos) /*!< Bit mask of TACQ field. */
++#define SAADC_CH_CONFIG_TACQ_3us (0UL) /*!< 3 us */
++#define SAADC_CH_CONFIG_TACQ_5us (1UL) /*!< 5 us */
++#define SAADC_CH_CONFIG_TACQ_10us (2UL) /*!< 10 us */
++#define SAADC_CH_CONFIG_TACQ_15us (3UL) /*!< 15 us */
++#define SAADC_CH_CONFIG_TACQ_20us (4UL) /*!< 20 us */
++#define SAADC_CH_CONFIG_TACQ_40us (5UL) /*!< 40 us */
++
++/* Bit 12 : Reference control */
++#define SAADC_CH_CONFIG_REFSEL_Pos (12UL) /*!< Position of REFSEL field. */
++#define SAADC_CH_CONFIG_REFSEL_Msk (0x1UL << SAADC_CH_CONFIG_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
++#define SAADC_CH_CONFIG_REFSEL_Internal (0UL) /*!< Internal reference (0.6 V) */
++#define SAADC_CH_CONFIG_REFSEL_VDD1_4 (1UL) /*!< VDD/4 as reference */
++
++/* Bits 10..8 : Gain control */
++#define SAADC_CH_CONFIG_GAIN_Pos (8UL) /*!< Position of GAIN field. */
++#define SAADC_CH_CONFIG_GAIN_Msk (0x7UL << SAADC_CH_CONFIG_GAIN_Pos) /*!< Bit mask of GAIN field. */
++#define SAADC_CH_CONFIG_GAIN_Gain1_6 (0UL) /*!< 1/6 */
++#define SAADC_CH_CONFIG_GAIN_Gain1_5 (1UL) /*!< 1/5 */
++#define SAADC_CH_CONFIG_GAIN_Gain1_4 (2UL) /*!< 1/4 */
++#define SAADC_CH_CONFIG_GAIN_Gain1_3 (3UL) /*!< 1/3 */
++#define SAADC_CH_CONFIG_GAIN_Gain1_2 (4UL) /*!< 1/2 */
++#define SAADC_CH_CONFIG_GAIN_Gain1 (5UL) /*!< 1 */
++#define SAADC_CH_CONFIG_GAIN_Gain2 (6UL) /*!< 2 */
++#define SAADC_CH_CONFIG_GAIN_Gain4 (7UL) /*!< 4 */
++
++/* Bits 5..4 : Negative channel resistor control */
++#define SAADC_CH_CONFIG_RESN_Pos (4UL) /*!< Position of RESN field. */
++#define SAADC_CH_CONFIG_RESN_Msk (0x3UL << SAADC_CH_CONFIG_RESN_Pos) /*!< Bit mask of RESN field. */
++#define SAADC_CH_CONFIG_RESN_Bypass (0UL) /*!< Bypass resistor ladder */
++#define SAADC_CH_CONFIG_RESN_Pulldown (1UL) /*!< Pull-down to GND */
++#define SAADC_CH_CONFIG_RESN_Pullup (2UL) /*!< Pull-up to VDD */
++#define SAADC_CH_CONFIG_RESN_VDD1_2 (3UL) /*!< Set input at VDD/2 */
++
++/* Bits 1..0 : Positive channel resistor control */
++#define SAADC_CH_CONFIG_RESP_Pos (0UL) /*!< Position of RESP field. */
++#define SAADC_CH_CONFIG_RESP_Msk (0x3UL << SAADC_CH_CONFIG_RESP_Pos) /*!< Bit mask of RESP field. */
++#define SAADC_CH_CONFIG_RESP_Bypass (0UL) /*!< Bypass resistor ladder */
++#define SAADC_CH_CONFIG_RESP_Pulldown (1UL) /*!< Pull-down to GND */
++#define SAADC_CH_CONFIG_RESP_Pullup (2UL) /*!< Pull-up to VDD */
++#define SAADC_CH_CONFIG_RESP_VDD1_2 (3UL) /*!< Set input at VDD/2 */
++
++/* Register: SAADC_CH_LIMIT */
++/* Description: Description cluster: High/low limits for event monitoring of a channel */
++
++/* Bits 31..16 : High level limit */
++#define SAADC_CH_LIMIT_HIGH_Pos (16UL) /*!< Position of HIGH field. */
++#define SAADC_CH_LIMIT_HIGH_Msk (0xFFFFUL << SAADC_CH_LIMIT_HIGH_Pos) /*!< Bit mask of HIGH field. */
++
++/* Bits 15..0 : Low level limit */
++#define SAADC_CH_LIMIT_LOW_Pos (0UL) /*!< Position of LOW field. */
++#define SAADC_CH_LIMIT_LOW_Msk (0xFFFFUL << SAADC_CH_LIMIT_LOW_Pos) /*!< Bit mask of LOW field. */
++
++/* Register: SAADC_RESOLUTION */
++/* Description: Resolution configuration */
++
++/* Bits 2..0 : Set the resolution */
++#define SAADC_RESOLUTION_VAL_Pos (0UL) /*!< Position of VAL field. */
++#define SAADC_RESOLUTION_VAL_Msk (0x7UL << SAADC_RESOLUTION_VAL_Pos) /*!< Bit mask of VAL field. */
++#define SAADC_RESOLUTION_VAL_8bit (0UL) /*!< 8 bits */
++#define SAADC_RESOLUTION_VAL_10bit (1UL) /*!< 10 bits */
++#define SAADC_RESOLUTION_VAL_12bit (2UL) /*!< 12 bits */
++#define SAADC_RESOLUTION_VAL_14bit (3UL) /*!< 14 bits */
++
++/* Register: SAADC_OVERSAMPLE */
++/* Description: Oversampling configuration. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used. */
++
++/* Bits 3..0 : Oversample control */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Pos (0UL) /*!< Position of OVERSAMPLE field. */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Msk (0xFUL << SAADC_OVERSAMPLE_OVERSAMPLE_Pos) /*!< Bit mask of OVERSAMPLE field. */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Bypass (0UL) /*!< Bypass oversampling */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Over2x (1UL) /*!< Oversample 2x */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Over4x (2UL) /*!< Oversample 4x */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Over8x (3UL) /*!< Oversample 8x */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Over16x (4UL) /*!< Oversample 16x */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Over32x (5UL) /*!< Oversample 32x */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Over64x (6UL) /*!< Oversample 64x */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Over128x (7UL) /*!< Oversample 128x */
++#define SAADC_OVERSAMPLE_OVERSAMPLE_Over256x (8UL) /*!< Oversample 256x */
++
++/* Register: SAADC_SAMPLERATE */
++/* Description: Controls normal or continuous sample rate */
++
++/* Bit 12 : Select mode for sample rate control */
++#define SAADC_SAMPLERATE_MODE_Pos (12UL) /*!< Position of MODE field. */
++#define SAADC_SAMPLERATE_MODE_Msk (0x1UL << SAADC_SAMPLERATE_MODE_Pos) /*!< Bit mask of MODE field. */
++#define SAADC_SAMPLERATE_MODE_Task (0UL) /*!< Rate is controlled from SAMPLE task */
++#define SAADC_SAMPLERATE_MODE_Timers (1UL) /*!< Rate is controlled from local timer (use CC to control the rate) */
++
++/* Bits 10..0 : Capture and compare value. Sample rate is 16 MHz/CC */
++#define SAADC_SAMPLERATE_CC_Pos (0UL) /*!< Position of CC field. */
++#define SAADC_SAMPLERATE_CC_Msk (0x7FFUL << SAADC_SAMPLERATE_CC_Pos) /*!< Bit mask of CC field. */
++
++/* Register: SAADC_RESULT_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define SAADC_RESULT_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define SAADC_RESULT_PTR_PTR_Msk (0xFFFFFFFFUL << SAADC_RESULT_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: SAADC_RESULT_MAXCNT */
++/* Description: Maximum number of 16-bit samples to be written to output RAM buffer */
++
++/* Bits 14..0 : Maximum number of 16-bit samples to be written to output RAM buffer */
++#define SAADC_RESULT_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define SAADC_RESULT_MAXCNT_MAXCNT_Msk (0x7FFFUL << SAADC_RESULT_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: SAADC_RESULT_AMOUNT */
++/* Description: Number of 16-bit samples written to output RAM buffer since the previous START task */
++
++/* Bits 14..0 : Number of 16-bit samples written to output RAM buffer since the previous START task. This register can be read after an END or STOPPED event. */
++#define SAADC_RESULT_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define SAADC_RESULT_AMOUNT_AMOUNT_Msk (0x7FFFUL << SAADC_RESULT_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++
++/* Peripheral: SPI */
++/* Description: Serial Peripheral Interface 0 */
++
++/* Register: SPI_EVENTS_READY */
++/* Description: TXD byte sent and RXD byte received */
++
++/* Bit 0 : TXD byte sent and RXD byte received */
++#define SPI_EVENTS_READY_EVENTS_READY_Pos (0UL) /*!< Position of EVENTS_READY field. */
++#define SPI_EVENTS_READY_EVENTS_READY_Msk (0x1UL << SPI_EVENTS_READY_EVENTS_READY_Pos) /*!< Bit mask of EVENTS_READY field. */
++#define SPI_EVENTS_READY_EVENTS_READY_NotGenerated (0UL) /*!< Event not generated */
++#define SPI_EVENTS_READY_EVENTS_READY_Generated (1UL) /*!< Event generated */
++
++/* Register: SPI_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 2 : Write '1' to enable interrupt for event READY */
++#define SPI_INTENSET_READY_Pos (2UL) /*!< Position of READY field. */
++#define SPI_INTENSET_READY_Msk (0x1UL << SPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
++#define SPI_INTENSET_READY_Disabled (0UL) /*!< Read: Disabled */
++#define SPI_INTENSET_READY_Enabled (1UL) /*!< Read: Enabled */
++#define SPI_INTENSET_READY_Set (1UL) /*!< Enable */
++
++/* Register: SPI_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 2 : Write '1' to disable interrupt for event READY */
++#define SPI_INTENCLR_READY_Pos (2UL) /*!< Position of READY field. */
++#define SPI_INTENCLR_READY_Msk (0x1UL << SPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
++#define SPI_INTENCLR_READY_Disabled (0UL) /*!< Read: Disabled */
++#define SPI_INTENCLR_READY_Enabled (1UL) /*!< Read: Enabled */
++#define SPI_INTENCLR_READY_Clear (1UL) /*!< Disable */
++
++/* Register: SPI_ENABLE */
++/* Description: Enable SPI */
++
++/* Bits 3..0 : Enable or disable SPI */
++#define SPI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define SPI_ENABLE_ENABLE_Msk (0xFUL << SPI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define SPI_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPI */
++#define SPI_ENABLE_ENABLE_Enabled (1UL) /*!< Enable SPI */
++
++/* Register: SPI_PSEL_SCK */
++/* Description: Pin select for SCK */
++
++/* Bit 31 : Connection */
++#define SPI_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPI_PSEL_SCK_CONNECT_Msk (0x1UL << SPI_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPI_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
++#define SPI_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPI_PSEL_SCK_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPI_PSEL_SCK_PORT_Msk (0x1UL << SPI_PSEL_SCK_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPI_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPI_PSEL_SCK_PIN_Msk (0x1FUL << SPI_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPI_PSEL_MOSI */
++/* Description: Pin select for MOSI signal */
++
++/* Bit 31 : Connection */
++#define SPI_PSEL_MOSI_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPI_PSEL_MOSI_CONNECT_Msk (0x1UL << SPI_PSEL_MOSI_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPI_PSEL_MOSI_CONNECT_Connected (0UL) /*!< Connect */
++#define SPI_PSEL_MOSI_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPI_PSEL_MOSI_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPI_PSEL_MOSI_PORT_Msk (0x1UL << SPI_PSEL_MOSI_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPI_PSEL_MOSI_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPI_PSEL_MOSI_PIN_Msk (0x1FUL << SPI_PSEL_MOSI_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPI_PSEL_MISO */
++/* Description: Pin select for MISO signal */
++
++/* Bit 31 : Connection */
++#define SPI_PSEL_MISO_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPI_PSEL_MISO_CONNECT_Msk (0x1UL << SPI_PSEL_MISO_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPI_PSEL_MISO_CONNECT_Connected (0UL) /*!< Connect */
++#define SPI_PSEL_MISO_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPI_PSEL_MISO_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPI_PSEL_MISO_PORT_Msk (0x1UL << SPI_PSEL_MISO_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPI_PSEL_MISO_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPI_PSEL_MISO_PIN_Msk (0x1FUL << SPI_PSEL_MISO_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPI_RXD */
++/* Description: RXD register */
++
++/* Bits 7..0 : RX data received. Double buffered */
++#define SPI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
++#define SPI_RXD_RXD_Msk (0xFFUL << SPI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
++
++/* Register: SPI_TXD */
++/* Description: TXD register */
++
++/* Bits 7..0 : TX data to send. Double buffered. */
++#define SPI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
++#define SPI_TXD_TXD_Msk (0xFFUL << SPI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
++
++/* Register: SPI_FREQUENCY */
++/* Description: SPI frequency. Accuracy depends on the HFCLK source selected. */
++
++/* Bits 31..0 : SPI master data rate */
++#define SPI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
++#define SPI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
++#define SPI_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125 kbps */
++#define SPI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
++#define SPI_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500 kbps */
++#define SPI_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1 Mbps */
++#define SPI_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2 Mbps */
++#define SPI_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4 Mbps */
++#define SPI_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8 Mbps */
++
++/* Register: SPI_CONFIG */
++/* Description: Configuration register */
++
++/* Bit 2 : Serial clock (SCK) polarity */
++#define SPI_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
++#define SPI_CONFIG_CPOL_Msk (0x1UL << SPI_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
++#define SPI_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
++#define SPI_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
++
++/* Bit 1 : Serial clock (SCK) phase */
++#define SPI_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
++#define SPI_CONFIG_CPHA_Msk (0x1UL << SPI_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
++#define SPI_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
++#define SPI_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
++
++/* Bit 0 : Bit order */
++#define SPI_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
++#define SPI_CONFIG_ORDER_Msk (0x1UL << SPI_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
++#define SPI_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
++#define SPI_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
++
++
++/* Peripheral: SPIM */
++/* Description: Serial Peripheral Interface Master with EasyDMA 0 */
++
++/* Register: SPIM_TASKS_START */
++/* Description: Start SPI transaction */
++
++/* Bit 0 : Start SPI transaction */
++#define SPIM_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define SPIM_TASKS_START_TASKS_START_Msk (0x1UL << SPIM_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define SPIM_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SPIM_TASKS_STOP */
++/* Description: Stop SPI transaction */
++
++/* Bit 0 : Stop SPI transaction */
++#define SPIM_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define SPIM_TASKS_STOP_TASKS_STOP_Msk (0x1UL << SPIM_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define SPIM_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SPIM_TASKS_SUSPEND */
++/* Description: Suspend SPI transaction */
++
++/* Bit 0 : Suspend SPI transaction */
++#define SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Pos (0UL) /*!< Position of TASKS_SUSPEND field. */
++#define SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Msk (0x1UL << SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Pos) /*!< Bit mask of TASKS_SUSPEND field. */
++#define SPIM_TASKS_SUSPEND_TASKS_SUSPEND_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SPIM_TASKS_RESUME */
++/* Description: Resume SPI transaction */
++
++/* Bit 0 : Resume SPI transaction */
++#define SPIM_TASKS_RESUME_TASKS_RESUME_Pos (0UL) /*!< Position of TASKS_RESUME field. */
++#define SPIM_TASKS_RESUME_TASKS_RESUME_Msk (0x1UL << SPIM_TASKS_RESUME_TASKS_RESUME_Pos) /*!< Bit mask of TASKS_RESUME field. */
++#define SPIM_TASKS_RESUME_TASKS_RESUME_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SPIM_EVENTS_STOPPED */
++/* Description: SPI transaction has stopped */
++
++/* Bit 0 : SPI transaction has stopped */
++#define SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define SPIM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define SPIM_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: SPIM_EVENTS_ENDRX */
++/* Description: End of RXD buffer reached */
++
++/* Bit 0 : End of RXD buffer reached */
++#define SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Pos (0UL) /*!< Position of EVENTS_ENDRX field. */
++#define SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Msk (0x1UL << SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Pos) /*!< Bit mask of EVENTS_ENDRX field. */
++#define SPIM_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated (0UL) /*!< Event not generated */
++#define SPIM_EVENTS_ENDRX_EVENTS_ENDRX_Generated (1UL) /*!< Event generated */
++
++/* Register: SPIM_EVENTS_END */
++/* Description: End of RXD buffer and TXD buffer reached */
++
++/* Bit 0 : End of RXD buffer and TXD buffer reached */
++#define SPIM_EVENTS_END_EVENTS_END_Pos (0UL) /*!< Position of EVENTS_END field. */
++#define SPIM_EVENTS_END_EVENTS_END_Msk (0x1UL << SPIM_EVENTS_END_EVENTS_END_Pos) /*!< Bit mask of EVENTS_END field. */
++#define SPIM_EVENTS_END_EVENTS_END_NotGenerated (0UL) /*!< Event not generated */
++#define SPIM_EVENTS_END_EVENTS_END_Generated (1UL) /*!< Event generated */
++
++/* Register: SPIM_EVENTS_ENDTX */
++/* Description: End of TXD buffer reached */
++
++/* Bit 0 : End of TXD buffer reached */
++#define SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Pos (0UL) /*!< Position of EVENTS_ENDTX field. */
++#define SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Msk (0x1UL << SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Pos) /*!< Bit mask of EVENTS_ENDTX field. */
++#define SPIM_EVENTS_ENDTX_EVENTS_ENDTX_NotGenerated (0UL) /*!< Event not generated */
++#define SPIM_EVENTS_ENDTX_EVENTS_ENDTX_Generated (1UL) /*!< Event generated */
++
++/* Register: SPIM_EVENTS_STARTED */
++/* Description: Transaction started */
++
++/* Bit 0 : Transaction started */
++#define SPIM_EVENTS_STARTED_EVENTS_STARTED_Pos (0UL) /*!< Position of EVENTS_STARTED field. */
++#define SPIM_EVENTS_STARTED_EVENTS_STARTED_Msk (0x1UL << SPIM_EVENTS_STARTED_EVENTS_STARTED_Pos) /*!< Bit mask of EVENTS_STARTED field. */
++#define SPIM_EVENTS_STARTED_EVENTS_STARTED_NotGenerated (0UL) /*!< Event not generated */
++#define SPIM_EVENTS_STARTED_EVENTS_STARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: SPIM_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 17 : Shortcut between event END and task START */
++#define SPIM_SHORTS_END_START_Pos (17UL) /*!< Position of END_START field. */
++#define SPIM_SHORTS_END_START_Msk (0x1UL << SPIM_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
++#define SPIM_SHORTS_END_START_Disabled (0UL) /*!< Disable shortcut */
++#define SPIM_SHORTS_END_START_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: SPIM_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 19 : Write '1' to enable interrupt for event STARTED */
++#define SPIM_INTENSET_STARTED_Pos (19UL) /*!< Position of STARTED field. */
++#define SPIM_INTENSET_STARTED_Msk (0x1UL << SPIM_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define SPIM_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENSET_STARTED_Set (1UL) /*!< Enable */
++
++/* Bit 8 : Write '1' to enable interrupt for event ENDTX */
++#define SPIM_INTENSET_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
++#define SPIM_INTENSET_ENDTX_Msk (0x1UL << SPIM_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
++#define SPIM_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENSET_ENDTX_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event END */
++#define SPIM_INTENSET_END_Pos (6UL) /*!< Position of END field. */
++#define SPIM_INTENSET_END_Msk (0x1UL << SPIM_INTENSET_END_Pos) /*!< Bit mask of END field. */
++#define SPIM_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENSET_END_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event ENDRX */
++#define SPIM_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
++#define SPIM_INTENSET_ENDRX_Msk (0x1UL << SPIM_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define SPIM_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENSET_ENDRX_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event STOPPED */
++#define SPIM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define SPIM_INTENSET_STOPPED_Msk (0x1UL << SPIM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define SPIM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Register: SPIM_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 19 : Write '1' to disable interrupt for event STARTED */
++#define SPIM_INTENCLR_STARTED_Pos (19UL) /*!< Position of STARTED field. */
++#define SPIM_INTENCLR_STARTED_Msk (0x1UL << SPIM_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define SPIM_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 8 : Write '1' to disable interrupt for event ENDTX */
++#define SPIM_INTENCLR_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
++#define SPIM_INTENCLR_ENDTX_Msk (0x1UL << SPIM_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
++#define SPIM_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event END */
++#define SPIM_INTENCLR_END_Pos (6UL) /*!< Position of END field. */
++#define SPIM_INTENCLR_END_Msk (0x1UL << SPIM_INTENCLR_END_Pos) /*!< Bit mask of END field. */
++#define SPIM_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENCLR_END_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event ENDRX */
++#define SPIM_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
++#define SPIM_INTENCLR_ENDRX_Msk (0x1UL << SPIM_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define SPIM_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event STOPPED */
++#define SPIM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define SPIM_INTENCLR_STOPPED_Msk (0x1UL << SPIM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define SPIM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define SPIM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define SPIM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Register: SPIM_STALLSTAT */
++/* Description: Stall status for EasyDMA RAM accesses. The fields in this register are set to STALL by hardware whenever a stall occurs and can be cleared (set to NOSTALL) by the CPU. */
++
++/* Bit 1 : Stall status for EasyDMA RAM writes */
++#define SPIM_STALLSTAT_RX_Pos (1UL) /*!< Position of RX field. */
++#define SPIM_STALLSTAT_RX_Msk (0x1UL << SPIM_STALLSTAT_RX_Pos) /*!< Bit mask of RX field. */
++#define SPIM_STALLSTAT_RX_NOSTALL (0UL) /*!< No stall */
++#define SPIM_STALLSTAT_RX_STALL (1UL) /*!< A stall has occurred */
++
++/* Bit 0 : Stall status for EasyDMA RAM reads */
++#define SPIM_STALLSTAT_TX_Pos (0UL) /*!< Position of TX field. */
++#define SPIM_STALLSTAT_TX_Msk (0x1UL << SPIM_STALLSTAT_TX_Pos) /*!< Bit mask of TX field. */
++#define SPIM_STALLSTAT_TX_NOSTALL (0UL) /*!< No stall */
++#define SPIM_STALLSTAT_TX_STALL (1UL) /*!< A stall has occurred */
++
++/* Register: SPIM_ENABLE */
++/* Description: Enable SPIM */
++
++/* Bits 3..0 : Enable or disable SPIM */
++#define SPIM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define SPIM_ENABLE_ENABLE_Msk (0xFUL << SPIM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define SPIM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPIM */
++#define SPIM_ENABLE_ENABLE_Enabled (7UL) /*!< Enable SPIM */
++
++/* Register: SPIM_PSEL_SCK */
++/* Description: Pin select for SCK */
++
++/* Bit 31 : Connection */
++#define SPIM_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIM_PSEL_SCK_CONNECT_Msk (0x1UL << SPIM_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIM_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIM_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIM_PSEL_SCK_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIM_PSEL_SCK_PORT_Msk (0x1UL << SPIM_PSEL_SCK_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIM_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIM_PSEL_SCK_PIN_Msk (0x1FUL << SPIM_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIM_PSEL_MOSI */
++/* Description: Pin select for MOSI signal */
++
++/* Bit 31 : Connection */
++#define SPIM_PSEL_MOSI_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIM_PSEL_MOSI_CONNECT_Msk (0x1UL << SPIM_PSEL_MOSI_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIM_PSEL_MOSI_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIM_PSEL_MOSI_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIM_PSEL_MOSI_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIM_PSEL_MOSI_PORT_Msk (0x1UL << SPIM_PSEL_MOSI_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIM_PSEL_MOSI_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIM_PSEL_MOSI_PIN_Msk (0x1FUL << SPIM_PSEL_MOSI_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIM_PSEL_MISO */
++/* Description: Pin select for MISO signal */
++
++/* Bit 31 : Connection */
++#define SPIM_PSEL_MISO_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIM_PSEL_MISO_CONNECT_Msk (0x1UL << SPIM_PSEL_MISO_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIM_PSEL_MISO_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIM_PSEL_MISO_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIM_PSEL_MISO_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIM_PSEL_MISO_PORT_Msk (0x1UL << SPIM_PSEL_MISO_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIM_PSEL_MISO_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIM_PSEL_MISO_PIN_Msk (0x1FUL << SPIM_PSEL_MISO_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIM_PSEL_CSN */
++/* Description: Pin select for CSN */
++
++/* Bit 31 : Connection */
++#define SPIM_PSEL_CSN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIM_PSEL_CSN_CONNECT_Msk (0x1UL << SPIM_PSEL_CSN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIM_PSEL_CSN_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIM_PSEL_CSN_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIM_PSEL_CSN_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIM_PSEL_CSN_PORT_Msk (0x1UL << SPIM_PSEL_CSN_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIM_PSEL_CSN_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIM_PSEL_CSN_PIN_Msk (0x1FUL << SPIM_PSEL_CSN_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIM_FREQUENCY */
++/* Description: SPI frequency. Accuracy depends on the HFCLK source selected. */
++
++/* Bits 31..0 : SPI master data rate */
++#define SPIM_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
++#define SPIM_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPIM_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
++#define SPIM_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125 kbps */
++#define SPIM_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
++#define SPIM_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500 kbps */
++#define SPIM_FREQUENCY_FREQUENCY_M16 (0x0A000000UL) /*!< 16 Mbps */
++#define SPIM_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1 Mbps */
++#define SPIM_FREQUENCY_FREQUENCY_M32 (0x14000000UL) /*!< 32 Mbps */
++#define SPIM_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2 Mbps */
++#define SPIM_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4 Mbps */
++#define SPIM_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8 Mbps */
++
++/* Register: SPIM_RXD_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define SPIM_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define SPIM_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIM_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: SPIM_RXD_MAXCNT */
++/* Description: Maximum number of bytes in receive buffer */
++
++/* Bits 15..0 : Maximum number of bytes in receive buffer */
++#define SPIM_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define SPIM_RXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << SPIM_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: SPIM_RXD_AMOUNT */
++/* Description: Number of bytes transferred in the last transaction */
++
++/* Bits 15..0 : Number of bytes transferred in the last transaction */
++#define SPIM_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define SPIM_RXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << SPIM_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: SPIM_RXD_LIST */
++/* Description: EasyDMA list type */
++
++/* Bits 1..0 : List type */
++#define SPIM_RXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
++#define SPIM_RXD_LIST_LIST_Msk (0x3UL << SPIM_RXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
++#define SPIM_RXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
++#define SPIM_RXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
++
++/* Register: SPIM_TXD_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define SPIM_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define SPIM_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIM_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: SPIM_TXD_MAXCNT */
++/* Description: Number of bytes in transmit buffer */
++
++/* Bits 15..0 : Maximum number of bytes in transmit buffer */
++#define SPIM_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define SPIM_TXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << SPIM_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: SPIM_TXD_AMOUNT */
++/* Description: Number of bytes transferred in the last transaction */
++
++/* Bits 15..0 : Number of bytes transferred in the last transaction */
++#define SPIM_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define SPIM_TXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << SPIM_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: SPIM_TXD_LIST */
++/* Description: EasyDMA list type */
++
++/* Bits 1..0 : List type */
++#define SPIM_TXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
++#define SPIM_TXD_LIST_LIST_Msk (0x3UL << SPIM_TXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
++#define SPIM_TXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
++#define SPIM_TXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
++
++/* Register: SPIM_CONFIG */
++/* Description: Configuration register */
++
++/* Bit 2 : Serial clock (SCK) polarity */
++#define SPIM_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
++#define SPIM_CONFIG_CPOL_Msk (0x1UL << SPIM_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
++#define SPIM_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
++#define SPIM_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
++
++/* Bit 1 : Serial clock (SCK) phase */
++#define SPIM_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
++#define SPIM_CONFIG_CPHA_Msk (0x1UL << SPIM_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
++#define SPIM_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
++#define SPIM_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
++
++/* Bit 0 : Bit order */
++#define SPIM_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
++#define SPIM_CONFIG_ORDER_Msk (0x1UL << SPIM_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
++#define SPIM_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
++#define SPIM_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
++
++/* Register: SPIM_IFTIMING_RXDELAY */
++/* Description: Sample delay for input serial data on MISO */
++
++/* Bits 2..0 : Sample delay for input serial data on MISO. The value specifies the number of 64 MHz clock cycles (15.625 ns) delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK. */
++#define SPIM_IFTIMING_RXDELAY_RXDELAY_Pos (0UL) /*!< Position of RXDELAY field. */
++#define SPIM_IFTIMING_RXDELAY_RXDELAY_Msk (0x7UL << SPIM_IFTIMING_RXDELAY_RXDELAY_Pos) /*!< Bit mask of RXDELAY field. */
++
++/* Register: SPIM_IFTIMING_CSNDUR */
++/* Description: Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions */
++
++/* Bits 7..0 : Minimum duration between edge of CSN and edge of SCK and minimum duration CSN must stay high between transactions. The value is specified in number of 64 MHz clock cycles (15.625 ns). */
++#define SPIM_IFTIMING_CSNDUR_CSNDUR_Pos (0UL) /*!< Position of CSNDUR field. */
++#define SPIM_IFTIMING_CSNDUR_CSNDUR_Msk (0xFFUL << SPIM_IFTIMING_CSNDUR_CSNDUR_Pos) /*!< Bit mask of CSNDUR field. */
++
++/* Register: SPIM_CSNPOL */
++/* Description: Polarity of CSN output */
++
++/* Bit 0 : Polarity of CSN output */
++#define SPIM_CSNPOL_CSNPOL_Pos (0UL) /*!< Position of CSNPOL field. */
++#define SPIM_CSNPOL_CSNPOL_Msk (0x1UL << SPIM_CSNPOL_CSNPOL_Pos) /*!< Bit mask of CSNPOL field. */
++#define SPIM_CSNPOL_CSNPOL_LOW (0UL) /*!< Active low (idle state high) */
++#define SPIM_CSNPOL_CSNPOL_HIGH (1UL) /*!< Active high (idle state low) */
++
++/* Register: SPIM_PSELDCX */
++/* Description: Pin select for DCX signal */
++
++/* Bit 31 : Connection */
++#define SPIM_PSELDCX_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIM_PSELDCX_CONNECT_Msk (0x1UL << SPIM_PSELDCX_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIM_PSELDCX_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIM_PSELDCX_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIM_PSELDCX_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIM_PSELDCX_PORT_Msk (0x1UL << SPIM_PSELDCX_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIM_PSELDCX_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIM_PSELDCX_PIN_Msk (0x1FUL << SPIM_PSELDCX_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIM_DCXCNT */
++/* Description: DCX configuration */
++
++/* Bits 3..0 : This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes. */
++#define SPIM_DCXCNT_DCXCNT_Pos (0UL) /*!< Position of DCXCNT field. */
++#define SPIM_DCXCNT_DCXCNT_Msk (0xFUL << SPIM_DCXCNT_DCXCNT_Pos) /*!< Bit mask of DCXCNT field. */
++
++/* Register: SPIM_ORC */
++/* Description: Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT */
++
++/* Bits 7..0 : Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT. */
++#define SPIM_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
++#define SPIM_ORC_ORC_Msk (0xFFUL << SPIM_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
++
++
++/* Peripheral: SPIS */
++/* Description: SPI Slave 0 */
++
++/* Register: SPIS_TASKS_ACQUIRE */
++/* Description: Acquire SPI semaphore */
++
++/* Bit 0 : Acquire SPI semaphore */
++#define SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Pos (0UL) /*!< Position of TASKS_ACQUIRE field. */
++#define SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Msk (0x1UL << SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Pos) /*!< Bit mask of TASKS_ACQUIRE field. */
++#define SPIS_TASKS_ACQUIRE_TASKS_ACQUIRE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SPIS_TASKS_RELEASE */
++/* Description: Release SPI semaphore, enabling the SPI slave to acquire it */
++
++/* Bit 0 : Release SPI semaphore, enabling the SPI slave to acquire it */
++#define SPIS_TASKS_RELEASE_TASKS_RELEASE_Pos (0UL) /*!< Position of TASKS_RELEASE field. */
++#define SPIS_TASKS_RELEASE_TASKS_RELEASE_Msk (0x1UL << SPIS_TASKS_RELEASE_TASKS_RELEASE_Pos) /*!< Bit mask of TASKS_RELEASE field. */
++#define SPIS_TASKS_RELEASE_TASKS_RELEASE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: SPIS_EVENTS_END */
++/* Description: Granted transaction completed */
++
++/* Bit 0 : Granted transaction completed */
++#define SPIS_EVENTS_END_EVENTS_END_Pos (0UL) /*!< Position of EVENTS_END field. */
++#define SPIS_EVENTS_END_EVENTS_END_Msk (0x1UL << SPIS_EVENTS_END_EVENTS_END_Pos) /*!< Bit mask of EVENTS_END field. */
++#define SPIS_EVENTS_END_EVENTS_END_NotGenerated (0UL) /*!< Event not generated */
++#define SPIS_EVENTS_END_EVENTS_END_Generated (1UL) /*!< Event generated */
++
++/* Register: SPIS_EVENTS_ENDRX */
++/* Description: End of RXD buffer reached */
++
++/* Bit 0 : End of RXD buffer reached */
++#define SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Pos (0UL) /*!< Position of EVENTS_ENDRX field. */
++#define SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Msk (0x1UL << SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Pos) /*!< Bit mask of EVENTS_ENDRX field. */
++#define SPIS_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated (0UL) /*!< Event not generated */
++#define SPIS_EVENTS_ENDRX_EVENTS_ENDRX_Generated (1UL) /*!< Event generated */
++
++/* Register: SPIS_EVENTS_ACQUIRED */
++/* Description: Semaphore acquired */
++
++/* Bit 0 : Semaphore acquired */
++#define SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Pos (0UL) /*!< Position of EVENTS_ACQUIRED field. */
++#define SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Msk (0x1UL << SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Pos) /*!< Bit mask of EVENTS_ACQUIRED field. */
++#define SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_NotGenerated (0UL) /*!< Event not generated */
++#define SPIS_EVENTS_ACQUIRED_EVENTS_ACQUIRED_Generated (1UL) /*!< Event generated */
++
++/* Register: SPIS_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 2 : Shortcut between event END and task ACQUIRE */
++#define SPIS_SHORTS_END_ACQUIRE_Pos (2UL) /*!< Position of END_ACQUIRE field. */
++#define SPIS_SHORTS_END_ACQUIRE_Msk (0x1UL << SPIS_SHORTS_END_ACQUIRE_Pos) /*!< Bit mask of END_ACQUIRE field. */
++#define SPIS_SHORTS_END_ACQUIRE_Disabled (0UL) /*!< Disable shortcut */
++#define SPIS_SHORTS_END_ACQUIRE_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: SPIS_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 10 : Write '1' to enable interrupt for event ACQUIRED */
++#define SPIS_INTENSET_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
++#define SPIS_INTENSET_ACQUIRED_Msk (0x1UL << SPIS_INTENSET_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
++#define SPIS_INTENSET_ACQUIRED_Disabled (0UL) /*!< Read: Disabled */
++#define SPIS_INTENSET_ACQUIRED_Enabled (1UL) /*!< Read: Enabled */
++#define SPIS_INTENSET_ACQUIRED_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event ENDRX */
++#define SPIS_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
++#define SPIS_INTENSET_ENDRX_Msk (0x1UL << SPIS_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define SPIS_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
++#define SPIS_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
++#define SPIS_INTENSET_ENDRX_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event END */
++#define SPIS_INTENSET_END_Pos (1UL) /*!< Position of END field. */
++#define SPIS_INTENSET_END_Msk (0x1UL << SPIS_INTENSET_END_Pos) /*!< Bit mask of END field. */
++#define SPIS_INTENSET_END_Disabled (0UL) /*!< Read: Disabled */
++#define SPIS_INTENSET_END_Enabled (1UL) /*!< Read: Enabled */
++#define SPIS_INTENSET_END_Set (1UL) /*!< Enable */
++
++/* Register: SPIS_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 10 : Write '1' to disable interrupt for event ACQUIRED */
++#define SPIS_INTENCLR_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
++#define SPIS_INTENCLR_ACQUIRED_Msk (0x1UL << SPIS_INTENCLR_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
++#define SPIS_INTENCLR_ACQUIRED_Disabled (0UL) /*!< Read: Disabled */
++#define SPIS_INTENCLR_ACQUIRED_Enabled (1UL) /*!< Read: Enabled */
++#define SPIS_INTENCLR_ACQUIRED_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event ENDRX */
++#define SPIS_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
++#define SPIS_INTENCLR_ENDRX_Msk (0x1UL << SPIS_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define SPIS_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
++#define SPIS_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
++#define SPIS_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event END */
++#define SPIS_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
++#define SPIS_INTENCLR_END_Msk (0x1UL << SPIS_INTENCLR_END_Pos) /*!< Bit mask of END field. */
++#define SPIS_INTENCLR_END_Disabled (0UL) /*!< Read: Disabled */
++#define SPIS_INTENCLR_END_Enabled (1UL) /*!< Read: Enabled */
++#define SPIS_INTENCLR_END_Clear (1UL) /*!< Disable */
++
++/* Register: SPIS_SEMSTAT */
++/* Description: Semaphore status register */
++
++/* Bits 1..0 : Semaphore status */
++#define SPIS_SEMSTAT_SEMSTAT_Pos (0UL) /*!< Position of SEMSTAT field. */
++#define SPIS_SEMSTAT_SEMSTAT_Msk (0x3UL << SPIS_SEMSTAT_SEMSTAT_Pos) /*!< Bit mask of SEMSTAT field. */
++#define SPIS_SEMSTAT_SEMSTAT_Free (0UL) /*!< Semaphore is free */
++#define SPIS_SEMSTAT_SEMSTAT_CPU (1UL) /*!< Semaphore is assigned to CPU */
++#define SPIS_SEMSTAT_SEMSTAT_SPIS (2UL) /*!< Semaphore is assigned to SPI slave */
++#define SPIS_SEMSTAT_SEMSTAT_CPUPending (3UL) /*!< Semaphore is assigned to SPI but a handover to the CPU is pending */
++
++/* Register: SPIS_STATUS */
++/* Description: Status from last transaction */
++
++/* Bit 1 : RX buffer overflow detected, and prevented */
++#define SPIS_STATUS_OVERFLOW_Pos (1UL) /*!< Position of OVERFLOW field. */
++#define SPIS_STATUS_OVERFLOW_Msk (0x1UL << SPIS_STATUS_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
++#define SPIS_STATUS_OVERFLOW_NotPresent (0UL) /*!< Read: error not present */
++#define SPIS_STATUS_OVERFLOW_Present (1UL) /*!< Read: error present */
++#define SPIS_STATUS_OVERFLOW_Clear (1UL) /*!< Write: clear error on writing '1' */
++
++/* Bit 0 : TX buffer over-read detected, and prevented */
++#define SPIS_STATUS_OVERREAD_Pos (0UL) /*!< Position of OVERREAD field. */
++#define SPIS_STATUS_OVERREAD_Msk (0x1UL << SPIS_STATUS_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
++#define SPIS_STATUS_OVERREAD_NotPresent (0UL) /*!< Read: error not present */
++#define SPIS_STATUS_OVERREAD_Present (1UL) /*!< Read: error present */
++#define SPIS_STATUS_OVERREAD_Clear (1UL) /*!< Write: clear error on writing '1' */
++
++/* Register: SPIS_ENABLE */
++/* Description: Enable SPI slave */
++
++/* Bits 3..0 : Enable or disable SPI slave */
++#define SPIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define SPIS_ENABLE_ENABLE_Msk (0xFUL << SPIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define SPIS_ENABLE_ENABLE_Disabled (0UL) /*!< Disable SPI slave */
++#define SPIS_ENABLE_ENABLE_Enabled (2UL) /*!< Enable SPI slave */
++
++/* Register: SPIS_PSEL_SCK */
++/* Description: Pin select for SCK */
++
++/* Bit 31 : Connection */
++#define SPIS_PSEL_SCK_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIS_PSEL_SCK_CONNECT_Msk (0x1UL << SPIS_PSEL_SCK_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIS_PSEL_SCK_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIS_PSEL_SCK_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIS_PSEL_SCK_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIS_PSEL_SCK_PORT_Msk (0x1UL << SPIS_PSEL_SCK_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIS_PSEL_SCK_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIS_PSEL_SCK_PIN_Msk (0x1FUL << SPIS_PSEL_SCK_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIS_PSEL_MISO */
++/* Description: Pin select for MISO signal */
++
++/* Bit 31 : Connection */
++#define SPIS_PSEL_MISO_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIS_PSEL_MISO_CONNECT_Msk (0x1UL << SPIS_PSEL_MISO_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIS_PSEL_MISO_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIS_PSEL_MISO_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIS_PSEL_MISO_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIS_PSEL_MISO_PORT_Msk (0x1UL << SPIS_PSEL_MISO_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIS_PSEL_MISO_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIS_PSEL_MISO_PIN_Msk (0x1FUL << SPIS_PSEL_MISO_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIS_PSEL_MOSI */
++/* Description: Pin select for MOSI signal */
++
++/* Bit 31 : Connection */
++#define SPIS_PSEL_MOSI_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIS_PSEL_MOSI_CONNECT_Msk (0x1UL << SPIS_PSEL_MOSI_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIS_PSEL_MOSI_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIS_PSEL_MOSI_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIS_PSEL_MOSI_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIS_PSEL_MOSI_PORT_Msk (0x1UL << SPIS_PSEL_MOSI_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIS_PSEL_MOSI_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIS_PSEL_MOSI_PIN_Msk (0x1FUL << SPIS_PSEL_MOSI_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIS_PSEL_CSN */
++/* Description: Pin select for CSN signal */
++
++/* Bit 31 : Connection */
++#define SPIS_PSEL_CSN_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define SPIS_PSEL_CSN_CONNECT_Msk (0x1UL << SPIS_PSEL_CSN_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define SPIS_PSEL_CSN_CONNECT_Connected (0UL) /*!< Connect */
++#define SPIS_PSEL_CSN_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define SPIS_PSEL_CSN_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define SPIS_PSEL_CSN_PORT_Msk (0x1UL << SPIS_PSEL_CSN_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define SPIS_PSEL_CSN_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define SPIS_PSEL_CSN_PIN_Msk (0x1FUL << SPIS_PSEL_CSN_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: SPIS_RXD_PTR */
++/* Description: RXD data pointer */
++
++/* Bits 31..0 : RXD data pointer */
++#define SPIS_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define SPIS_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIS_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: SPIS_RXD_MAXCNT */
++/* Description: Maximum number of bytes in receive buffer */
++
++/* Bits 15..0 : Maximum number of bytes in receive buffer */
++#define SPIS_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define SPIS_RXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << SPIS_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: SPIS_RXD_AMOUNT */
++/* Description: Number of bytes received in last granted transaction */
++
++/* Bits 15..0 : Number of bytes received in the last granted transaction */
++#define SPIS_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define SPIS_RXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << SPIS_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: SPIS_RXD_LIST */
++/* Description: EasyDMA list type */
++
++/* Bits 1..0 : List type */
++#define SPIS_RXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
++#define SPIS_RXD_LIST_LIST_Msk (0x3UL << SPIS_RXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
++#define SPIS_RXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
++#define SPIS_RXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
++
++/* Register: SPIS_TXD_PTR */
++/* Description: TXD data pointer */
++
++/* Bits 31..0 : TXD data pointer */
++#define SPIS_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define SPIS_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << SPIS_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: SPIS_TXD_MAXCNT */
++/* Description: Maximum number of bytes in transmit buffer */
++
++/* Bits 15..0 : Maximum number of bytes in transmit buffer */
++#define SPIS_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define SPIS_TXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << SPIS_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: SPIS_TXD_AMOUNT */
++/* Description: Number of bytes transmitted in last granted transaction */
++
++/* Bits 15..0 : Number of bytes transmitted in last granted transaction */
++#define SPIS_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define SPIS_TXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << SPIS_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: SPIS_TXD_LIST */
++/* Description: EasyDMA list type */
++
++/* Bits 1..0 : List type */
++#define SPIS_TXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
++#define SPIS_TXD_LIST_LIST_Msk (0x3UL << SPIS_TXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
++#define SPIS_TXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
++#define SPIS_TXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
++
++/* Register: SPIS_CONFIG */
++/* Description: Configuration register */
++
++/* Bit 2 : Serial clock (SCK) polarity */
++#define SPIS_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
++#define SPIS_CONFIG_CPOL_Msk (0x1UL << SPIS_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
++#define SPIS_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high */
++#define SPIS_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low */
++
++/* Bit 1 : Serial clock (SCK) phase */
++#define SPIS_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
++#define SPIS_CONFIG_CPHA_Msk (0x1UL << SPIS_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
++#define SPIS_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of clock, shift serial data on trailing edge */
++#define SPIS_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of clock, shift serial data on leading edge */
++
++/* Bit 0 : Bit order */
++#define SPIS_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
++#define SPIS_CONFIG_ORDER_Msk (0x1UL << SPIS_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
++#define SPIS_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit shifted out first */
++#define SPIS_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit shifted out first */
++
++/* Register: SPIS_DEF */
++/* Description: Default character. Character clocked out in case of an ignored transaction. */
++
++/* Bits 7..0 : Default character. Character clocked out in case of an ignored transaction. */
++#define SPIS_DEF_DEF_Pos (0UL) /*!< Position of DEF field. */
++#define SPIS_DEF_DEF_Msk (0xFFUL << SPIS_DEF_DEF_Pos) /*!< Bit mask of DEF field. */
++
++/* Register: SPIS_ORC */
++/* Description: Over-read character */
++
++/* Bits 7..0 : Over-read character. Character clocked out after an over-read of the transmit buffer. */
++#define SPIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
++#define SPIS_ORC_ORC_Msk (0xFFUL << SPIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
++
++
++/* Peripheral: TEMP */
++/* Description: Temperature Sensor */
++
++/* Register: TEMP_TASKS_START */
++/* Description: Start temperature measurement */
++
++/* Bit 0 : Start temperature measurement */
++#define TEMP_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define TEMP_TASKS_START_TASKS_START_Msk (0x1UL << TEMP_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define TEMP_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TEMP_TASKS_STOP */
++/* Description: Stop temperature measurement */
++
++/* Bit 0 : Stop temperature measurement */
++#define TEMP_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define TEMP_TASKS_STOP_TASKS_STOP_Msk (0x1UL << TEMP_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define TEMP_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TEMP_EVENTS_DATARDY */
++/* Description: Temperature measurement complete, data ready */
++
++/* Bit 0 : Temperature measurement complete, data ready */
++#define TEMP_EVENTS_DATARDY_EVENTS_DATARDY_Pos (0UL) /*!< Position of EVENTS_DATARDY field. */
++#define TEMP_EVENTS_DATARDY_EVENTS_DATARDY_Msk (0x1UL << TEMP_EVENTS_DATARDY_EVENTS_DATARDY_Pos) /*!< Bit mask of EVENTS_DATARDY field. */
++#define TEMP_EVENTS_DATARDY_EVENTS_DATARDY_NotGenerated (0UL) /*!< Event not generated */
++#define TEMP_EVENTS_DATARDY_EVENTS_DATARDY_Generated (1UL) /*!< Event generated */
++
++/* Register: TEMP_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 0 : Write '1' to enable interrupt for event DATARDY */
++#define TEMP_INTENSET_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
++#define TEMP_INTENSET_DATARDY_Msk (0x1UL << TEMP_INTENSET_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
++#define TEMP_INTENSET_DATARDY_Disabled (0UL) /*!< Read: Disabled */
++#define TEMP_INTENSET_DATARDY_Enabled (1UL) /*!< Read: Enabled */
++#define TEMP_INTENSET_DATARDY_Set (1UL) /*!< Enable */
++
++/* Register: TEMP_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 0 : Write '1' to disable interrupt for event DATARDY */
++#define TEMP_INTENCLR_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
++#define TEMP_INTENCLR_DATARDY_Msk (0x1UL << TEMP_INTENCLR_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
++#define TEMP_INTENCLR_DATARDY_Disabled (0UL) /*!< Read: Disabled */
++#define TEMP_INTENCLR_DATARDY_Enabled (1UL) /*!< Read: Enabled */
++#define TEMP_INTENCLR_DATARDY_Clear (1UL) /*!< Disable */
++
++/* Register: TEMP_TEMP */
++/* Description: Temperature in degC (0.25deg steps) */
++
++/* Bits 31..0 : Temperature in degC (0.25deg steps) */
++#define TEMP_TEMP_TEMP_Pos (0UL) /*!< Position of TEMP field. */
++#define TEMP_TEMP_TEMP_Msk (0xFFFFFFFFUL << TEMP_TEMP_TEMP_Pos) /*!< Bit mask of TEMP field. */
++
++/* Register: TEMP_A0 */
++/* Description: Slope of first piecewise linear function */
++
++/* Bits 11..0 : Slope of first piecewise linear function */
++#define TEMP_A0_A0_Pos (0UL) /*!< Position of A0 field. */
++#define TEMP_A0_A0_Msk (0xFFFUL << TEMP_A0_A0_Pos) /*!< Bit mask of A0 field. */
++
++/* Register: TEMP_A1 */
++/* Description: Slope of second piecewise linear function */
++
++/* Bits 11..0 : Slope of second piecewise linear function */
++#define TEMP_A1_A1_Pos (0UL) /*!< Position of A1 field. */
++#define TEMP_A1_A1_Msk (0xFFFUL << TEMP_A1_A1_Pos) /*!< Bit mask of A1 field. */
++
++/* Register: TEMP_A2 */
++/* Description: Slope of third piecewise linear function */
++
++/* Bits 11..0 : Slope of third piecewise linear function */
++#define TEMP_A2_A2_Pos (0UL) /*!< Position of A2 field. */
++#define TEMP_A2_A2_Msk (0xFFFUL << TEMP_A2_A2_Pos) /*!< Bit mask of A2 field. */
++
++/* Register: TEMP_A3 */
++/* Description: Slope of fourth piecewise linear function */
++
++/* Bits 11..0 : Slope of fourth piecewise linear function */
++#define TEMP_A3_A3_Pos (0UL) /*!< Position of A3 field. */
++#define TEMP_A3_A3_Msk (0xFFFUL << TEMP_A3_A3_Pos) /*!< Bit mask of A3 field. */
++
++/* Register: TEMP_A4 */
++/* Description: Slope of fifth piecewise linear function */
++
++/* Bits 11..0 : Slope of fifth piecewise linear function */
++#define TEMP_A4_A4_Pos (0UL) /*!< Position of A4 field. */
++#define TEMP_A4_A4_Msk (0xFFFUL << TEMP_A4_A4_Pos) /*!< Bit mask of A4 field. */
++
++/* Register: TEMP_A5 */
++/* Description: Slope of sixth piecewise linear function */
++
++/* Bits 11..0 : Slope of sixth piecewise linear function */
++#define TEMP_A5_A5_Pos (0UL) /*!< Position of A5 field. */
++#define TEMP_A5_A5_Msk (0xFFFUL << TEMP_A5_A5_Pos) /*!< Bit mask of A5 field. */
++
++/* Register: TEMP_B0 */
++/* Description: y-intercept of first piecewise linear function */
++
++/* Bits 13..0 : y-intercept of first piecewise linear function */
++#define TEMP_B0_B0_Pos (0UL) /*!< Position of B0 field. */
++#define TEMP_B0_B0_Msk (0x3FFFUL << TEMP_B0_B0_Pos) /*!< Bit mask of B0 field. */
++
++/* Register: TEMP_B1 */
++/* Description: y-intercept of second piecewise linear function */
++
++/* Bits 13..0 : y-intercept of second piecewise linear function */
++#define TEMP_B1_B1_Pos (0UL) /*!< Position of B1 field. */
++#define TEMP_B1_B1_Msk (0x3FFFUL << TEMP_B1_B1_Pos) /*!< Bit mask of B1 field. */
++
++/* Register: TEMP_B2 */
++/* Description: y-intercept of third piecewise linear function */
++
++/* Bits 13..0 : y-intercept of third piecewise linear function */
++#define TEMP_B2_B2_Pos (0UL) /*!< Position of B2 field. */
++#define TEMP_B2_B2_Msk (0x3FFFUL << TEMP_B2_B2_Pos) /*!< Bit mask of B2 field. */
++
++/* Register: TEMP_B3 */
++/* Description: y-intercept of fourth piecewise linear function */
++
++/* Bits 13..0 : y-intercept of fourth piecewise linear function */
++#define TEMP_B3_B3_Pos (0UL) /*!< Position of B3 field. */
++#define TEMP_B3_B3_Msk (0x3FFFUL << TEMP_B3_B3_Pos) /*!< Bit mask of B3 field. */
++
++/* Register: TEMP_B4 */
++/* Description: y-intercept of fifth piecewise linear function */
++
++/* Bits 13..0 : y-intercept of fifth piecewise linear function */
++#define TEMP_B4_B4_Pos (0UL) /*!< Position of B4 field. */
++#define TEMP_B4_B4_Msk (0x3FFFUL << TEMP_B4_B4_Pos) /*!< Bit mask of B4 field. */
++
++/* Register: TEMP_B5 */
++/* Description: y-intercept of sixth piecewise linear function */
++
++/* Bits 13..0 : y-intercept of sixth piecewise linear function */
++#define TEMP_B5_B5_Pos (0UL) /*!< Position of B5 field. */
++#define TEMP_B5_B5_Msk (0x3FFFUL << TEMP_B5_B5_Pos) /*!< Bit mask of B5 field. */
++
++/* Register: TEMP_T0 */
++/* Description: End point of first piecewise linear function */
++
++/* Bits 7..0 : End point of first piecewise linear function */
++#define TEMP_T0_T0_Pos (0UL) /*!< Position of T0 field. */
++#define TEMP_T0_T0_Msk (0xFFUL << TEMP_T0_T0_Pos) /*!< Bit mask of T0 field. */
++
++/* Register: TEMP_T1 */
++/* Description: End point of second piecewise linear function */
++
++/* Bits 7..0 : End point of second piecewise linear function */
++#define TEMP_T1_T1_Pos (0UL) /*!< Position of T1 field. */
++#define TEMP_T1_T1_Msk (0xFFUL << TEMP_T1_T1_Pos) /*!< Bit mask of T1 field. */
++
++/* Register: TEMP_T2 */
++/* Description: End point of third piecewise linear function */
++
++/* Bits 7..0 : End point of third piecewise linear function */
++#define TEMP_T2_T2_Pos (0UL) /*!< Position of T2 field. */
++#define TEMP_T2_T2_Msk (0xFFUL << TEMP_T2_T2_Pos) /*!< Bit mask of T2 field. */
++
++/* Register: TEMP_T3 */
++/* Description: End point of fourth piecewise linear function */
++
++/* Bits 7..0 : End point of fourth piecewise linear function */
++#define TEMP_T3_T3_Pos (0UL) /*!< Position of T3 field. */
++#define TEMP_T3_T3_Msk (0xFFUL << TEMP_T3_T3_Pos) /*!< Bit mask of T3 field. */
++
++/* Register: TEMP_T4 */
++/* Description: End point of fifth piecewise linear function */
++
++/* Bits 7..0 : End point of fifth piecewise linear function */
++#define TEMP_T4_T4_Pos (0UL) /*!< Position of T4 field. */
++#define TEMP_T4_T4_Msk (0xFFUL << TEMP_T4_T4_Pos) /*!< Bit mask of T4 field. */
++
++
++/* Peripheral: TIMER */
++/* Description: Timer/Counter 0 */
++
++/* Register: TIMER_TASKS_START */
++/* Description: Start Timer */
++
++/* Bit 0 : Start Timer */
++#define TIMER_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define TIMER_TASKS_START_TASKS_START_Msk (0x1UL << TIMER_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define TIMER_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TIMER_TASKS_STOP */
++/* Description: Stop Timer */
++
++/* Bit 0 : Stop Timer */
++#define TIMER_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define TIMER_TASKS_STOP_TASKS_STOP_Msk (0x1UL << TIMER_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define TIMER_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TIMER_TASKS_COUNT */
++/* Description: Increment Timer (Counter mode only) */
++
++/* Bit 0 : Increment Timer (Counter mode only) */
++#define TIMER_TASKS_COUNT_TASKS_COUNT_Pos (0UL) /*!< Position of TASKS_COUNT field. */
++#define TIMER_TASKS_COUNT_TASKS_COUNT_Msk (0x1UL << TIMER_TASKS_COUNT_TASKS_COUNT_Pos) /*!< Bit mask of TASKS_COUNT field. */
++#define TIMER_TASKS_COUNT_TASKS_COUNT_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TIMER_TASKS_CLEAR */
++/* Description: Clear time */
++
++/* Bit 0 : Clear time */
++#define TIMER_TASKS_CLEAR_TASKS_CLEAR_Pos (0UL) /*!< Position of TASKS_CLEAR field. */
++#define TIMER_TASKS_CLEAR_TASKS_CLEAR_Msk (0x1UL << TIMER_TASKS_CLEAR_TASKS_CLEAR_Pos) /*!< Bit mask of TASKS_CLEAR field. */
++#define TIMER_TASKS_CLEAR_TASKS_CLEAR_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TIMER_TASKS_SHUTDOWN */
++/* Description: Deprecated register - Shut down timer */
++
++/* Bit 0 : Deprecated field -  Shut down timer */
++#define TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Pos (0UL) /*!< Position of TASKS_SHUTDOWN field. */
++#define TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Msk (0x1UL << TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Pos) /*!< Bit mask of TASKS_SHUTDOWN field. */
++#define TIMER_TASKS_SHUTDOWN_TASKS_SHUTDOWN_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TIMER_TASKS_CAPTURE */
++/* Description: Description collection: Capture Timer value to CC[n] register */
++
++/* Bit 0 : Capture Timer value to CC[n] register */
++#define TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Pos (0UL) /*!< Position of TASKS_CAPTURE field. */
++#define TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Msk (0x1UL << TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Pos) /*!< Bit mask of TASKS_CAPTURE field. */
++#define TIMER_TASKS_CAPTURE_TASKS_CAPTURE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TIMER_EVENTS_COMPARE */
++/* Description: Description collection: Compare event on CC[n] match */
++
++/* Bit 0 : Compare event on CC[n] match */
++#define TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Pos (0UL) /*!< Position of EVENTS_COMPARE field. */
++#define TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Msk (0x1UL << TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Pos) /*!< Bit mask of EVENTS_COMPARE field. */
++#define TIMER_EVENTS_COMPARE_EVENTS_COMPARE_NotGenerated (0UL) /*!< Event not generated */
++#define TIMER_EVENTS_COMPARE_EVENTS_COMPARE_Generated (1UL) /*!< Event generated */
++
++/* Register: TIMER_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 13 : Shortcut between event COMPARE[5] and task STOP */
++#define TIMER_SHORTS_COMPARE5_STOP_Pos (13UL) /*!< Position of COMPARE5_STOP field. */
++#define TIMER_SHORTS_COMPARE5_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE5_STOP_Pos) /*!< Bit mask of COMPARE5_STOP field. */
++#define TIMER_SHORTS_COMPARE5_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE5_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 12 : Shortcut between event COMPARE[4] and task STOP */
++#define TIMER_SHORTS_COMPARE4_STOP_Pos (12UL) /*!< Position of COMPARE4_STOP field. */
++#define TIMER_SHORTS_COMPARE4_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE4_STOP_Pos) /*!< Bit mask of COMPARE4_STOP field. */
++#define TIMER_SHORTS_COMPARE4_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE4_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 11 : Shortcut between event COMPARE[3] and task STOP */
++#define TIMER_SHORTS_COMPARE3_STOP_Pos (11UL) /*!< Position of COMPARE3_STOP field. */
++#define TIMER_SHORTS_COMPARE3_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE3_STOP_Pos) /*!< Bit mask of COMPARE3_STOP field. */
++#define TIMER_SHORTS_COMPARE3_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE3_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 10 : Shortcut between event COMPARE[2] and task STOP */
++#define TIMER_SHORTS_COMPARE2_STOP_Pos (10UL) /*!< Position of COMPARE2_STOP field. */
++#define TIMER_SHORTS_COMPARE2_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE2_STOP_Pos) /*!< Bit mask of COMPARE2_STOP field. */
++#define TIMER_SHORTS_COMPARE2_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE2_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 9 : Shortcut between event COMPARE[1] and task STOP */
++#define TIMER_SHORTS_COMPARE1_STOP_Pos (9UL) /*!< Position of COMPARE1_STOP field. */
++#define TIMER_SHORTS_COMPARE1_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE1_STOP_Pos) /*!< Bit mask of COMPARE1_STOP field. */
++#define TIMER_SHORTS_COMPARE1_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE1_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 8 : Shortcut between event COMPARE[0] and task STOP */
++#define TIMER_SHORTS_COMPARE0_STOP_Pos (8UL) /*!< Position of COMPARE0_STOP field. */
++#define TIMER_SHORTS_COMPARE0_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE0_STOP_Pos) /*!< Bit mask of COMPARE0_STOP field. */
++#define TIMER_SHORTS_COMPARE0_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE0_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 5 : Shortcut between event COMPARE[5] and task CLEAR */
++#define TIMER_SHORTS_COMPARE5_CLEAR_Pos (5UL) /*!< Position of COMPARE5_CLEAR field. */
++#define TIMER_SHORTS_COMPARE5_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE5_CLEAR_Pos) /*!< Bit mask of COMPARE5_CLEAR field. */
++#define TIMER_SHORTS_COMPARE5_CLEAR_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE5_CLEAR_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 4 : Shortcut between event COMPARE[4] and task CLEAR */
++#define TIMER_SHORTS_COMPARE4_CLEAR_Pos (4UL) /*!< Position of COMPARE4_CLEAR field. */
++#define TIMER_SHORTS_COMPARE4_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE4_CLEAR_Pos) /*!< Bit mask of COMPARE4_CLEAR field. */
++#define TIMER_SHORTS_COMPARE4_CLEAR_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE4_CLEAR_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 3 : Shortcut between event COMPARE[3] and task CLEAR */
++#define TIMER_SHORTS_COMPARE3_CLEAR_Pos (3UL) /*!< Position of COMPARE3_CLEAR field. */
++#define TIMER_SHORTS_COMPARE3_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE3_CLEAR_Pos) /*!< Bit mask of COMPARE3_CLEAR field. */
++#define TIMER_SHORTS_COMPARE3_CLEAR_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE3_CLEAR_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 2 : Shortcut between event COMPARE[2] and task CLEAR */
++#define TIMER_SHORTS_COMPARE2_CLEAR_Pos (2UL) /*!< Position of COMPARE2_CLEAR field. */
++#define TIMER_SHORTS_COMPARE2_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE2_CLEAR_Pos) /*!< Bit mask of COMPARE2_CLEAR field. */
++#define TIMER_SHORTS_COMPARE2_CLEAR_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE2_CLEAR_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 1 : Shortcut between event COMPARE[1] and task CLEAR */
++#define TIMER_SHORTS_COMPARE1_CLEAR_Pos (1UL) /*!< Position of COMPARE1_CLEAR field. */
++#define TIMER_SHORTS_COMPARE1_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE1_CLEAR_Pos) /*!< Bit mask of COMPARE1_CLEAR field. */
++#define TIMER_SHORTS_COMPARE1_CLEAR_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE1_CLEAR_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event COMPARE[0] and task CLEAR */
++#define TIMER_SHORTS_COMPARE0_CLEAR_Pos (0UL) /*!< Position of COMPARE0_CLEAR field. */
++#define TIMER_SHORTS_COMPARE0_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE0_CLEAR_Pos) /*!< Bit mask of COMPARE0_CLEAR field. */
++#define TIMER_SHORTS_COMPARE0_CLEAR_Disabled (0UL) /*!< Disable shortcut */
++#define TIMER_SHORTS_COMPARE0_CLEAR_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: TIMER_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 21 : Write '1' to enable interrupt for event COMPARE[5] */
++#define TIMER_INTENSET_COMPARE5_Pos (21UL) /*!< Position of COMPARE5 field. */
++#define TIMER_INTENSET_COMPARE5_Msk (0x1UL << TIMER_INTENSET_COMPARE5_Pos) /*!< Bit mask of COMPARE5 field. */
++#define TIMER_INTENSET_COMPARE5_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENSET_COMPARE5_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENSET_COMPARE5_Set (1UL) /*!< Enable */
++
++/* Bit 20 : Write '1' to enable interrupt for event COMPARE[4] */
++#define TIMER_INTENSET_COMPARE4_Pos (20UL) /*!< Position of COMPARE4 field. */
++#define TIMER_INTENSET_COMPARE4_Msk (0x1UL << TIMER_INTENSET_COMPARE4_Pos) /*!< Bit mask of COMPARE4 field. */
++#define TIMER_INTENSET_COMPARE4_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENSET_COMPARE4_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENSET_COMPARE4_Set (1UL) /*!< Enable */
++
++/* Bit 19 : Write '1' to enable interrupt for event COMPARE[3] */
++#define TIMER_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
++#define TIMER_INTENSET_COMPARE3_Msk (0x1UL << TIMER_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
++#define TIMER_INTENSET_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENSET_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENSET_COMPARE3_Set (1UL) /*!< Enable */
++
++/* Bit 18 : Write '1' to enable interrupt for event COMPARE[2] */
++#define TIMER_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
++#define TIMER_INTENSET_COMPARE2_Msk (0x1UL << TIMER_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
++#define TIMER_INTENSET_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENSET_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENSET_COMPARE2_Set (1UL) /*!< Enable */
++
++/* Bit 17 : Write '1' to enable interrupt for event COMPARE[1] */
++#define TIMER_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
++#define TIMER_INTENSET_COMPARE1_Msk (0x1UL << TIMER_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
++#define TIMER_INTENSET_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENSET_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENSET_COMPARE1_Set (1UL) /*!< Enable */
++
++/* Bit 16 : Write '1' to enable interrupt for event COMPARE[0] */
++#define TIMER_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
++#define TIMER_INTENSET_COMPARE0_Msk (0x1UL << TIMER_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
++#define TIMER_INTENSET_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENSET_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENSET_COMPARE0_Set (1UL) /*!< Enable */
++
++/* Register: TIMER_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 21 : Write '1' to disable interrupt for event COMPARE[5] */
++#define TIMER_INTENCLR_COMPARE5_Pos (21UL) /*!< Position of COMPARE5 field. */
++#define TIMER_INTENCLR_COMPARE5_Msk (0x1UL << TIMER_INTENCLR_COMPARE5_Pos) /*!< Bit mask of COMPARE5 field. */
++#define TIMER_INTENCLR_COMPARE5_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENCLR_COMPARE5_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENCLR_COMPARE5_Clear (1UL) /*!< Disable */
++
++/* Bit 20 : Write '1' to disable interrupt for event COMPARE[4] */
++#define TIMER_INTENCLR_COMPARE4_Pos (20UL) /*!< Position of COMPARE4 field. */
++#define TIMER_INTENCLR_COMPARE4_Msk (0x1UL << TIMER_INTENCLR_COMPARE4_Pos) /*!< Bit mask of COMPARE4 field. */
++#define TIMER_INTENCLR_COMPARE4_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENCLR_COMPARE4_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENCLR_COMPARE4_Clear (1UL) /*!< Disable */
++
++/* Bit 19 : Write '1' to disable interrupt for event COMPARE[3] */
++#define TIMER_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
++#define TIMER_INTENCLR_COMPARE3_Msk (0x1UL << TIMER_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
++#define TIMER_INTENCLR_COMPARE3_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENCLR_COMPARE3_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable */
++
++/* Bit 18 : Write '1' to disable interrupt for event COMPARE[2] */
++#define TIMER_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
++#define TIMER_INTENCLR_COMPARE2_Msk (0x1UL << TIMER_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
++#define TIMER_INTENCLR_COMPARE2_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENCLR_COMPARE2_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable */
++
++/* Bit 17 : Write '1' to disable interrupt for event COMPARE[1] */
++#define TIMER_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
++#define TIMER_INTENCLR_COMPARE1_Msk (0x1UL << TIMER_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
++#define TIMER_INTENCLR_COMPARE1_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENCLR_COMPARE1_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable */
++
++/* Bit 16 : Write '1' to disable interrupt for event COMPARE[0] */
++#define TIMER_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
++#define TIMER_INTENCLR_COMPARE0_Msk (0x1UL << TIMER_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
++#define TIMER_INTENCLR_COMPARE0_Disabled (0UL) /*!< Read: Disabled */
++#define TIMER_INTENCLR_COMPARE0_Enabled (1UL) /*!< Read: Enabled */
++#define TIMER_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable */
++
++/* Register: TIMER_MODE */
++/* Description: Timer mode selection */
++
++/* Bits 1..0 : Timer mode */
++#define TIMER_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
++#define TIMER_MODE_MODE_Msk (0x3UL << TIMER_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
++#define TIMER_MODE_MODE_Timer (0UL) /*!< Select Timer mode */
++#define TIMER_MODE_MODE_Counter (1UL) /*!< Deprecated enumerator -  Select Counter mode */
++#define TIMER_MODE_MODE_LowPowerCounter (2UL) /*!< Select Low Power Counter mode */
++
++/* Register: TIMER_BITMODE */
++/* Description: Configure the number of bits used by the TIMER */
++
++/* Bits 1..0 : Timer bit width */
++#define TIMER_BITMODE_BITMODE_Pos (0UL) /*!< Position of BITMODE field. */
++#define TIMER_BITMODE_BITMODE_Msk (0x3UL << TIMER_BITMODE_BITMODE_Pos) /*!< Bit mask of BITMODE field. */
++#define TIMER_BITMODE_BITMODE_16Bit (0UL) /*!< 16 bit timer bit width */
++#define TIMER_BITMODE_BITMODE_08Bit (1UL) /*!< 8 bit timer bit width */
++#define TIMER_BITMODE_BITMODE_24Bit (2UL) /*!< 24 bit timer bit width */
++#define TIMER_BITMODE_BITMODE_32Bit (3UL) /*!< 32 bit timer bit width */
++
++/* Register: TIMER_PRESCALER */
++/* Description: Timer prescaler register */
++
++/* Bits 3..0 : Prescaler value */
++#define TIMER_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
++#define TIMER_PRESCALER_PRESCALER_Msk (0xFUL << TIMER_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
++
++/* Register: TIMER_CC */
++/* Description: Description collection: Capture/Compare register n */
++
++/* Bits 31..0 : Capture/Compare value */
++#define TIMER_CC_CC_Pos (0UL) /*!< Position of CC field. */
++#define TIMER_CC_CC_Msk (0xFFFFFFFFUL << TIMER_CC_CC_Pos) /*!< Bit mask of CC field. */
++
++
++/* Peripheral: TWI */
++/* Description: I2C compatible Two-Wire Interface 0 */
++
++/* Register: TWI_TASKS_STARTRX */
++/* Description: Start TWI receive sequence */
++
++/* Bit 0 : Start TWI receive sequence */
++#define TWI_TASKS_STARTRX_TASKS_STARTRX_Pos (0UL) /*!< Position of TASKS_STARTRX field. */
++#define TWI_TASKS_STARTRX_TASKS_STARTRX_Msk (0x1UL << TWI_TASKS_STARTRX_TASKS_STARTRX_Pos) /*!< Bit mask of TASKS_STARTRX field. */
++#define TWI_TASKS_STARTRX_TASKS_STARTRX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWI_TASKS_STARTTX */
++/* Description: Start TWI transmit sequence */
++
++/* Bit 0 : Start TWI transmit sequence */
++#define TWI_TASKS_STARTTX_TASKS_STARTTX_Pos (0UL) /*!< Position of TASKS_STARTTX field. */
++#define TWI_TASKS_STARTTX_TASKS_STARTTX_Msk (0x1UL << TWI_TASKS_STARTTX_TASKS_STARTTX_Pos) /*!< Bit mask of TASKS_STARTTX field. */
++#define TWI_TASKS_STARTTX_TASKS_STARTTX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWI_TASKS_STOP */
++/* Description: Stop TWI transaction */
++
++/* Bit 0 : Stop TWI transaction */
++#define TWI_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define TWI_TASKS_STOP_TASKS_STOP_Msk (0x1UL << TWI_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define TWI_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWI_TASKS_SUSPEND */
++/* Description: Suspend TWI transaction */
++
++/* Bit 0 : Suspend TWI transaction */
++#define TWI_TASKS_SUSPEND_TASKS_SUSPEND_Pos (0UL) /*!< Position of TASKS_SUSPEND field. */
++#define TWI_TASKS_SUSPEND_TASKS_SUSPEND_Msk (0x1UL << TWI_TASKS_SUSPEND_TASKS_SUSPEND_Pos) /*!< Bit mask of TASKS_SUSPEND field. */
++#define TWI_TASKS_SUSPEND_TASKS_SUSPEND_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWI_TASKS_RESUME */
++/* Description: Resume TWI transaction */
++
++/* Bit 0 : Resume TWI transaction */
++#define TWI_TASKS_RESUME_TASKS_RESUME_Pos (0UL) /*!< Position of TASKS_RESUME field. */
++#define TWI_TASKS_RESUME_TASKS_RESUME_Msk (0x1UL << TWI_TASKS_RESUME_TASKS_RESUME_Pos) /*!< Bit mask of TASKS_RESUME field. */
++#define TWI_TASKS_RESUME_TASKS_RESUME_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWI_EVENTS_STOPPED */
++/* Description: TWI stopped */
++
++/* Bit 0 : TWI stopped */
++#define TWI_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define TWI_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << TWI_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define TWI_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define TWI_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWI_EVENTS_RXDREADY */
++/* Description: TWI RXD byte received */
++
++/* Bit 0 : TWI RXD byte received */
++#define TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_Pos (0UL) /*!< Position of EVENTS_RXDREADY field. */
++#define TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_Msk (0x1UL << TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_Pos) /*!< Bit mask of EVENTS_RXDREADY field. */
++#define TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_NotGenerated (0UL) /*!< Event not generated */
++#define TWI_EVENTS_RXDREADY_EVENTS_RXDREADY_Generated (1UL) /*!< Event generated */
++
++/* Register: TWI_EVENTS_TXDSENT */
++/* Description: TWI TXD byte sent */
++
++/* Bit 0 : TWI TXD byte sent */
++#define TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_Pos (0UL) /*!< Position of EVENTS_TXDSENT field. */
++#define TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_Msk (0x1UL << TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_Pos) /*!< Bit mask of EVENTS_TXDSENT field. */
++#define TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_NotGenerated (0UL) /*!< Event not generated */
++#define TWI_EVENTS_TXDSENT_EVENTS_TXDSENT_Generated (1UL) /*!< Event generated */
++
++/* Register: TWI_EVENTS_ERROR */
++/* Description: TWI error */
++
++/* Bit 0 : TWI error */
++#define TWI_EVENTS_ERROR_EVENTS_ERROR_Pos (0UL) /*!< Position of EVENTS_ERROR field. */
++#define TWI_EVENTS_ERROR_EVENTS_ERROR_Msk (0x1UL << TWI_EVENTS_ERROR_EVENTS_ERROR_Pos) /*!< Bit mask of EVENTS_ERROR field. */
++#define TWI_EVENTS_ERROR_EVENTS_ERROR_NotGenerated (0UL) /*!< Event not generated */
++#define TWI_EVENTS_ERROR_EVENTS_ERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: TWI_EVENTS_BB */
++/* Description: TWI byte boundary, generated before each byte that is sent or received */
++
++/* Bit 0 : TWI byte boundary, generated before each byte that is sent or received */
++#define TWI_EVENTS_BB_EVENTS_BB_Pos (0UL) /*!< Position of EVENTS_BB field. */
++#define TWI_EVENTS_BB_EVENTS_BB_Msk (0x1UL << TWI_EVENTS_BB_EVENTS_BB_Pos) /*!< Bit mask of EVENTS_BB field. */
++#define TWI_EVENTS_BB_EVENTS_BB_NotGenerated (0UL) /*!< Event not generated */
++#define TWI_EVENTS_BB_EVENTS_BB_Generated (1UL) /*!< Event generated */
++
++/* Register: TWI_EVENTS_SUSPENDED */
++/* Description: TWI entered the suspended state */
++
++/* Bit 0 : TWI entered the suspended state */
++#define TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Pos (0UL) /*!< Position of EVENTS_SUSPENDED field. */
++#define TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Msk (0x1UL << TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Pos) /*!< Bit mask of EVENTS_SUSPENDED field. */
++#define TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_NotGenerated (0UL) /*!< Event not generated */
++#define TWI_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWI_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 1 : Shortcut between event BB and task STOP */
++#define TWI_SHORTS_BB_STOP_Pos (1UL) /*!< Position of BB_STOP field. */
++#define TWI_SHORTS_BB_STOP_Msk (0x1UL << TWI_SHORTS_BB_STOP_Pos) /*!< Bit mask of BB_STOP field. */
++#define TWI_SHORTS_BB_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TWI_SHORTS_BB_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event BB and task SUSPEND */
++#define TWI_SHORTS_BB_SUSPEND_Pos (0UL) /*!< Position of BB_SUSPEND field. */
++#define TWI_SHORTS_BB_SUSPEND_Msk (0x1UL << TWI_SHORTS_BB_SUSPEND_Pos) /*!< Bit mask of BB_SUSPEND field. */
++#define TWI_SHORTS_BB_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
++#define TWI_SHORTS_BB_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: TWI_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 18 : Write '1' to enable interrupt for event SUSPENDED */
++#define TWI_INTENSET_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
++#define TWI_INTENSET_SUSPENDED_Msk (0x1UL << TWI_INTENSET_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
++#define TWI_INTENSET_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENSET_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENSET_SUSPENDED_Set (1UL) /*!< Enable */
++
++/* Bit 14 : Write '1' to enable interrupt for event BB */
++#define TWI_INTENSET_BB_Pos (14UL) /*!< Position of BB field. */
++#define TWI_INTENSET_BB_Msk (0x1UL << TWI_INTENSET_BB_Pos) /*!< Bit mask of BB field. */
++#define TWI_INTENSET_BB_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENSET_BB_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENSET_BB_Set (1UL) /*!< Enable */
++
++/* Bit 9 : Write '1' to enable interrupt for event ERROR */
++#define TWI_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define TWI_INTENSET_ERROR_Msk (0x1UL << TWI_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define TWI_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENSET_ERROR_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event TXDSENT */
++#define TWI_INTENSET_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
++#define TWI_INTENSET_TXDSENT_Msk (0x1UL << TWI_INTENSET_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
++#define TWI_INTENSET_TXDSENT_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENSET_TXDSENT_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENSET_TXDSENT_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event RXDREADY */
++#define TWI_INTENSET_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
++#define TWI_INTENSET_RXDREADY_Msk (0x1UL << TWI_INTENSET_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
++#define TWI_INTENSET_RXDREADY_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENSET_RXDREADY_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENSET_RXDREADY_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event STOPPED */
++#define TWI_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define TWI_INTENSET_STOPPED_Msk (0x1UL << TWI_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define TWI_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Register: TWI_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 18 : Write '1' to disable interrupt for event SUSPENDED */
++#define TWI_INTENCLR_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
++#define TWI_INTENCLR_SUSPENDED_Msk (0x1UL << TWI_INTENCLR_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
++#define TWI_INTENCLR_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENCLR_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENCLR_SUSPENDED_Clear (1UL) /*!< Disable */
++
++/* Bit 14 : Write '1' to disable interrupt for event BB */
++#define TWI_INTENCLR_BB_Pos (14UL) /*!< Position of BB field. */
++#define TWI_INTENCLR_BB_Msk (0x1UL << TWI_INTENCLR_BB_Pos) /*!< Bit mask of BB field. */
++#define TWI_INTENCLR_BB_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENCLR_BB_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENCLR_BB_Clear (1UL) /*!< Disable */
++
++/* Bit 9 : Write '1' to disable interrupt for event ERROR */
++#define TWI_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define TWI_INTENCLR_ERROR_Msk (0x1UL << TWI_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define TWI_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event TXDSENT */
++#define TWI_INTENCLR_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
++#define TWI_INTENCLR_TXDSENT_Msk (0x1UL << TWI_INTENCLR_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
++#define TWI_INTENCLR_TXDSENT_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENCLR_TXDSENT_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENCLR_TXDSENT_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event RXDREADY */
++#define TWI_INTENCLR_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
++#define TWI_INTENCLR_RXDREADY_Msk (0x1UL << TWI_INTENCLR_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
++#define TWI_INTENCLR_RXDREADY_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENCLR_RXDREADY_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENCLR_RXDREADY_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event STOPPED */
++#define TWI_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define TWI_INTENCLR_STOPPED_Msk (0x1UL << TWI_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define TWI_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define TWI_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define TWI_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Register: TWI_ERRORSRC */
++/* Description: Error source */
++
++/* Bit 2 : NACK received after sending a data byte (write '1' to clear) */
++#define TWI_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
++#define TWI_ERRORSRC_DNACK_Msk (0x1UL << TWI_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
++#define TWI_ERRORSRC_DNACK_NotPresent (0UL) /*!< Read: error not present */
++#define TWI_ERRORSRC_DNACK_Present (1UL) /*!< Read: error present */
++
++/* Bit 1 : NACK received after sending the address (write '1' to clear) */
++#define TWI_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
++#define TWI_ERRORSRC_ANACK_Msk (0x1UL << TWI_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
++#define TWI_ERRORSRC_ANACK_NotPresent (0UL) /*!< Read: error not present */
++#define TWI_ERRORSRC_ANACK_Present (1UL) /*!< Read: error present */
++
++/* Bit 0 : Overrun error */
++#define TWI_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
++#define TWI_ERRORSRC_OVERRUN_Msk (0x1UL << TWI_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
++#define TWI_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: no overrun occured */
++#define TWI_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: overrun occured */
++
++/* Register: TWI_ENABLE */
++/* Description: Enable TWI */
++
++/* Bits 3..0 : Enable or disable TWI */
++#define TWI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define TWI_ENABLE_ENABLE_Msk (0xFUL << TWI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define TWI_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWI */
++#define TWI_ENABLE_ENABLE_Enabled (5UL) /*!< Enable TWI */
++
++/* Register: TWI_PSEL_SCL */
++/* Description: Pin select for SCL */
++
++/* Bit 31 : Connection */
++#define TWI_PSEL_SCL_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define TWI_PSEL_SCL_CONNECT_Msk (0x1UL << TWI_PSEL_SCL_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define TWI_PSEL_SCL_CONNECT_Connected (0UL) /*!< Connect */
++#define TWI_PSEL_SCL_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define TWI_PSEL_SCL_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define TWI_PSEL_SCL_PORT_Msk (0x1UL << TWI_PSEL_SCL_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define TWI_PSEL_SCL_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define TWI_PSEL_SCL_PIN_Msk (0x1FUL << TWI_PSEL_SCL_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: TWI_PSEL_SDA */
++/* Description: Pin select for SDA */
++
++/* Bit 31 : Connection */
++#define TWI_PSEL_SDA_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define TWI_PSEL_SDA_CONNECT_Msk (0x1UL << TWI_PSEL_SDA_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define TWI_PSEL_SDA_CONNECT_Connected (0UL) /*!< Connect */
++#define TWI_PSEL_SDA_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define TWI_PSEL_SDA_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define TWI_PSEL_SDA_PORT_Msk (0x1UL << TWI_PSEL_SDA_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define TWI_PSEL_SDA_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define TWI_PSEL_SDA_PIN_Msk (0x1FUL << TWI_PSEL_SDA_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: TWI_RXD */
++/* Description: RXD register */
++
++/* Bits 7..0 : RXD register */
++#define TWI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
++#define TWI_RXD_RXD_Msk (0xFFUL << TWI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
++
++/* Register: TWI_TXD */
++/* Description: TXD register */
++
++/* Bits 7..0 : TXD register */
++#define TWI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
++#define TWI_TXD_TXD_Msk (0xFFUL << TWI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
++
++/* Register: TWI_FREQUENCY */
++/* Description: TWI frequency. Accuracy depends on the HFCLK source selected. */
++
++/* Bits 31..0 : TWI master clock frequency */
++#define TWI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
++#define TWI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
++#define TWI_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps */
++#define TWI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
++#define TWI_FREQUENCY_FREQUENCY_K400 (0x06680000UL) /*!< 400 kbps (actual rate 410.256 kbps) */
++
++/* Register: TWI_ADDRESS */
++/* Description: Address used in the TWI transfer */
++
++/* Bits 6..0 : Address used in the TWI transfer */
++#define TWI_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
++#define TWI_ADDRESS_ADDRESS_Msk (0x7FUL << TWI_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
++
++
++/* Peripheral: TWIM */
++/* Description: I2C compatible Two-Wire Master Interface with EasyDMA 0 */
++
++/* Register: TWIM_TASKS_STARTRX */
++/* Description: Start TWI receive sequence */
++
++/* Bit 0 : Start TWI receive sequence */
++#define TWIM_TASKS_STARTRX_TASKS_STARTRX_Pos (0UL) /*!< Position of TASKS_STARTRX field. */
++#define TWIM_TASKS_STARTRX_TASKS_STARTRX_Msk (0x1UL << TWIM_TASKS_STARTRX_TASKS_STARTRX_Pos) /*!< Bit mask of TASKS_STARTRX field. */
++#define TWIM_TASKS_STARTRX_TASKS_STARTRX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIM_TASKS_STARTTX */
++/* Description: Start TWI transmit sequence */
++
++/* Bit 0 : Start TWI transmit sequence */
++#define TWIM_TASKS_STARTTX_TASKS_STARTTX_Pos (0UL) /*!< Position of TASKS_STARTTX field. */
++#define TWIM_TASKS_STARTTX_TASKS_STARTTX_Msk (0x1UL << TWIM_TASKS_STARTTX_TASKS_STARTTX_Pos) /*!< Bit mask of TASKS_STARTTX field. */
++#define TWIM_TASKS_STARTTX_TASKS_STARTTX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIM_TASKS_STOP */
++/* Description: Stop TWI transaction. Must be issued while the TWI master is not suspended. */
++
++/* Bit 0 : Stop TWI transaction. Must be issued while the TWI master is not suspended. */
++#define TWIM_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define TWIM_TASKS_STOP_TASKS_STOP_Msk (0x1UL << TWIM_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define TWIM_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIM_TASKS_SUSPEND */
++/* Description: Suspend TWI transaction */
++
++/* Bit 0 : Suspend TWI transaction */
++#define TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Pos (0UL) /*!< Position of TASKS_SUSPEND field. */
++#define TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Msk (0x1UL << TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Pos) /*!< Bit mask of TASKS_SUSPEND field. */
++#define TWIM_TASKS_SUSPEND_TASKS_SUSPEND_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIM_TASKS_RESUME */
++/* Description: Resume TWI transaction */
++
++/* Bit 0 : Resume TWI transaction */
++#define TWIM_TASKS_RESUME_TASKS_RESUME_Pos (0UL) /*!< Position of TASKS_RESUME field. */
++#define TWIM_TASKS_RESUME_TASKS_RESUME_Msk (0x1UL << TWIM_TASKS_RESUME_TASKS_RESUME_Pos) /*!< Bit mask of TASKS_RESUME field. */
++#define TWIM_TASKS_RESUME_TASKS_RESUME_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIM_EVENTS_STOPPED */
++/* Description: TWI stopped */
++
++/* Bit 0 : TWI stopped */
++#define TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define TWIM_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define TWIM_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIM_EVENTS_ERROR */
++/* Description: TWI error */
++
++/* Bit 0 : TWI error */
++#define TWIM_EVENTS_ERROR_EVENTS_ERROR_Pos (0UL) /*!< Position of EVENTS_ERROR field. */
++#define TWIM_EVENTS_ERROR_EVENTS_ERROR_Msk (0x1UL << TWIM_EVENTS_ERROR_EVENTS_ERROR_Pos) /*!< Bit mask of EVENTS_ERROR field. */
++#define TWIM_EVENTS_ERROR_EVENTS_ERROR_NotGenerated (0UL) /*!< Event not generated */
++#define TWIM_EVENTS_ERROR_EVENTS_ERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIM_EVENTS_SUSPENDED */
++/* Description: SUSPEND task has been issued, TWI traffic is now suspended. */
++
++/* Bit 0 : SUSPEND task has been issued, TWI traffic is now suspended. */
++#define TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Pos (0UL) /*!< Position of EVENTS_SUSPENDED field. */
++#define TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Msk (0x1UL << TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Pos) /*!< Bit mask of EVENTS_SUSPENDED field. */
++#define TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_NotGenerated (0UL) /*!< Event not generated */
++#define TWIM_EVENTS_SUSPENDED_EVENTS_SUSPENDED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIM_EVENTS_RXSTARTED */
++/* Description: Receive sequence started */
++
++/* Bit 0 : Receive sequence started */
++#define TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos (0UL) /*!< Position of EVENTS_RXSTARTED field. */
++#define TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk (0x1UL << TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos) /*!< Bit mask of EVENTS_RXSTARTED field. */
++#define TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define TWIM_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIM_EVENTS_TXSTARTED */
++/* Description: Transmit sequence started */
++
++/* Bit 0 : Transmit sequence started */
++#define TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos (0UL) /*!< Position of EVENTS_TXSTARTED field. */
++#define TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk (0x1UL << TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos) /*!< Bit mask of EVENTS_TXSTARTED field. */
++#define TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define TWIM_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIM_EVENTS_LASTRX */
++/* Description: Byte boundary, starting to receive the last byte */
++
++/* Bit 0 : Byte boundary, starting to receive the last byte */
++#define TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Pos (0UL) /*!< Position of EVENTS_LASTRX field. */
++#define TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Msk (0x1UL << TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Pos) /*!< Bit mask of EVENTS_LASTRX field. */
++#define TWIM_EVENTS_LASTRX_EVENTS_LASTRX_NotGenerated (0UL) /*!< Event not generated */
++#define TWIM_EVENTS_LASTRX_EVENTS_LASTRX_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIM_EVENTS_LASTTX */
++/* Description: Byte boundary, starting to transmit the last byte */
++
++/* Bit 0 : Byte boundary, starting to transmit the last byte */
++#define TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Pos (0UL) /*!< Position of EVENTS_LASTTX field. */
++#define TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Msk (0x1UL << TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Pos) /*!< Bit mask of EVENTS_LASTTX field. */
++#define TWIM_EVENTS_LASTTX_EVENTS_LASTTX_NotGenerated (0UL) /*!< Event not generated */
++#define TWIM_EVENTS_LASTTX_EVENTS_LASTTX_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIM_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 12 : Shortcut between event LASTRX and task STOP */
++#define TWIM_SHORTS_LASTRX_STOP_Pos (12UL) /*!< Position of LASTRX_STOP field. */
++#define TWIM_SHORTS_LASTRX_STOP_Msk (0x1UL << TWIM_SHORTS_LASTRX_STOP_Pos) /*!< Bit mask of LASTRX_STOP field. */
++#define TWIM_SHORTS_LASTRX_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TWIM_SHORTS_LASTRX_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 11 : Shortcut between event LASTRX and task SUSPEND */
++#define TWIM_SHORTS_LASTRX_SUSPEND_Pos (11UL) /*!< Position of LASTRX_SUSPEND field. */
++#define TWIM_SHORTS_LASTRX_SUSPEND_Msk (0x1UL << TWIM_SHORTS_LASTRX_SUSPEND_Pos) /*!< Bit mask of LASTRX_SUSPEND field. */
++#define TWIM_SHORTS_LASTRX_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
++#define TWIM_SHORTS_LASTRX_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 10 : Shortcut between event LASTRX and task STARTTX */
++#define TWIM_SHORTS_LASTRX_STARTTX_Pos (10UL) /*!< Position of LASTRX_STARTTX field. */
++#define TWIM_SHORTS_LASTRX_STARTTX_Msk (0x1UL << TWIM_SHORTS_LASTRX_STARTTX_Pos) /*!< Bit mask of LASTRX_STARTTX field. */
++#define TWIM_SHORTS_LASTRX_STARTTX_Disabled (0UL) /*!< Disable shortcut */
++#define TWIM_SHORTS_LASTRX_STARTTX_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 9 : Shortcut between event LASTTX and task STOP */
++#define TWIM_SHORTS_LASTTX_STOP_Pos (9UL) /*!< Position of LASTTX_STOP field. */
++#define TWIM_SHORTS_LASTTX_STOP_Msk (0x1UL << TWIM_SHORTS_LASTTX_STOP_Pos) /*!< Bit mask of LASTTX_STOP field. */
++#define TWIM_SHORTS_LASTTX_STOP_Disabled (0UL) /*!< Disable shortcut */
++#define TWIM_SHORTS_LASTTX_STOP_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 8 : Shortcut between event LASTTX and task SUSPEND */
++#define TWIM_SHORTS_LASTTX_SUSPEND_Pos (8UL) /*!< Position of LASTTX_SUSPEND field. */
++#define TWIM_SHORTS_LASTTX_SUSPEND_Msk (0x1UL << TWIM_SHORTS_LASTTX_SUSPEND_Pos) /*!< Bit mask of LASTTX_SUSPEND field. */
++#define TWIM_SHORTS_LASTTX_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
++#define TWIM_SHORTS_LASTTX_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 7 : Shortcut between event LASTTX and task STARTRX */
++#define TWIM_SHORTS_LASTTX_STARTRX_Pos (7UL) /*!< Position of LASTTX_STARTRX field. */
++#define TWIM_SHORTS_LASTTX_STARTRX_Msk (0x1UL << TWIM_SHORTS_LASTTX_STARTRX_Pos) /*!< Bit mask of LASTTX_STARTRX field. */
++#define TWIM_SHORTS_LASTTX_STARTRX_Disabled (0UL) /*!< Disable shortcut */
++#define TWIM_SHORTS_LASTTX_STARTRX_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: TWIM_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 24 : Enable or disable interrupt for event LASTTX */
++#define TWIM_INTEN_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
++#define TWIM_INTEN_LASTTX_Msk (0x1UL << TWIM_INTEN_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
++#define TWIM_INTEN_LASTTX_Disabled (0UL) /*!< Disable */
++#define TWIM_INTEN_LASTTX_Enabled (1UL) /*!< Enable */
++
++/* Bit 23 : Enable or disable interrupt for event LASTRX */
++#define TWIM_INTEN_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
++#define TWIM_INTEN_LASTRX_Msk (0x1UL << TWIM_INTEN_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
++#define TWIM_INTEN_LASTRX_Disabled (0UL) /*!< Disable */
++#define TWIM_INTEN_LASTRX_Enabled (1UL) /*!< Enable */
++
++/* Bit 20 : Enable or disable interrupt for event TXSTARTED */
++#define TWIM_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define TWIM_INTEN_TXSTARTED_Msk (0x1UL << TWIM_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define TWIM_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
++#define TWIM_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 19 : Enable or disable interrupt for event RXSTARTED */
++#define TWIM_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define TWIM_INTEN_RXSTARTED_Msk (0x1UL << TWIM_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define TWIM_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
++#define TWIM_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 18 : Enable or disable interrupt for event SUSPENDED */
++#define TWIM_INTEN_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
++#define TWIM_INTEN_SUSPENDED_Msk (0x1UL << TWIM_INTEN_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
++#define TWIM_INTEN_SUSPENDED_Disabled (0UL) /*!< Disable */
++#define TWIM_INTEN_SUSPENDED_Enabled (1UL) /*!< Enable */
++
++/* Bit 9 : Enable or disable interrupt for event ERROR */
++#define TWIM_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define TWIM_INTEN_ERROR_Msk (0x1UL << TWIM_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define TWIM_INTEN_ERROR_Disabled (0UL) /*!< Disable */
++#define TWIM_INTEN_ERROR_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event STOPPED */
++#define TWIM_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define TWIM_INTEN_STOPPED_Msk (0x1UL << TWIM_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define TWIM_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
++#define TWIM_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
++
++/* Register: TWIM_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 24 : Write '1' to enable interrupt for event LASTTX */
++#define TWIM_INTENSET_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
++#define TWIM_INTENSET_LASTTX_Msk (0x1UL << TWIM_INTENSET_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
++#define TWIM_INTENSET_LASTTX_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENSET_LASTTX_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENSET_LASTTX_Set (1UL) /*!< Enable */
++
++/* Bit 23 : Write '1' to enable interrupt for event LASTRX */
++#define TWIM_INTENSET_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
++#define TWIM_INTENSET_LASTRX_Msk (0x1UL << TWIM_INTENSET_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
++#define TWIM_INTENSET_LASTRX_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENSET_LASTRX_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENSET_LASTRX_Set (1UL) /*!< Enable */
++
++/* Bit 20 : Write '1' to enable interrupt for event TXSTARTED */
++#define TWIM_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define TWIM_INTENSET_TXSTARTED_Msk (0x1UL << TWIM_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define TWIM_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 19 : Write '1' to enable interrupt for event RXSTARTED */
++#define TWIM_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define TWIM_INTENSET_RXSTARTED_Msk (0x1UL << TWIM_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define TWIM_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 18 : Write '1' to enable interrupt for event SUSPENDED */
++#define TWIM_INTENSET_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
++#define TWIM_INTENSET_SUSPENDED_Msk (0x1UL << TWIM_INTENSET_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
++#define TWIM_INTENSET_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENSET_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENSET_SUSPENDED_Set (1UL) /*!< Enable */
++
++/* Bit 9 : Write '1' to enable interrupt for event ERROR */
++#define TWIM_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define TWIM_INTENSET_ERROR_Msk (0x1UL << TWIM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define TWIM_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENSET_ERROR_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event STOPPED */
++#define TWIM_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define TWIM_INTENSET_STOPPED_Msk (0x1UL << TWIM_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define TWIM_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Register: TWIM_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 24 : Write '1' to disable interrupt for event LASTTX */
++#define TWIM_INTENCLR_LASTTX_Pos (24UL) /*!< Position of LASTTX field. */
++#define TWIM_INTENCLR_LASTTX_Msk (0x1UL << TWIM_INTENCLR_LASTTX_Pos) /*!< Bit mask of LASTTX field. */
++#define TWIM_INTENCLR_LASTTX_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENCLR_LASTTX_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENCLR_LASTTX_Clear (1UL) /*!< Disable */
++
++/* Bit 23 : Write '1' to disable interrupt for event LASTRX */
++#define TWIM_INTENCLR_LASTRX_Pos (23UL) /*!< Position of LASTRX field. */
++#define TWIM_INTENCLR_LASTRX_Msk (0x1UL << TWIM_INTENCLR_LASTRX_Pos) /*!< Bit mask of LASTRX field. */
++#define TWIM_INTENCLR_LASTRX_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENCLR_LASTRX_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENCLR_LASTRX_Clear (1UL) /*!< Disable */
++
++/* Bit 20 : Write '1' to disable interrupt for event TXSTARTED */
++#define TWIM_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define TWIM_INTENCLR_TXSTARTED_Msk (0x1UL << TWIM_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define TWIM_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 19 : Write '1' to disable interrupt for event RXSTARTED */
++#define TWIM_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define TWIM_INTENCLR_RXSTARTED_Msk (0x1UL << TWIM_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define TWIM_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 18 : Write '1' to disable interrupt for event SUSPENDED */
++#define TWIM_INTENCLR_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
++#define TWIM_INTENCLR_SUSPENDED_Msk (0x1UL << TWIM_INTENCLR_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
++#define TWIM_INTENCLR_SUSPENDED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENCLR_SUSPENDED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENCLR_SUSPENDED_Clear (1UL) /*!< Disable */
++
++/* Bit 9 : Write '1' to disable interrupt for event ERROR */
++#define TWIM_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define TWIM_INTENCLR_ERROR_Msk (0x1UL << TWIM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define TWIM_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event STOPPED */
++#define TWIM_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define TWIM_INTENCLR_STOPPED_Msk (0x1UL << TWIM_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define TWIM_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIM_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIM_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Register: TWIM_ERRORSRC */
++/* Description: Error source */
++
++/* Bit 2 : NACK received after sending a data byte (write '1' to clear) */
++#define TWIM_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
++#define TWIM_ERRORSRC_DNACK_Msk (0x1UL << TWIM_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
++#define TWIM_ERRORSRC_DNACK_NotReceived (0UL) /*!< Error did not occur */
++#define TWIM_ERRORSRC_DNACK_Received (1UL) /*!< Error occurred */
++
++/* Bit 1 : NACK received after sending the address (write '1' to clear) */
++#define TWIM_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
++#define TWIM_ERRORSRC_ANACK_Msk (0x1UL << TWIM_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
++#define TWIM_ERRORSRC_ANACK_NotReceived (0UL) /*!< Error did not occur */
++#define TWIM_ERRORSRC_ANACK_Received (1UL) /*!< Error occurred */
++
++/* Bit 0 : Overrun error */
++#define TWIM_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
++#define TWIM_ERRORSRC_OVERRUN_Msk (0x1UL << TWIM_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
++#define TWIM_ERRORSRC_OVERRUN_NotReceived (0UL) /*!< Error did not occur */
++#define TWIM_ERRORSRC_OVERRUN_Received (1UL) /*!< Error occurred */
++
++/* Register: TWIM_ENABLE */
++/* Description: Enable TWIM */
++
++/* Bits 3..0 : Enable or disable TWIM */
++#define TWIM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define TWIM_ENABLE_ENABLE_Msk (0xFUL << TWIM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define TWIM_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWIM */
++#define TWIM_ENABLE_ENABLE_Enabled (6UL) /*!< Enable TWIM */
++
++/* Register: TWIM_PSEL_SCL */
++/* Description: Pin select for SCL signal */
++
++/* Bit 31 : Connection */
++#define TWIM_PSEL_SCL_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define TWIM_PSEL_SCL_CONNECT_Msk (0x1UL << TWIM_PSEL_SCL_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define TWIM_PSEL_SCL_CONNECT_Connected (0UL) /*!< Connect */
++#define TWIM_PSEL_SCL_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define TWIM_PSEL_SCL_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define TWIM_PSEL_SCL_PORT_Msk (0x1UL << TWIM_PSEL_SCL_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define TWIM_PSEL_SCL_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define TWIM_PSEL_SCL_PIN_Msk (0x1FUL << TWIM_PSEL_SCL_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: TWIM_PSEL_SDA */
++/* Description: Pin select for SDA signal */
++
++/* Bit 31 : Connection */
++#define TWIM_PSEL_SDA_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define TWIM_PSEL_SDA_CONNECT_Msk (0x1UL << TWIM_PSEL_SDA_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define TWIM_PSEL_SDA_CONNECT_Connected (0UL) /*!< Connect */
++#define TWIM_PSEL_SDA_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define TWIM_PSEL_SDA_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define TWIM_PSEL_SDA_PORT_Msk (0x1UL << TWIM_PSEL_SDA_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define TWIM_PSEL_SDA_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define TWIM_PSEL_SDA_PIN_Msk (0x1FUL << TWIM_PSEL_SDA_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: TWIM_FREQUENCY */
++/* Description: TWI frequency. Accuracy depends on the HFCLK source selected. */
++
++/* Bits 31..0 : TWI master clock frequency */
++#define TWIM_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
++#define TWIM_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWIM_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
++#define TWIM_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps */
++#define TWIM_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps */
++#define TWIM_FREQUENCY_FREQUENCY_K400 (0x06400000UL) /*!< 400 kbps */
++
++/* Register: TWIM_RXD_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define TWIM_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define TWIM_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIM_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: TWIM_RXD_MAXCNT */
++/* Description: Maximum number of bytes in receive buffer */
++
++/* Bits 15..0 : Maximum number of bytes in receive buffer */
++#define TWIM_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define TWIM_RXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << TWIM_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: TWIM_RXD_AMOUNT */
++/* Description: Number of bytes transferred in the last transaction */
++
++/* Bits 15..0 : Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte. */
++#define TWIM_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define TWIM_RXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << TWIM_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: TWIM_RXD_LIST */
++/* Description: EasyDMA list type */
++
++/* Bits 2..0 : List type */
++#define TWIM_RXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
++#define TWIM_RXD_LIST_LIST_Msk (0x7UL << TWIM_RXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
++#define TWIM_RXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
++#define TWIM_RXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
++
++/* Register: TWIM_TXD_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define TWIM_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define TWIM_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIM_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: TWIM_TXD_MAXCNT */
++/* Description: Maximum number of bytes in transmit buffer */
++
++/* Bits 15..0 : Maximum number of bytes in transmit buffer */
++#define TWIM_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define TWIM_TXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << TWIM_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: TWIM_TXD_AMOUNT */
++/* Description: Number of bytes transferred in the last transaction */
++
++/* Bits 15..0 : Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte. */
++#define TWIM_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define TWIM_TXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << TWIM_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: TWIM_TXD_LIST */
++/* Description: EasyDMA list type */
++
++/* Bits 2..0 : List type */
++#define TWIM_TXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
++#define TWIM_TXD_LIST_LIST_Msk (0x7UL << TWIM_TXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
++#define TWIM_TXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
++#define TWIM_TXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
++
++/* Register: TWIM_ADDRESS */
++/* Description: Address used in the TWI transfer */
++
++/* Bits 6..0 : Address used in the TWI transfer */
++#define TWIM_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
++#define TWIM_ADDRESS_ADDRESS_Msk (0x7FUL << TWIM_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
++
++
++/* Peripheral: TWIS */
++/* Description: I2C compatible Two-Wire Slave Interface with EasyDMA 0 */
++
++/* Register: TWIS_TASKS_STOP */
++/* Description: Stop TWI transaction */
++
++/* Bit 0 : Stop TWI transaction */
++#define TWIS_TASKS_STOP_TASKS_STOP_Pos (0UL) /*!< Position of TASKS_STOP field. */
++#define TWIS_TASKS_STOP_TASKS_STOP_Msk (0x1UL << TWIS_TASKS_STOP_TASKS_STOP_Pos) /*!< Bit mask of TASKS_STOP field. */
++#define TWIS_TASKS_STOP_TASKS_STOP_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIS_TASKS_SUSPEND */
++/* Description: Suspend TWI transaction */
++
++/* Bit 0 : Suspend TWI transaction */
++#define TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Pos (0UL) /*!< Position of TASKS_SUSPEND field. */
++#define TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Msk (0x1UL << TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Pos) /*!< Bit mask of TASKS_SUSPEND field. */
++#define TWIS_TASKS_SUSPEND_TASKS_SUSPEND_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIS_TASKS_RESUME */
++/* Description: Resume TWI transaction */
++
++/* Bit 0 : Resume TWI transaction */
++#define TWIS_TASKS_RESUME_TASKS_RESUME_Pos (0UL) /*!< Position of TASKS_RESUME field. */
++#define TWIS_TASKS_RESUME_TASKS_RESUME_Msk (0x1UL << TWIS_TASKS_RESUME_TASKS_RESUME_Pos) /*!< Bit mask of TASKS_RESUME field. */
++#define TWIS_TASKS_RESUME_TASKS_RESUME_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIS_TASKS_PREPARERX */
++/* Description: Prepare the TWI slave to respond to a write command */
++
++/* Bit 0 : Prepare the TWI slave to respond to a write command */
++#define TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Pos (0UL) /*!< Position of TASKS_PREPARERX field. */
++#define TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Msk (0x1UL << TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Pos) /*!< Bit mask of TASKS_PREPARERX field. */
++#define TWIS_TASKS_PREPARERX_TASKS_PREPARERX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIS_TASKS_PREPARETX */
++/* Description: Prepare the TWI slave to respond to a read command */
++
++/* Bit 0 : Prepare the TWI slave to respond to a read command */
++#define TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Pos (0UL) /*!< Position of TASKS_PREPARETX field. */
++#define TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Msk (0x1UL << TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Pos) /*!< Bit mask of TASKS_PREPARETX field. */
++#define TWIS_TASKS_PREPARETX_TASKS_PREPARETX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: TWIS_EVENTS_STOPPED */
++/* Description: TWI stopped */
++
++/* Bit 0 : TWI stopped */
++#define TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Pos (0UL) /*!< Position of EVENTS_STOPPED field. */
++#define TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Msk (0x1UL << TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Pos) /*!< Bit mask of EVENTS_STOPPED field. */
++#define TWIS_EVENTS_STOPPED_EVENTS_STOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define TWIS_EVENTS_STOPPED_EVENTS_STOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIS_EVENTS_ERROR */
++/* Description: TWI error */
++
++/* Bit 0 : TWI error */
++#define TWIS_EVENTS_ERROR_EVENTS_ERROR_Pos (0UL) /*!< Position of EVENTS_ERROR field. */
++#define TWIS_EVENTS_ERROR_EVENTS_ERROR_Msk (0x1UL << TWIS_EVENTS_ERROR_EVENTS_ERROR_Pos) /*!< Bit mask of EVENTS_ERROR field. */
++#define TWIS_EVENTS_ERROR_EVENTS_ERROR_NotGenerated (0UL) /*!< Event not generated */
++#define TWIS_EVENTS_ERROR_EVENTS_ERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIS_EVENTS_RXSTARTED */
++/* Description: Receive sequence started */
++
++/* Bit 0 : Receive sequence started */
++#define TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos (0UL) /*!< Position of EVENTS_RXSTARTED field. */
++#define TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk (0x1UL << TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos) /*!< Bit mask of EVENTS_RXSTARTED field. */
++#define TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define TWIS_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIS_EVENTS_TXSTARTED */
++/* Description: Transmit sequence started */
++
++/* Bit 0 : Transmit sequence started */
++#define TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos (0UL) /*!< Position of EVENTS_TXSTARTED field. */
++#define TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk (0x1UL << TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos) /*!< Bit mask of EVENTS_TXSTARTED field. */
++#define TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define TWIS_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIS_EVENTS_WRITE */
++/* Description: Write command received */
++
++/* Bit 0 : Write command received */
++#define TWIS_EVENTS_WRITE_EVENTS_WRITE_Pos (0UL) /*!< Position of EVENTS_WRITE field. */
++#define TWIS_EVENTS_WRITE_EVENTS_WRITE_Msk (0x1UL << TWIS_EVENTS_WRITE_EVENTS_WRITE_Pos) /*!< Bit mask of EVENTS_WRITE field. */
++#define TWIS_EVENTS_WRITE_EVENTS_WRITE_NotGenerated (0UL) /*!< Event not generated */
++#define TWIS_EVENTS_WRITE_EVENTS_WRITE_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIS_EVENTS_READ */
++/* Description: Read command received */
++
++/* Bit 0 : Read command received */
++#define TWIS_EVENTS_READ_EVENTS_READ_Pos (0UL) /*!< Position of EVENTS_READ field. */
++#define TWIS_EVENTS_READ_EVENTS_READ_Msk (0x1UL << TWIS_EVENTS_READ_EVENTS_READ_Pos) /*!< Bit mask of EVENTS_READ field. */
++#define TWIS_EVENTS_READ_EVENTS_READ_NotGenerated (0UL) /*!< Event not generated */
++#define TWIS_EVENTS_READ_EVENTS_READ_Generated (1UL) /*!< Event generated */
++
++/* Register: TWIS_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 14 : Shortcut between event READ and task SUSPEND */
++#define TWIS_SHORTS_READ_SUSPEND_Pos (14UL) /*!< Position of READ_SUSPEND field. */
++#define TWIS_SHORTS_READ_SUSPEND_Msk (0x1UL << TWIS_SHORTS_READ_SUSPEND_Pos) /*!< Bit mask of READ_SUSPEND field. */
++#define TWIS_SHORTS_READ_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
++#define TWIS_SHORTS_READ_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 13 : Shortcut between event WRITE and task SUSPEND */
++#define TWIS_SHORTS_WRITE_SUSPEND_Pos (13UL) /*!< Position of WRITE_SUSPEND field. */
++#define TWIS_SHORTS_WRITE_SUSPEND_Msk (0x1UL << TWIS_SHORTS_WRITE_SUSPEND_Pos) /*!< Bit mask of WRITE_SUSPEND field. */
++#define TWIS_SHORTS_WRITE_SUSPEND_Disabled (0UL) /*!< Disable shortcut */
++#define TWIS_SHORTS_WRITE_SUSPEND_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: TWIS_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 26 : Enable or disable interrupt for event READ */
++#define TWIS_INTEN_READ_Pos (26UL) /*!< Position of READ field. */
++#define TWIS_INTEN_READ_Msk (0x1UL << TWIS_INTEN_READ_Pos) /*!< Bit mask of READ field. */
++#define TWIS_INTEN_READ_Disabled (0UL) /*!< Disable */
++#define TWIS_INTEN_READ_Enabled (1UL) /*!< Enable */
++
++/* Bit 25 : Enable or disable interrupt for event WRITE */
++#define TWIS_INTEN_WRITE_Pos (25UL) /*!< Position of WRITE field. */
++#define TWIS_INTEN_WRITE_Msk (0x1UL << TWIS_INTEN_WRITE_Pos) /*!< Bit mask of WRITE field. */
++#define TWIS_INTEN_WRITE_Disabled (0UL) /*!< Disable */
++#define TWIS_INTEN_WRITE_Enabled (1UL) /*!< Enable */
++
++/* Bit 20 : Enable or disable interrupt for event TXSTARTED */
++#define TWIS_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define TWIS_INTEN_TXSTARTED_Msk (0x1UL << TWIS_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define TWIS_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
++#define TWIS_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 19 : Enable or disable interrupt for event RXSTARTED */
++#define TWIS_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define TWIS_INTEN_RXSTARTED_Msk (0x1UL << TWIS_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define TWIS_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
++#define TWIS_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 9 : Enable or disable interrupt for event ERROR */
++#define TWIS_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define TWIS_INTEN_ERROR_Msk (0x1UL << TWIS_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define TWIS_INTEN_ERROR_Disabled (0UL) /*!< Disable */
++#define TWIS_INTEN_ERROR_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event STOPPED */
++#define TWIS_INTEN_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define TWIS_INTEN_STOPPED_Msk (0x1UL << TWIS_INTEN_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define TWIS_INTEN_STOPPED_Disabled (0UL) /*!< Disable */
++#define TWIS_INTEN_STOPPED_Enabled (1UL) /*!< Enable */
++
++/* Register: TWIS_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 26 : Write '1' to enable interrupt for event READ */
++#define TWIS_INTENSET_READ_Pos (26UL) /*!< Position of READ field. */
++#define TWIS_INTENSET_READ_Msk (0x1UL << TWIS_INTENSET_READ_Pos) /*!< Bit mask of READ field. */
++#define TWIS_INTENSET_READ_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENSET_READ_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENSET_READ_Set (1UL) /*!< Enable */
++
++/* Bit 25 : Write '1' to enable interrupt for event WRITE */
++#define TWIS_INTENSET_WRITE_Pos (25UL) /*!< Position of WRITE field. */
++#define TWIS_INTENSET_WRITE_Msk (0x1UL << TWIS_INTENSET_WRITE_Pos) /*!< Bit mask of WRITE field. */
++#define TWIS_INTENSET_WRITE_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENSET_WRITE_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENSET_WRITE_Set (1UL) /*!< Enable */
++
++/* Bit 20 : Write '1' to enable interrupt for event TXSTARTED */
++#define TWIS_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define TWIS_INTENSET_TXSTARTED_Msk (0x1UL << TWIS_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define TWIS_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 19 : Write '1' to enable interrupt for event RXSTARTED */
++#define TWIS_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define TWIS_INTENSET_RXSTARTED_Msk (0x1UL << TWIS_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define TWIS_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 9 : Write '1' to enable interrupt for event ERROR */
++#define TWIS_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define TWIS_INTENSET_ERROR_Msk (0x1UL << TWIS_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define TWIS_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENSET_ERROR_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event STOPPED */
++#define TWIS_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define TWIS_INTENSET_STOPPED_Msk (0x1UL << TWIS_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define TWIS_INTENSET_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENSET_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENSET_STOPPED_Set (1UL) /*!< Enable */
++
++/* Register: TWIS_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 26 : Write '1' to disable interrupt for event READ */
++#define TWIS_INTENCLR_READ_Pos (26UL) /*!< Position of READ field. */
++#define TWIS_INTENCLR_READ_Msk (0x1UL << TWIS_INTENCLR_READ_Pos) /*!< Bit mask of READ field. */
++#define TWIS_INTENCLR_READ_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENCLR_READ_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENCLR_READ_Clear (1UL) /*!< Disable */
++
++/* Bit 25 : Write '1' to disable interrupt for event WRITE */
++#define TWIS_INTENCLR_WRITE_Pos (25UL) /*!< Position of WRITE field. */
++#define TWIS_INTENCLR_WRITE_Msk (0x1UL << TWIS_INTENCLR_WRITE_Pos) /*!< Bit mask of WRITE field. */
++#define TWIS_INTENCLR_WRITE_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENCLR_WRITE_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENCLR_WRITE_Clear (1UL) /*!< Disable */
++
++/* Bit 20 : Write '1' to disable interrupt for event TXSTARTED */
++#define TWIS_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define TWIS_INTENCLR_TXSTARTED_Msk (0x1UL << TWIS_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define TWIS_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 19 : Write '1' to disable interrupt for event RXSTARTED */
++#define TWIS_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define TWIS_INTENCLR_RXSTARTED_Msk (0x1UL << TWIS_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define TWIS_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 9 : Write '1' to disable interrupt for event ERROR */
++#define TWIS_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define TWIS_INTENCLR_ERROR_Msk (0x1UL << TWIS_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define TWIS_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event STOPPED */
++#define TWIS_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
++#define TWIS_INTENCLR_STOPPED_Msk (0x1UL << TWIS_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
++#define TWIS_INTENCLR_STOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define TWIS_INTENCLR_STOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define TWIS_INTENCLR_STOPPED_Clear (1UL) /*!< Disable */
++
++/* Register: TWIS_ERRORSRC */
++/* Description: Error source */
++
++/* Bit 3 : TX buffer over-read detected, and prevented */
++#define TWIS_ERRORSRC_OVERREAD_Pos (3UL) /*!< Position of OVERREAD field. */
++#define TWIS_ERRORSRC_OVERREAD_Msk (0x1UL << TWIS_ERRORSRC_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
++#define TWIS_ERRORSRC_OVERREAD_NotDetected (0UL) /*!< Error did not occur */
++#define TWIS_ERRORSRC_OVERREAD_Detected (1UL) /*!< Error occurred */
++
++/* Bit 2 : NACK sent after receiving a data byte */
++#define TWIS_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
++#define TWIS_ERRORSRC_DNACK_Msk (0x1UL << TWIS_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
++#define TWIS_ERRORSRC_DNACK_NotReceived (0UL) /*!< Error did not occur */
++#define TWIS_ERRORSRC_DNACK_Received (1UL) /*!< Error occurred */
++
++/* Bit 0 : RX buffer overflow detected, and prevented */
++#define TWIS_ERRORSRC_OVERFLOW_Pos (0UL) /*!< Position of OVERFLOW field. */
++#define TWIS_ERRORSRC_OVERFLOW_Msk (0x1UL << TWIS_ERRORSRC_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
++#define TWIS_ERRORSRC_OVERFLOW_NotDetected (0UL) /*!< Error did not occur */
++#define TWIS_ERRORSRC_OVERFLOW_Detected (1UL) /*!< Error occurred */
++
++/* Register: TWIS_MATCH */
++/* Description: Status register indicating which address had a match */
++
++/* Bit 0 : Indication of which address in {ADDRESS} that matched the incoming address */
++#define TWIS_MATCH_MATCH_Pos (0UL) /*!< Position of MATCH field. */
++#define TWIS_MATCH_MATCH_Msk (0x1UL << TWIS_MATCH_MATCH_Pos) /*!< Bit mask of MATCH field. */
++
++/* Register: TWIS_ENABLE */
++/* Description: Enable TWIS */
++
++/* Bits 3..0 : Enable or disable TWIS */
++#define TWIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define TWIS_ENABLE_ENABLE_Msk (0xFUL << TWIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define TWIS_ENABLE_ENABLE_Disabled (0UL) /*!< Disable TWIS */
++#define TWIS_ENABLE_ENABLE_Enabled (9UL) /*!< Enable TWIS */
++
++/* Register: TWIS_PSEL_SCL */
++/* Description: Pin select for SCL signal */
++
++/* Bit 31 : Connection */
++#define TWIS_PSEL_SCL_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define TWIS_PSEL_SCL_CONNECT_Msk (0x1UL << TWIS_PSEL_SCL_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define TWIS_PSEL_SCL_CONNECT_Connected (0UL) /*!< Connect */
++#define TWIS_PSEL_SCL_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define TWIS_PSEL_SCL_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define TWIS_PSEL_SCL_PORT_Msk (0x1UL << TWIS_PSEL_SCL_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define TWIS_PSEL_SCL_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define TWIS_PSEL_SCL_PIN_Msk (0x1FUL << TWIS_PSEL_SCL_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: TWIS_PSEL_SDA */
++/* Description: Pin select for SDA signal */
++
++/* Bit 31 : Connection */
++#define TWIS_PSEL_SDA_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define TWIS_PSEL_SDA_CONNECT_Msk (0x1UL << TWIS_PSEL_SDA_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define TWIS_PSEL_SDA_CONNECT_Connected (0UL) /*!< Connect */
++#define TWIS_PSEL_SDA_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define TWIS_PSEL_SDA_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define TWIS_PSEL_SDA_PORT_Msk (0x1UL << TWIS_PSEL_SDA_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define TWIS_PSEL_SDA_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define TWIS_PSEL_SDA_PIN_Msk (0x1FUL << TWIS_PSEL_SDA_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: TWIS_RXD_PTR */
++/* Description: RXD Data pointer */
++
++/* Bits 31..0 : RXD Data pointer */
++#define TWIS_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define TWIS_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIS_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: TWIS_RXD_MAXCNT */
++/* Description: Maximum number of bytes in RXD buffer */
++
++/* Bits 15..0 : Maximum number of bytes in RXD buffer */
++#define TWIS_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define TWIS_RXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << TWIS_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: TWIS_RXD_AMOUNT */
++/* Description: Number of bytes transferred in the last RXD transaction */
++
++/* Bits 15..0 : Number of bytes transferred in the last RXD transaction */
++#define TWIS_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define TWIS_RXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << TWIS_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: TWIS_RXD_LIST */
++/* Description: EasyDMA list type */
++
++/* Bits 1..0 : List type */
++#define TWIS_RXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
++#define TWIS_RXD_LIST_LIST_Msk (0x3UL << TWIS_RXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
++#define TWIS_RXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
++#define TWIS_RXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
++
++/* Register: TWIS_TXD_PTR */
++/* Description: TXD Data pointer */
++
++/* Bits 31..0 : TXD Data pointer */
++#define TWIS_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define TWIS_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << TWIS_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: TWIS_TXD_MAXCNT */
++/* Description: Maximum number of bytes in TXD buffer */
++
++/* Bits 15..0 : Maximum number of bytes in TXD buffer */
++#define TWIS_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define TWIS_TXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << TWIS_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: TWIS_TXD_AMOUNT */
++/* Description: Number of bytes transferred in the last TXD transaction */
++
++/* Bits 15..0 : Number of bytes transferred in the last TXD transaction */
++#define TWIS_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define TWIS_TXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << TWIS_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: TWIS_TXD_LIST */
++/* Description: EasyDMA list type */
++
++/* Bits 1..0 : List type */
++#define TWIS_TXD_LIST_LIST_Pos (0UL) /*!< Position of LIST field. */
++#define TWIS_TXD_LIST_LIST_Msk (0x3UL << TWIS_TXD_LIST_LIST_Pos) /*!< Bit mask of LIST field. */
++#define TWIS_TXD_LIST_LIST_Disabled (0UL) /*!< Disable EasyDMA list */
++#define TWIS_TXD_LIST_LIST_ArrayList (1UL) /*!< Use array list */
++
++/* Register: TWIS_ADDRESS */
++/* Description: Description collection: TWI slave address n */
++
++/* Bits 6..0 : TWI slave address */
++#define TWIS_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
++#define TWIS_ADDRESS_ADDRESS_Msk (0x7FUL << TWIS_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
++
++/* Register: TWIS_CONFIG */
++/* Description: Configuration register for the address match mechanism */
++
++/* Bit 1 : Enable or disable address matching on ADDRESS[1] */
++#define TWIS_CONFIG_ADDRESS1_Pos (1UL) /*!< Position of ADDRESS1 field. */
++#define TWIS_CONFIG_ADDRESS1_Msk (0x1UL << TWIS_CONFIG_ADDRESS1_Pos) /*!< Bit mask of ADDRESS1 field. */
++#define TWIS_CONFIG_ADDRESS1_Disabled (0UL) /*!< Disabled */
++#define TWIS_CONFIG_ADDRESS1_Enabled (1UL) /*!< Enabled */
++
++/* Bit 0 : Enable or disable address matching on ADDRESS[0] */
++#define TWIS_CONFIG_ADDRESS0_Pos (0UL) /*!< Position of ADDRESS0 field. */
++#define TWIS_CONFIG_ADDRESS0_Msk (0x1UL << TWIS_CONFIG_ADDRESS0_Pos) /*!< Bit mask of ADDRESS0 field. */
++#define TWIS_CONFIG_ADDRESS0_Disabled (0UL) /*!< Disabled */
++#define TWIS_CONFIG_ADDRESS0_Enabled (1UL) /*!< Enabled */
++
++/* Register: TWIS_ORC */
++/* Description: Over-read character. Character sent out in case of an over-read of the transmit buffer. */
++
++/* Bits 7..0 : Over-read character. Character sent out in case of an over-read of the transmit buffer. */
++#define TWIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
++#define TWIS_ORC_ORC_Msk (0xFFUL << TWIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
++
++
++/* Peripheral: UART */
++/* Description: Universal Asynchronous Receiver/Transmitter */
++
++/* Register: UART_TASKS_STARTRX */
++/* Description: Start UART receiver */
++
++/* Bit 0 : Start UART receiver */
++#define UART_TASKS_STARTRX_TASKS_STARTRX_Pos (0UL) /*!< Position of TASKS_STARTRX field. */
++#define UART_TASKS_STARTRX_TASKS_STARTRX_Msk (0x1UL << UART_TASKS_STARTRX_TASKS_STARTRX_Pos) /*!< Bit mask of TASKS_STARTRX field. */
++#define UART_TASKS_STARTRX_TASKS_STARTRX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UART_TASKS_STOPRX */
++/* Description: Stop UART receiver */
++
++/* Bit 0 : Stop UART receiver */
++#define UART_TASKS_STOPRX_TASKS_STOPRX_Pos (0UL) /*!< Position of TASKS_STOPRX field. */
++#define UART_TASKS_STOPRX_TASKS_STOPRX_Msk (0x1UL << UART_TASKS_STOPRX_TASKS_STOPRX_Pos) /*!< Bit mask of TASKS_STOPRX field. */
++#define UART_TASKS_STOPRX_TASKS_STOPRX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UART_TASKS_STARTTX */
++/* Description: Start UART transmitter */
++
++/* Bit 0 : Start UART transmitter */
++#define UART_TASKS_STARTTX_TASKS_STARTTX_Pos (0UL) /*!< Position of TASKS_STARTTX field. */
++#define UART_TASKS_STARTTX_TASKS_STARTTX_Msk (0x1UL << UART_TASKS_STARTTX_TASKS_STARTTX_Pos) /*!< Bit mask of TASKS_STARTTX field. */
++#define UART_TASKS_STARTTX_TASKS_STARTTX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UART_TASKS_STOPTX */
++/* Description: Stop UART transmitter */
++
++/* Bit 0 : Stop UART transmitter */
++#define UART_TASKS_STOPTX_TASKS_STOPTX_Pos (0UL) /*!< Position of TASKS_STOPTX field. */
++#define UART_TASKS_STOPTX_TASKS_STOPTX_Msk (0x1UL << UART_TASKS_STOPTX_TASKS_STOPTX_Pos) /*!< Bit mask of TASKS_STOPTX field. */
++#define UART_TASKS_STOPTX_TASKS_STOPTX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UART_TASKS_SUSPEND */
++/* Description: Suspend UART */
++
++/* Bit 0 : Suspend UART */
++#define UART_TASKS_SUSPEND_TASKS_SUSPEND_Pos (0UL) /*!< Position of TASKS_SUSPEND field. */
++#define UART_TASKS_SUSPEND_TASKS_SUSPEND_Msk (0x1UL << UART_TASKS_SUSPEND_TASKS_SUSPEND_Pos) /*!< Bit mask of TASKS_SUSPEND field. */
++#define UART_TASKS_SUSPEND_TASKS_SUSPEND_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UART_EVENTS_CTS */
++/* Description: CTS is activated (set low). Clear To Send. */
++
++/* Bit 0 : CTS is activated (set low). Clear To Send. */
++#define UART_EVENTS_CTS_EVENTS_CTS_Pos (0UL) /*!< Position of EVENTS_CTS field. */
++#define UART_EVENTS_CTS_EVENTS_CTS_Msk (0x1UL << UART_EVENTS_CTS_EVENTS_CTS_Pos) /*!< Bit mask of EVENTS_CTS field. */
++#define UART_EVENTS_CTS_EVENTS_CTS_NotGenerated (0UL) /*!< Event not generated */
++#define UART_EVENTS_CTS_EVENTS_CTS_Generated (1UL) /*!< Event generated */
++
++/* Register: UART_EVENTS_NCTS */
++/* Description: CTS is deactivated (set high). Not Clear To Send. */
++
++/* Bit 0 : CTS is deactivated (set high). Not Clear To Send. */
++#define UART_EVENTS_NCTS_EVENTS_NCTS_Pos (0UL) /*!< Position of EVENTS_NCTS field. */
++#define UART_EVENTS_NCTS_EVENTS_NCTS_Msk (0x1UL << UART_EVENTS_NCTS_EVENTS_NCTS_Pos) /*!< Bit mask of EVENTS_NCTS field. */
++#define UART_EVENTS_NCTS_EVENTS_NCTS_NotGenerated (0UL) /*!< Event not generated */
++#define UART_EVENTS_NCTS_EVENTS_NCTS_Generated (1UL) /*!< Event generated */
++
++/* Register: UART_EVENTS_RXDRDY */
++/* Description: Data received in RXD */
++
++/* Bit 0 : Data received in RXD */
++#define UART_EVENTS_RXDRDY_EVENTS_RXDRDY_Pos (0UL) /*!< Position of EVENTS_RXDRDY field. */
++#define UART_EVENTS_RXDRDY_EVENTS_RXDRDY_Msk (0x1UL << UART_EVENTS_RXDRDY_EVENTS_RXDRDY_Pos) /*!< Bit mask of EVENTS_RXDRDY field. */
++#define UART_EVENTS_RXDRDY_EVENTS_RXDRDY_NotGenerated (0UL) /*!< Event not generated */
++#define UART_EVENTS_RXDRDY_EVENTS_RXDRDY_Generated (1UL) /*!< Event generated */
++
++/* Register: UART_EVENTS_TXDRDY */
++/* Description: Data sent from TXD */
++
++/* Bit 0 : Data sent from TXD */
++#define UART_EVENTS_TXDRDY_EVENTS_TXDRDY_Pos (0UL) /*!< Position of EVENTS_TXDRDY field. */
++#define UART_EVENTS_TXDRDY_EVENTS_TXDRDY_Msk (0x1UL << UART_EVENTS_TXDRDY_EVENTS_TXDRDY_Pos) /*!< Bit mask of EVENTS_TXDRDY field. */
++#define UART_EVENTS_TXDRDY_EVENTS_TXDRDY_NotGenerated (0UL) /*!< Event not generated */
++#define UART_EVENTS_TXDRDY_EVENTS_TXDRDY_Generated (1UL) /*!< Event generated */
++
++/* Register: UART_EVENTS_ERROR */
++/* Description: Error detected */
++
++/* Bit 0 : Error detected */
++#define UART_EVENTS_ERROR_EVENTS_ERROR_Pos (0UL) /*!< Position of EVENTS_ERROR field. */
++#define UART_EVENTS_ERROR_EVENTS_ERROR_Msk (0x1UL << UART_EVENTS_ERROR_EVENTS_ERROR_Pos) /*!< Bit mask of EVENTS_ERROR field. */
++#define UART_EVENTS_ERROR_EVENTS_ERROR_NotGenerated (0UL) /*!< Event not generated */
++#define UART_EVENTS_ERROR_EVENTS_ERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: UART_EVENTS_RXTO */
++/* Description: Receiver timeout */
++
++/* Bit 0 : Receiver timeout */
++#define UART_EVENTS_RXTO_EVENTS_RXTO_Pos (0UL) /*!< Position of EVENTS_RXTO field. */
++#define UART_EVENTS_RXTO_EVENTS_RXTO_Msk (0x1UL << UART_EVENTS_RXTO_EVENTS_RXTO_Pos) /*!< Bit mask of EVENTS_RXTO field. */
++#define UART_EVENTS_RXTO_EVENTS_RXTO_NotGenerated (0UL) /*!< Event not generated */
++#define UART_EVENTS_RXTO_EVENTS_RXTO_Generated (1UL) /*!< Event generated */
++
++/* Register: UART_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 4 : Shortcut between event NCTS and task STOPRX */
++#define UART_SHORTS_NCTS_STOPRX_Pos (4UL) /*!< Position of NCTS_STOPRX field. */
++#define UART_SHORTS_NCTS_STOPRX_Msk (0x1UL << UART_SHORTS_NCTS_STOPRX_Pos) /*!< Bit mask of NCTS_STOPRX field. */
++#define UART_SHORTS_NCTS_STOPRX_Disabled (0UL) /*!< Disable shortcut */
++#define UART_SHORTS_NCTS_STOPRX_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 3 : Shortcut between event CTS and task STARTRX */
++#define UART_SHORTS_CTS_STARTRX_Pos (3UL) /*!< Position of CTS_STARTRX field. */
++#define UART_SHORTS_CTS_STARTRX_Msk (0x1UL << UART_SHORTS_CTS_STARTRX_Pos) /*!< Bit mask of CTS_STARTRX field. */
++#define UART_SHORTS_CTS_STARTRX_Disabled (0UL) /*!< Disable shortcut */
++#define UART_SHORTS_CTS_STARTRX_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: UART_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 17 : Write '1' to enable interrupt for event RXTO */
++#define UART_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
++#define UART_INTENSET_RXTO_Msk (0x1UL << UART_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
++#define UART_INTENSET_RXTO_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENSET_RXTO_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENSET_RXTO_Set (1UL) /*!< Enable */
++
++/* Bit 9 : Write '1' to enable interrupt for event ERROR */
++#define UART_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define UART_INTENSET_ERROR_Msk (0x1UL << UART_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define UART_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENSET_ERROR_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event TXDRDY */
++#define UART_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
++#define UART_INTENSET_TXDRDY_Msk (0x1UL << UART_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
++#define UART_INTENSET_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENSET_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENSET_TXDRDY_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event RXDRDY */
++#define UART_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
++#define UART_INTENSET_RXDRDY_Msk (0x1UL << UART_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
++#define UART_INTENSET_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENSET_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENSET_RXDRDY_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event NCTS */
++#define UART_INTENSET_NCTS_Pos (1UL) /*!< Position of NCTS field. */
++#define UART_INTENSET_NCTS_Msk (0x1UL << UART_INTENSET_NCTS_Pos) /*!< Bit mask of NCTS field. */
++#define UART_INTENSET_NCTS_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENSET_NCTS_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENSET_NCTS_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event CTS */
++#define UART_INTENSET_CTS_Pos (0UL) /*!< Position of CTS field. */
++#define UART_INTENSET_CTS_Msk (0x1UL << UART_INTENSET_CTS_Pos) /*!< Bit mask of CTS field. */
++#define UART_INTENSET_CTS_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENSET_CTS_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENSET_CTS_Set (1UL) /*!< Enable */
++
++/* Register: UART_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 17 : Write '1' to disable interrupt for event RXTO */
++#define UART_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
++#define UART_INTENCLR_RXTO_Msk (0x1UL << UART_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
++#define UART_INTENCLR_RXTO_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENCLR_RXTO_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENCLR_RXTO_Clear (1UL) /*!< Disable */
++
++/* Bit 9 : Write '1' to disable interrupt for event ERROR */
++#define UART_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define UART_INTENCLR_ERROR_Msk (0x1UL << UART_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define UART_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event TXDRDY */
++#define UART_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
++#define UART_INTENCLR_TXDRDY_Msk (0x1UL << UART_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
++#define UART_INTENCLR_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENCLR_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event RXDRDY */
++#define UART_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
++#define UART_INTENCLR_RXDRDY_Msk (0x1UL << UART_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
++#define UART_INTENCLR_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENCLR_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event NCTS */
++#define UART_INTENCLR_NCTS_Pos (1UL) /*!< Position of NCTS field. */
++#define UART_INTENCLR_NCTS_Msk (0x1UL << UART_INTENCLR_NCTS_Pos) /*!< Bit mask of NCTS field. */
++#define UART_INTENCLR_NCTS_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENCLR_NCTS_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENCLR_NCTS_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event CTS */
++#define UART_INTENCLR_CTS_Pos (0UL) /*!< Position of CTS field. */
++#define UART_INTENCLR_CTS_Msk (0x1UL << UART_INTENCLR_CTS_Pos) /*!< Bit mask of CTS field. */
++#define UART_INTENCLR_CTS_Disabled (0UL) /*!< Read: Disabled */
++#define UART_INTENCLR_CTS_Enabled (1UL) /*!< Read: Enabled */
++#define UART_INTENCLR_CTS_Clear (1UL) /*!< Disable */
++
++/* Register: UART_ERRORSRC */
++/* Description: Error source */
++
++/* Bit 3 : Break condition */
++#define UART_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
++#define UART_ERRORSRC_BREAK_Msk (0x1UL << UART_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
++#define UART_ERRORSRC_BREAK_NotPresent (0UL) /*!< Read: error not present */
++#define UART_ERRORSRC_BREAK_Present (1UL) /*!< Read: error present */
++
++/* Bit 2 : Framing error occurred */
++#define UART_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
++#define UART_ERRORSRC_FRAMING_Msk (0x1UL << UART_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
++#define UART_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Read: error not present */
++#define UART_ERRORSRC_FRAMING_Present (1UL) /*!< Read: error present */
++
++/* Bit 1 : Parity error */
++#define UART_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
++#define UART_ERRORSRC_PARITY_Msk (0x1UL << UART_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
++#define UART_ERRORSRC_PARITY_NotPresent (0UL) /*!< Read: error not present */
++#define UART_ERRORSRC_PARITY_Present (1UL) /*!< Read: error present */
++
++/* Bit 0 : Overrun error */
++#define UART_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
++#define UART_ERRORSRC_OVERRUN_Msk (0x1UL << UART_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
++#define UART_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: error not present */
++#define UART_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: error present */
++
++/* Register: UART_ENABLE */
++/* Description: Enable UART */
++
++/* Bits 3..0 : Enable or disable UART */
++#define UART_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define UART_ENABLE_ENABLE_Msk (0xFUL << UART_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define UART_ENABLE_ENABLE_Disabled (0UL) /*!< Disable UART */
++#define UART_ENABLE_ENABLE_Enabled (4UL) /*!< Enable UART */
++
++/* Register: UART_PSEL_RTS */
++/* Description: Pin select for RTS */
++
++/* Bit 31 : Connection */
++#define UART_PSEL_RTS_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UART_PSEL_RTS_CONNECT_Msk (0x1UL << UART_PSEL_RTS_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UART_PSEL_RTS_CONNECT_Connected (0UL) /*!< Connect */
++#define UART_PSEL_RTS_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define UART_PSEL_RTS_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UART_PSEL_RTS_PORT_Msk (0x1UL << UART_PSEL_RTS_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define UART_PSEL_RTS_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UART_PSEL_RTS_PIN_Msk (0x1FUL << UART_PSEL_RTS_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UART_PSEL_TXD */
++/* Description: Pin select for TXD */
++
++/* Bit 31 : Connection */
++#define UART_PSEL_TXD_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UART_PSEL_TXD_CONNECT_Msk (0x1UL << UART_PSEL_TXD_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UART_PSEL_TXD_CONNECT_Connected (0UL) /*!< Connect */
++#define UART_PSEL_TXD_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define UART_PSEL_TXD_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UART_PSEL_TXD_PORT_Msk (0x1UL << UART_PSEL_TXD_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define UART_PSEL_TXD_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UART_PSEL_TXD_PIN_Msk (0x1FUL << UART_PSEL_TXD_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UART_PSEL_CTS */
++/* Description: Pin select for CTS */
++
++/* Bit 31 : Connection */
++#define UART_PSEL_CTS_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UART_PSEL_CTS_CONNECT_Msk (0x1UL << UART_PSEL_CTS_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UART_PSEL_CTS_CONNECT_Connected (0UL) /*!< Connect */
++#define UART_PSEL_CTS_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define UART_PSEL_CTS_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UART_PSEL_CTS_PORT_Msk (0x1UL << UART_PSEL_CTS_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define UART_PSEL_CTS_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UART_PSEL_CTS_PIN_Msk (0x1FUL << UART_PSEL_CTS_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UART_PSEL_RXD */
++/* Description: Pin select for RXD */
++
++/* Bit 31 : Connection */
++#define UART_PSEL_RXD_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UART_PSEL_RXD_CONNECT_Msk (0x1UL << UART_PSEL_RXD_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UART_PSEL_RXD_CONNECT_Connected (0UL) /*!< Connect */
++#define UART_PSEL_RXD_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define UART_PSEL_RXD_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UART_PSEL_RXD_PORT_Msk (0x1UL << UART_PSEL_RXD_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define UART_PSEL_RXD_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UART_PSEL_RXD_PIN_Msk (0x1FUL << UART_PSEL_RXD_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UART_RXD */
++/* Description: RXD register */
++
++/* Bits 7..0 : RX data received in previous transfers, double buffered */
++#define UART_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
++#define UART_RXD_RXD_Msk (0xFFUL << UART_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
++
++/* Register: UART_TXD */
++/* Description: TXD register */
++
++/* Bits 7..0 : TX data to be transferred */
++#define UART_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
++#define UART_TXD_TXD_Msk (0xFFUL << UART_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
++
++/* Register: UART_BAUDRATE */
++/* Description: Baud rate. Accuracy depends on the HFCLK source selected. */
++
++/* Bits 31..0 : Baud rate */
++#define UART_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
++#define UART_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UART_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
++#define UART_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud (actual rate: 1205) */
++#define UART_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud (actual rate: 2396) */
++#define UART_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud (actual rate: 4808) */
++#define UART_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud (actual rate: 9598) */
++#define UART_BAUDRATE_BAUDRATE_Baud14400 (0x003B0000UL) /*!< 14400 baud (actual rate: 14414) */
++#define UART_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud (actual rate: 19208) */
++#define UART_BAUDRATE_BAUDRATE_Baud28800 (0x0075F000UL) /*!< 28800 baud (actual rate: 28829) */
++#define UART_BAUDRATE_BAUDRATE_Baud31250 (0x00800000UL) /*!< 31250 baud */
++#define UART_BAUDRATE_BAUDRATE_Baud38400 (0x009D5000UL) /*!< 38400 baud (actual rate: 38462) */
++#define UART_BAUDRATE_BAUDRATE_Baud56000 (0x00E50000UL) /*!< 56000 baud (actual rate: 55944) */
++#define UART_BAUDRATE_BAUDRATE_Baud57600 (0x00EBF000UL) /*!< 57600 baud (actual rate: 57762) */
++#define UART_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud (actual rate: 76923) */
++#define UART_BAUDRATE_BAUDRATE_Baud115200 (0x01D7E000UL) /*!< 115200 baud (actual rate: 115942) */
++#define UART_BAUDRATE_BAUDRATE_Baud230400 (0x03AFB000UL) /*!< 230400 baud (actual rate: 231884) */
++#define UART_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud */
++#define UART_BAUDRATE_BAUDRATE_Baud460800 (0x075F7000UL) /*!< 460800 baud (actual rate: 470588) */
++#define UART_BAUDRATE_BAUDRATE_Baud921600 (0x0EBED000UL) /*!< 921600 baud (actual rate: 941176) */
++#define UART_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1Mega baud */
++
++/* Register: UART_CONFIG */
++/* Description: Configuration of parity and hardware flow control */
++
++/* Bit 4 : Stop bits */
++#define UART_CONFIG_STOP_Pos (4UL) /*!< Position of STOP field. */
++#define UART_CONFIG_STOP_Msk (0x1UL << UART_CONFIG_STOP_Pos) /*!< Bit mask of STOP field. */
++#define UART_CONFIG_STOP_One (0UL) /*!< One stop bit */
++#define UART_CONFIG_STOP_Two (1UL) /*!< Two stop bits */
++
++/* Bits 3..1 : Parity */
++#define UART_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
++#define UART_CONFIG_PARITY_Msk (0x7UL << UART_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
++#define UART_CONFIG_PARITY_Excluded (0x0UL) /*!< Exclude parity bit */
++#define UART_CONFIG_PARITY_Included (0x7UL) /*!< Include parity bit */
++
++/* Bit 0 : Hardware flow control */
++#define UART_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
++#define UART_CONFIG_HWFC_Msk (0x1UL << UART_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
++#define UART_CONFIG_HWFC_Disabled (0UL) /*!< Disabled */
++#define UART_CONFIG_HWFC_Enabled (1UL) /*!< Enabled */
++
++
++/* Peripheral: UARTE */
++/* Description: UART with EasyDMA 0 */
++
++/* Register: UARTE_TASKS_STARTRX */
++/* Description: Start UART receiver */
++
++/* Bit 0 : Start UART receiver */
++#define UARTE_TASKS_STARTRX_TASKS_STARTRX_Pos (0UL) /*!< Position of TASKS_STARTRX field. */
++#define UARTE_TASKS_STARTRX_TASKS_STARTRX_Msk (0x1UL << UARTE_TASKS_STARTRX_TASKS_STARTRX_Pos) /*!< Bit mask of TASKS_STARTRX field. */
++#define UARTE_TASKS_STARTRX_TASKS_STARTRX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UARTE_TASKS_STOPRX */
++/* Description: Stop UART receiver */
++
++/* Bit 0 : Stop UART receiver */
++#define UARTE_TASKS_STOPRX_TASKS_STOPRX_Pos (0UL) /*!< Position of TASKS_STOPRX field. */
++#define UARTE_TASKS_STOPRX_TASKS_STOPRX_Msk (0x1UL << UARTE_TASKS_STOPRX_TASKS_STOPRX_Pos) /*!< Bit mask of TASKS_STOPRX field. */
++#define UARTE_TASKS_STOPRX_TASKS_STOPRX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UARTE_TASKS_STARTTX */
++/* Description: Start UART transmitter */
++
++/* Bit 0 : Start UART transmitter */
++#define UARTE_TASKS_STARTTX_TASKS_STARTTX_Pos (0UL) /*!< Position of TASKS_STARTTX field. */
++#define UARTE_TASKS_STARTTX_TASKS_STARTTX_Msk (0x1UL << UARTE_TASKS_STARTTX_TASKS_STARTTX_Pos) /*!< Bit mask of TASKS_STARTTX field. */
++#define UARTE_TASKS_STARTTX_TASKS_STARTTX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UARTE_TASKS_STOPTX */
++/* Description: Stop UART transmitter */
++
++/* Bit 0 : Stop UART transmitter */
++#define UARTE_TASKS_STOPTX_TASKS_STOPTX_Pos (0UL) /*!< Position of TASKS_STOPTX field. */
++#define UARTE_TASKS_STOPTX_TASKS_STOPTX_Msk (0x1UL << UARTE_TASKS_STOPTX_TASKS_STOPTX_Pos) /*!< Bit mask of TASKS_STOPTX field. */
++#define UARTE_TASKS_STOPTX_TASKS_STOPTX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UARTE_TASKS_FLUSHRX */
++/* Description: Flush RX FIFO into RX buffer */
++
++/* Bit 0 : Flush RX FIFO into RX buffer */
++#define UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Pos (0UL) /*!< Position of TASKS_FLUSHRX field. */
++#define UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Msk (0x1UL << UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Pos) /*!< Bit mask of TASKS_FLUSHRX field. */
++#define UARTE_TASKS_FLUSHRX_TASKS_FLUSHRX_Trigger (1UL) /*!< Trigger task */
++
++/* Register: UARTE_EVENTS_CTS */
++/* Description: CTS is activated (set low). Clear To Send. */
++
++/* Bit 0 : CTS is activated (set low). Clear To Send. */
++#define UARTE_EVENTS_CTS_EVENTS_CTS_Pos (0UL) /*!< Position of EVENTS_CTS field. */
++#define UARTE_EVENTS_CTS_EVENTS_CTS_Msk (0x1UL << UARTE_EVENTS_CTS_EVENTS_CTS_Pos) /*!< Bit mask of EVENTS_CTS field. */
++#define UARTE_EVENTS_CTS_EVENTS_CTS_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_CTS_EVENTS_CTS_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_NCTS */
++/* Description: CTS is deactivated (set high). Not Clear To Send. */
++
++/* Bit 0 : CTS is deactivated (set high). Not Clear To Send. */
++#define UARTE_EVENTS_NCTS_EVENTS_NCTS_Pos (0UL) /*!< Position of EVENTS_NCTS field. */
++#define UARTE_EVENTS_NCTS_EVENTS_NCTS_Msk (0x1UL << UARTE_EVENTS_NCTS_EVENTS_NCTS_Pos) /*!< Bit mask of EVENTS_NCTS field. */
++#define UARTE_EVENTS_NCTS_EVENTS_NCTS_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_NCTS_EVENTS_NCTS_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_RXDRDY */
++/* Description: Data received in RXD (but potentially not yet transferred to Data RAM) */
++
++/* Bit 0 : Data received in RXD (but potentially not yet transferred to Data RAM) */
++#define UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Pos (0UL) /*!< Position of EVENTS_RXDRDY field. */
++#define UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Msk (0x1UL << UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Pos) /*!< Bit mask of EVENTS_RXDRDY field. */
++#define UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_RXDRDY_EVENTS_RXDRDY_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_ENDRX */
++/* Description: Receive buffer is filled up */
++
++/* Bit 0 : Receive buffer is filled up */
++#define UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Pos (0UL) /*!< Position of EVENTS_ENDRX field. */
++#define UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Msk (0x1UL << UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Pos) /*!< Bit mask of EVENTS_ENDRX field. */
++#define UARTE_EVENTS_ENDRX_EVENTS_ENDRX_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_ENDRX_EVENTS_ENDRX_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_TXDRDY */
++/* Description: Data sent from TXD */
++
++/* Bit 0 : Data sent from TXD */
++#define UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Pos (0UL) /*!< Position of EVENTS_TXDRDY field. */
++#define UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Msk (0x1UL << UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Pos) /*!< Bit mask of EVENTS_TXDRDY field. */
++#define UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_TXDRDY_EVENTS_TXDRDY_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_ENDTX */
++/* Description: Last TX byte transmitted */
++
++/* Bit 0 : Last TX byte transmitted */
++#define UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Pos (0UL) /*!< Position of EVENTS_ENDTX field. */
++#define UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Msk (0x1UL << UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Pos) /*!< Bit mask of EVENTS_ENDTX field. */
++#define UARTE_EVENTS_ENDTX_EVENTS_ENDTX_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_ENDTX_EVENTS_ENDTX_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_ERROR */
++/* Description: Error detected */
++
++/* Bit 0 : Error detected */
++#define UARTE_EVENTS_ERROR_EVENTS_ERROR_Pos (0UL) /*!< Position of EVENTS_ERROR field. */
++#define UARTE_EVENTS_ERROR_EVENTS_ERROR_Msk (0x1UL << UARTE_EVENTS_ERROR_EVENTS_ERROR_Pos) /*!< Bit mask of EVENTS_ERROR field. */
++#define UARTE_EVENTS_ERROR_EVENTS_ERROR_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_ERROR_EVENTS_ERROR_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_RXTO */
++/* Description: Receiver timeout */
++
++/* Bit 0 : Receiver timeout */
++#define UARTE_EVENTS_RXTO_EVENTS_RXTO_Pos (0UL) /*!< Position of EVENTS_RXTO field. */
++#define UARTE_EVENTS_RXTO_EVENTS_RXTO_Msk (0x1UL << UARTE_EVENTS_RXTO_EVENTS_RXTO_Pos) /*!< Bit mask of EVENTS_RXTO field. */
++#define UARTE_EVENTS_RXTO_EVENTS_RXTO_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_RXTO_EVENTS_RXTO_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_RXSTARTED */
++/* Description: UART receiver has started */
++
++/* Bit 0 : UART receiver has started */
++#define UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos (0UL) /*!< Position of EVENTS_RXSTARTED field. */
++#define UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Msk (0x1UL << UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Pos) /*!< Bit mask of EVENTS_RXSTARTED field. */
++#define UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_RXSTARTED_EVENTS_RXSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_TXSTARTED */
++/* Description: UART transmitter has started */
++
++/* Bit 0 : UART transmitter has started */
++#define UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos (0UL) /*!< Position of EVENTS_TXSTARTED field. */
++#define UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Msk (0x1UL << UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Pos) /*!< Bit mask of EVENTS_TXSTARTED field. */
++#define UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_TXSTARTED_EVENTS_TXSTARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_EVENTS_TXSTOPPED */
++/* Description: Transmitter stopped */
++
++/* Bit 0 : Transmitter stopped */
++#define UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Pos (0UL) /*!< Position of EVENTS_TXSTOPPED field. */
++#define UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Msk (0x1UL << UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Pos) /*!< Bit mask of EVENTS_TXSTOPPED field. */
++#define UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_NotGenerated (0UL) /*!< Event not generated */
++#define UARTE_EVENTS_TXSTOPPED_EVENTS_TXSTOPPED_Generated (1UL) /*!< Event generated */
++
++/* Register: UARTE_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 6 : Shortcut between event ENDRX and task STOPRX */
++#define UARTE_SHORTS_ENDRX_STOPRX_Pos (6UL) /*!< Position of ENDRX_STOPRX field. */
++#define UARTE_SHORTS_ENDRX_STOPRX_Msk (0x1UL << UARTE_SHORTS_ENDRX_STOPRX_Pos) /*!< Bit mask of ENDRX_STOPRX field. */
++#define UARTE_SHORTS_ENDRX_STOPRX_Disabled (0UL) /*!< Disable shortcut */
++#define UARTE_SHORTS_ENDRX_STOPRX_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 5 : Shortcut between event ENDRX and task STARTRX */
++#define UARTE_SHORTS_ENDRX_STARTRX_Pos (5UL) /*!< Position of ENDRX_STARTRX field. */
++#define UARTE_SHORTS_ENDRX_STARTRX_Msk (0x1UL << UARTE_SHORTS_ENDRX_STARTRX_Pos) /*!< Bit mask of ENDRX_STARTRX field. */
++#define UARTE_SHORTS_ENDRX_STARTRX_Disabled (0UL) /*!< Disable shortcut */
++#define UARTE_SHORTS_ENDRX_STARTRX_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: UARTE_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 22 : Enable or disable interrupt for event TXSTOPPED */
++#define UARTE_INTEN_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
++#define UARTE_INTEN_TXSTOPPED_Msk (0x1UL << UARTE_INTEN_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
++#define UARTE_INTEN_TXSTOPPED_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_TXSTOPPED_Enabled (1UL) /*!< Enable */
++
++/* Bit 20 : Enable or disable interrupt for event TXSTARTED */
++#define UARTE_INTEN_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define UARTE_INTEN_TXSTARTED_Msk (0x1UL << UARTE_INTEN_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define UARTE_INTEN_TXSTARTED_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_TXSTARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 19 : Enable or disable interrupt for event RXSTARTED */
++#define UARTE_INTEN_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define UARTE_INTEN_RXSTARTED_Msk (0x1UL << UARTE_INTEN_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define UARTE_INTEN_RXSTARTED_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_RXSTARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 17 : Enable or disable interrupt for event RXTO */
++#define UARTE_INTEN_RXTO_Pos (17UL) /*!< Position of RXTO field. */
++#define UARTE_INTEN_RXTO_Msk (0x1UL << UARTE_INTEN_RXTO_Pos) /*!< Bit mask of RXTO field. */
++#define UARTE_INTEN_RXTO_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_RXTO_Enabled (1UL) /*!< Enable */
++
++/* Bit 9 : Enable or disable interrupt for event ERROR */
++#define UARTE_INTEN_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define UARTE_INTEN_ERROR_Msk (0x1UL << UARTE_INTEN_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define UARTE_INTEN_ERROR_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_ERROR_Enabled (1UL) /*!< Enable */
++
++/* Bit 8 : Enable or disable interrupt for event ENDTX */
++#define UARTE_INTEN_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
++#define UARTE_INTEN_ENDTX_Msk (0x1UL << UARTE_INTEN_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
++#define UARTE_INTEN_ENDTX_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_ENDTX_Enabled (1UL) /*!< Enable */
++
++/* Bit 7 : Enable or disable interrupt for event TXDRDY */
++#define UARTE_INTEN_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
++#define UARTE_INTEN_TXDRDY_Msk (0x1UL << UARTE_INTEN_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
++#define UARTE_INTEN_TXDRDY_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_TXDRDY_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable interrupt for event ENDRX */
++#define UARTE_INTEN_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
++#define UARTE_INTEN_ENDRX_Msk (0x1UL << UARTE_INTEN_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define UARTE_INTEN_ENDRX_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_ENDRX_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event RXDRDY */
++#define UARTE_INTEN_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
++#define UARTE_INTEN_RXDRDY_Msk (0x1UL << UARTE_INTEN_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
++#define UARTE_INTEN_RXDRDY_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_RXDRDY_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event NCTS */
++#define UARTE_INTEN_NCTS_Pos (1UL) /*!< Position of NCTS field. */
++#define UARTE_INTEN_NCTS_Msk (0x1UL << UARTE_INTEN_NCTS_Pos) /*!< Bit mask of NCTS field. */
++#define UARTE_INTEN_NCTS_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_NCTS_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event CTS */
++#define UARTE_INTEN_CTS_Pos (0UL) /*!< Position of CTS field. */
++#define UARTE_INTEN_CTS_Msk (0x1UL << UARTE_INTEN_CTS_Pos) /*!< Bit mask of CTS field. */
++#define UARTE_INTEN_CTS_Disabled (0UL) /*!< Disable */
++#define UARTE_INTEN_CTS_Enabled (1UL) /*!< Enable */
++
++/* Register: UARTE_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 22 : Write '1' to enable interrupt for event TXSTOPPED */
++#define UARTE_INTENSET_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
++#define UARTE_INTENSET_TXSTOPPED_Msk (0x1UL << UARTE_INTENSET_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
++#define UARTE_INTENSET_TXSTOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_TXSTOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_TXSTOPPED_Set (1UL) /*!< Enable */
++
++/* Bit 20 : Write '1' to enable interrupt for event TXSTARTED */
++#define UARTE_INTENSET_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define UARTE_INTENSET_TXSTARTED_Msk (0x1UL << UARTE_INTENSET_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define UARTE_INTENSET_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_TXSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 19 : Write '1' to enable interrupt for event RXSTARTED */
++#define UARTE_INTENSET_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define UARTE_INTENSET_RXSTARTED_Msk (0x1UL << UARTE_INTENSET_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define UARTE_INTENSET_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_RXSTARTED_Set (1UL) /*!< Enable */
++
++/* Bit 17 : Write '1' to enable interrupt for event RXTO */
++#define UARTE_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
++#define UARTE_INTENSET_RXTO_Msk (0x1UL << UARTE_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
++#define UARTE_INTENSET_RXTO_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_RXTO_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_RXTO_Set (1UL) /*!< Enable */
++
++/* Bit 9 : Write '1' to enable interrupt for event ERROR */
++#define UARTE_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define UARTE_INTENSET_ERROR_Msk (0x1UL << UARTE_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define UARTE_INTENSET_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_ERROR_Set (1UL) /*!< Enable */
++
++/* Bit 8 : Write '1' to enable interrupt for event ENDTX */
++#define UARTE_INTENSET_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
++#define UARTE_INTENSET_ENDTX_Msk (0x1UL << UARTE_INTENSET_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
++#define UARTE_INTENSET_ENDTX_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_ENDTX_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_ENDTX_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event TXDRDY */
++#define UARTE_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
++#define UARTE_INTENSET_TXDRDY_Msk (0x1UL << UARTE_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
++#define UARTE_INTENSET_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_TXDRDY_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event ENDRX */
++#define UARTE_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
++#define UARTE_INTENSET_ENDRX_Msk (0x1UL << UARTE_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define UARTE_INTENSET_ENDRX_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_ENDRX_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_ENDRX_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event RXDRDY */
++#define UARTE_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
++#define UARTE_INTENSET_RXDRDY_Msk (0x1UL << UARTE_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
++#define UARTE_INTENSET_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_RXDRDY_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event NCTS */
++#define UARTE_INTENSET_NCTS_Pos (1UL) /*!< Position of NCTS field. */
++#define UARTE_INTENSET_NCTS_Msk (0x1UL << UARTE_INTENSET_NCTS_Pos) /*!< Bit mask of NCTS field. */
++#define UARTE_INTENSET_NCTS_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_NCTS_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_NCTS_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event CTS */
++#define UARTE_INTENSET_CTS_Pos (0UL) /*!< Position of CTS field. */
++#define UARTE_INTENSET_CTS_Msk (0x1UL << UARTE_INTENSET_CTS_Pos) /*!< Bit mask of CTS field. */
++#define UARTE_INTENSET_CTS_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENSET_CTS_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENSET_CTS_Set (1UL) /*!< Enable */
++
++/* Register: UARTE_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 22 : Write '1' to disable interrupt for event TXSTOPPED */
++#define UARTE_INTENCLR_TXSTOPPED_Pos (22UL) /*!< Position of TXSTOPPED field. */
++#define UARTE_INTENCLR_TXSTOPPED_Msk (0x1UL << UARTE_INTENCLR_TXSTOPPED_Pos) /*!< Bit mask of TXSTOPPED field. */
++#define UARTE_INTENCLR_TXSTOPPED_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_TXSTOPPED_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_TXSTOPPED_Clear (1UL) /*!< Disable */
++
++/* Bit 20 : Write '1' to disable interrupt for event TXSTARTED */
++#define UARTE_INTENCLR_TXSTARTED_Pos (20UL) /*!< Position of TXSTARTED field. */
++#define UARTE_INTENCLR_TXSTARTED_Msk (0x1UL << UARTE_INTENCLR_TXSTARTED_Pos) /*!< Bit mask of TXSTARTED field. */
++#define UARTE_INTENCLR_TXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_TXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_TXSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 19 : Write '1' to disable interrupt for event RXSTARTED */
++#define UARTE_INTENCLR_RXSTARTED_Pos (19UL) /*!< Position of RXSTARTED field. */
++#define UARTE_INTENCLR_RXSTARTED_Msk (0x1UL << UARTE_INTENCLR_RXSTARTED_Pos) /*!< Bit mask of RXSTARTED field. */
++#define UARTE_INTENCLR_RXSTARTED_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_RXSTARTED_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_RXSTARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 17 : Write '1' to disable interrupt for event RXTO */
++#define UARTE_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
++#define UARTE_INTENCLR_RXTO_Msk (0x1UL << UARTE_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
++#define UARTE_INTENCLR_RXTO_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_RXTO_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_RXTO_Clear (1UL) /*!< Disable */
++
++/* Bit 9 : Write '1' to disable interrupt for event ERROR */
++#define UARTE_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
++#define UARTE_INTENCLR_ERROR_Msk (0x1UL << UARTE_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
++#define UARTE_INTENCLR_ERROR_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_ERROR_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_ERROR_Clear (1UL) /*!< Disable */
++
++/* Bit 8 : Write '1' to disable interrupt for event ENDTX */
++#define UARTE_INTENCLR_ENDTX_Pos (8UL) /*!< Position of ENDTX field. */
++#define UARTE_INTENCLR_ENDTX_Msk (0x1UL << UARTE_INTENCLR_ENDTX_Pos) /*!< Bit mask of ENDTX field. */
++#define UARTE_INTENCLR_ENDTX_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_ENDTX_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_ENDTX_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event TXDRDY */
++#define UARTE_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
++#define UARTE_INTENCLR_TXDRDY_Msk (0x1UL << UARTE_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
++#define UARTE_INTENCLR_TXDRDY_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_TXDRDY_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event ENDRX */
++#define UARTE_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
++#define UARTE_INTENCLR_ENDRX_Msk (0x1UL << UARTE_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
++#define UARTE_INTENCLR_ENDRX_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_ENDRX_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_ENDRX_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event RXDRDY */
++#define UARTE_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
++#define UARTE_INTENCLR_RXDRDY_Msk (0x1UL << UARTE_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
++#define UARTE_INTENCLR_RXDRDY_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_RXDRDY_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event NCTS */
++#define UARTE_INTENCLR_NCTS_Pos (1UL) /*!< Position of NCTS field. */
++#define UARTE_INTENCLR_NCTS_Msk (0x1UL << UARTE_INTENCLR_NCTS_Pos) /*!< Bit mask of NCTS field. */
++#define UARTE_INTENCLR_NCTS_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_NCTS_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_NCTS_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event CTS */
++#define UARTE_INTENCLR_CTS_Pos (0UL) /*!< Position of CTS field. */
++#define UARTE_INTENCLR_CTS_Msk (0x1UL << UARTE_INTENCLR_CTS_Pos) /*!< Bit mask of CTS field. */
++#define UARTE_INTENCLR_CTS_Disabled (0UL) /*!< Read: Disabled */
++#define UARTE_INTENCLR_CTS_Enabled (1UL) /*!< Read: Enabled */
++#define UARTE_INTENCLR_CTS_Clear (1UL) /*!< Disable */
++
++/* Register: UARTE_ERRORSRC */
++/* Description: Error source This register is read/write one to clear. */
++
++/* Bit 3 : Break condition */
++#define UARTE_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
++#define UARTE_ERRORSRC_BREAK_Msk (0x1UL << UARTE_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
++#define UARTE_ERRORSRC_BREAK_NotPresent (0UL) /*!< Read: error not present */
++#define UARTE_ERRORSRC_BREAK_Present (1UL) /*!< Read: error present */
++
++/* Bit 2 : Framing error occurred */
++#define UARTE_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
++#define UARTE_ERRORSRC_FRAMING_Msk (0x1UL << UARTE_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
++#define UARTE_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Read: error not present */
++#define UARTE_ERRORSRC_FRAMING_Present (1UL) /*!< Read: error present */
++
++/* Bit 1 : Parity error */
++#define UARTE_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
++#define UARTE_ERRORSRC_PARITY_Msk (0x1UL << UARTE_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
++#define UARTE_ERRORSRC_PARITY_NotPresent (0UL) /*!< Read: error not present */
++#define UARTE_ERRORSRC_PARITY_Present (1UL) /*!< Read: error present */
++
++/* Bit 0 : Overrun error */
++#define UARTE_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
++#define UARTE_ERRORSRC_OVERRUN_Msk (0x1UL << UARTE_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
++#define UARTE_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Read: error not present */
++#define UARTE_ERRORSRC_OVERRUN_Present (1UL) /*!< Read: error present */
++
++/* Register: UARTE_ENABLE */
++/* Description: Enable UART */
++
++/* Bits 3..0 : Enable or disable UARTE */
++#define UARTE_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define UARTE_ENABLE_ENABLE_Msk (0xFUL << UARTE_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define UARTE_ENABLE_ENABLE_Disabled (0UL) /*!< Disable UARTE */
++#define UARTE_ENABLE_ENABLE_Enabled (8UL) /*!< Enable UARTE */
++
++/* Register: UARTE_PSEL_RTS */
++/* Description: Pin select for RTS signal */
++
++/* Bit 31 : Connection */
++#define UARTE_PSEL_RTS_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UARTE_PSEL_RTS_CONNECT_Msk (0x1UL << UARTE_PSEL_RTS_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UARTE_PSEL_RTS_CONNECT_Connected (0UL) /*!< Connect */
++#define UARTE_PSEL_RTS_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define UARTE_PSEL_RTS_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UARTE_PSEL_RTS_PORT_Msk (0x1UL << UARTE_PSEL_RTS_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define UARTE_PSEL_RTS_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UARTE_PSEL_RTS_PIN_Msk (0x1FUL << UARTE_PSEL_RTS_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UARTE_PSEL_TXD */
++/* Description: Pin select for TXD signal */
++
++/* Bit 31 : Connection */
++#define UARTE_PSEL_TXD_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UARTE_PSEL_TXD_CONNECT_Msk (0x1UL << UARTE_PSEL_TXD_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UARTE_PSEL_TXD_CONNECT_Connected (0UL) /*!< Connect */
++#define UARTE_PSEL_TXD_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define UARTE_PSEL_TXD_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UARTE_PSEL_TXD_PORT_Msk (0x1UL << UARTE_PSEL_TXD_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define UARTE_PSEL_TXD_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UARTE_PSEL_TXD_PIN_Msk (0x1FUL << UARTE_PSEL_TXD_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UARTE_PSEL_CTS */
++/* Description: Pin select for CTS signal */
++
++/* Bit 31 : Connection */
++#define UARTE_PSEL_CTS_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UARTE_PSEL_CTS_CONNECT_Msk (0x1UL << UARTE_PSEL_CTS_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UARTE_PSEL_CTS_CONNECT_Connected (0UL) /*!< Connect */
++#define UARTE_PSEL_CTS_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define UARTE_PSEL_CTS_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UARTE_PSEL_CTS_PORT_Msk (0x1UL << UARTE_PSEL_CTS_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define UARTE_PSEL_CTS_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UARTE_PSEL_CTS_PIN_Msk (0x1FUL << UARTE_PSEL_CTS_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UARTE_PSEL_RXD */
++/* Description: Pin select for RXD signal */
++
++/* Bit 31 : Connection */
++#define UARTE_PSEL_RXD_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UARTE_PSEL_RXD_CONNECT_Msk (0x1UL << UARTE_PSEL_RXD_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UARTE_PSEL_RXD_CONNECT_Connected (0UL) /*!< Connect */
++#define UARTE_PSEL_RXD_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number */
++#define UARTE_PSEL_RXD_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UARTE_PSEL_RXD_PORT_Msk (0x1UL << UARTE_PSEL_RXD_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : Pin number */
++#define UARTE_PSEL_RXD_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UARTE_PSEL_RXD_PIN_Msk (0x1FUL << UARTE_PSEL_RXD_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UARTE_BAUDRATE */
++/* Description: Baud rate. Accuracy depends on the HFCLK source selected. */
++
++/* Bits 31..0 : Baud rate */
++#define UARTE_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
++#define UARTE_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UARTE_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
++#define UARTE_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud (actual rate: 1205) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud (actual rate: 2396) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud (actual rate: 4808) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud (actual rate: 9598) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud14400 (0x003AF000UL) /*!< 14400 baud (actual rate: 14401) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud (actual rate: 19208) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud28800 (0x0075C000UL) /*!< 28800 baud (actual rate: 28777) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud31250 (0x00800000UL) /*!< 31250 baud */
++#define UARTE_BAUDRATE_BAUDRATE_Baud38400 (0x009D0000UL) /*!< 38400 baud (actual rate: 38369) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud56000 (0x00E50000UL) /*!< 56000 baud (actual rate: 55944) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud57600 (0x00EB0000UL) /*!< 57600 baud (actual rate: 57554) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud (actual rate: 76923) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud115200 (0x01D60000UL) /*!< 115200 baud (actual rate: 115108) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud230400 (0x03B00000UL) /*!< 230400 baud (actual rate: 231884) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud */
++#define UARTE_BAUDRATE_BAUDRATE_Baud460800 (0x07400000UL) /*!< 460800 baud (actual rate: 457143) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud921600 (0x0F000000UL) /*!< 921600 baud (actual rate: 941176) */
++#define UARTE_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1 megabaud */
++
++/* Register: UARTE_RXD_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define UARTE_RXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define UARTE_RXD_PTR_PTR_Msk (0xFFFFFFFFUL << UARTE_RXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: UARTE_RXD_MAXCNT */
++/* Description: Maximum number of bytes in receive buffer */
++
++/* Bits 15..0 : Maximum number of bytes in receive buffer */
++#define UARTE_RXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define UARTE_RXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << UARTE_RXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: UARTE_RXD_AMOUNT */
++/* Description: Number of bytes transferred in the last transaction */
++
++/* Bits 15..0 : Number of bytes transferred in the last transaction */
++#define UARTE_RXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define UARTE_RXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << UARTE_RXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: UARTE_TXD_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define UARTE_TXD_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define UARTE_TXD_PTR_PTR_Msk (0xFFFFFFFFUL << UARTE_TXD_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: UARTE_TXD_MAXCNT */
++/* Description: Maximum number of bytes in transmit buffer */
++
++/* Bits 15..0 : Maximum number of bytes in transmit buffer */
++#define UARTE_TXD_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define UARTE_TXD_MAXCNT_MAXCNT_Msk (0xFFFFUL << UARTE_TXD_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: UARTE_TXD_AMOUNT */
++/* Description: Number of bytes transferred in the last transaction */
++
++/* Bits 15..0 : Number of bytes transferred in the last transaction */
++#define UARTE_TXD_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define UARTE_TXD_AMOUNT_AMOUNT_Msk (0xFFFFUL << UARTE_TXD_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: UARTE_CONFIG */
++/* Description: Configuration of parity and hardware flow control */
++
++/* Bit 4 : Stop bits */
++#define UARTE_CONFIG_STOP_Pos (4UL) /*!< Position of STOP field. */
++#define UARTE_CONFIG_STOP_Msk (0x1UL << UARTE_CONFIG_STOP_Pos) /*!< Bit mask of STOP field. */
++#define UARTE_CONFIG_STOP_One (0UL) /*!< One stop bit */
++#define UARTE_CONFIG_STOP_Two (1UL) /*!< Two stop bits */
++
++/* Bits 3..1 : Parity */
++#define UARTE_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
++#define UARTE_CONFIG_PARITY_Msk (0x7UL << UARTE_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
++#define UARTE_CONFIG_PARITY_Excluded (0x0UL) /*!< Exclude parity bit */
++#define UARTE_CONFIG_PARITY_Included (0x7UL) /*!< Include even parity bit */
++
++/* Bit 0 : Hardware flow control */
++#define UARTE_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
++#define UARTE_CONFIG_HWFC_Msk (0x1UL << UARTE_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
++#define UARTE_CONFIG_HWFC_Disabled (0UL) /*!< Disabled */
++#define UARTE_CONFIG_HWFC_Enabled (1UL) /*!< Enabled */
++
++
++/* Peripheral: UICR */
++/* Description: User information configuration registers */
++
++/* Register: UICR_NRFFW */
++/* Description: Description collection: Reserved for Nordic firmware design */
++
++/* Bits 31..0 : Reserved for Nordic firmware design */
++#define UICR_NRFFW_NRFFW_Pos (0UL) /*!< Position of NRFFW field. */
++#define UICR_NRFFW_NRFFW_Msk (0xFFFFFFFFUL << UICR_NRFFW_NRFFW_Pos) /*!< Bit mask of NRFFW field. */
++
++/* Register: UICR_NRFHW */
++/* Description: Description collection: Reserved for Nordic hardware design */
++
++/* Bits 31..0 : Reserved for Nordic hardware design */
++#define UICR_NRFHW_NRFHW_Pos (0UL) /*!< Position of NRFHW field. */
++#define UICR_NRFHW_NRFHW_Msk (0xFFFFFFFFUL << UICR_NRFHW_NRFHW_Pos) /*!< Bit mask of NRFHW field. */
++
++/* Register: UICR_CUSTOMER */
++/* Description: Description collection: Reserved for customer */
++
++/* Bits 31..0 : Reserved for customer */
++#define UICR_CUSTOMER_CUSTOMER_Pos (0UL) /*!< Position of CUSTOMER field. */
++#define UICR_CUSTOMER_CUSTOMER_Msk (0xFFFFFFFFUL << UICR_CUSTOMER_CUSTOMER_Pos) /*!< Bit mask of CUSTOMER field. */
++
++/* Register: UICR_PSELRESET */
++/* Description: Description collection: Mapping of the nRESET function (see POWER chapter for details) */
++
++/* Bit 31 : Connection */
++#define UICR_PSELRESET_CONNECT_Pos (31UL) /*!< Position of CONNECT field. */
++#define UICR_PSELRESET_CONNECT_Msk (0x1UL << UICR_PSELRESET_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define UICR_PSELRESET_CONNECT_Connected (0UL) /*!< Connect */
++#define UICR_PSELRESET_CONNECT_Disconnected (1UL) /*!< Disconnect */
++
++/* Bit 5 : Port number onto which nRESET is exposed */
++#define UICR_PSELRESET_PORT_Pos (5UL) /*!< Position of PORT field. */
++#define UICR_PSELRESET_PORT_Msk (0x1UL << UICR_PSELRESET_PORT_Pos) /*!< Bit mask of PORT field. */
++
++/* Bits 4..0 : GPIO pin number onto which nRESET is exposed */
++#define UICR_PSELRESET_PIN_Pos (0UL) /*!< Position of PIN field. */
++#define UICR_PSELRESET_PIN_Msk (0x1FUL << UICR_PSELRESET_PIN_Pos) /*!< Bit mask of PIN field. */
++
++/* Register: UICR_APPROTECT */
++/* Description: Access port protection */
++
++/* Bits 7..0 : Enable or disable access port protection. */
++#define UICR_APPROTECT_PALL_Pos (0UL) /*!< Position of PALL field. */
++#define UICR_APPROTECT_PALL_Msk (0xFFUL << UICR_APPROTECT_PALL_Pos) /*!< Bit mask of PALL field. */
++#define UICR_APPROTECT_PALL_Enabled (0x00UL) /*!< Enable */
++#define UICR_APPROTECT_PALL_HwDisabled (0x5AUL) /*!< Hardware disable of access port protection for devices where access port protection is controlled by hardware and software */
++#define UICR_APPROTECT_PALL_Disabled (0xFFUL) /*!< Hardware disable of access port protection for devices where access port protection is controlled by hardware */
++
++/* Register: UICR_NFCPINS */
++/* Description: Setting of pins dedicated to NFC functionality: NFC antenna or GPIO */
++
++/* Bit 0 : Setting of pins dedicated to NFC functionality */
++#define UICR_NFCPINS_PROTECT_Pos (0UL) /*!< Position of PROTECT field. */
++#define UICR_NFCPINS_PROTECT_Msk (0x1UL << UICR_NFCPINS_PROTECT_Pos) /*!< Bit mask of PROTECT field. */
++#define UICR_NFCPINS_PROTECT_Disabled (0UL) /*!< Operation as GPIO pins. Same protection as normal GPIO pins. */
++#define UICR_NFCPINS_PROTECT_NFC (1UL) /*!< Operation as NFC antenna pins. Configures the protection for NFC operation. */
++
++/* Register: UICR_DEBUGCTRL */
++/* Description: Processor debug control */
++
++/* Bits 15..8 : Configure CPU flash patch and breakpoint (FPB) unit behavior */
++#define UICR_DEBUGCTRL_CPUFPBEN_Pos (8UL) /*!< Position of CPUFPBEN field. */
++#define UICR_DEBUGCTRL_CPUFPBEN_Msk (0xFFUL << UICR_DEBUGCTRL_CPUFPBEN_Pos) /*!< Bit mask of CPUFPBEN field. */
++#define UICR_DEBUGCTRL_CPUFPBEN_Disabled (0x00UL) /*!< Disable CPU FPB unit. Writes into the FPB registers will be ignored. */
++#define UICR_DEBUGCTRL_CPUFPBEN_Enabled (0xFFUL) /*!< Enable CPU FPB unit (default behavior) */
++
++/* Bits 7..0 : Configure CPU non-intrusive debug features */
++#define UICR_DEBUGCTRL_CPUNIDEN_Pos (0UL) /*!< Position of CPUNIDEN field. */
++#define UICR_DEBUGCTRL_CPUNIDEN_Msk (0xFFUL << UICR_DEBUGCTRL_CPUNIDEN_Pos) /*!< Bit mask of CPUNIDEN field. */
++#define UICR_DEBUGCTRL_CPUNIDEN_Disabled (0x00UL) /*!< Disable CPU ITM and ETM functionality */
++#define UICR_DEBUGCTRL_CPUNIDEN_Enabled (0xFFUL) /*!< Enable CPU ITM and ETM functionality (default behavior) */
++
++/* Register: UICR_REGOUT0 */
++/* Description: Output voltage from REG0 regulator stage. The maximum output voltage from this stage is given as VDDH - V_VDDH-VDD. */
++
++/* Bits 2..0 : Output voltage from REG0 regulator stage. */
++#define UICR_REGOUT0_VOUT_Pos (0UL) /*!< Position of VOUT field. */
++#define UICR_REGOUT0_VOUT_Msk (0x7UL << UICR_REGOUT0_VOUT_Pos) /*!< Bit mask of VOUT field. */
++#define UICR_REGOUT0_VOUT_1V8 (0UL) /*!< 1.8 V */
++#define UICR_REGOUT0_VOUT_2V1 (1UL) /*!< 2.1 V */
++#define UICR_REGOUT0_VOUT_2V4 (2UL) /*!< 2.4 V */
++#define UICR_REGOUT0_VOUT_2V7 (3UL) /*!< 2.7 V */
++#define UICR_REGOUT0_VOUT_3V0 (4UL) /*!< 3.0 V */
++#define UICR_REGOUT0_VOUT_3V3 (5UL) /*!< 3.3 V */
++#define UICR_REGOUT0_VOUT_DEFAULT (7UL) /*!< Default voltage: 1.8 V */
++
++
++/* Peripheral: USBD */
++/* Description: Universal serial bus device */
++
++/* Register: USBD_TASKS_STARTEPIN */
++/* Description: Description collection: Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host */
++
++/* Bit 0 : Captures the EPIN[n].PTR and EPIN[n].MAXCNT registers values, and enables endpoint IN n to respond to traffic from host */
++#define USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Pos (0UL) /*!< Position of TASKS_STARTEPIN field. */
++#define USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Msk (0x1UL << USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Pos) /*!< Bit mask of TASKS_STARTEPIN field. */
++#define USBD_TASKS_STARTEPIN_TASKS_STARTEPIN_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_TASKS_STARTISOIN */
++/* Description: Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint */
++
++/* Bit 0 : Captures the ISOIN.PTR and ISOIN.MAXCNT registers values, and enables sending data on ISO endpoint */
++#define USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Pos (0UL) /*!< Position of TASKS_STARTISOIN field. */
++#define USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Msk (0x1UL << USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Pos) /*!< Bit mask of TASKS_STARTISOIN field. */
++#define USBD_TASKS_STARTISOIN_TASKS_STARTISOIN_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_TASKS_STARTEPOUT */
++/* Description: Description collection: Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host */
++
++/* Bit 0 : Captures the EPOUT[n].PTR and EPOUT[n].MAXCNT registers values, and enables endpoint n to respond to traffic from host */
++#define USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Pos (0UL) /*!< Position of TASKS_STARTEPOUT field. */
++#define USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Msk (0x1UL << USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Pos) /*!< Bit mask of TASKS_STARTEPOUT field. */
++#define USBD_TASKS_STARTEPOUT_TASKS_STARTEPOUT_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_TASKS_STARTISOOUT */
++/* Description: Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint */
++
++/* Bit 0 : Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers values, and enables receiving of data on ISO endpoint */
++#define USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Pos (0UL) /*!< Position of TASKS_STARTISOOUT field. */
++#define USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Msk (0x1UL << USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Pos) /*!< Bit mask of TASKS_STARTISOOUT field. */
++#define USBD_TASKS_STARTISOOUT_TASKS_STARTISOOUT_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_TASKS_EP0RCVOUT */
++/* Description: Allows OUT data stage on control endpoint 0 */
++
++/* Bit 0 : Allows OUT data stage on control endpoint 0 */
++#define USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Pos (0UL) /*!< Position of TASKS_EP0RCVOUT field. */
++#define USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Msk (0x1UL << USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Pos) /*!< Bit mask of TASKS_EP0RCVOUT field. */
++#define USBD_TASKS_EP0RCVOUT_TASKS_EP0RCVOUT_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_TASKS_EP0STATUS */
++/* Description: Allows status stage on control endpoint 0 */
++
++/* Bit 0 : Allows status stage on control endpoint 0 */
++#define USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Pos (0UL) /*!< Position of TASKS_EP0STATUS field. */
++#define USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Msk (0x1UL << USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Pos) /*!< Bit mask of TASKS_EP0STATUS field. */
++#define USBD_TASKS_EP0STATUS_TASKS_EP0STATUS_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_TASKS_EP0STALL */
++/* Description: Stalls data and status stage on control endpoint 0 */
++
++/* Bit 0 : Stalls data and status stage on control endpoint 0 */
++#define USBD_TASKS_EP0STALL_TASKS_EP0STALL_Pos (0UL) /*!< Position of TASKS_EP0STALL field. */
++#define USBD_TASKS_EP0STALL_TASKS_EP0STALL_Msk (0x1UL << USBD_TASKS_EP0STALL_TASKS_EP0STALL_Pos) /*!< Bit mask of TASKS_EP0STALL field. */
++#define USBD_TASKS_EP0STALL_TASKS_EP0STALL_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_TASKS_DPDMDRIVE */
++/* Description: Forces D+ and D- lines into the state defined in the DPDMVALUE register */
++
++/* Bit 0 : Forces D+ and D- lines into the state defined in the DPDMVALUE register */
++#define USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Pos (0UL) /*!< Position of TASKS_DPDMDRIVE field. */
++#define USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Msk (0x1UL << USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Pos) /*!< Bit mask of TASKS_DPDMDRIVE field. */
++#define USBD_TASKS_DPDMDRIVE_TASKS_DPDMDRIVE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_TASKS_DPDMNODRIVE */
++/* Description: Stops forcing D+ and D- lines into any state (USB engine takes control) */
++
++/* Bit 0 : Stops forcing D+ and D- lines into any state (USB engine takes control) */
++#define USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Pos (0UL) /*!< Position of TASKS_DPDMNODRIVE field. */
++#define USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Msk (0x1UL << USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Pos) /*!< Bit mask of TASKS_DPDMNODRIVE field. */
++#define USBD_TASKS_DPDMNODRIVE_TASKS_DPDMNODRIVE_Trigger (1UL) /*!< Trigger task */
++
++/* Register: USBD_EVENTS_USBRESET */
++/* Description: Signals that a USB reset condition has been detected on USB lines */
++
++/* Bit 0 : Signals that a USB reset condition has been detected on USB lines */
++#define USBD_EVENTS_USBRESET_EVENTS_USBRESET_Pos (0UL) /*!< Position of EVENTS_USBRESET field. */
++#define USBD_EVENTS_USBRESET_EVENTS_USBRESET_Msk (0x1UL << USBD_EVENTS_USBRESET_EVENTS_USBRESET_Pos) /*!< Bit mask of EVENTS_USBRESET field. */
++#define USBD_EVENTS_USBRESET_EVENTS_USBRESET_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_USBRESET_EVENTS_USBRESET_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_STARTED */
++/* Description: Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register */
++
++/* Bit 0 : Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT, or EPOUT[n].PTR and EPOUT[n].MAXCNT registers have been captured on all endpoints reported in the EPSTATUS register */
++#define USBD_EVENTS_STARTED_EVENTS_STARTED_Pos (0UL) /*!< Position of EVENTS_STARTED field. */
++#define USBD_EVENTS_STARTED_EVENTS_STARTED_Msk (0x1UL << USBD_EVENTS_STARTED_EVENTS_STARTED_Pos) /*!< Bit mask of EVENTS_STARTED field. */
++#define USBD_EVENTS_STARTED_EVENTS_STARTED_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_STARTED_EVENTS_STARTED_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_ENDEPIN */
++/* Description: Description collection: The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software. */
++
++/* Bit 0 : The whole EPIN[n] buffer has been consumed. The buffer can be accessed safely by software. */
++#define USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Pos (0UL) /*!< Position of EVENTS_ENDEPIN field. */
++#define USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Msk (0x1UL << USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Pos) /*!< Bit mask of EVENTS_ENDEPIN field. */
++#define USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_ENDEPIN_EVENTS_ENDEPIN_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_EP0DATADONE */
++/* Description: An acknowledged data transfer has taken place on the control endpoint */
++
++/* Bit 0 : An acknowledged data transfer has taken place on the control endpoint */
++#define USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Pos (0UL) /*!< Position of EVENTS_EP0DATADONE field. */
++#define USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Msk (0x1UL << USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Pos) /*!< Bit mask of EVENTS_EP0DATADONE field. */
++#define USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_EP0DATADONE_EVENTS_EP0DATADONE_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_ENDISOIN */
++/* Description: The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software. */
++
++/* Bit 0 : The whole ISOIN buffer has been consumed. The buffer can be accessed safely by software. */
++#define USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Pos (0UL) /*!< Position of EVENTS_ENDISOIN field. */
++#define USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Msk (0x1UL << USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Pos) /*!< Bit mask of EVENTS_ENDISOIN field. */
++#define USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_ENDISOIN_EVENTS_ENDISOIN_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_ENDEPOUT */
++/* Description: Description collection: The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software. */
++
++/* Bit 0 : The whole EPOUT[n] buffer has been consumed. The buffer can be accessed safely by software. */
++#define USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Pos (0UL) /*!< Position of EVENTS_ENDEPOUT field. */
++#define USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Msk (0x1UL << USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Pos) /*!< Bit mask of EVENTS_ENDEPOUT field. */
++#define USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_ENDEPOUT_EVENTS_ENDEPOUT_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_ENDISOOUT */
++/* Description: The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software. */
++
++/* Bit 0 : The whole ISOOUT buffer has been consumed. The buffer can be accessed safely by software. */
++#define USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Pos (0UL) /*!< Position of EVENTS_ENDISOOUT field. */
++#define USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Msk (0x1UL << USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Pos) /*!< Bit mask of EVENTS_ENDISOOUT field. */
++#define USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_ENDISOOUT_EVENTS_ENDISOOUT_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_SOF */
++/* Description: Signals that a SOF (start of frame) condition has been detected on USB lines */
++
++/* Bit 0 : Signals that a SOF (start of frame) condition has been detected on USB lines */
++#define USBD_EVENTS_SOF_EVENTS_SOF_Pos (0UL) /*!< Position of EVENTS_SOF field. */
++#define USBD_EVENTS_SOF_EVENTS_SOF_Msk (0x1UL << USBD_EVENTS_SOF_EVENTS_SOF_Pos) /*!< Bit mask of EVENTS_SOF field. */
++#define USBD_EVENTS_SOF_EVENTS_SOF_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_SOF_EVENTS_SOF_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_USBEVENT */
++/* Description: An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause. */
++
++/* Bit 0 : An event or an error not covered by specific events has occurred. Check EVENTCAUSE register to find the cause. */
++#define USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Pos (0UL) /*!< Position of EVENTS_USBEVENT field. */
++#define USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Msk (0x1UL << USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Pos) /*!< Bit mask of EVENTS_USBEVENT field. */
++#define USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_USBEVENT_EVENTS_USBEVENT_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_EP0SETUP */
++/* Description: A valid SETUP token has been received (and acknowledged) on the control endpoint */
++
++/* Bit 0 : A valid SETUP token has been received (and acknowledged) on the control endpoint */
++#define USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Pos (0UL) /*!< Position of EVENTS_EP0SETUP field. */
++#define USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Msk (0x1UL << USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Pos) /*!< Bit mask of EVENTS_EP0SETUP field. */
++#define USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_EP0SETUP_EVENTS_EP0SETUP_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_EVENTS_EPDATA */
++/* Description: A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register */
++
++/* Bit 0 : A data transfer has occurred on a data endpoint, indicated by the EPDATASTATUS register */
++#define USBD_EVENTS_EPDATA_EVENTS_EPDATA_Pos (0UL) /*!< Position of EVENTS_EPDATA field. */
++#define USBD_EVENTS_EPDATA_EVENTS_EPDATA_Msk (0x1UL << USBD_EVENTS_EPDATA_EVENTS_EPDATA_Pos) /*!< Bit mask of EVENTS_EPDATA field. */
++#define USBD_EVENTS_EPDATA_EVENTS_EPDATA_NotGenerated (0UL) /*!< Event not generated */
++#define USBD_EVENTS_EPDATA_EVENTS_EPDATA_Generated (1UL) /*!< Event generated */
++
++/* Register: USBD_SHORTS */
++/* Description: Shortcuts between local events and tasks */
++
++/* Bit 4 : Shortcut between event ENDEPOUT[0] and task EP0RCVOUT */
++#define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Pos (4UL) /*!< Position of ENDEPOUT0_EP0RCVOUT field. */
++#define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Msk (0x1UL << USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Pos) /*!< Bit mask of ENDEPOUT0_EP0RCVOUT field. */
++#define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Disabled (0UL) /*!< Disable shortcut */
++#define USBD_SHORTS_ENDEPOUT0_EP0RCVOUT_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 3 : Shortcut between event ENDEPOUT[0] and task EP0STATUS */
++#define USBD_SHORTS_ENDEPOUT0_EP0STATUS_Pos (3UL) /*!< Position of ENDEPOUT0_EP0STATUS field. */
++#define USBD_SHORTS_ENDEPOUT0_EP0STATUS_Msk (0x1UL << USBD_SHORTS_ENDEPOUT0_EP0STATUS_Pos) /*!< Bit mask of ENDEPOUT0_EP0STATUS field. */
++#define USBD_SHORTS_ENDEPOUT0_EP0STATUS_Disabled (0UL) /*!< Disable shortcut */
++#define USBD_SHORTS_ENDEPOUT0_EP0STATUS_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 2 : Shortcut between event EP0DATADONE and task EP0STATUS */
++#define USBD_SHORTS_EP0DATADONE_EP0STATUS_Pos (2UL) /*!< Position of EP0DATADONE_EP0STATUS field. */
++#define USBD_SHORTS_EP0DATADONE_EP0STATUS_Msk (0x1UL << USBD_SHORTS_EP0DATADONE_EP0STATUS_Pos) /*!< Bit mask of EP0DATADONE_EP0STATUS field. */
++#define USBD_SHORTS_EP0DATADONE_EP0STATUS_Disabled (0UL) /*!< Disable shortcut */
++#define USBD_SHORTS_EP0DATADONE_EP0STATUS_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 1 : Shortcut between event EP0DATADONE and task STARTEPOUT[0] */
++#define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Pos (1UL) /*!< Position of EP0DATADONE_STARTEPOUT0 field. */
++#define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Msk (0x1UL << USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Pos) /*!< Bit mask of EP0DATADONE_STARTEPOUT0 field. */
++#define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Disabled (0UL) /*!< Disable shortcut */
++#define USBD_SHORTS_EP0DATADONE_STARTEPOUT0_Enabled (1UL) /*!< Enable shortcut */
++
++/* Bit 0 : Shortcut between event EP0DATADONE and task STARTEPIN[0] */
++#define USBD_SHORTS_EP0DATADONE_STARTEPIN0_Pos (0UL) /*!< Position of EP0DATADONE_STARTEPIN0 field. */
++#define USBD_SHORTS_EP0DATADONE_STARTEPIN0_Msk (0x1UL << USBD_SHORTS_EP0DATADONE_STARTEPIN0_Pos) /*!< Bit mask of EP0DATADONE_STARTEPIN0 field. */
++#define USBD_SHORTS_EP0DATADONE_STARTEPIN0_Disabled (0UL) /*!< Disable shortcut */
++#define USBD_SHORTS_EP0DATADONE_STARTEPIN0_Enabled (1UL) /*!< Enable shortcut */
++
++/* Register: USBD_INTEN */
++/* Description: Enable or disable interrupt */
++
++/* Bit 24 : Enable or disable interrupt for event EPDATA */
++#define USBD_INTEN_EPDATA_Pos (24UL) /*!< Position of EPDATA field. */
++#define USBD_INTEN_EPDATA_Msk (0x1UL << USBD_INTEN_EPDATA_Pos) /*!< Bit mask of EPDATA field. */
++#define USBD_INTEN_EPDATA_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_EPDATA_Enabled (1UL) /*!< Enable */
++
++/* Bit 23 : Enable or disable interrupt for event EP0SETUP */
++#define USBD_INTEN_EP0SETUP_Pos (23UL) /*!< Position of EP0SETUP field. */
++#define USBD_INTEN_EP0SETUP_Msk (0x1UL << USBD_INTEN_EP0SETUP_Pos) /*!< Bit mask of EP0SETUP field. */
++#define USBD_INTEN_EP0SETUP_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_EP0SETUP_Enabled (1UL) /*!< Enable */
++
++/* Bit 22 : Enable or disable interrupt for event USBEVENT */
++#define USBD_INTEN_USBEVENT_Pos (22UL) /*!< Position of USBEVENT field. */
++#define USBD_INTEN_USBEVENT_Msk (0x1UL << USBD_INTEN_USBEVENT_Pos) /*!< Bit mask of USBEVENT field. */
++#define USBD_INTEN_USBEVENT_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_USBEVENT_Enabled (1UL) /*!< Enable */
++
++/* Bit 21 : Enable or disable interrupt for event SOF */
++#define USBD_INTEN_SOF_Pos (21UL) /*!< Position of SOF field. */
++#define USBD_INTEN_SOF_Msk (0x1UL << USBD_INTEN_SOF_Pos) /*!< Bit mask of SOF field. */
++#define USBD_INTEN_SOF_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_SOF_Enabled (1UL) /*!< Enable */
++
++/* Bit 20 : Enable or disable interrupt for event ENDISOOUT */
++#define USBD_INTEN_ENDISOOUT_Pos (20UL) /*!< Position of ENDISOOUT field. */
++#define USBD_INTEN_ENDISOOUT_Msk (0x1UL << USBD_INTEN_ENDISOOUT_Pos) /*!< Bit mask of ENDISOOUT field. */
++#define USBD_INTEN_ENDISOOUT_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDISOOUT_Enabled (1UL) /*!< Enable */
++
++/* Bit 19 : Enable or disable interrupt for event ENDEPOUT[7] */
++#define USBD_INTEN_ENDEPOUT7_Pos (19UL) /*!< Position of ENDEPOUT7 field. */
++#define USBD_INTEN_ENDEPOUT7_Msk (0x1UL << USBD_INTEN_ENDEPOUT7_Pos) /*!< Bit mask of ENDEPOUT7 field. */
++#define USBD_INTEN_ENDEPOUT7_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPOUT7_Enabled (1UL) /*!< Enable */
++
++/* Bit 18 : Enable or disable interrupt for event ENDEPOUT[6] */
++#define USBD_INTEN_ENDEPOUT6_Pos (18UL) /*!< Position of ENDEPOUT6 field. */
++#define USBD_INTEN_ENDEPOUT6_Msk (0x1UL << USBD_INTEN_ENDEPOUT6_Pos) /*!< Bit mask of ENDEPOUT6 field. */
++#define USBD_INTEN_ENDEPOUT6_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPOUT6_Enabled (1UL) /*!< Enable */
++
++/* Bit 17 : Enable or disable interrupt for event ENDEPOUT[5] */
++#define USBD_INTEN_ENDEPOUT5_Pos (17UL) /*!< Position of ENDEPOUT5 field. */
++#define USBD_INTEN_ENDEPOUT5_Msk (0x1UL << USBD_INTEN_ENDEPOUT5_Pos) /*!< Bit mask of ENDEPOUT5 field. */
++#define USBD_INTEN_ENDEPOUT5_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPOUT5_Enabled (1UL) /*!< Enable */
++
++/* Bit 16 : Enable or disable interrupt for event ENDEPOUT[4] */
++#define USBD_INTEN_ENDEPOUT4_Pos (16UL) /*!< Position of ENDEPOUT4 field. */
++#define USBD_INTEN_ENDEPOUT4_Msk (0x1UL << USBD_INTEN_ENDEPOUT4_Pos) /*!< Bit mask of ENDEPOUT4 field. */
++#define USBD_INTEN_ENDEPOUT4_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPOUT4_Enabled (1UL) /*!< Enable */
++
++/* Bit 15 : Enable or disable interrupt for event ENDEPOUT[3] */
++#define USBD_INTEN_ENDEPOUT3_Pos (15UL) /*!< Position of ENDEPOUT3 field. */
++#define USBD_INTEN_ENDEPOUT3_Msk (0x1UL << USBD_INTEN_ENDEPOUT3_Pos) /*!< Bit mask of ENDEPOUT3 field. */
++#define USBD_INTEN_ENDEPOUT3_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPOUT3_Enabled (1UL) /*!< Enable */
++
++/* Bit 14 : Enable or disable interrupt for event ENDEPOUT[2] */
++#define USBD_INTEN_ENDEPOUT2_Pos (14UL) /*!< Position of ENDEPOUT2 field. */
++#define USBD_INTEN_ENDEPOUT2_Msk (0x1UL << USBD_INTEN_ENDEPOUT2_Pos) /*!< Bit mask of ENDEPOUT2 field. */
++#define USBD_INTEN_ENDEPOUT2_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPOUT2_Enabled (1UL) /*!< Enable */
++
++/* Bit 13 : Enable or disable interrupt for event ENDEPOUT[1] */
++#define USBD_INTEN_ENDEPOUT1_Pos (13UL) /*!< Position of ENDEPOUT1 field. */
++#define USBD_INTEN_ENDEPOUT1_Msk (0x1UL << USBD_INTEN_ENDEPOUT1_Pos) /*!< Bit mask of ENDEPOUT1 field. */
++#define USBD_INTEN_ENDEPOUT1_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPOUT1_Enabled (1UL) /*!< Enable */
++
++/* Bit 12 : Enable or disable interrupt for event ENDEPOUT[0] */
++#define USBD_INTEN_ENDEPOUT0_Pos (12UL) /*!< Position of ENDEPOUT0 field. */
++#define USBD_INTEN_ENDEPOUT0_Msk (0x1UL << USBD_INTEN_ENDEPOUT0_Pos) /*!< Bit mask of ENDEPOUT0 field. */
++#define USBD_INTEN_ENDEPOUT0_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPOUT0_Enabled (1UL) /*!< Enable */
++
++/* Bit 11 : Enable or disable interrupt for event ENDISOIN */
++#define USBD_INTEN_ENDISOIN_Pos (11UL) /*!< Position of ENDISOIN field. */
++#define USBD_INTEN_ENDISOIN_Msk (0x1UL << USBD_INTEN_ENDISOIN_Pos) /*!< Bit mask of ENDISOIN field. */
++#define USBD_INTEN_ENDISOIN_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDISOIN_Enabled (1UL) /*!< Enable */
++
++/* Bit 10 : Enable or disable interrupt for event EP0DATADONE */
++#define USBD_INTEN_EP0DATADONE_Pos (10UL) /*!< Position of EP0DATADONE field. */
++#define USBD_INTEN_EP0DATADONE_Msk (0x1UL << USBD_INTEN_EP0DATADONE_Pos) /*!< Bit mask of EP0DATADONE field. */
++#define USBD_INTEN_EP0DATADONE_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_EP0DATADONE_Enabled (1UL) /*!< Enable */
++
++/* Bit 9 : Enable or disable interrupt for event ENDEPIN[7] */
++#define USBD_INTEN_ENDEPIN7_Pos (9UL) /*!< Position of ENDEPIN7 field. */
++#define USBD_INTEN_ENDEPIN7_Msk (0x1UL << USBD_INTEN_ENDEPIN7_Pos) /*!< Bit mask of ENDEPIN7 field. */
++#define USBD_INTEN_ENDEPIN7_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPIN7_Enabled (1UL) /*!< Enable */
++
++/* Bit 8 : Enable or disable interrupt for event ENDEPIN[6] */
++#define USBD_INTEN_ENDEPIN6_Pos (8UL) /*!< Position of ENDEPIN6 field. */
++#define USBD_INTEN_ENDEPIN6_Msk (0x1UL << USBD_INTEN_ENDEPIN6_Pos) /*!< Bit mask of ENDEPIN6 field. */
++#define USBD_INTEN_ENDEPIN6_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPIN6_Enabled (1UL) /*!< Enable */
++
++/* Bit 7 : Enable or disable interrupt for event ENDEPIN[5] */
++#define USBD_INTEN_ENDEPIN5_Pos (7UL) /*!< Position of ENDEPIN5 field. */
++#define USBD_INTEN_ENDEPIN5_Msk (0x1UL << USBD_INTEN_ENDEPIN5_Pos) /*!< Bit mask of ENDEPIN5 field. */
++#define USBD_INTEN_ENDEPIN5_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPIN5_Enabled (1UL) /*!< Enable */
++
++/* Bit 6 : Enable or disable interrupt for event ENDEPIN[4] */
++#define USBD_INTEN_ENDEPIN4_Pos (6UL) /*!< Position of ENDEPIN4 field. */
++#define USBD_INTEN_ENDEPIN4_Msk (0x1UL << USBD_INTEN_ENDEPIN4_Pos) /*!< Bit mask of ENDEPIN4 field. */
++#define USBD_INTEN_ENDEPIN4_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPIN4_Enabled (1UL) /*!< Enable */
++
++/* Bit 5 : Enable or disable interrupt for event ENDEPIN[3] */
++#define USBD_INTEN_ENDEPIN3_Pos (5UL) /*!< Position of ENDEPIN3 field. */
++#define USBD_INTEN_ENDEPIN3_Msk (0x1UL << USBD_INTEN_ENDEPIN3_Pos) /*!< Bit mask of ENDEPIN3 field. */
++#define USBD_INTEN_ENDEPIN3_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPIN3_Enabled (1UL) /*!< Enable */
++
++/* Bit 4 : Enable or disable interrupt for event ENDEPIN[2] */
++#define USBD_INTEN_ENDEPIN2_Pos (4UL) /*!< Position of ENDEPIN2 field. */
++#define USBD_INTEN_ENDEPIN2_Msk (0x1UL << USBD_INTEN_ENDEPIN2_Pos) /*!< Bit mask of ENDEPIN2 field. */
++#define USBD_INTEN_ENDEPIN2_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPIN2_Enabled (1UL) /*!< Enable */
++
++/* Bit 3 : Enable or disable interrupt for event ENDEPIN[1] */
++#define USBD_INTEN_ENDEPIN1_Pos (3UL) /*!< Position of ENDEPIN1 field. */
++#define USBD_INTEN_ENDEPIN1_Msk (0x1UL << USBD_INTEN_ENDEPIN1_Pos) /*!< Bit mask of ENDEPIN1 field. */
++#define USBD_INTEN_ENDEPIN1_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPIN1_Enabled (1UL) /*!< Enable */
++
++/* Bit 2 : Enable or disable interrupt for event ENDEPIN[0] */
++#define USBD_INTEN_ENDEPIN0_Pos (2UL) /*!< Position of ENDEPIN0 field. */
++#define USBD_INTEN_ENDEPIN0_Msk (0x1UL << USBD_INTEN_ENDEPIN0_Pos) /*!< Bit mask of ENDEPIN0 field. */
++#define USBD_INTEN_ENDEPIN0_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_ENDEPIN0_Enabled (1UL) /*!< Enable */
++
++/* Bit 1 : Enable or disable interrupt for event STARTED */
++#define USBD_INTEN_STARTED_Pos (1UL) /*!< Position of STARTED field. */
++#define USBD_INTEN_STARTED_Msk (0x1UL << USBD_INTEN_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define USBD_INTEN_STARTED_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_STARTED_Enabled (1UL) /*!< Enable */
++
++/* Bit 0 : Enable or disable interrupt for event USBRESET */
++#define USBD_INTEN_USBRESET_Pos (0UL) /*!< Position of USBRESET field. */
++#define USBD_INTEN_USBRESET_Msk (0x1UL << USBD_INTEN_USBRESET_Pos) /*!< Bit mask of USBRESET field. */
++#define USBD_INTEN_USBRESET_Disabled (0UL) /*!< Disable */
++#define USBD_INTEN_USBRESET_Enabled (1UL) /*!< Enable */
++
++/* Register: USBD_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 24 : Write '1' to enable interrupt for event EPDATA */
++#define USBD_INTENSET_EPDATA_Pos (24UL) /*!< Position of EPDATA field. */
++#define USBD_INTENSET_EPDATA_Msk (0x1UL << USBD_INTENSET_EPDATA_Pos) /*!< Bit mask of EPDATA field. */
++#define USBD_INTENSET_EPDATA_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_EPDATA_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_EPDATA_Set (1UL) /*!< Enable */
++
++/* Bit 23 : Write '1' to enable interrupt for event EP0SETUP */
++#define USBD_INTENSET_EP0SETUP_Pos (23UL) /*!< Position of EP0SETUP field. */
++#define USBD_INTENSET_EP0SETUP_Msk (0x1UL << USBD_INTENSET_EP0SETUP_Pos) /*!< Bit mask of EP0SETUP field. */
++#define USBD_INTENSET_EP0SETUP_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_EP0SETUP_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_EP0SETUP_Set (1UL) /*!< Enable */
++
++/* Bit 22 : Write '1' to enable interrupt for event USBEVENT */
++#define USBD_INTENSET_USBEVENT_Pos (22UL) /*!< Position of USBEVENT field. */
++#define USBD_INTENSET_USBEVENT_Msk (0x1UL << USBD_INTENSET_USBEVENT_Pos) /*!< Bit mask of USBEVENT field. */
++#define USBD_INTENSET_USBEVENT_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_USBEVENT_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_USBEVENT_Set (1UL) /*!< Enable */
++
++/* Bit 21 : Write '1' to enable interrupt for event SOF */
++#define USBD_INTENSET_SOF_Pos (21UL) /*!< Position of SOF field. */
++#define USBD_INTENSET_SOF_Msk (0x1UL << USBD_INTENSET_SOF_Pos) /*!< Bit mask of SOF field. */
++#define USBD_INTENSET_SOF_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_SOF_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_SOF_Set (1UL) /*!< Enable */
++
++/* Bit 20 : Write '1' to enable interrupt for event ENDISOOUT */
++#define USBD_INTENSET_ENDISOOUT_Pos (20UL) /*!< Position of ENDISOOUT field. */
++#define USBD_INTENSET_ENDISOOUT_Msk (0x1UL << USBD_INTENSET_ENDISOOUT_Pos) /*!< Bit mask of ENDISOOUT field. */
++#define USBD_INTENSET_ENDISOOUT_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDISOOUT_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDISOOUT_Set (1UL) /*!< Enable */
++
++/* Bit 19 : Write '1' to enable interrupt for event ENDEPOUT[7] */
++#define USBD_INTENSET_ENDEPOUT7_Pos (19UL) /*!< Position of ENDEPOUT7 field. */
++#define USBD_INTENSET_ENDEPOUT7_Msk (0x1UL << USBD_INTENSET_ENDEPOUT7_Pos) /*!< Bit mask of ENDEPOUT7 field. */
++#define USBD_INTENSET_ENDEPOUT7_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPOUT7_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPOUT7_Set (1UL) /*!< Enable */
++
++/* Bit 18 : Write '1' to enable interrupt for event ENDEPOUT[6] */
++#define USBD_INTENSET_ENDEPOUT6_Pos (18UL) /*!< Position of ENDEPOUT6 field. */
++#define USBD_INTENSET_ENDEPOUT6_Msk (0x1UL << USBD_INTENSET_ENDEPOUT6_Pos) /*!< Bit mask of ENDEPOUT6 field. */
++#define USBD_INTENSET_ENDEPOUT6_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPOUT6_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPOUT6_Set (1UL) /*!< Enable */
++
++/* Bit 17 : Write '1' to enable interrupt for event ENDEPOUT[5] */
++#define USBD_INTENSET_ENDEPOUT5_Pos (17UL) /*!< Position of ENDEPOUT5 field. */
++#define USBD_INTENSET_ENDEPOUT5_Msk (0x1UL << USBD_INTENSET_ENDEPOUT5_Pos) /*!< Bit mask of ENDEPOUT5 field. */
++#define USBD_INTENSET_ENDEPOUT5_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPOUT5_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPOUT5_Set (1UL) /*!< Enable */
++
++/* Bit 16 : Write '1' to enable interrupt for event ENDEPOUT[4] */
++#define USBD_INTENSET_ENDEPOUT4_Pos (16UL) /*!< Position of ENDEPOUT4 field. */
++#define USBD_INTENSET_ENDEPOUT4_Msk (0x1UL << USBD_INTENSET_ENDEPOUT4_Pos) /*!< Bit mask of ENDEPOUT4 field. */
++#define USBD_INTENSET_ENDEPOUT4_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPOUT4_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPOUT4_Set (1UL) /*!< Enable */
++
++/* Bit 15 : Write '1' to enable interrupt for event ENDEPOUT[3] */
++#define USBD_INTENSET_ENDEPOUT3_Pos (15UL) /*!< Position of ENDEPOUT3 field. */
++#define USBD_INTENSET_ENDEPOUT3_Msk (0x1UL << USBD_INTENSET_ENDEPOUT3_Pos) /*!< Bit mask of ENDEPOUT3 field. */
++#define USBD_INTENSET_ENDEPOUT3_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPOUT3_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPOUT3_Set (1UL) /*!< Enable */
++
++/* Bit 14 : Write '1' to enable interrupt for event ENDEPOUT[2] */
++#define USBD_INTENSET_ENDEPOUT2_Pos (14UL) /*!< Position of ENDEPOUT2 field. */
++#define USBD_INTENSET_ENDEPOUT2_Msk (0x1UL << USBD_INTENSET_ENDEPOUT2_Pos) /*!< Bit mask of ENDEPOUT2 field. */
++#define USBD_INTENSET_ENDEPOUT2_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPOUT2_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPOUT2_Set (1UL) /*!< Enable */
++
++/* Bit 13 : Write '1' to enable interrupt for event ENDEPOUT[1] */
++#define USBD_INTENSET_ENDEPOUT1_Pos (13UL) /*!< Position of ENDEPOUT1 field. */
++#define USBD_INTENSET_ENDEPOUT1_Msk (0x1UL << USBD_INTENSET_ENDEPOUT1_Pos) /*!< Bit mask of ENDEPOUT1 field. */
++#define USBD_INTENSET_ENDEPOUT1_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPOUT1_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPOUT1_Set (1UL) /*!< Enable */
++
++/* Bit 12 : Write '1' to enable interrupt for event ENDEPOUT[0] */
++#define USBD_INTENSET_ENDEPOUT0_Pos (12UL) /*!< Position of ENDEPOUT0 field. */
++#define USBD_INTENSET_ENDEPOUT0_Msk (0x1UL << USBD_INTENSET_ENDEPOUT0_Pos) /*!< Bit mask of ENDEPOUT0 field. */
++#define USBD_INTENSET_ENDEPOUT0_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPOUT0_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPOUT0_Set (1UL) /*!< Enable */
++
++/* Bit 11 : Write '1' to enable interrupt for event ENDISOIN */
++#define USBD_INTENSET_ENDISOIN_Pos (11UL) /*!< Position of ENDISOIN field. */
++#define USBD_INTENSET_ENDISOIN_Msk (0x1UL << USBD_INTENSET_ENDISOIN_Pos) /*!< Bit mask of ENDISOIN field. */
++#define USBD_INTENSET_ENDISOIN_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDISOIN_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDISOIN_Set (1UL) /*!< Enable */
++
++/* Bit 10 : Write '1' to enable interrupt for event EP0DATADONE */
++#define USBD_INTENSET_EP0DATADONE_Pos (10UL) /*!< Position of EP0DATADONE field. */
++#define USBD_INTENSET_EP0DATADONE_Msk (0x1UL << USBD_INTENSET_EP0DATADONE_Pos) /*!< Bit mask of EP0DATADONE field. */
++#define USBD_INTENSET_EP0DATADONE_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_EP0DATADONE_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_EP0DATADONE_Set (1UL) /*!< Enable */
++
++/* Bit 9 : Write '1' to enable interrupt for event ENDEPIN[7] */
++#define USBD_INTENSET_ENDEPIN7_Pos (9UL) /*!< Position of ENDEPIN7 field. */
++#define USBD_INTENSET_ENDEPIN7_Msk (0x1UL << USBD_INTENSET_ENDEPIN7_Pos) /*!< Bit mask of ENDEPIN7 field. */
++#define USBD_INTENSET_ENDEPIN7_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPIN7_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPIN7_Set (1UL) /*!< Enable */
++
++/* Bit 8 : Write '1' to enable interrupt for event ENDEPIN[6] */
++#define USBD_INTENSET_ENDEPIN6_Pos (8UL) /*!< Position of ENDEPIN6 field. */
++#define USBD_INTENSET_ENDEPIN6_Msk (0x1UL << USBD_INTENSET_ENDEPIN6_Pos) /*!< Bit mask of ENDEPIN6 field. */
++#define USBD_INTENSET_ENDEPIN6_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPIN6_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPIN6_Set (1UL) /*!< Enable */
++
++/* Bit 7 : Write '1' to enable interrupt for event ENDEPIN[5] */
++#define USBD_INTENSET_ENDEPIN5_Pos (7UL) /*!< Position of ENDEPIN5 field. */
++#define USBD_INTENSET_ENDEPIN5_Msk (0x1UL << USBD_INTENSET_ENDEPIN5_Pos) /*!< Bit mask of ENDEPIN5 field. */
++#define USBD_INTENSET_ENDEPIN5_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPIN5_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPIN5_Set (1UL) /*!< Enable */
++
++/* Bit 6 : Write '1' to enable interrupt for event ENDEPIN[4] */
++#define USBD_INTENSET_ENDEPIN4_Pos (6UL) /*!< Position of ENDEPIN4 field. */
++#define USBD_INTENSET_ENDEPIN4_Msk (0x1UL << USBD_INTENSET_ENDEPIN4_Pos) /*!< Bit mask of ENDEPIN4 field. */
++#define USBD_INTENSET_ENDEPIN4_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPIN4_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPIN4_Set (1UL) /*!< Enable */
++
++/* Bit 5 : Write '1' to enable interrupt for event ENDEPIN[3] */
++#define USBD_INTENSET_ENDEPIN3_Pos (5UL) /*!< Position of ENDEPIN3 field. */
++#define USBD_INTENSET_ENDEPIN3_Msk (0x1UL << USBD_INTENSET_ENDEPIN3_Pos) /*!< Bit mask of ENDEPIN3 field. */
++#define USBD_INTENSET_ENDEPIN3_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPIN3_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPIN3_Set (1UL) /*!< Enable */
++
++/* Bit 4 : Write '1' to enable interrupt for event ENDEPIN[2] */
++#define USBD_INTENSET_ENDEPIN2_Pos (4UL) /*!< Position of ENDEPIN2 field. */
++#define USBD_INTENSET_ENDEPIN2_Msk (0x1UL << USBD_INTENSET_ENDEPIN2_Pos) /*!< Bit mask of ENDEPIN2 field. */
++#define USBD_INTENSET_ENDEPIN2_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPIN2_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPIN2_Set (1UL) /*!< Enable */
++
++/* Bit 3 : Write '1' to enable interrupt for event ENDEPIN[1] */
++#define USBD_INTENSET_ENDEPIN1_Pos (3UL) /*!< Position of ENDEPIN1 field. */
++#define USBD_INTENSET_ENDEPIN1_Msk (0x1UL << USBD_INTENSET_ENDEPIN1_Pos) /*!< Bit mask of ENDEPIN1 field. */
++#define USBD_INTENSET_ENDEPIN1_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPIN1_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPIN1_Set (1UL) /*!< Enable */
++
++/* Bit 2 : Write '1' to enable interrupt for event ENDEPIN[0] */
++#define USBD_INTENSET_ENDEPIN0_Pos (2UL) /*!< Position of ENDEPIN0 field. */
++#define USBD_INTENSET_ENDEPIN0_Msk (0x1UL << USBD_INTENSET_ENDEPIN0_Pos) /*!< Bit mask of ENDEPIN0 field. */
++#define USBD_INTENSET_ENDEPIN0_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_ENDEPIN0_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_ENDEPIN0_Set (1UL) /*!< Enable */
++
++/* Bit 1 : Write '1' to enable interrupt for event STARTED */
++#define USBD_INTENSET_STARTED_Pos (1UL) /*!< Position of STARTED field. */
++#define USBD_INTENSET_STARTED_Msk (0x1UL << USBD_INTENSET_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define USBD_INTENSET_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_STARTED_Set (1UL) /*!< Enable */
++
++/* Bit 0 : Write '1' to enable interrupt for event USBRESET */
++#define USBD_INTENSET_USBRESET_Pos (0UL) /*!< Position of USBRESET field. */
++#define USBD_INTENSET_USBRESET_Msk (0x1UL << USBD_INTENSET_USBRESET_Pos) /*!< Bit mask of USBRESET field. */
++#define USBD_INTENSET_USBRESET_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENSET_USBRESET_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENSET_USBRESET_Set (1UL) /*!< Enable */
++
++/* Register: USBD_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 24 : Write '1' to disable interrupt for event EPDATA */
++#define USBD_INTENCLR_EPDATA_Pos (24UL) /*!< Position of EPDATA field. */
++#define USBD_INTENCLR_EPDATA_Msk (0x1UL << USBD_INTENCLR_EPDATA_Pos) /*!< Bit mask of EPDATA field. */
++#define USBD_INTENCLR_EPDATA_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_EPDATA_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_EPDATA_Clear (1UL) /*!< Disable */
++
++/* Bit 23 : Write '1' to disable interrupt for event EP0SETUP */
++#define USBD_INTENCLR_EP0SETUP_Pos (23UL) /*!< Position of EP0SETUP field. */
++#define USBD_INTENCLR_EP0SETUP_Msk (0x1UL << USBD_INTENCLR_EP0SETUP_Pos) /*!< Bit mask of EP0SETUP field. */
++#define USBD_INTENCLR_EP0SETUP_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_EP0SETUP_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_EP0SETUP_Clear (1UL) /*!< Disable */
++
++/* Bit 22 : Write '1' to disable interrupt for event USBEVENT */
++#define USBD_INTENCLR_USBEVENT_Pos (22UL) /*!< Position of USBEVENT field. */
++#define USBD_INTENCLR_USBEVENT_Msk (0x1UL << USBD_INTENCLR_USBEVENT_Pos) /*!< Bit mask of USBEVENT field. */
++#define USBD_INTENCLR_USBEVENT_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_USBEVENT_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_USBEVENT_Clear (1UL) /*!< Disable */
++
++/* Bit 21 : Write '1' to disable interrupt for event SOF */
++#define USBD_INTENCLR_SOF_Pos (21UL) /*!< Position of SOF field. */
++#define USBD_INTENCLR_SOF_Msk (0x1UL << USBD_INTENCLR_SOF_Pos) /*!< Bit mask of SOF field. */
++#define USBD_INTENCLR_SOF_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_SOF_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_SOF_Clear (1UL) /*!< Disable */
++
++/* Bit 20 : Write '1' to disable interrupt for event ENDISOOUT */
++#define USBD_INTENCLR_ENDISOOUT_Pos (20UL) /*!< Position of ENDISOOUT field. */
++#define USBD_INTENCLR_ENDISOOUT_Msk (0x1UL << USBD_INTENCLR_ENDISOOUT_Pos) /*!< Bit mask of ENDISOOUT field. */
++#define USBD_INTENCLR_ENDISOOUT_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDISOOUT_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDISOOUT_Clear (1UL) /*!< Disable */
++
++/* Bit 19 : Write '1' to disable interrupt for event ENDEPOUT[7] */
++#define USBD_INTENCLR_ENDEPOUT7_Pos (19UL) /*!< Position of ENDEPOUT7 field. */
++#define USBD_INTENCLR_ENDEPOUT7_Msk (0x1UL << USBD_INTENCLR_ENDEPOUT7_Pos) /*!< Bit mask of ENDEPOUT7 field. */
++#define USBD_INTENCLR_ENDEPOUT7_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPOUT7_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPOUT7_Clear (1UL) /*!< Disable */
++
++/* Bit 18 : Write '1' to disable interrupt for event ENDEPOUT[6] */
++#define USBD_INTENCLR_ENDEPOUT6_Pos (18UL) /*!< Position of ENDEPOUT6 field. */
++#define USBD_INTENCLR_ENDEPOUT6_Msk (0x1UL << USBD_INTENCLR_ENDEPOUT6_Pos) /*!< Bit mask of ENDEPOUT6 field. */
++#define USBD_INTENCLR_ENDEPOUT6_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPOUT6_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPOUT6_Clear (1UL) /*!< Disable */
++
++/* Bit 17 : Write '1' to disable interrupt for event ENDEPOUT[5] */
++#define USBD_INTENCLR_ENDEPOUT5_Pos (17UL) /*!< Position of ENDEPOUT5 field. */
++#define USBD_INTENCLR_ENDEPOUT5_Msk (0x1UL << USBD_INTENCLR_ENDEPOUT5_Pos) /*!< Bit mask of ENDEPOUT5 field. */
++#define USBD_INTENCLR_ENDEPOUT5_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPOUT5_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPOUT5_Clear (1UL) /*!< Disable */
++
++/* Bit 16 : Write '1' to disable interrupt for event ENDEPOUT[4] */
++#define USBD_INTENCLR_ENDEPOUT4_Pos (16UL) /*!< Position of ENDEPOUT4 field. */
++#define USBD_INTENCLR_ENDEPOUT4_Msk (0x1UL << USBD_INTENCLR_ENDEPOUT4_Pos) /*!< Bit mask of ENDEPOUT4 field. */
++#define USBD_INTENCLR_ENDEPOUT4_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPOUT4_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPOUT4_Clear (1UL) /*!< Disable */
++
++/* Bit 15 : Write '1' to disable interrupt for event ENDEPOUT[3] */
++#define USBD_INTENCLR_ENDEPOUT3_Pos (15UL) /*!< Position of ENDEPOUT3 field. */
++#define USBD_INTENCLR_ENDEPOUT3_Msk (0x1UL << USBD_INTENCLR_ENDEPOUT3_Pos) /*!< Bit mask of ENDEPOUT3 field. */
++#define USBD_INTENCLR_ENDEPOUT3_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPOUT3_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPOUT3_Clear (1UL) /*!< Disable */
++
++/* Bit 14 : Write '1' to disable interrupt for event ENDEPOUT[2] */
++#define USBD_INTENCLR_ENDEPOUT2_Pos (14UL) /*!< Position of ENDEPOUT2 field. */
++#define USBD_INTENCLR_ENDEPOUT2_Msk (0x1UL << USBD_INTENCLR_ENDEPOUT2_Pos) /*!< Bit mask of ENDEPOUT2 field. */
++#define USBD_INTENCLR_ENDEPOUT2_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPOUT2_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPOUT2_Clear (1UL) /*!< Disable */
++
++/* Bit 13 : Write '1' to disable interrupt for event ENDEPOUT[1] */
++#define USBD_INTENCLR_ENDEPOUT1_Pos (13UL) /*!< Position of ENDEPOUT1 field. */
++#define USBD_INTENCLR_ENDEPOUT1_Msk (0x1UL << USBD_INTENCLR_ENDEPOUT1_Pos) /*!< Bit mask of ENDEPOUT1 field. */
++#define USBD_INTENCLR_ENDEPOUT1_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPOUT1_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPOUT1_Clear (1UL) /*!< Disable */
++
++/* Bit 12 : Write '1' to disable interrupt for event ENDEPOUT[0] */
++#define USBD_INTENCLR_ENDEPOUT0_Pos (12UL) /*!< Position of ENDEPOUT0 field. */
++#define USBD_INTENCLR_ENDEPOUT0_Msk (0x1UL << USBD_INTENCLR_ENDEPOUT0_Pos) /*!< Bit mask of ENDEPOUT0 field. */
++#define USBD_INTENCLR_ENDEPOUT0_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPOUT0_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPOUT0_Clear (1UL) /*!< Disable */
++
++/* Bit 11 : Write '1' to disable interrupt for event ENDISOIN */
++#define USBD_INTENCLR_ENDISOIN_Pos (11UL) /*!< Position of ENDISOIN field. */
++#define USBD_INTENCLR_ENDISOIN_Msk (0x1UL << USBD_INTENCLR_ENDISOIN_Pos) /*!< Bit mask of ENDISOIN field. */
++#define USBD_INTENCLR_ENDISOIN_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDISOIN_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDISOIN_Clear (1UL) /*!< Disable */
++
++/* Bit 10 : Write '1' to disable interrupt for event EP0DATADONE */
++#define USBD_INTENCLR_EP0DATADONE_Pos (10UL) /*!< Position of EP0DATADONE field. */
++#define USBD_INTENCLR_EP0DATADONE_Msk (0x1UL << USBD_INTENCLR_EP0DATADONE_Pos) /*!< Bit mask of EP0DATADONE field. */
++#define USBD_INTENCLR_EP0DATADONE_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_EP0DATADONE_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_EP0DATADONE_Clear (1UL) /*!< Disable */
++
++/* Bit 9 : Write '1' to disable interrupt for event ENDEPIN[7] */
++#define USBD_INTENCLR_ENDEPIN7_Pos (9UL) /*!< Position of ENDEPIN7 field. */
++#define USBD_INTENCLR_ENDEPIN7_Msk (0x1UL << USBD_INTENCLR_ENDEPIN7_Pos) /*!< Bit mask of ENDEPIN7 field. */
++#define USBD_INTENCLR_ENDEPIN7_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPIN7_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPIN7_Clear (1UL) /*!< Disable */
++
++/* Bit 8 : Write '1' to disable interrupt for event ENDEPIN[6] */
++#define USBD_INTENCLR_ENDEPIN6_Pos (8UL) /*!< Position of ENDEPIN6 field. */
++#define USBD_INTENCLR_ENDEPIN6_Msk (0x1UL << USBD_INTENCLR_ENDEPIN6_Pos) /*!< Bit mask of ENDEPIN6 field. */
++#define USBD_INTENCLR_ENDEPIN6_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPIN6_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPIN6_Clear (1UL) /*!< Disable */
++
++/* Bit 7 : Write '1' to disable interrupt for event ENDEPIN[5] */
++#define USBD_INTENCLR_ENDEPIN5_Pos (7UL) /*!< Position of ENDEPIN5 field. */
++#define USBD_INTENCLR_ENDEPIN5_Msk (0x1UL << USBD_INTENCLR_ENDEPIN5_Pos) /*!< Bit mask of ENDEPIN5 field. */
++#define USBD_INTENCLR_ENDEPIN5_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPIN5_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPIN5_Clear (1UL) /*!< Disable */
++
++/* Bit 6 : Write '1' to disable interrupt for event ENDEPIN[4] */
++#define USBD_INTENCLR_ENDEPIN4_Pos (6UL) /*!< Position of ENDEPIN4 field. */
++#define USBD_INTENCLR_ENDEPIN4_Msk (0x1UL << USBD_INTENCLR_ENDEPIN4_Pos) /*!< Bit mask of ENDEPIN4 field. */
++#define USBD_INTENCLR_ENDEPIN4_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPIN4_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPIN4_Clear (1UL) /*!< Disable */
++
++/* Bit 5 : Write '1' to disable interrupt for event ENDEPIN[3] */
++#define USBD_INTENCLR_ENDEPIN3_Pos (5UL) /*!< Position of ENDEPIN3 field. */
++#define USBD_INTENCLR_ENDEPIN3_Msk (0x1UL << USBD_INTENCLR_ENDEPIN3_Pos) /*!< Bit mask of ENDEPIN3 field. */
++#define USBD_INTENCLR_ENDEPIN3_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPIN3_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPIN3_Clear (1UL) /*!< Disable */
++
++/* Bit 4 : Write '1' to disable interrupt for event ENDEPIN[2] */
++#define USBD_INTENCLR_ENDEPIN2_Pos (4UL) /*!< Position of ENDEPIN2 field. */
++#define USBD_INTENCLR_ENDEPIN2_Msk (0x1UL << USBD_INTENCLR_ENDEPIN2_Pos) /*!< Bit mask of ENDEPIN2 field. */
++#define USBD_INTENCLR_ENDEPIN2_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPIN2_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPIN2_Clear (1UL) /*!< Disable */
++
++/* Bit 3 : Write '1' to disable interrupt for event ENDEPIN[1] */
++#define USBD_INTENCLR_ENDEPIN1_Pos (3UL) /*!< Position of ENDEPIN1 field. */
++#define USBD_INTENCLR_ENDEPIN1_Msk (0x1UL << USBD_INTENCLR_ENDEPIN1_Pos) /*!< Bit mask of ENDEPIN1 field. */
++#define USBD_INTENCLR_ENDEPIN1_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPIN1_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPIN1_Clear (1UL) /*!< Disable */
++
++/* Bit 2 : Write '1' to disable interrupt for event ENDEPIN[0] */
++#define USBD_INTENCLR_ENDEPIN0_Pos (2UL) /*!< Position of ENDEPIN0 field. */
++#define USBD_INTENCLR_ENDEPIN0_Msk (0x1UL << USBD_INTENCLR_ENDEPIN0_Pos) /*!< Bit mask of ENDEPIN0 field. */
++#define USBD_INTENCLR_ENDEPIN0_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_ENDEPIN0_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_ENDEPIN0_Clear (1UL) /*!< Disable */
++
++/* Bit 1 : Write '1' to disable interrupt for event STARTED */
++#define USBD_INTENCLR_STARTED_Pos (1UL) /*!< Position of STARTED field. */
++#define USBD_INTENCLR_STARTED_Msk (0x1UL << USBD_INTENCLR_STARTED_Pos) /*!< Bit mask of STARTED field. */
++#define USBD_INTENCLR_STARTED_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_STARTED_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_STARTED_Clear (1UL) /*!< Disable */
++
++/* Bit 0 : Write '1' to disable interrupt for event USBRESET */
++#define USBD_INTENCLR_USBRESET_Pos (0UL) /*!< Position of USBRESET field. */
++#define USBD_INTENCLR_USBRESET_Msk (0x1UL << USBD_INTENCLR_USBRESET_Pos) /*!< Bit mask of USBRESET field. */
++#define USBD_INTENCLR_USBRESET_Disabled (0UL) /*!< Read: Disabled */
++#define USBD_INTENCLR_USBRESET_Enabled (1UL) /*!< Read: Enabled */
++#define USBD_INTENCLR_USBRESET_Clear (1UL) /*!< Disable */
++
++/* Register: USBD_EVENTCAUSE */
++/* Description: Details on what caused the USBEVENT event */
++
++/* Bit 11 : USB device is ready for normal operation. Write '1' to clear. */
++#define USBD_EVENTCAUSE_READY_Pos (11UL) /*!< Position of READY field. */
++#define USBD_EVENTCAUSE_READY_Msk (0x1UL << USBD_EVENTCAUSE_READY_Pos) /*!< Bit mask of READY field. */
++#define USBD_EVENTCAUSE_READY_NotDetected (0UL) /*!< USBEVENT was not issued due to USBD peripheral ready */
++#define USBD_EVENTCAUSE_READY_Ready (1UL) /*!< USBD peripheral is ready */
++
++/* Bit 10 : USB MAC has been woken up and operational. Write '1' to clear. */
++#define USBD_EVENTCAUSE_USBWUALLOWED_Pos (10UL) /*!< Position of USBWUALLOWED field. */
++#define USBD_EVENTCAUSE_USBWUALLOWED_Msk (0x1UL << USBD_EVENTCAUSE_USBWUALLOWED_Pos) /*!< Bit mask of USBWUALLOWED field. */
++#define USBD_EVENTCAUSE_USBWUALLOWED_NotAllowed (0UL) /*!< Wake up not allowed */
++#define USBD_EVENTCAUSE_USBWUALLOWED_Allowed (1UL) /*!< Wake up allowed */
++
++/* Bit 9 : Signals that a RESUME condition (K state or activity restart) has been detected on USB lines. Write '1' to clear. */
++#define USBD_EVENTCAUSE_RESUME_Pos (9UL) /*!< Position of RESUME field. */
++#define USBD_EVENTCAUSE_RESUME_Msk (0x1UL << USBD_EVENTCAUSE_RESUME_Pos) /*!< Bit mask of RESUME field. */
++#define USBD_EVENTCAUSE_RESUME_NotDetected (0UL) /*!< Resume not detected */
++#define USBD_EVENTCAUSE_RESUME_Detected (1UL) /*!< Resume detected */
++
++/* Bit 8 : Signals that USB lines have been idle long enough for the device to enter suspend. Write '1' to clear. */
++#define USBD_EVENTCAUSE_SUSPEND_Pos (8UL) /*!< Position of SUSPEND field. */
++#define USBD_EVENTCAUSE_SUSPEND_Msk (0x1UL << USBD_EVENTCAUSE_SUSPEND_Pos) /*!< Bit mask of SUSPEND field. */
++#define USBD_EVENTCAUSE_SUSPEND_NotDetected (0UL) /*!< Suspend not detected */
++#define USBD_EVENTCAUSE_SUSPEND_Detected (1UL) /*!< Suspend detected */
++
++/* Bit 0 : CRC error was detected on isochronous OUT endpoint 8. Write '1' to clear. */
++#define USBD_EVENTCAUSE_ISOOUTCRC_Pos (0UL) /*!< Position of ISOOUTCRC field. */
++#define USBD_EVENTCAUSE_ISOOUTCRC_Msk (0x1UL << USBD_EVENTCAUSE_ISOOUTCRC_Pos) /*!< Bit mask of ISOOUTCRC field. */
++#define USBD_EVENTCAUSE_ISOOUTCRC_NotDetected (0UL) /*!< No error detected */
++#define USBD_EVENTCAUSE_ISOOUTCRC_Detected (1UL) /*!< Error detected */
++
++/* Register: USBD_HALTED_EPIN */
++/* Description: Description collection: IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint. */
++
++/* Bits 15..0 : IN endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint. */
++#define USBD_HALTED_EPIN_GETSTATUS_Pos (0UL) /*!< Position of GETSTATUS field. */
++#define USBD_HALTED_EPIN_GETSTATUS_Msk (0xFFFFUL << USBD_HALTED_EPIN_GETSTATUS_Pos) /*!< Bit mask of GETSTATUS field. */
++#define USBD_HALTED_EPIN_GETSTATUS_NotHalted (0UL) /*!< Endpoint is not halted */
++#define USBD_HALTED_EPIN_GETSTATUS_Halted (1UL) /*!< Endpoint is halted */
++
++/* Register: USBD_HALTED_EPOUT */
++/* Description: Description collection: OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint. */
++
++/* Bits 15..0 : OUT endpoint halted status. Can be used as is as response to a GetStatus() request to endpoint. */
++#define USBD_HALTED_EPOUT_GETSTATUS_Pos (0UL) /*!< Position of GETSTATUS field. */
++#define USBD_HALTED_EPOUT_GETSTATUS_Msk (0xFFFFUL << USBD_HALTED_EPOUT_GETSTATUS_Pos) /*!< Bit mask of GETSTATUS field. */
++#define USBD_HALTED_EPOUT_GETSTATUS_NotHalted (0UL) /*!< Endpoint is not halted */
++#define USBD_HALTED_EPOUT_GETSTATUS_Halted (1UL) /*!< Endpoint is halted */
++
++/* Register: USBD_EPSTATUS */
++/* Description: Provides information on which endpoint's EasyDMA registers have been captured */
++
++/* Bit 24 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT8_Pos (24UL) /*!< Position of EPOUT8 field. */
++#define USBD_EPSTATUS_EPOUT8_Msk (0x1UL << USBD_EPSTATUS_EPOUT8_Pos) /*!< Bit mask of EPOUT8 field. */
++#define USBD_EPSTATUS_EPOUT8_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT8_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 23 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT7_Pos (23UL) /*!< Position of EPOUT7 field. */
++#define USBD_EPSTATUS_EPOUT7_Msk (0x1UL << USBD_EPSTATUS_EPOUT7_Pos) /*!< Bit mask of EPOUT7 field. */
++#define USBD_EPSTATUS_EPOUT7_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT7_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 22 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT6_Pos (22UL) /*!< Position of EPOUT6 field. */
++#define USBD_EPSTATUS_EPOUT6_Msk (0x1UL << USBD_EPSTATUS_EPOUT6_Pos) /*!< Bit mask of EPOUT6 field. */
++#define USBD_EPSTATUS_EPOUT6_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT6_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 21 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT5_Pos (21UL) /*!< Position of EPOUT5 field. */
++#define USBD_EPSTATUS_EPOUT5_Msk (0x1UL << USBD_EPSTATUS_EPOUT5_Pos) /*!< Bit mask of EPOUT5 field. */
++#define USBD_EPSTATUS_EPOUT5_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT5_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 20 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT4_Pos (20UL) /*!< Position of EPOUT4 field. */
++#define USBD_EPSTATUS_EPOUT4_Msk (0x1UL << USBD_EPSTATUS_EPOUT4_Pos) /*!< Bit mask of EPOUT4 field. */
++#define USBD_EPSTATUS_EPOUT4_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT4_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 19 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT3_Pos (19UL) /*!< Position of EPOUT3 field. */
++#define USBD_EPSTATUS_EPOUT3_Msk (0x1UL << USBD_EPSTATUS_EPOUT3_Pos) /*!< Bit mask of EPOUT3 field. */
++#define USBD_EPSTATUS_EPOUT3_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT3_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 18 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT2_Pos (18UL) /*!< Position of EPOUT2 field. */
++#define USBD_EPSTATUS_EPOUT2_Msk (0x1UL << USBD_EPSTATUS_EPOUT2_Pos) /*!< Bit mask of EPOUT2 field. */
++#define USBD_EPSTATUS_EPOUT2_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT2_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 17 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT1_Pos (17UL) /*!< Position of EPOUT1 field. */
++#define USBD_EPSTATUS_EPOUT1_Msk (0x1UL << USBD_EPSTATUS_EPOUT1_Pos) /*!< Bit mask of EPOUT1 field. */
++#define USBD_EPSTATUS_EPOUT1_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT1_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 16 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPOUT0_Pos (16UL) /*!< Position of EPOUT0 field. */
++#define USBD_EPSTATUS_EPOUT0_Msk (0x1UL << USBD_EPSTATUS_EPOUT0_Pos) /*!< Bit mask of EPOUT0 field. */
++#define USBD_EPSTATUS_EPOUT0_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPOUT0_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 8 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN8_Pos (8UL) /*!< Position of EPIN8 field. */
++#define USBD_EPSTATUS_EPIN8_Msk (0x1UL << USBD_EPSTATUS_EPIN8_Pos) /*!< Bit mask of EPIN8 field. */
++#define USBD_EPSTATUS_EPIN8_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN8_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 7 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN7_Pos (7UL) /*!< Position of EPIN7 field. */
++#define USBD_EPSTATUS_EPIN7_Msk (0x1UL << USBD_EPSTATUS_EPIN7_Pos) /*!< Bit mask of EPIN7 field. */
++#define USBD_EPSTATUS_EPIN7_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN7_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 6 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN6_Pos (6UL) /*!< Position of EPIN6 field. */
++#define USBD_EPSTATUS_EPIN6_Msk (0x1UL << USBD_EPSTATUS_EPIN6_Pos) /*!< Bit mask of EPIN6 field. */
++#define USBD_EPSTATUS_EPIN6_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN6_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 5 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN5_Pos (5UL) /*!< Position of EPIN5 field. */
++#define USBD_EPSTATUS_EPIN5_Msk (0x1UL << USBD_EPSTATUS_EPIN5_Pos) /*!< Bit mask of EPIN5 field. */
++#define USBD_EPSTATUS_EPIN5_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN5_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 4 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN4_Pos (4UL) /*!< Position of EPIN4 field. */
++#define USBD_EPSTATUS_EPIN4_Msk (0x1UL << USBD_EPSTATUS_EPIN4_Pos) /*!< Bit mask of EPIN4 field. */
++#define USBD_EPSTATUS_EPIN4_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN4_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 3 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN3_Pos (3UL) /*!< Position of EPIN3 field. */
++#define USBD_EPSTATUS_EPIN3_Msk (0x1UL << USBD_EPSTATUS_EPIN3_Pos) /*!< Bit mask of EPIN3 field. */
++#define USBD_EPSTATUS_EPIN3_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN3_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 2 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN2_Pos (2UL) /*!< Position of EPIN2 field. */
++#define USBD_EPSTATUS_EPIN2_Msk (0x1UL << USBD_EPSTATUS_EPIN2_Pos) /*!< Bit mask of EPIN2 field. */
++#define USBD_EPSTATUS_EPIN2_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN2_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 1 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN1_Pos (1UL) /*!< Position of EPIN1 field. */
++#define USBD_EPSTATUS_EPIN1_Msk (0x1UL << USBD_EPSTATUS_EPIN1_Pos) /*!< Bit mask of EPIN1 field. */
++#define USBD_EPSTATUS_EPIN1_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN1_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Bit 0 : Captured state of endpoint's EasyDMA registers. Write '1' to clear. */
++#define USBD_EPSTATUS_EPIN0_Pos (0UL) /*!< Position of EPIN0 field. */
++#define USBD_EPSTATUS_EPIN0_Msk (0x1UL << USBD_EPSTATUS_EPIN0_Pos) /*!< Bit mask of EPIN0 field. */
++#define USBD_EPSTATUS_EPIN0_NoData (0UL) /*!< EasyDMA registers have not been captured for this endpoint */
++#define USBD_EPSTATUS_EPIN0_DataDone (1UL) /*!< EasyDMA registers have been captured for this endpoint */
++
++/* Register: USBD_EPDATASTATUS */
++/* Description: Provides information on which endpoint(s) an acknowledged data transfer has occurred (EPDATA event) */
++
++/* Bit 23 : Acknowledged data transfer on this OUT endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPOUT7_Pos (23UL) /*!< Position of EPOUT7 field. */
++#define USBD_EPDATASTATUS_EPOUT7_Msk (0x1UL << USBD_EPDATASTATUS_EPOUT7_Pos) /*!< Bit mask of EPOUT7 field. */
++#define USBD_EPDATASTATUS_EPOUT7_NotStarted (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPOUT7_Started (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 22 : Acknowledged data transfer on this OUT endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPOUT6_Pos (22UL) /*!< Position of EPOUT6 field. */
++#define USBD_EPDATASTATUS_EPOUT6_Msk (0x1UL << USBD_EPDATASTATUS_EPOUT6_Pos) /*!< Bit mask of EPOUT6 field. */
++#define USBD_EPDATASTATUS_EPOUT6_NotStarted (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPOUT6_Started (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 21 : Acknowledged data transfer on this OUT endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPOUT5_Pos (21UL) /*!< Position of EPOUT5 field. */
++#define USBD_EPDATASTATUS_EPOUT5_Msk (0x1UL << USBD_EPDATASTATUS_EPOUT5_Pos) /*!< Bit mask of EPOUT5 field. */
++#define USBD_EPDATASTATUS_EPOUT5_NotStarted (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPOUT5_Started (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 20 : Acknowledged data transfer on this OUT endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPOUT4_Pos (20UL) /*!< Position of EPOUT4 field. */
++#define USBD_EPDATASTATUS_EPOUT4_Msk (0x1UL << USBD_EPDATASTATUS_EPOUT4_Pos) /*!< Bit mask of EPOUT4 field. */
++#define USBD_EPDATASTATUS_EPOUT4_NotStarted (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPOUT4_Started (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 19 : Acknowledged data transfer on this OUT endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPOUT3_Pos (19UL) /*!< Position of EPOUT3 field. */
++#define USBD_EPDATASTATUS_EPOUT3_Msk (0x1UL << USBD_EPDATASTATUS_EPOUT3_Pos) /*!< Bit mask of EPOUT3 field. */
++#define USBD_EPDATASTATUS_EPOUT3_NotStarted (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPOUT3_Started (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 18 : Acknowledged data transfer on this OUT endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPOUT2_Pos (18UL) /*!< Position of EPOUT2 field. */
++#define USBD_EPDATASTATUS_EPOUT2_Msk (0x1UL << USBD_EPDATASTATUS_EPOUT2_Pos) /*!< Bit mask of EPOUT2 field. */
++#define USBD_EPDATASTATUS_EPOUT2_NotStarted (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPOUT2_Started (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 17 : Acknowledged data transfer on this OUT endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPOUT1_Pos (17UL) /*!< Position of EPOUT1 field. */
++#define USBD_EPDATASTATUS_EPOUT1_Msk (0x1UL << USBD_EPDATASTATUS_EPOUT1_Pos) /*!< Bit mask of EPOUT1 field. */
++#define USBD_EPDATASTATUS_EPOUT1_NotStarted (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPOUT1_Started (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 7 : Acknowledged data transfer on this IN endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPIN7_Pos (7UL) /*!< Position of EPIN7 field. */
++#define USBD_EPDATASTATUS_EPIN7_Msk (0x1UL << USBD_EPDATASTATUS_EPIN7_Pos) /*!< Bit mask of EPIN7 field. */
++#define USBD_EPDATASTATUS_EPIN7_NotDone (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPIN7_DataDone (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 6 : Acknowledged data transfer on this IN endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPIN6_Pos (6UL) /*!< Position of EPIN6 field. */
++#define USBD_EPDATASTATUS_EPIN6_Msk (0x1UL << USBD_EPDATASTATUS_EPIN6_Pos) /*!< Bit mask of EPIN6 field. */
++#define USBD_EPDATASTATUS_EPIN6_NotDone (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPIN6_DataDone (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 5 : Acknowledged data transfer on this IN endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPIN5_Pos (5UL) /*!< Position of EPIN5 field. */
++#define USBD_EPDATASTATUS_EPIN5_Msk (0x1UL << USBD_EPDATASTATUS_EPIN5_Pos) /*!< Bit mask of EPIN5 field. */
++#define USBD_EPDATASTATUS_EPIN5_NotDone (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPIN5_DataDone (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 4 : Acknowledged data transfer on this IN endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPIN4_Pos (4UL) /*!< Position of EPIN4 field. */
++#define USBD_EPDATASTATUS_EPIN4_Msk (0x1UL << USBD_EPDATASTATUS_EPIN4_Pos) /*!< Bit mask of EPIN4 field. */
++#define USBD_EPDATASTATUS_EPIN4_NotDone (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPIN4_DataDone (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 3 : Acknowledged data transfer on this IN endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPIN3_Pos (3UL) /*!< Position of EPIN3 field. */
++#define USBD_EPDATASTATUS_EPIN3_Msk (0x1UL << USBD_EPDATASTATUS_EPIN3_Pos) /*!< Bit mask of EPIN3 field. */
++#define USBD_EPDATASTATUS_EPIN3_NotDone (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPIN3_DataDone (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 2 : Acknowledged data transfer on this IN endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPIN2_Pos (2UL) /*!< Position of EPIN2 field. */
++#define USBD_EPDATASTATUS_EPIN2_Msk (0x1UL << USBD_EPDATASTATUS_EPIN2_Pos) /*!< Bit mask of EPIN2 field. */
++#define USBD_EPDATASTATUS_EPIN2_NotDone (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPIN2_DataDone (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Bit 1 : Acknowledged data transfer on this IN endpoint. Write '1' to clear. */
++#define USBD_EPDATASTATUS_EPIN1_Pos (1UL) /*!< Position of EPIN1 field. */
++#define USBD_EPDATASTATUS_EPIN1_Msk (0x1UL << USBD_EPDATASTATUS_EPIN1_Pos) /*!< Bit mask of EPIN1 field. */
++#define USBD_EPDATASTATUS_EPIN1_NotDone (0UL) /*!< No acknowledged data transfer on this endpoint */
++#define USBD_EPDATASTATUS_EPIN1_DataDone (1UL) /*!< Acknowledged data transfer on this endpoint has occurred */
++
++/* Register: USBD_USBADDR */
++/* Description: Device USB address */
++
++/* Bits 6..0 : Device USB address */
++#define USBD_USBADDR_ADDR_Pos (0UL) /*!< Position of ADDR field. */
++#define USBD_USBADDR_ADDR_Msk (0x7FUL << USBD_USBADDR_ADDR_Pos) /*!< Bit mask of ADDR field. */
++
++/* Register: USBD_BMREQUESTTYPE */
++/* Description: SETUP data, byte 0, bmRequestType */
++
++/* Bit 7 : Data transfer direction */
++#define USBD_BMREQUESTTYPE_DIRECTION_Pos (7UL) /*!< Position of DIRECTION field. */
++#define USBD_BMREQUESTTYPE_DIRECTION_Msk (0x1UL << USBD_BMREQUESTTYPE_DIRECTION_Pos) /*!< Bit mask of DIRECTION field. */
++#define USBD_BMREQUESTTYPE_DIRECTION_HostToDevice (0UL) /*!< Host-to-device */
++#define USBD_BMREQUESTTYPE_DIRECTION_DeviceToHost (1UL) /*!< Device-to-host */
++
++/* Bits 6..5 : Data transfer type */
++#define USBD_BMREQUESTTYPE_TYPE_Pos (5UL) /*!< Position of TYPE field. */
++#define USBD_BMREQUESTTYPE_TYPE_Msk (0x3UL << USBD_BMREQUESTTYPE_TYPE_Pos) /*!< Bit mask of TYPE field. */
++#define USBD_BMREQUESTTYPE_TYPE_Standard (0UL) /*!< Standard */
++#define USBD_BMREQUESTTYPE_TYPE_Class (1UL) /*!< Class */
++#define USBD_BMREQUESTTYPE_TYPE_Vendor (2UL) /*!< Vendor */
++
++/* Bits 4..0 : Data transfer type */
++#define USBD_BMREQUESTTYPE_RECIPIENT_Pos (0UL) /*!< Position of RECIPIENT field. */
++#define USBD_BMREQUESTTYPE_RECIPIENT_Msk (0x1FUL << USBD_BMREQUESTTYPE_RECIPIENT_Pos) /*!< Bit mask of RECIPIENT field. */
++#define USBD_BMREQUESTTYPE_RECIPIENT_Device (0UL) /*!< Device */
++#define USBD_BMREQUESTTYPE_RECIPIENT_Interface (1UL) /*!< Interface */
++#define USBD_BMREQUESTTYPE_RECIPIENT_Endpoint (2UL) /*!< Endpoint */
++#define USBD_BMREQUESTTYPE_RECIPIENT_Other (3UL) /*!< Other */
++
++/* Register: USBD_BREQUEST */
++/* Description: SETUP data, byte 1, bRequest */
++
++/* Bits 7..0 : SETUP data, byte 1, bRequest. Values provided for standard requests only, user must implement class and vendor values. */
++#define USBD_BREQUEST_BREQUEST_Pos (0UL) /*!< Position of BREQUEST field. */
++#define USBD_BREQUEST_BREQUEST_Msk (0xFFUL << USBD_BREQUEST_BREQUEST_Pos) /*!< Bit mask of BREQUEST field. */
++#define USBD_BREQUEST_BREQUEST_STD_GET_STATUS (0UL) /*!< Standard request GET_STATUS */
++#define USBD_BREQUEST_BREQUEST_STD_CLEAR_FEATURE (1UL) /*!< Standard request CLEAR_FEATURE */
++#define USBD_BREQUEST_BREQUEST_STD_SET_FEATURE (3UL) /*!< Standard request SET_FEATURE */
++#define USBD_BREQUEST_BREQUEST_STD_SET_ADDRESS (5UL) /*!< Standard request SET_ADDRESS */
++#define USBD_BREQUEST_BREQUEST_STD_GET_DESCRIPTOR (6UL) /*!< Standard request GET_DESCRIPTOR */
++#define USBD_BREQUEST_BREQUEST_STD_SET_DESCRIPTOR (7UL) /*!< Standard request SET_DESCRIPTOR */
++#define USBD_BREQUEST_BREQUEST_STD_GET_CONFIGURATION (8UL) /*!< Standard request GET_CONFIGURATION */
++#define USBD_BREQUEST_BREQUEST_STD_SET_CONFIGURATION (9UL) /*!< Standard request SET_CONFIGURATION */
++#define USBD_BREQUEST_BREQUEST_STD_GET_INTERFACE (10UL) /*!< Standard request GET_INTERFACE */
++#define USBD_BREQUEST_BREQUEST_STD_SET_INTERFACE (11UL) /*!< Standard request SET_INTERFACE */
++#define USBD_BREQUEST_BREQUEST_STD_SYNCH_FRAME (12UL) /*!< Standard request SYNCH_FRAME */
++
++/* Register: USBD_WVALUEL */
++/* Description: SETUP data, byte 2, LSB of wValue */
++
++/* Bits 7..0 : SETUP data, byte 2, LSB of wValue */
++#define USBD_WVALUEL_WVALUEL_Pos (0UL) /*!< Position of WVALUEL field. */
++#define USBD_WVALUEL_WVALUEL_Msk (0xFFUL << USBD_WVALUEL_WVALUEL_Pos) /*!< Bit mask of WVALUEL field. */
++
++/* Register: USBD_WVALUEH */
++/* Description: SETUP data, byte 3, MSB of wValue */
++
++/* Bits 7..0 : SETUP data, byte 3, MSB of wValue */
++#define USBD_WVALUEH_WVALUEH_Pos (0UL) /*!< Position of WVALUEH field. */
++#define USBD_WVALUEH_WVALUEH_Msk (0xFFUL << USBD_WVALUEH_WVALUEH_Pos) /*!< Bit mask of WVALUEH field. */
++
++/* Register: USBD_WINDEXL */
++/* Description: SETUP data, byte 4, LSB of wIndex */
++
++/* Bits 7..0 : SETUP data, byte 4, LSB of wIndex */
++#define USBD_WINDEXL_WINDEXL_Pos (0UL) /*!< Position of WINDEXL field. */
++#define USBD_WINDEXL_WINDEXL_Msk (0xFFUL << USBD_WINDEXL_WINDEXL_Pos) /*!< Bit mask of WINDEXL field. */
++
++/* Register: USBD_WINDEXH */
++/* Description: SETUP data, byte 5, MSB of wIndex */
++
++/* Bits 7..0 : SETUP data, byte 5, MSB of wIndex */
++#define USBD_WINDEXH_WINDEXH_Pos (0UL) /*!< Position of WINDEXH field. */
++#define USBD_WINDEXH_WINDEXH_Msk (0xFFUL << USBD_WINDEXH_WINDEXH_Pos) /*!< Bit mask of WINDEXH field. */
++
++/* Register: USBD_WLENGTHL */
++/* Description: SETUP data, byte 6, LSB of wLength */
++
++/* Bits 7..0 : SETUP data, byte 6, LSB of wLength */
++#define USBD_WLENGTHL_WLENGTHL_Pos (0UL) /*!< Position of WLENGTHL field. */
++#define USBD_WLENGTHL_WLENGTHL_Msk (0xFFUL << USBD_WLENGTHL_WLENGTHL_Pos) /*!< Bit mask of WLENGTHL field. */
++
++/* Register: USBD_WLENGTHH */
++/* Description: SETUP data, byte 7, MSB of wLength */
++
++/* Bits 7..0 : SETUP data, byte 7, MSB of wLength */
++#define USBD_WLENGTHH_WLENGTHH_Pos (0UL) /*!< Position of WLENGTHH field. */
++#define USBD_WLENGTHH_WLENGTHH_Msk (0xFFUL << USBD_WLENGTHH_WLENGTHH_Pos) /*!< Bit mask of WLENGTHH field. */
++
++/* Register: USBD_SIZE_EPOUT */
++/* Description: Description collection: Number of bytes received last in the data stage of this OUT endpoint */
++
++/* Bits 6..0 : Number of bytes received last in the data stage of this OUT endpoint */
++#define USBD_SIZE_EPOUT_SIZE_Pos (0UL) /*!< Position of SIZE field. */
++#define USBD_SIZE_EPOUT_SIZE_Msk (0x7FUL << USBD_SIZE_EPOUT_SIZE_Pos) /*!< Bit mask of SIZE field. */
++
++/* Register: USBD_SIZE_ISOOUT */
++/* Description: Number of bytes received last on this ISO OUT data endpoint */
++
++/* Bit 16 : Zero-length data packet received */
++#define USBD_SIZE_ISOOUT_ZERO_Pos (16UL) /*!< Position of ZERO field. */
++#define USBD_SIZE_ISOOUT_ZERO_Msk (0x1UL << USBD_SIZE_ISOOUT_ZERO_Pos) /*!< Bit mask of ZERO field. */
++#define USBD_SIZE_ISOOUT_ZERO_Normal (0UL) /*!< No zero-length data received, use value in SIZE */
++#define USBD_SIZE_ISOOUT_ZERO_ZeroData (1UL) /*!< Zero-length data received, ignore value in SIZE */
++
++/* Bits 9..0 : Number of bytes received last on this ISO OUT data endpoint */
++#define USBD_SIZE_ISOOUT_SIZE_Pos (0UL) /*!< Position of SIZE field. */
++#define USBD_SIZE_ISOOUT_SIZE_Msk (0x3FFUL << USBD_SIZE_ISOOUT_SIZE_Pos) /*!< Bit mask of SIZE field. */
++
++/* Register: USBD_ENABLE */
++/* Description: Enable USB */
++
++/* Bit 0 : Enable USB */
++#define USBD_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
++#define USBD_ENABLE_ENABLE_Msk (0x1UL << USBD_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
++#define USBD_ENABLE_ENABLE_Disabled (0UL) /*!< USB peripheral is disabled */
++#define USBD_ENABLE_ENABLE_Enabled (1UL) /*!< USB peripheral is enabled */
++
++/* Register: USBD_USBPULLUP */
++/* Description: Control of the USB pull-up */
++
++/* Bit 0 : Control of the USB pull-up on the D+ line */
++#define USBD_USBPULLUP_CONNECT_Pos (0UL) /*!< Position of CONNECT field. */
++#define USBD_USBPULLUP_CONNECT_Msk (0x1UL << USBD_USBPULLUP_CONNECT_Pos) /*!< Bit mask of CONNECT field. */
++#define USBD_USBPULLUP_CONNECT_Disabled (0UL) /*!< Pull-up is disconnected */
++#define USBD_USBPULLUP_CONNECT_Enabled (1UL) /*!< Pull-up is connected to D+ */
++
++/* Register: USBD_DPDMVALUE */
++/* Description: State D+ and D- lines will be forced into by the DPDMDRIVE task. The DPDMNODRIVE task reverts the control of the lines to MAC IP (no forcing). */
++
++/* Bits 4..0 : State D+ and D- lines will be forced into by the DPDMDRIVE task */
++#define USBD_DPDMVALUE_STATE_Pos (0UL) /*!< Position of STATE field. */
++#define USBD_DPDMVALUE_STATE_Msk (0x1FUL << USBD_DPDMVALUE_STATE_Pos) /*!< Bit mask of STATE field. */
++#define USBD_DPDMVALUE_STATE_Resume (1UL) /*!< D+ forced low, D- forced high (K state) for a timing preset in hardware (50 us or 5 ms, depending on bus state) */
++#define USBD_DPDMVALUE_STATE_J (2UL) /*!< D+ forced high, D- forced low (J state) */
++#define USBD_DPDMVALUE_STATE_K (4UL) /*!< D+ forced low, D- forced high (K state) */
++
++/* Register: USBD_DTOGGLE */
++/* Description: Data toggle control and status */
++
++/* Bits 9..8 : Data toggle value */
++#define USBD_DTOGGLE_VALUE_Pos (8UL) /*!< Position of VALUE field. */
++#define USBD_DTOGGLE_VALUE_Msk (0x3UL << USBD_DTOGGLE_VALUE_Pos) /*!< Bit mask of VALUE field. */
++#define USBD_DTOGGLE_VALUE_Nop (0UL) /*!< No action on data toggle when writing the register with this value */
++#define USBD_DTOGGLE_VALUE_Data0 (1UL) /*!< Data toggle is DATA0 on endpoint set by EP and IO */
++#define USBD_DTOGGLE_VALUE_Data1 (2UL) /*!< Data toggle is DATA1 on endpoint set by EP and IO */
++
++/* Bit 7 : Selects IN or OUT endpoint */
++#define USBD_DTOGGLE_IO_Pos (7UL) /*!< Position of IO field. */
++#define USBD_DTOGGLE_IO_Msk (0x1UL << USBD_DTOGGLE_IO_Pos) /*!< Bit mask of IO field. */
++#define USBD_DTOGGLE_IO_Out (0UL) /*!< Selects OUT endpoint */
++#define USBD_DTOGGLE_IO_In (1UL) /*!< Selects IN endpoint */
++
++/* Bits 2..0 : Select bulk endpoint number */
++#define USBD_DTOGGLE_EP_Pos (0UL) /*!< Position of EP field. */
++#define USBD_DTOGGLE_EP_Msk (0x7UL << USBD_DTOGGLE_EP_Pos) /*!< Bit mask of EP field. */
++
++/* Register: USBD_EPINEN */
++/* Description: Endpoint IN enable */
++
++/* Bit 8 : Enable ISO IN endpoint */
++#define USBD_EPINEN_ISOIN_Pos (8UL) /*!< Position of ISOIN field. */
++#define USBD_EPINEN_ISOIN_Msk (0x1UL << USBD_EPINEN_ISOIN_Pos) /*!< Bit mask of ISOIN field. */
++#define USBD_EPINEN_ISOIN_Disable (0UL) /*!< Disable ISO IN endpoint 8 */
++#define USBD_EPINEN_ISOIN_Enable (1UL) /*!< Enable ISO IN endpoint 8 */
++
++/* Bit 7 : Enable IN endpoint 7 */
++#define USBD_EPINEN_IN7_Pos (7UL) /*!< Position of IN7 field. */
++#define USBD_EPINEN_IN7_Msk (0x1UL << USBD_EPINEN_IN7_Pos) /*!< Bit mask of IN7 field. */
++#define USBD_EPINEN_IN7_Disable (0UL) /*!< Disable endpoint IN 7 (no response to IN tokens) */
++#define USBD_EPINEN_IN7_Enable (1UL) /*!< Enable endpoint IN 7 (response to IN tokens) */
++
++/* Bit 6 : Enable IN endpoint 6 */
++#define USBD_EPINEN_IN6_Pos (6UL) /*!< Position of IN6 field. */
++#define USBD_EPINEN_IN6_Msk (0x1UL << USBD_EPINEN_IN6_Pos) /*!< Bit mask of IN6 field. */
++#define USBD_EPINEN_IN6_Disable (0UL) /*!< Disable endpoint IN 6 (no response to IN tokens) */
++#define USBD_EPINEN_IN6_Enable (1UL) /*!< Enable endpoint IN 6 (response to IN tokens) */
++
++/* Bit 5 : Enable IN endpoint 5 */
++#define USBD_EPINEN_IN5_Pos (5UL) /*!< Position of IN5 field. */
++#define USBD_EPINEN_IN5_Msk (0x1UL << USBD_EPINEN_IN5_Pos) /*!< Bit mask of IN5 field. */
++#define USBD_EPINEN_IN5_Disable (0UL) /*!< Disable endpoint IN 5 (no response to IN tokens) */
++#define USBD_EPINEN_IN5_Enable (1UL) /*!< Enable endpoint IN 5 (response to IN tokens) */
++
++/* Bit 4 : Enable IN endpoint 4 */
++#define USBD_EPINEN_IN4_Pos (4UL) /*!< Position of IN4 field. */
++#define USBD_EPINEN_IN4_Msk (0x1UL << USBD_EPINEN_IN4_Pos) /*!< Bit mask of IN4 field. */
++#define USBD_EPINEN_IN4_Disable (0UL) /*!< Disable endpoint IN 4 (no response to IN tokens) */
++#define USBD_EPINEN_IN4_Enable (1UL) /*!< Enable endpoint IN 4 (response to IN tokens) */
++
++/* Bit 3 : Enable IN endpoint 3 */
++#define USBD_EPINEN_IN3_Pos (3UL) /*!< Position of IN3 field. */
++#define USBD_EPINEN_IN3_Msk (0x1UL << USBD_EPINEN_IN3_Pos) /*!< Bit mask of IN3 field. */
++#define USBD_EPINEN_IN3_Disable (0UL) /*!< Disable endpoint IN 3 (no response to IN tokens) */
++#define USBD_EPINEN_IN3_Enable (1UL) /*!< Enable endpoint IN 3 (response to IN tokens) */
++
++/* Bit 2 : Enable IN endpoint 2 */
++#define USBD_EPINEN_IN2_Pos (2UL) /*!< Position of IN2 field. */
++#define USBD_EPINEN_IN2_Msk (0x1UL << USBD_EPINEN_IN2_Pos) /*!< Bit mask of IN2 field. */
++#define USBD_EPINEN_IN2_Disable (0UL) /*!< Disable endpoint IN 2 (no response to IN tokens) */
++#define USBD_EPINEN_IN2_Enable (1UL) /*!< Enable endpoint IN 2 (response to IN tokens) */
++
++/* Bit 1 : Enable IN endpoint 1 */
++#define USBD_EPINEN_IN1_Pos (1UL) /*!< Position of IN1 field. */
++#define USBD_EPINEN_IN1_Msk (0x1UL << USBD_EPINEN_IN1_Pos) /*!< Bit mask of IN1 field. */
++#define USBD_EPINEN_IN1_Disable (0UL) /*!< Disable endpoint IN 1 (no response to IN tokens) */
++#define USBD_EPINEN_IN1_Enable (1UL) /*!< Enable endpoint IN 1 (response to IN tokens) */
++
++/* Bit 0 : Enable IN endpoint 0 */
++#define USBD_EPINEN_IN0_Pos (0UL) /*!< Position of IN0 field. */
++#define USBD_EPINEN_IN0_Msk (0x1UL << USBD_EPINEN_IN0_Pos) /*!< Bit mask of IN0 field. */
++#define USBD_EPINEN_IN0_Disable (0UL) /*!< Disable endpoint IN 0 (no response to IN tokens) */
++#define USBD_EPINEN_IN0_Enable (1UL) /*!< Enable endpoint IN 0 (response to IN tokens) */
++
++/* Register: USBD_EPOUTEN */
++/* Description: Endpoint OUT enable */
++
++/* Bit 8 : Enable ISO OUT endpoint 8 */
++#define USBD_EPOUTEN_ISOOUT_Pos (8UL) /*!< Position of ISOOUT field. */
++#define USBD_EPOUTEN_ISOOUT_Msk (0x1UL << USBD_EPOUTEN_ISOOUT_Pos) /*!< Bit mask of ISOOUT field. */
++#define USBD_EPOUTEN_ISOOUT_Disable (0UL) /*!< Disable ISO OUT endpoint 8 */
++#define USBD_EPOUTEN_ISOOUT_Enable (1UL) /*!< Enable ISO OUT endpoint 8 */
++
++/* Bit 7 : Enable OUT endpoint 7 */
++#define USBD_EPOUTEN_OUT7_Pos (7UL) /*!< Position of OUT7 field. */
++#define USBD_EPOUTEN_OUT7_Msk (0x1UL << USBD_EPOUTEN_OUT7_Pos) /*!< Bit mask of OUT7 field. */
++#define USBD_EPOUTEN_OUT7_Disable (0UL) /*!< Disable endpoint OUT 7 (no response to OUT tokens) */
++#define USBD_EPOUTEN_OUT7_Enable (1UL) /*!< Enable endpoint OUT 7 (response to OUT tokens) */
++
++/* Bit 6 : Enable OUT endpoint 6 */
++#define USBD_EPOUTEN_OUT6_Pos (6UL) /*!< Position of OUT6 field. */
++#define USBD_EPOUTEN_OUT6_Msk (0x1UL << USBD_EPOUTEN_OUT6_Pos) /*!< Bit mask of OUT6 field. */
++#define USBD_EPOUTEN_OUT6_Disable (0UL) /*!< Disable endpoint OUT 6 (no response to OUT tokens) */
++#define USBD_EPOUTEN_OUT6_Enable (1UL) /*!< Enable endpoint OUT 6 (response to OUT tokens) */
++
++/* Bit 5 : Enable OUT endpoint 5 */
++#define USBD_EPOUTEN_OUT5_Pos (5UL) /*!< Position of OUT5 field. */
++#define USBD_EPOUTEN_OUT5_Msk (0x1UL << USBD_EPOUTEN_OUT5_Pos) /*!< Bit mask of OUT5 field. */
++#define USBD_EPOUTEN_OUT5_Disable (0UL) /*!< Disable endpoint OUT 5 (no response to OUT tokens) */
++#define USBD_EPOUTEN_OUT5_Enable (1UL) /*!< Enable endpoint OUT 5 (response to OUT tokens) */
++
++/* Bit 4 : Enable OUT endpoint 4 */
++#define USBD_EPOUTEN_OUT4_Pos (4UL) /*!< Position of OUT4 field. */
++#define USBD_EPOUTEN_OUT4_Msk (0x1UL << USBD_EPOUTEN_OUT4_Pos) /*!< Bit mask of OUT4 field. */
++#define USBD_EPOUTEN_OUT4_Disable (0UL) /*!< Disable endpoint OUT 4 (no response to OUT tokens) */
++#define USBD_EPOUTEN_OUT4_Enable (1UL) /*!< Enable endpoint OUT 4 (response to OUT tokens) */
++
++/* Bit 3 : Enable OUT endpoint 3 */
++#define USBD_EPOUTEN_OUT3_Pos (3UL) /*!< Position of OUT3 field. */
++#define USBD_EPOUTEN_OUT3_Msk (0x1UL << USBD_EPOUTEN_OUT3_Pos) /*!< Bit mask of OUT3 field. */
++#define USBD_EPOUTEN_OUT3_Disable (0UL) /*!< Disable endpoint OUT 3 (no response to OUT tokens) */
++#define USBD_EPOUTEN_OUT3_Enable (1UL) /*!< Enable endpoint OUT 3 (response to OUT tokens) */
++
++/* Bit 2 : Enable OUT endpoint 2 */
++#define USBD_EPOUTEN_OUT2_Pos (2UL) /*!< Position of OUT2 field. */
++#define USBD_EPOUTEN_OUT2_Msk (0x1UL << USBD_EPOUTEN_OUT2_Pos) /*!< Bit mask of OUT2 field. */
++#define USBD_EPOUTEN_OUT2_Disable (0UL) /*!< Disable endpoint OUT 2 (no response to OUT tokens) */
++#define USBD_EPOUTEN_OUT2_Enable (1UL) /*!< Enable endpoint OUT 2 (response to OUT tokens) */
++
++/* Bit 1 : Enable OUT endpoint 1 */
++#define USBD_EPOUTEN_OUT1_Pos (1UL) /*!< Position of OUT1 field. */
++#define USBD_EPOUTEN_OUT1_Msk (0x1UL << USBD_EPOUTEN_OUT1_Pos) /*!< Bit mask of OUT1 field. */
++#define USBD_EPOUTEN_OUT1_Disable (0UL) /*!< Disable endpoint OUT 1 (no response to OUT tokens) */
++#define USBD_EPOUTEN_OUT1_Enable (1UL) /*!< Enable endpoint OUT 1 (response to OUT tokens) */
++
++/* Bit 0 : Enable OUT endpoint 0 */
++#define USBD_EPOUTEN_OUT0_Pos (0UL) /*!< Position of OUT0 field. */
++#define USBD_EPOUTEN_OUT0_Msk (0x1UL << USBD_EPOUTEN_OUT0_Pos) /*!< Bit mask of OUT0 field. */
++#define USBD_EPOUTEN_OUT0_Disable (0UL) /*!< Disable endpoint OUT 0 (no response to OUT tokens) */
++#define USBD_EPOUTEN_OUT0_Enable (1UL) /*!< Enable endpoint OUT 0 (response to OUT tokens) */
++
++/* Register: USBD_EPSTALL */
++/* Description: STALL endpoints */
++
++/* Bit 8 : Stall selected endpoint */
++#define USBD_EPSTALL_STALL_Pos (8UL) /*!< Position of STALL field. */
++#define USBD_EPSTALL_STALL_Msk (0x1UL << USBD_EPSTALL_STALL_Pos) /*!< Bit mask of STALL field. */
++#define USBD_EPSTALL_STALL_UnStall (0UL) /*!< Don't stall selected endpoint */
++#define USBD_EPSTALL_STALL_Stall (1UL) /*!< Stall selected endpoint */
++
++/* Bit 7 : Selects IN or OUT endpoint */
++#define USBD_EPSTALL_IO_Pos (7UL) /*!< Position of IO field. */
++#define USBD_EPSTALL_IO_Msk (0x1UL << USBD_EPSTALL_IO_Pos) /*!< Bit mask of IO field. */
++#define USBD_EPSTALL_IO_Out (0UL) /*!< Selects OUT endpoint */
++#define USBD_EPSTALL_IO_In (1UL) /*!< Selects IN endpoint */
++
++/* Bits 2..0 : Select endpoint number */
++#define USBD_EPSTALL_EP_Pos (0UL) /*!< Position of EP field. */
++#define USBD_EPSTALL_EP_Msk (0x7UL << USBD_EPSTALL_EP_Pos) /*!< Bit mask of EP field. */
++
++/* Register: USBD_ISOSPLIT */
++/* Description: Controls the split of ISO buffers */
++
++/* Bits 15..0 : Controls the split of ISO buffers */
++#define USBD_ISOSPLIT_SPLIT_Pos (0UL) /*!< Position of SPLIT field. */
++#define USBD_ISOSPLIT_SPLIT_Msk (0xFFFFUL << USBD_ISOSPLIT_SPLIT_Pos) /*!< Bit mask of SPLIT field. */
++#define USBD_ISOSPLIT_SPLIT_OneDir (0x0000UL) /*!< Full buffer dedicated to either ISO IN or OUT */
++#define USBD_ISOSPLIT_SPLIT_HalfIN (0x0080UL) /*!< Lower half for IN, upper half for OUT */
++
++/* Register: USBD_FRAMECNTR */
++/* Description: Returns the current value of the start of frame counter */
++
++/* Bits 10..0 : Returns the current value of the start of frame counter */
++#define USBD_FRAMECNTR_FRAMECNTR_Pos (0UL) /*!< Position of FRAMECNTR field. */
++#define USBD_FRAMECNTR_FRAMECNTR_Msk (0x7FFUL << USBD_FRAMECNTR_FRAMECNTR_Pos) /*!< Bit mask of FRAMECNTR field. */
++
++/* Register: USBD_LOWPOWER */
++/* Description: Controls USBD peripheral low power mode during USB suspend */
++
++/* Bit 0 : Controls USBD peripheral low-power mode during USB suspend */
++#define USBD_LOWPOWER_LOWPOWER_Pos (0UL) /*!< Position of LOWPOWER field. */
++#define USBD_LOWPOWER_LOWPOWER_Msk (0x1UL << USBD_LOWPOWER_LOWPOWER_Pos) /*!< Bit mask of LOWPOWER field. */
++#define USBD_LOWPOWER_LOWPOWER_ForceNormal (0UL) /*!< Software must write this value to exit low power mode and before performing a remote wake-up */
++#define USBD_LOWPOWER_LOWPOWER_LowPower (1UL) /*!< Software must write this value to enter low power mode after DMA and software have finished interacting with the USB peripheral */
++
++/* Register: USBD_ISOINCONFIG */
++/* Description: Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent */
++
++/* Bit 0 : Controls the response of the ISO IN endpoint to an IN token when no data is ready to be sent */
++#define USBD_ISOINCONFIG_RESPONSE_Pos (0UL) /*!< Position of RESPONSE field. */
++#define USBD_ISOINCONFIG_RESPONSE_Msk (0x1UL << USBD_ISOINCONFIG_RESPONSE_Pos) /*!< Bit mask of RESPONSE field. */
++#define USBD_ISOINCONFIG_RESPONSE_NoResp (0UL) /*!< Endpoint does not respond in that case */
++#define USBD_ISOINCONFIG_RESPONSE_ZeroData (1UL) /*!< Endpoint responds with a zero-length data packet in that case */
++
++/* Register: USBD_EPIN_PTR */
++/* Description: Description cluster: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define USBD_EPIN_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define USBD_EPIN_PTR_PTR_Msk (0xFFFFFFFFUL << USBD_EPIN_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: USBD_EPIN_MAXCNT */
++/* Description: Description cluster: Maximum number of bytes to transfer */
++
++/* Bits 6..0 : Maximum number of bytes to transfer */
++#define USBD_EPIN_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define USBD_EPIN_MAXCNT_MAXCNT_Msk (0x7FUL << USBD_EPIN_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: USBD_EPIN_AMOUNT */
++/* Description: Description cluster: Number of bytes transferred in the last transaction */
++
++/* Bits 6..0 : Number of bytes transferred in the last transaction */
++#define USBD_EPIN_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define USBD_EPIN_AMOUNT_AMOUNT_Msk (0x7FUL << USBD_EPIN_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: USBD_ISOIN_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define USBD_ISOIN_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define USBD_ISOIN_PTR_PTR_Msk (0xFFFFFFFFUL << USBD_ISOIN_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: USBD_ISOIN_MAXCNT */
++/* Description: Maximum number of bytes to transfer */
++
++/* Bits 9..0 : Maximum number of bytes to transfer */
++#define USBD_ISOIN_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define USBD_ISOIN_MAXCNT_MAXCNT_Msk (0x3FFUL << USBD_ISOIN_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: USBD_ISOIN_AMOUNT */
++/* Description: Number of bytes transferred in the last transaction */
++
++/* Bits 9..0 : Number of bytes transferred in the last transaction */
++#define USBD_ISOIN_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define USBD_ISOIN_AMOUNT_AMOUNT_Msk (0x3FFUL << USBD_ISOIN_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: USBD_EPOUT_PTR */
++/* Description: Description cluster: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define USBD_EPOUT_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define USBD_EPOUT_PTR_PTR_Msk (0xFFFFFFFFUL << USBD_EPOUT_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: USBD_EPOUT_MAXCNT */
++/* Description: Description cluster: Maximum number of bytes to transfer */
++
++/* Bits 6..0 : Maximum number of bytes to transfer */
++#define USBD_EPOUT_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define USBD_EPOUT_MAXCNT_MAXCNT_Msk (0x7FUL << USBD_EPOUT_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: USBD_EPOUT_AMOUNT */
++/* Description: Description cluster: Number of bytes transferred in the last transaction */
++
++/* Bits 6..0 : Number of bytes transferred in the last transaction */
++#define USBD_EPOUT_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define USBD_EPOUT_AMOUNT_AMOUNT_Msk (0x7FUL << USBD_EPOUT_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++/* Register: USBD_ISOOUT_PTR */
++/* Description: Data pointer */
++
++/* Bits 31..0 : Data pointer */
++#define USBD_ISOOUT_PTR_PTR_Pos (0UL) /*!< Position of PTR field. */
++#define USBD_ISOOUT_PTR_PTR_Msk (0xFFFFFFFFUL << USBD_ISOOUT_PTR_PTR_Pos) /*!< Bit mask of PTR field. */
++
++/* Register: USBD_ISOOUT_MAXCNT */
++/* Description: Maximum number of bytes to transfer */
++
++/* Bits 9..0 : Maximum number of bytes to transfer */
++#define USBD_ISOOUT_MAXCNT_MAXCNT_Pos (0UL) /*!< Position of MAXCNT field. */
++#define USBD_ISOOUT_MAXCNT_MAXCNT_Msk (0x3FFUL << USBD_ISOOUT_MAXCNT_MAXCNT_Pos) /*!< Bit mask of MAXCNT field. */
++
++/* Register: USBD_ISOOUT_AMOUNT */
++/* Description: Number of bytes transferred in the last transaction */
++
++/* Bits 9..0 : Number of bytes transferred in the last transaction */
++#define USBD_ISOOUT_AMOUNT_AMOUNT_Pos (0UL) /*!< Position of AMOUNT field. */
++#define USBD_ISOOUT_AMOUNT_AMOUNT_Msk (0x3FFUL << USBD_ISOOUT_AMOUNT_AMOUNT_Pos) /*!< Bit mask of AMOUNT field. */
++
++
++/* Peripheral: WDT */
++/* Description: Watchdog Timer */
++
++/* Register: WDT_TASKS_START */
++/* Description: Start the watchdog */
++
++/* Bit 0 : Start the watchdog */
++#define WDT_TASKS_START_TASKS_START_Pos (0UL) /*!< Position of TASKS_START field. */
++#define WDT_TASKS_START_TASKS_START_Msk (0x1UL << WDT_TASKS_START_TASKS_START_Pos) /*!< Bit mask of TASKS_START field. */
++#define WDT_TASKS_START_TASKS_START_Trigger (1UL) /*!< Trigger task */
++
++/* Register: WDT_EVENTS_TIMEOUT */
++/* Description: Watchdog timeout */
++
++/* Bit 0 : Watchdog timeout */
++#define WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Pos (0UL) /*!< Position of EVENTS_TIMEOUT field. */
++#define WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Msk (0x1UL << WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Pos) /*!< Bit mask of EVENTS_TIMEOUT field. */
++#define WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_NotGenerated (0UL) /*!< Event not generated */
++#define WDT_EVENTS_TIMEOUT_EVENTS_TIMEOUT_Generated (1UL) /*!< Event generated */
++
++/* Register: WDT_INTENSET */
++/* Description: Enable interrupt */
++
++/* Bit 0 : Write '1' to enable interrupt for event TIMEOUT */
++#define WDT_INTENSET_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
++#define WDT_INTENSET_TIMEOUT_Msk (0x1UL << WDT_INTENSET_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
++#define WDT_INTENSET_TIMEOUT_Disabled (0UL) /*!< Read: Disabled */
++#define WDT_INTENSET_TIMEOUT_Enabled (1UL) /*!< Read: Enabled */
++#define WDT_INTENSET_TIMEOUT_Set (1UL) /*!< Enable */
++
++/* Register: WDT_INTENCLR */
++/* Description: Disable interrupt */
++
++/* Bit 0 : Write '1' to disable interrupt for event TIMEOUT */
++#define WDT_INTENCLR_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
++#define WDT_INTENCLR_TIMEOUT_Msk (0x1UL << WDT_INTENCLR_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
++#define WDT_INTENCLR_TIMEOUT_Disabled (0UL) /*!< Read: Disabled */
++#define WDT_INTENCLR_TIMEOUT_Enabled (1UL) /*!< Read: Enabled */
++#define WDT_INTENCLR_TIMEOUT_Clear (1UL) /*!< Disable */
++
++/* Register: WDT_RUNSTATUS */
++/* Description: Run status */
++
++/* Bit 0 : Indicates whether or not the watchdog is running */
++#define WDT_RUNSTATUS_RUNSTATUS_Pos (0UL) /*!< Position of RUNSTATUS field. */
++#define WDT_RUNSTATUS_RUNSTATUS_Msk (0x1UL << WDT_RUNSTATUS_RUNSTATUS_Pos) /*!< Bit mask of RUNSTATUS field. */
++#define WDT_RUNSTATUS_RUNSTATUS_NotRunning (0UL) /*!< Watchdog not running */
++#define WDT_RUNSTATUS_RUNSTATUS_Running (1UL) /*!< Watchdog is running */
++
++/* Register: WDT_REQSTATUS */
++/* Description: Request status */
++
++/* Bit 7 : Request status for RR[7] register */
++#define WDT_REQSTATUS_RR7_Pos (7UL) /*!< Position of RR7 field. */
++#define WDT_REQSTATUS_RR7_Msk (0x1UL << WDT_REQSTATUS_RR7_Pos) /*!< Bit mask of RR7 field. */
++#define WDT_REQSTATUS_RR7_DisabledOrRequested (0UL) /*!< RR[7] register is not enabled, or are already requesting reload */
++#define WDT_REQSTATUS_RR7_EnabledAndUnrequested (1UL) /*!< RR[7] register is enabled, and are not yet requesting reload */
++
++/* Bit 6 : Request status for RR[6] register */
++#define WDT_REQSTATUS_RR6_Pos (6UL) /*!< Position of RR6 field. */
++#define WDT_REQSTATUS_RR6_Msk (0x1UL << WDT_REQSTATUS_RR6_Pos) /*!< Bit mask of RR6 field. */
++#define WDT_REQSTATUS_RR6_DisabledOrRequested (0UL) /*!< RR[6] register is not enabled, or are already requesting reload */
++#define WDT_REQSTATUS_RR6_EnabledAndUnrequested (1UL) /*!< RR[6] register is enabled, and are not yet requesting reload */
++
++/* Bit 5 : Request status for RR[5] register */
++#define WDT_REQSTATUS_RR5_Pos (5UL) /*!< Position of RR5 field. */
++#define WDT_REQSTATUS_RR5_Msk (0x1UL << WDT_REQSTATUS_RR5_Pos) /*!< Bit mask of RR5 field. */
++#define WDT_REQSTATUS_RR5_DisabledOrRequested (0UL) /*!< RR[5] register is not enabled, or are already requesting reload */
++#define WDT_REQSTATUS_RR5_EnabledAndUnrequested (1UL) /*!< RR[5] register is enabled, and are not yet requesting reload */
++
++/* Bit 4 : Request status for RR[4] register */
++#define WDT_REQSTATUS_RR4_Pos (4UL) /*!< Position of RR4 field. */
++#define WDT_REQSTATUS_RR4_Msk (0x1UL << WDT_REQSTATUS_RR4_Pos) /*!< Bit mask of RR4 field. */
++#define WDT_REQSTATUS_RR4_DisabledOrRequested (0UL) /*!< RR[4] register is not enabled, or are already requesting reload */
++#define WDT_REQSTATUS_RR4_EnabledAndUnrequested (1UL) /*!< RR[4] register is enabled, and are not yet requesting reload */
++
++/* Bit 3 : Request status for RR[3] register */
++#define WDT_REQSTATUS_RR3_Pos (3UL) /*!< Position of RR3 field. */
++#define WDT_REQSTATUS_RR3_Msk (0x1UL << WDT_REQSTATUS_RR3_Pos) /*!< Bit mask of RR3 field. */
++#define WDT_REQSTATUS_RR3_DisabledOrRequested (0UL) /*!< RR[3] register is not enabled, or are already requesting reload */
++#define WDT_REQSTATUS_RR3_EnabledAndUnrequested (1UL) /*!< RR[3] register is enabled, and are not yet requesting reload */
++
++/* Bit 2 : Request status for RR[2] register */
++#define WDT_REQSTATUS_RR2_Pos (2UL) /*!< Position of RR2 field. */
++#define WDT_REQSTATUS_RR2_Msk (0x1UL << WDT_REQSTATUS_RR2_Pos) /*!< Bit mask of RR2 field. */
++#define WDT_REQSTATUS_RR2_DisabledOrRequested (0UL) /*!< RR[2] register is not enabled, or are already requesting reload */
++#define WDT_REQSTATUS_RR2_EnabledAndUnrequested (1UL) /*!< RR[2] register is enabled, and are not yet requesting reload */
++
++/* Bit 1 : Request status for RR[1] register */
++#define WDT_REQSTATUS_RR1_Pos (1UL) /*!< Position of RR1 field. */
++#define WDT_REQSTATUS_RR1_Msk (0x1UL << WDT_REQSTATUS_RR1_Pos) /*!< Bit mask of RR1 field. */
++#define WDT_REQSTATUS_RR1_DisabledOrRequested (0UL) /*!< RR[1] register is not enabled, or are already requesting reload */
++#define WDT_REQSTATUS_RR1_EnabledAndUnrequested (1UL) /*!< RR[1] register is enabled, and are not yet requesting reload */
++
++/* Bit 0 : Request status for RR[0] register */
++#define WDT_REQSTATUS_RR0_Pos (0UL) /*!< Position of RR0 field. */
++#define WDT_REQSTATUS_RR0_Msk (0x1UL << WDT_REQSTATUS_RR0_Pos) /*!< Bit mask of RR0 field. */
++#define WDT_REQSTATUS_RR0_DisabledOrRequested (0UL) /*!< RR[0] register is not enabled, or are already requesting reload */
++#define WDT_REQSTATUS_RR0_EnabledAndUnrequested (1UL) /*!< RR[0] register is enabled, and are not yet requesting reload */
++
++/* Register: WDT_CRV */
++/* Description: Counter reload value */
++
++/* Bits 31..0 : Counter reload value in number of cycles of the 32.768 kHz clock */
++#define WDT_CRV_CRV_Pos (0UL) /*!< Position of CRV field. */
++#define WDT_CRV_CRV_Msk (0xFFFFFFFFUL << WDT_CRV_CRV_Pos) /*!< Bit mask of CRV field. */
++
++/* Register: WDT_RREN */
++/* Description: Enable register for reload request registers */
++
++/* Bit 7 : Enable or disable RR[7] register */
++#define WDT_RREN_RR7_Pos (7UL) /*!< Position of RR7 field. */
++#define WDT_RREN_RR7_Msk (0x1UL << WDT_RREN_RR7_Pos) /*!< Bit mask of RR7 field. */
++#define WDT_RREN_RR7_Disabled (0UL) /*!< Disable RR[7] register */
++#define WDT_RREN_RR7_Enabled (1UL) /*!< Enable RR[7] register */
++
++/* Bit 6 : Enable or disable RR[6] register */
++#define WDT_RREN_RR6_Pos (6UL) /*!< Position of RR6 field. */
++#define WDT_RREN_RR6_Msk (0x1UL << WDT_RREN_RR6_Pos) /*!< Bit mask of RR6 field. */
++#define WDT_RREN_RR6_Disabled (0UL) /*!< Disable RR[6] register */
++#define WDT_RREN_RR6_Enabled (1UL) /*!< Enable RR[6] register */
++
++/* Bit 5 : Enable or disable RR[5] register */
++#define WDT_RREN_RR5_Pos (5UL) /*!< Position of RR5 field. */
++#define WDT_RREN_RR5_Msk (0x1UL << WDT_RREN_RR5_Pos) /*!< Bit mask of RR5 field. */
++#define WDT_RREN_RR5_Disabled (0UL) /*!< Disable RR[5] register */
++#define WDT_RREN_RR5_Enabled (1UL) /*!< Enable RR[5] register */
++
++/* Bit 4 : Enable or disable RR[4] register */
++#define WDT_RREN_RR4_Pos (4UL) /*!< Position of RR4 field. */
++#define WDT_RREN_RR4_Msk (0x1UL << WDT_RREN_RR4_Pos) /*!< Bit mask of RR4 field. */
++#define WDT_RREN_RR4_Disabled (0UL) /*!< Disable RR[4] register */
++#define WDT_RREN_RR4_Enabled (1UL) /*!< Enable RR[4] register */
++
++/* Bit 3 : Enable or disable RR[3] register */
++#define WDT_RREN_RR3_Pos (3UL) /*!< Position of RR3 field. */
++#define WDT_RREN_RR3_Msk (0x1UL << WDT_RREN_RR3_Pos) /*!< Bit mask of RR3 field. */
++#define WDT_RREN_RR3_Disabled (0UL) /*!< Disable RR[3] register */
++#define WDT_RREN_RR3_Enabled (1UL) /*!< Enable RR[3] register */
++
++/* Bit 2 : Enable or disable RR[2] register */
++#define WDT_RREN_RR2_Pos (2UL) /*!< Position of RR2 field. */
++#define WDT_RREN_RR2_Msk (0x1UL << WDT_RREN_RR2_Pos) /*!< Bit mask of RR2 field. */
++#define WDT_RREN_RR2_Disabled (0UL) /*!< Disable RR[2] register */
++#define WDT_RREN_RR2_Enabled (1UL) /*!< Enable RR[2] register */
++
++/* Bit 1 : Enable or disable RR[1] register */
++#define WDT_RREN_RR1_Pos (1UL) /*!< Position of RR1 field. */
++#define WDT_RREN_RR1_Msk (0x1UL << WDT_RREN_RR1_Pos) /*!< Bit mask of RR1 field. */
++#define WDT_RREN_RR1_Disabled (0UL) /*!< Disable RR[1] register */
++#define WDT_RREN_RR1_Enabled (1UL) /*!< Enable RR[1] register */
++
++/* Bit 0 : Enable or disable RR[0] register */
++#define WDT_RREN_RR0_Pos (0UL) /*!< Position of RR0 field. */
++#define WDT_RREN_RR0_Msk (0x1UL << WDT_RREN_RR0_Pos) /*!< Bit mask of RR0 field. */
++#define WDT_RREN_RR0_Disabled (0UL) /*!< Disable RR[0] register */
++#define WDT_RREN_RR0_Enabled (1UL) /*!< Enable RR[0] register */
++
++/* Register: WDT_CONFIG */
++/* Description: Configuration register */
++
++/* Bit 3 : Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger */
++#define WDT_CONFIG_HALT_Pos (3UL) /*!< Position of HALT field. */
++#define WDT_CONFIG_HALT_Msk (0x1UL << WDT_CONFIG_HALT_Pos) /*!< Bit mask of HALT field. */
++#define WDT_CONFIG_HALT_Pause (0UL) /*!< Pause watchdog while the CPU is halted by the debugger */
++#define WDT_CONFIG_HALT_Run (1UL) /*!< Keep the watchdog running while the CPU is halted by the debugger */
++
++/* Bit 0 : Configure the watchdog to either be paused, or kept running, while the CPU is sleeping */
++#define WDT_CONFIG_SLEEP_Pos (0UL) /*!< Position of SLEEP field. */
++#define WDT_CONFIG_SLEEP_Msk (0x1UL << WDT_CONFIG_SLEEP_Pos) /*!< Bit mask of SLEEP field. */
++#define WDT_CONFIG_SLEEP_Pause (0UL) /*!< Pause watchdog while the CPU is sleeping */
++#define WDT_CONFIG_SLEEP_Run (1UL) /*!< Keep the watchdog running while the CPU is sleeping */
++
++/* Register: WDT_RR */
++/* Description: Description collection: Reload request n */
++
++/* Bits 31..0 : Reload request register */
++#define WDT_RR_RR_Pos (0UL) /*!< Position of RR field. */
++#define WDT_RR_RR_Msk (0xFFFFFFFFUL << WDT_RR_RR_Pos) /*!< Bit mask of RR field. */
++#define WDT_RR_RR_Reload (0x6E524635UL) /*!< Value to request a reload of the watchdog timer */
++
++
++/*lint --flb "Leave library region" */
++#endif
+diff --git a/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz-2.emSession b/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz-2.emSession
+new file mode 100644
+index 00000000..f6dd7aea
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz-2.emSession
+@@ -0,0 +1,123 @@
++<!DOCTYPE CrossStudio_Session_File>
++<session>
++ <Bookmarks/>
++ <Breakpoints groups="Breakpoints" active_group="Breakpoints">
++  <BreakpointListItem trigger="" line="48" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_sctimer/01bsp_sctimer.c" useHWbreakpoint="false"/>
++  <BreakpointListItem trigger="" line="113" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_uart/01bsp_uart.c" useHWbreakpoint="false"/>
++  <BreakpointListItem trigger="" line="137" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_uart/01bsp_uart.c" useHWbreakpoint="false"/>
++ </Breakpoints>
++ <ExecutionProfileWindow/>
++ <FrameBuffer>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_leds_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_sctimer_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_uart_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_i2c_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_bmx160_Debug" addressText="" accessByDisplayWidth="0"/>
++ </FrameBuffer>
++ <Memory1>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++ </Memory1>
++ <Memory2>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++ </Memory2>
++ <Memory3>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++ </Memory3>
++ <Memory4>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++ </Memory4>
++ <Project>
++  <ProjectSessionItem path="nrf52840-dk"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp;sdk"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;application"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;chips"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_i2c"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_i2c;application"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;bsp"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;bsp;sdk"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;inc"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;application"/>
++ </Project>
++ <Register1>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++ </Register1>
++ <Register2>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++ </Register2>
++ <Register3>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++ </Register3>
++ <Register4>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++ </Register4>
++ <Threads>
++  <ThreadsWindow showLists=""/>
++ </Threads>
++ <TraceWindow>
++  <Trace enabled="Yes"/>
++ </TraceWindow>
++ <Watch1>
++  <Watches active="1" update="Never">
++   <Watchpoint expression="counter_current" name="counter_current" radix="16" linenumber="149" filename="../common/01bsp_leds/01bsp_leds.c"/>
++   <Watchpoint expression="timerflag" name="timerflag" radix="-1" linenumber="63" filename="../common/01bsp_leds/01bsp_leds.c"/>
++   <Watchpoint expression="byte" name="byte" radix="16" linenumber="139" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="uart_lastRxByteIndex" name="uart_lastRxByteIndex" radix="16" linenumber="137" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="stringToReceive" name="stringToReceive" radix="-1" linenumber="136" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="echoStartFlag" name="echoStartFlag" radix="16" linenumber="139" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="app_vars" name="app_vars" radix="-1" linenumber="42" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="i" name="i" radix="-1" linenumber="113" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="who_am_i" name="who_am_i" radix="16" linenumber="26" filename="../common/01bsp_i2c/01bsp_i2c.c"/>
++  </Watches>
++ </Watch1>
++ <Watch2>
++  <Watches active="0" update="Never"/>
++ </Watch2>
++ <Watch3>
++  <Watches active="0" update="Never"/>
++ </Watch3>
++ <Watch4>
++  <Watches active="0" update="Never"/>
++ </Watch4>
++ <Files>
++  <SessionOpenFile windowGroup="DockEditLeft" x="40" y="131" useTextEdit="1" path="01bsp_bmx160/01bsp_bmx160.c" left="0" selected="1" top="113" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="42" y="96" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/nrf52840_dk/01bsp_bmx160/01bsp_bmx160.c" path="../../bsp/chips/bmx160/bmx160.c" left="0" top="80" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="19" y="10" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/bsp/chips/bmx160/bmx160.c" path="../../bsp/chips/bmx160/bmx160.h" left="0" top="0" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="5" y="85" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/nrf52840_dk/01bsp_bmx160/01bsp_bmx160.c" path="../../bsp/boards/nrf52840_dk/i2c.c" left="0" top="70" codecName="Default"/>
++ </Files>
++ <EMStudioWindow activeProject="01bsp_bmx160" fileDialogDefaultFilter="*.emProject" autoConnectTarget="J-Link" buildConfiguration="Debug" sessionSettings="" debugSearchFileMap="" fileDialogInitialDirectory="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/nrf52840_dk" debugSearchPath="" autoConnectCapabilities="3711"/>
++</session>
+diff --git a/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz.emSession b/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz.emSession
+new file mode 100644
+index 00000000..3a026d37
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz.emSession
+@@ -0,0 +1,121 @@
++<!DOCTYPE CrossStudio_Session_File>
++<session>
++ <Bookmarks/>
++ <Breakpoints groups="Breakpoints" active_group="Breakpoints">
++  <BreakpointListItem trigger="" line="48" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_sctimer/01bsp_sctimer.c" useHWbreakpoint="false"/>
++  <BreakpointListItem trigger="" line="113" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_uart/01bsp_uart.c" useHWbreakpoint="false"/>
++  <BreakpointListItem trigger="" line="137" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_uart/01bsp_uart.c" useHWbreakpoint="false"/>
++  <Exceptions set="MemManage;UsageFault_Coprocessor;UsageFault_CheckingError;UsageFault_StateError;BusFault;ExceptionEntryReturnFault;HardFault"/>
++ </Breakpoints>
++ <ExecutionProfileWindow/>
++ <FrameBuffer>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_leds_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_sctimer_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_uart_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_i2c_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_bmx160_Debug" addressText="" accessByDisplayWidth="0"/>
++ </FrameBuffer>
++ <Memory1>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++ </Memory1>
++ <Memory2>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++ </Memory2>
++ <Memory3>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++ </Memory3>
++ <Memory4>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++ </Memory4>
++ <Project>
++  <ProjectSessionItem path="nrf52840-dk"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;application"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_i2c"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_i2c;application"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;application"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;bsp"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;bsp;sdk"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;inc"/>
++ </Project>
++ <Register1>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++ </Register1>
++ <Register2>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++ </Register2>
++ <Register3>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++ </Register3>
++ <Register4>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++ </Register4>
++ <Threads>
++  <ThreadsWindow showLists=""/>
++ </Threads>
++ <TraceWindow>
++  <Trace enabled="Yes"/>
++ </TraceWindow>
++ <Watch1>
++  <Watches active="1" update="Never">
++   <Watchpoint expression="counter_current" name="counter_current" radix="16" linenumber="149" filename="../common/01bsp_leds/01bsp_leds.c"/>
++   <Watchpoint expression="timerflag" name="timerflag" radix="-1" linenumber="63" filename="../common/01bsp_leds/01bsp_leds.c"/>
++   <Watchpoint expression="byte" name="byte" radix="16" linenumber="139" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="uart_lastRxByteIndex" name="uart_lastRxByteIndex" radix="16" linenumber="137" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="stringToReceive" name="stringToReceive" radix="-1" linenumber="136" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="echoStartFlag" name="echoStartFlag" radix="16" linenumber="139" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="app_vars" name="app_vars" radix="-1" linenumber="42" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="i" name="i" radix="-1" linenumber="113" filename="../common/01bsp_uart/01bsp_uart.c"/>
++   <Watchpoint expression="who_am_i" name="who_am_i" radix="16" linenumber="26" filename="../common/01bsp_i2c/01bsp_i2c.c"/>
++  </Watches>
++ </Watch1>
++ <Watch2>
++  <Watches active="0" update="Never"/>
++ </Watch2>
++ <Watch3>
++  <Watches active="0" update="Never"/>
++ </Watch3>
++ <Watch4>
++  <Watches active="0" update="Never"/>
++ </Watch4>
++ <Files>
++  <SessionOpenFile windowGroup="DockEditLeft" x="50" y="114" useTextEdit="1" path="01bsp_bmx160/01bsp_bmx160.c" left="0" top="107" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="29" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/board.c" left="0" selected="1" top="0" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="108" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/i2c.c" left="0" top="91" codecName="Default"/>
++ </Files>
++ <EMStudioWindow activeProject="01bsp_bmx160" fileDialogDefaultFilter="*.emProject" autoConnectTarget="J-Link" buildConfiguration="Debug" sessionSettings="" debugSearchFileMap="" fileDialogInitialDirectory="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/nrf52840_dk" debugSearchPath="" autoConnectCapabilities="3711"/>
++</session>
+diff --git a/projects/nrf52840_dk/nrf52840_dk.emProject b/projects/nrf52840_dk/nrf52840_dk.emProject
+index 45e9796f..131c2023 100644
+--- a/projects/nrf52840_dk/nrf52840_dk.emProject
++++ b/projects/nrf52840_dk/nrf52840_dk.emProject
+@@ -67,7 +67,7 @@
+       path="../../inc"
+       recurse="Yes" />
+   </project>
+-  <project Name="01bsp_debugpins">
++  <project Name="01bsp_bmx388">
+     <configuration
+       LIBRARY_IO_TYPE="None"
+       Name="Common"
+@@ -84,7 +84,7 @@
+       arm_target_device_name="nRF52840_xxAA"
+       arm_target_interface_type="SWD"
+       c_preprocessor_definitions="NRF52840_XXAA;NRF52840_DK"
+-      c_user_include_directories="../../bsp/boards;../../bsp/boards/nrf52840_dk;../../bsp/boards/nrf52840_dk/sdk;../../inc"
++      c_user_include_directories="../../bsp/boards;../../bsp/boards/nrf52840_dk;../../bsp/boards/nrf52840_dk/sdk;../../bsp/chips/bmx160;../../bsp/chips/bmx388;../../inc"
+       debug_register_definition_file="../../bsp/boards/nrf52840-dk/sdk/nrf52840.svd"
+       debug_start_from_entry_point_symbol="No"
+       debug_target_connection="J-Link"
+@@ -104,7 +104,7 @@
+       Name="application"
+       exclude=""
+       filter="*.c"
+-      path="../common/01bsp_debugpins"
++      path="../common/01bsp_bmx388"
+       recurse="Yes" />
+     <folder
+       Name="bsp"
+@@ -112,6 +112,12 @@
+       filter="*.s;*.c;*.h"
+       path="../../bsp/boards/nrf52840_dk"
+       recurse="Yes" />
++    <folder
++      Name="chips"
++      exclude=""
++      filter=""
++      path="../../bsp/chips/bmx388"
++      recurse="Yes" />
+     <folder
+       Name="inc"
+       exclude=""
+@@ -119,7 +125,7 @@
+       path="../../inc"
+       recurse="Yes" />
+   </project>
+-  <project Name="01bsp_eui64">
++  <project Name="01bsp_debugpins">
+     <configuration
+       LIBRARY_IO_TYPE="None"
+       Name="Common"
+@@ -156,7 +162,7 @@
+       Name="application"
+       exclude=""
+       filter="*.c"
+-      path="../common/01bsp_eui64"
++      path="../common/01bsp_debugpins"
+       recurse="Yes" />
+     <folder
+       Name="bsp"
+@@ -171,7 +177,7 @@
+       path="../../inc"
+       recurse="Yes" />
+   </project>
+-  <project Name="01bsp_i2c">
++  <project Name="01bsp_eui64">
+     <configuration
+       LIBRARY_IO_TYPE="None"
+       Name="Common"
+@@ -208,7 +214,7 @@
+       Name="application"
+       exclude=""
+       filter="*.c"
+-      path="../common/01bsp_i2c"
++      path="../common/01bsp_eui64"
+       recurse="Yes" />
+     <folder
+       Name="bsp"
+@@ -216,12 +222,6 @@
+       filter="*.s;*.c;*.h"
+       path="../../bsp/boards/nrf52840_dk"
+       recurse="Yes" />
+-    <folder
+-      Name="chips"
+-      exclude=""
+-      filter=""
+-      path="../../bsp/chips/bmx160"
+-      recurse="Yes" />
+     <folder
+       Name="inc"
+       exclude=""
+@@ -229,6 +229,96 @@
+       path="../../inc"
+       recurse="Yes" />
+   </project>
++  <project Name="01bsp_i2c">
++    <configuration
++      LIBRARY_IO_TYPE="None"
++      Name="Common"
++      arm_architecture="v7EM"
++      arm_core_type="Cortex-M4"
++      arm_endian="Little"
++      arm_fp_abi="Hard"
++      arm_fpu_type="FPv4-SP-D16"
++      arm_linker_heap_size="8192"
++      arm_linker_process_stack_size="0"
++      arm_linker_stack_size="8192"
++      arm_linker_treat_warnings_as_errors="No"
++      arm_simulator_memory_simulation_parameter="RWX 00000000,00100000,FFFFFFFF;RWX 20000000,00010000,CDCDCDCD"
++      arm_target_device_name="nRF52840_xxAA"
++      arm_target_interface_type="SWD"
++      c_preprocessor_definitions="NRF52840_XXAA;NRF52840_DK"
++      c_user_include_directories="../../bsp/boards;../../bsp/boards/nrf52840_dk;../../bsp/boards/nrf52840_dk/sdk;../../inc"
++      debug_register_definition_file="../../bsp/boards/nrf52840-dk/sdk/nrf52840.svd"
++      debug_start_from_entry_point_symbol="No"
++      debug_target_connection="J-Link"
++      gcc_debugging_level="Level 3"
++      gcc_entry_point="Reset_Handler"
++      linker_output_format="hex"
++      linker_printf_fmt_level="long"
++      linker_printf_width_precision_supported="Yes"
++      linker_scanf_fmt_level="long"
++      linker_section_placement_file="flash_placement.xml"
++      linker_section_placement_macros="FLASH_PH_START=0x0;FLASH_PH_SIZE=0x100000;RAM_PH_START=0x20000000;RAM_PH_SIZE=0x40000;FLASH_START=0x0;FLASH_SIZE=0x100000;RAM_START=0x20000000;RAM_SIZE=0x40000"
++      linker_section_placements_segments="FLASH1 RX 0x0 0x100000;RAM1 RWX 0x20000000 0x40000"
++      macros=""
++      project_directory=""
++      project_type="Executable" />
++    <folder Name="application">
++      <file file_name="01bsp_i2c.c" />
++    </folder>
++    <folder Name="bsp">
++      <folder Name="sdk">
++        <file file_name="cmsis_compiler.h" />
++        <file file_name="cmsis_gcc.h" />
++        <file file_name="cmsis_version.h" />
++        <file file_name="compiler_abstraction.h" />
++        <file file_name="core_cm4.h" />
++        <file file_name="mpu_armv7.h" />
++        <file file_name="nrf.h" />
++        <file file_name="nrf51_erratas.h" />
++        <file file_name="nrf51_to_nrf52840.h" />
++        <file file_name="nrf52840.h" />
++        <file file_name="nrf52840_bitfields.h" />
++        <file file_name="nrf52840_peripherals.h" />
++        <file file_name="nrf52_erratas.h" />
++        <file file_name="nrf52_to_nrf52840.h" />
++        <file file_name="nrf53_erratas.h" />
++        <file file_name="nrf91_erratas.h" />
++        <file file_name="nrf_erratas.h" />
++        <file file_name="nrf_peripherals.h" />
++        <file file_name="ses_startup_nrf52840.s" />
++        <file file_name="ses_startup_nrf_common.s" />
++        <file file_name="system_nrf52.h" />
++        <file file_name="system_nrf52840.c" />
++        <file file_name="system_nrf52840.h" />
++        <file file_name="system_nrf52_approtect.h" />
++        <file file_name="thumb_crt0.s" />
++      </folder>
++      <file file_name="adc.c" />
++      <file file_name="adc.h" />
++      <file file_name="board.c" />
++      <file file_name="board_info.h" />
++      <file file_name="cryptoengine.c" />
++      <file file_name="debugpins.c" />
++      <file file_name="eui64.c" />
++      <file file_name="i2c.c" />
++      <file file_name="leds.c" />
++      <file file_name="radio.c" />
++      <file file_name="sctimer.c" />
++      <file file_name="sensors.c" />
++      <file file_name="spi.c" />
++      <file file_name="uart.c" />
++    </folder>
++    <folder Name="chips">
++      <file file_name="bmx160.c" />
++      <file file_name="bmx160.h" />
++    </folder>
++    <folder Name="inc">
++      <file file_name="af.h" />
++      <file file_name="check_config.h" />
++      <file file_name="config.h" />
++      <file file_name="opendefs.h" />
++    </folder>
++  </project>
+   <project Name="01bsp_leds">
+     <configuration
+       LIBRARY_IO_TYPE="None"
+diff --git a/projects/nrf52840_dk/nrf52840_dk.emSession b/projects/nrf52840_dk/nrf52840_dk.emSession
+index 3a026d37..83e1eed5 100644
+--- a/projects/nrf52840_dk/nrf52840_dk.emSession
++++ b/projects/nrf52840_dk/nrf52840_dk.emSession
+@@ -2,9 +2,9 @@
+ <session>
+  <Bookmarks/>
+  <Breakpoints groups="Breakpoints" active_group="Breakpoints">
++  <BreakpointListItem trigger="" line="102" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_bmx388/01bsp_bmx388.c" useHWbreakpoint="false"/>
++  <BreakpointListItem trigger="" line="98" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_bmx388/01bsp_bmx388.c" useHWbreakpoint="false"/>
+   <BreakpointListItem trigger="" line="48" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_sctimer/01bsp_sctimer.c" useHWbreakpoint="false"/>
+-  <BreakpointListItem trigger="" line="113" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_uart/01bsp_uart.c" useHWbreakpoint="false"/>
+-  <BreakpointListItem trigger="" line="137" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_uart/01bsp_uart.c" useHWbreakpoint="false"/>
+   <Exceptions set="MemManage;UsageFault_Coprocessor;UsageFault_CheckingError;UsageFault_StateError;BusFault;ExceptionEntryReturnFault;HardFault"/>
+  </Breakpoints>
+  <ExecutionProfileWindow/>
+@@ -12,77 +12,89 @@
+   <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_leds_Debug" addressText="" accessByDisplayWidth="0"/>
+   <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_sctimer_Debug" addressText="" accessByDisplayWidth="0"/>
+   <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_uart_Debug" addressText="" accessByDisplayWidth="0"/>
+-  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_i2c_Debug" addressText="" accessByDisplayWidth="0"/>
+   <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_bmx160_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_i2c_Debug" addressText="" accessByDisplayWidth="0"/>
++  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_bmx388_Debug" addressText="" accessByDisplayWidth="0"/>
+  </FrameBuffer>
+  <Memory1>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
+-  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+  </Memory1>
+  <Memory2>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
+-  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+  </Memory2>
+  <Memory3>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
+-  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+  </Memory3>
+  <Memory4>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
+-  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
+   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
++  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+  </Memory4>
+  <Project>
+   <ProjectSessionItem path="nrf52840-dk"/>
+   <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160"/>
+   <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;application"/>
+   <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp"/>
+-  <ProjectSessionItem path="nrf52840-dk;01bsp_i2c"/>
+-  <ProjectSessionItem path="nrf52840-dk;01bsp_i2c;application"/>
+-  <ProjectSessionItem path="nrf52840-dk;01bsp_uart"/>
+-  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;application"/>
+-  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;bsp"/>
+-  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;bsp;sdk"/>
+-  <ProjectSessionItem path="nrf52840-dk;01bsp_uart;inc"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp;sdk"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;chips"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;application"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;bsp"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;bsp;sdk"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;chips"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;inc"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_eui64"/>
++  <ProjectSessionItem path="nrf52840-dk;01bsp_eui64;application"/>
+  </Project>
+  <Register1>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+-  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  </Register1>
+  <Register2>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+-  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  </Register2>
+  <Register3>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+-  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  </Register3>
+  <Register4>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+-  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
++  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  </Register4>
+  <Threads>
+   <ThreadsWindow showLists=""/>
+@@ -94,13 +106,10 @@
+   <Watches active="1" update="Never">
+    <Watchpoint expression="counter_current" name="counter_current" radix="16" linenumber="149" filename="../common/01bsp_leds/01bsp_leds.c"/>
+    <Watchpoint expression="timerflag" name="timerflag" radix="-1" linenumber="63" filename="../common/01bsp_leds/01bsp_leds.c"/>
+-   <Watchpoint expression="byte" name="byte" radix="16" linenumber="139" filename="../common/01bsp_uart/01bsp_uart.c"/>
+-   <Watchpoint expression="uart_lastRxByteIndex" name="uart_lastRxByteIndex" radix="16" linenumber="137" filename="../common/01bsp_uart/01bsp_uart.c"/>
+-   <Watchpoint expression="stringToReceive" name="stringToReceive" radix="-1" linenumber="136" filename="../common/01bsp_uart/01bsp_uart.c"/>
+-   <Watchpoint expression="echoStartFlag" name="echoStartFlag" radix="16" linenumber="139" filename="../common/01bsp_uart/01bsp_uart.c"/>
+-   <Watchpoint expression="app_vars" name="app_vars" radix="-1" linenumber="42" filename="../common/01bsp_uart/01bsp_uart.c"/>
+-   <Watchpoint expression="i" name="i" radix="-1" linenumber="113" filename="../common/01bsp_uart/01bsp_uart.c"/>
+-   <Watchpoint expression="who_am_i" name="who_am_i" radix="16" linenumber="26" filename="../common/01bsp_i2c/01bsp_i2c.c"/>
++   <Watchpoint expression="app_vars" name="app_vars" radix="-1" linenumber="43" filename="../common/01bsp_i2c/01bsp_i2c.c"/>
++   <Watchpoint expression="stasus" name="stasus" radix="-1" linenumber="100" filename="../common/01bsp_bmx388/01bsp_bmx388.c"/>
++   <Watchpoint expression="bmx388x_var" name="bmx388x_var" radix="-1" linenumber="139" filename="../../bsp/chips/bmx388/bmx388.c"/>
++   <Watchpoint expression="pwr_status" name="pwr_status" radix="-1" linenumber="83" filename="../common/01bsp_bmx388/01bsp_bmx388.c"/>
+   </Watches>
+  </Watch1>
+  <Watch2>
+@@ -113,9 +122,15 @@
+   <Watches active="0" update="Never"/>
+  </Watch4>
+  <Files>
+-  <SessionOpenFile windowGroup="DockEditLeft" x="50" y="114" useTextEdit="1" path="01bsp_bmx160/01bsp_bmx160.c" left="0" top="107" codecName="Default"/>
+-  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="29" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/board.c" left="0" selected="1" top="0" codecName="Default"/>
+-  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="108" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/i2c.c" left="0" top="91" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="150" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/common/01bsp_bmx388/01bsp_bmx388.c" path="../../bsp/chips/bmx388/bmx388.c" left="0" top="127" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="27" y="51" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/common/01bsp_bmx388/01bsp_bmx388.c" path="../../bsp/chips/bmx388/bmx388.h" left="0" top="29" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="29" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/board.c" left="0" top="77" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="8" y="101" useTextEdit="1" path="../common/01bsp_bmx388/01bsp_bmx388.c" left="0" selected="1" top="79" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="29" y="146" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/bsp/chips/bmx388/bmx388.c" path="../../bsp/boards/nrf52840_dk/i2c.c" left="0" top="130" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="71" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/sdk/ses_startup_nrf52840.s" left="0" top="54" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="18" y="14" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/uart.c" left="0" top="167" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="8" y="49" useTextEdit="1" path="../../bsp/boards/uart.h" left="0" top="30" codecName="Default"/>
++  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="292" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/sdk/thumb_crt0.s" left="0" top="277" codecName="Default"/>
+  </Files>
+- <EMStudioWindow activeProject="01bsp_bmx160" fileDialogDefaultFilter="*.emProject" autoConnectTarget="J-Link" buildConfiguration="Debug" sessionSettings="" debugSearchFileMap="" fileDialogInitialDirectory="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/nrf52840_dk" debugSearchPath="" autoConnectCapabilities="3711"/>
++ <EMStudioWindow activeProject="01bsp_bmx388" fileDialogDefaultFilter="*.emProject" autoConnectTarget="J-Link" buildConfiguration="Debug" sessionSettings="" debugSearchFileMap="" fileDialogInitialDirectory="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/nrf52840_dk" debugSearchPath="" autoConnectCapabilities="3711"/>
+ </session>
+diff --git a/projects/nrf52840_dk/nrf52840_peripherals.h b/projects/nrf52840_dk/nrf52840_peripherals.h
+new file mode 100644
+index 00000000..0194438e
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf52840_peripherals.h
+@@ -0,0 +1,327 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#ifndef _NRF52840_PERIPHERALS_H
++#define _NRF52840_PERIPHERALS_H
++
++
++/* Clock Peripheral */
++#define CLOCK_PRESENT
++#define CLOCK_COUNT 1
++
++/* Power Peripheral */
++#define POWER_PRESENT
++#define POWER_COUNT 1
++
++#define POWER_FEATURE_RAM_REGISTERS_PRESENT
++#define POWER_FEATURE_RAM_REGISTERS_COUNT       9
++
++#define POWER_FEATURE_VDDH_PRESENT
++#define POWER_FEATURE_VDDH_DCDC_PRESENT
++
++/* Non-Volatile Memory Controller */
++#define NVMC_PRESENT
++#define NVMC_COUNT 1
++
++#define NVMC_FEATURE_CACHE_PRESENT
++
++/* Floating Point Unit */
++#define FPU_PRESENT
++#define FPU_COUNT 1
++
++/* Systick timer */
++#define SYSTICK_PRESENT
++#define SYSTICK_COUNT 1
++
++/* Software Interrupts */
++#define SWI_PRESENT
++#define SWI_COUNT 6
++
++/* Memory Watch Unit */
++#define MWU_PRESENT
++#define MWU_COUNT 1
++
++/* GPIO */
++#define GPIO_PRESENT
++#define GPIO_COUNT 2
++
++#define P0_PIN_NUM 32
++#define P1_PIN_NUM 16
++
++#define P0_FEATURE_PINS_PRESENT 0xFFFFFFFFUL
++#define P1_FEATURE_PINS_PRESENT 0x0000FFFFUL
++
++/* ACL */
++#define ACL_PRESENT
++
++#define ACL_REGIONS_COUNT 8
++
++/* Radio */
++#define RADIO_PRESENT
++#define RADIO_COUNT 1
++
++#define RADIO_EASYDMA_MAXCNT_SIZE 8
++#define RADIO_FEATURE_IEEE_802_15_4_PRESENT
++
++#define RADIO_TXPOWER_TXPOWER_Max RADIO_TXPOWER_TXPOWER_Pos8dBm
++
++/* Accelerated Address Resolver */
++#define AAR_PRESENT
++#define AAR_COUNT 1
++
++#define AAR_MAX_IRK_NUM 16
++
++/* AES Electronic CodeBook mode encryption */
++#define ECB_PRESENT
++#define ECB_COUNT 1
++
++/* AES CCM mode encryption */
++#define CCM_PRESENT
++#define CCM_COUNT 1
++
++/* NFC Tag */
++#define NFCT_PRESENT
++#define NFCT_COUNT 1
++
++#define NFCT_EASYDMA_MAXCNT_SIZE 9
++
++/* Peripheral to Peripheral Interconnect */
++#define PPI_PRESENT
++#define PPI_COUNT 1
++
++#define PPI_CH_NUM 20
++#define PPI_FIXED_CH_NUM 12
++#define PPI_GROUP_NUM 6
++#define PPI_FEATURE_FORKS_PRESENT
++
++/* Event Generator Unit */
++#define EGU_PRESENT
++#define EGU_COUNT 6
++
++#define EGU0_CH_NUM 16
++#define EGU1_CH_NUM 16
++#define EGU2_CH_NUM 16
++#define EGU3_CH_NUM 16
++#define EGU4_CH_NUM 16
++#define EGU5_CH_NUM 16
++
++/* Timer/Counter */
++#define TIMER_PRESENT
++#define TIMER_COUNT 5
++
++#define TIMER0_MAX_SIZE 32
++#define TIMER1_MAX_SIZE 32
++#define TIMER2_MAX_SIZE 32
++#define TIMER3_MAX_SIZE 32
++#define TIMER4_MAX_SIZE 32
++
++#define TIMER0_CC_NUM 4
++#define TIMER1_CC_NUM 4
++#define TIMER2_CC_NUM 4
++#define TIMER3_CC_NUM 6
++#define TIMER4_CC_NUM 6
++
++/* Real Time Counter */
++#define RTC_PRESENT
++#define RTC_COUNT 3
++
++#define RTC0_CC_NUM 3
++#define RTC1_CC_NUM 4
++#define RTC2_CC_NUM 4
++
++/* RNG */
++#define RNG_PRESENT
++#define RNG_COUNT 1
++
++/* Watchdog Timer */
++#define WDT_PRESENT
++#define WDT_COUNT 1
++
++/* Temperature Sensor */
++#define TEMP_PRESENT
++#define TEMP_COUNT 1
++
++/* Serial Peripheral Interface Master */
++#define SPI_PRESENT
++#define SPI_COUNT 3
++
++/* Serial Peripheral Interface Master with DMA */
++#define SPIM_PRESENT
++#define SPIM_COUNT 4
++
++#define SPIM0_MAX_DATARATE  8
++#define SPIM1_MAX_DATARATE  8
++#define SPIM2_MAX_DATARATE  8
++#define SPIM3_MAX_DATARATE  32
++
++#define SPIM0_FEATURE_HARDWARE_CSN_PRESENT  0
++#define SPIM1_FEATURE_HARDWARE_CSN_PRESENT  0
++#define SPIM2_FEATURE_HARDWARE_CSN_PRESENT  0
++#define SPIM3_FEATURE_HARDWARE_CSN_PRESENT  1
++
++#define SPIM0_FEATURE_DCX_PRESENT  0
++#define SPIM1_FEATURE_DCX_PRESENT  0
++#define SPIM2_FEATURE_DCX_PRESENT  0
++#define SPIM3_FEATURE_DCX_PRESENT  1
++
++#define SPIM0_FEATURE_RXDELAY_PRESENT  0
++#define SPIM1_FEATURE_RXDELAY_PRESENT  0
++#define SPIM2_FEATURE_RXDELAY_PRESENT  0
++#define SPIM3_FEATURE_RXDELAY_PRESENT  1
++
++#define SPIM0_EASYDMA_MAXCNT_SIZE 16
++#define SPIM1_EASYDMA_MAXCNT_SIZE 16
++#define SPIM2_EASYDMA_MAXCNT_SIZE 16
++#define SPIM3_EASYDMA_MAXCNT_SIZE 16
++
++/* Serial Peripheral Interface Slave with DMA*/
++#define SPIS_PRESENT
++#define SPIS_COUNT 3
++
++#define SPIS0_EASYDMA_MAXCNT_SIZE 16
++#define SPIS1_EASYDMA_MAXCNT_SIZE 16
++#define SPIS2_EASYDMA_MAXCNT_SIZE 16
++
++/* Two Wire Interface Master */
++#define TWI_PRESENT
++#define TWI_COUNT 2
++
++/* Two Wire Interface Master with DMA */
++#define TWIM_PRESENT
++#define TWIM_COUNT 2
++
++#define TWIM0_EASYDMA_MAXCNT_SIZE 16
++#define TWIM1_EASYDMA_MAXCNT_SIZE 16
++
++/* Two Wire Interface Slave with DMA */
++#define TWIS_PRESENT
++#define TWIS_COUNT 2
++
++#define TWIS0_EASYDMA_MAXCNT_SIZE 16
++#define TWIS1_EASYDMA_MAXCNT_SIZE 16
++
++/* Universal Asynchronous Receiver-Transmitter */
++#define UART_PRESENT
++#define UART_COUNT 1
++
++/* Universal Asynchronous Receiver-Transmitter with DMA */
++#define UARTE_PRESENT
++#define UARTE_COUNT 2
++
++#define UARTE0_EASYDMA_MAXCNT_SIZE 16
++#define UARTE1_EASYDMA_MAXCNT_SIZE 16
++
++/* Quadrature Decoder */
++#define QDEC_PRESENT
++#define QDEC_COUNT 1
++
++/* Successive Approximation Analog to Digital Converter */
++#define SAADC_PRESENT
++#define SAADC_COUNT 1
++
++#define SAADC_EASYDMA_MAXCNT_SIZE 15
++
++#define SAADC_CH_NUM 8
++
++/* GPIO Tasks and Events */
++#define GPIOTE_PRESENT
++#define GPIOTE_COUNT 1
++
++#define GPIOTE_CH_NUM 8
++
++#define GPIOTE_FEATURE_SET_PRESENT
++#define GPIOTE_FEATURE_CLR_PRESENT
++
++/* Low Power Comparator */
++#define LPCOMP_PRESENT
++#define LPCOMP_COUNT 1
++
++#define LPCOMP_REFSEL_RESOLUTION 16
++
++#define LPCOMP_FEATURE_HYST_PRESENT
++
++/* Comparator */
++#define COMP_PRESENT
++#define COMP_COUNT 1
++
++/* Pulse Width Modulator */
++#define PWM_PRESENT
++#define PWM_COUNT 4
++
++#define PWM0_CH_NUM 4
++#define PWM1_CH_NUM 4
++#define PWM2_CH_NUM 4
++#define PWM3_CH_NUM 4
++
++#define PWM0_EASYDMA_MAXCNT_SIZE 15
++#define PWM1_EASYDMA_MAXCNT_SIZE 15
++#define PWM2_EASYDMA_MAXCNT_SIZE 15
++#define PWM3_EASYDMA_MAXCNT_SIZE 15
++
++/* Pulse Density Modulator */
++#define PDM_PRESENT
++#define PDM_COUNT 1
++
++#define PDM_EASYDMA_MAXCNT_SIZE 15
++
++/* Inter-IC Sound Interface */
++#define I2S_PRESENT
++#define I2S_COUNT 1
++
++#define I2S_EASYDMA_MAXCNT_SIZE 14
++
++/* Universal Serial Bus Device */
++#define USBD_PRESENT
++#define USBD_COUNT 1
++
++#define USBD_EASYDMA_MAXCNT_SIZE 7
++
++/* ARM TrustZone Cryptocell 310 */
++#define CRYPTOCELL_PRESENT
++#define CRYPTOCELL_COUNT 1
++
++/* Quad SPI */
++#define QSPI_PRESENT
++#define QSPI_COUNT 1
++
++#define QSPI_EASYDMA_MAXCNT_SIZE 20
++
++#endif      // _NRF52840_PERIPHERALS_H
+diff --git a/projects/nrf52840_dk/nrf52_erratas.h b/projects/nrf52840_dk/nrf52_erratas.h
+new file mode 100644
+index 00000000..ddaf5f85
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf52_erratas.h
+@@ -0,0 +1,13035 @@
++#ifndef NRF52_ERRATAS_H
++#define NRF52_ERRATAS_H
++
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#include <stdint.h>
++#include <stdbool.h>
++#include "compiler_abstraction.h"
++
++static bool nrf52_errata_1(void) __UNUSED;
++static bool nrf52_errata_2(void) __UNUSED;
++static bool nrf52_errata_3(void) __UNUSED;
++static bool nrf52_errata_4(void) __UNUSED;
++static bool nrf52_errata_7(void) __UNUSED;
++static bool nrf52_errata_8(void) __UNUSED;
++static bool nrf52_errata_9(void) __UNUSED;
++static bool nrf52_errata_10(void) __UNUSED;
++static bool nrf52_errata_11(void) __UNUSED;
++static bool nrf52_errata_12(void) __UNUSED;
++static bool nrf52_errata_15(void) __UNUSED;
++static bool nrf52_errata_16(void) __UNUSED;
++static bool nrf52_errata_17(void) __UNUSED;
++static bool nrf52_errata_20(void) __UNUSED;
++static bool nrf52_errata_23(void) __UNUSED;
++static bool nrf52_errata_24(void) __UNUSED;
++static bool nrf52_errata_25(void) __UNUSED;
++static bool nrf52_errata_26(void) __UNUSED;
++static bool nrf52_errata_27(void) __UNUSED;
++static bool nrf52_errata_28(void) __UNUSED;
++static bool nrf52_errata_29(void) __UNUSED;
++static bool nrf52_errata_30(void) __UNUSED;
++static bool nrf52_errata_31(void) __UNUSED;
++static bool nrf52_errata_32(void) __UNUSED;
++static bool nrf52_errata_33(void) __UNUSED;
++static bool nrf52_errata_34(void) __UNUSED;
++static bool nrf52_errata_35(void) __UNUSED;
++static bool nrf52_errata_36(void) __UNUSED;
++static bool nrf52_errata_37(void) __UNUSED;
++static bool nrf52_errata_38(void) __UNUSED;
++static bool nrf52_errata_39(void) __UNUSED;
++static bool nrf52_errata_40(void) __UNUSED;
++static bool nrf52_errata_41(void) __UNUSED;
++static bool nrf52_errata_42(void) __UNUSED;
++static bool nrf52_errata_43(void) __UNUSED;
++static bool nrf52_errata_44(void) __UNUSED;
++static bool nrf52_errata_46(void) __UNUSED;
++static bool nrf52_errata_47(void) __UNUSED;
++static bool nrf52_errata_48(void) __UNUSED;
++static bool nrf52_errata_49(void) __UNUSED;
++static bool nrf52_errata_51(void) __UNUSED;
++static bool nrf52_errata_54(void) __UNUSED;
++static bool nrf52_errata_55(void) __UNUSED;
++static bool nrf52_errata_57(void) __UNUSED;
++static bool nrf52_errata_58(void) __UNUSED;
++static bool nrf52_errata_62(void) __UNUSED;
++static bool nrf52_errata_63(void) __UNUSED;
++static bool nrf52_errata_64(void) __UNUSED;
++static bool nrf52_errata_65(void) __UNUSED;
++static bool nrf52_errata_66(void) __UNUSED;
++static bool nrf52_errata_67(void) __UNUSED;
++static bool nrf52_errata_68(void) __UNUSED;
++static bool nrf52_errata_70(void) __UNUSED;
++static bool nrf52_errata_71(void) __UNUSED;
++static bool nrf52_errata_72(void) __UNUSED;
++static bool nrf52_errata_73(void) __UNUSED;
++static bool nrf52_errata_74(void) __UNUSED;
++static bool nrf52_errata_75(void) __UNUSED;
++static bool nrf52_errata_76(void) __UNUSED;
++static bool nrf52_errata_77(void) __UNUSED;
++static bool nrf52_errata_78(void) __UNUSED;
++static bool nrf52_errata_79(void) __UNUSED;
++static bool nrf52_errata_81(void) __UNUSED;
++static bool nrf52_errata_83(void) __UNUSED;
++static bool nrf52_errata_84(void) __UNUSED;
++static bool nrf52_errata_86(void) __UNUSED;
++static bool nrf52_errata_87(void) __UNUSED;
++static bool nrf52_errata_88(void) __UNUSED;
++static bool nrf52_errata_89(void) __UNUSED;
++static bool nrf52_errata_91(void) __UNUSED;
++static bool nrf52_errata_94(void) __UNUSED;
++static bool nrf52_errata_96(void) __UNUSED;
++static bool nrf52_errata_97(void) __UNUSED;
++static bool nrf52_errata_98(void) __UNUSED;
++static bool nrf52_errata_101(void) __UNUSED;
++static bool nrf52_errata_102(void) __UNUSED;
++static bool nrf52_errata_103(void) __UNUSED;
++static bool nrf52_errata_104(void) __UNUSED;
++static bool nrf52_errata_106(void) __UNUSED;
++static bool nrf52_errata_107(void) __UNUSED;
++static bool nrf52_errata_108(void) __UNUSED;
++static bool nrf52_errata_109(void) __UNUSED;
++static bool nrf52_errata_110(void) __UNUSED;
++static bool nrf52_errata_111(void) __UNUSED;
++static bool nrf52_errata_112(void) __UNUSED;
++static bool nrf52_errata_113(void) __UNUSED;
++static bool nrf52_errata_115(void) __UNUSED;
++static bool nrf52_errata_116(void) __UNUSED;
++static bool nrf52_errata_117(void) __UNUSED;
++static bool nrf52_errata_118(void) __UNUSED;
++static bool nrf52_errata_119(void) __UNUSED;
++static bool nrf52_errata_120(void) __UNUSED;
++static bool nrf52_errata_121(void) __UNUSED;
++static bool nrf52_errata_122(void) __UNUSED;
++static bool nrf52_errata_127(void) __UNUSED;
++static bool nrf52_errata_128(void) __UNUSED;
++static bool nrf52_errata_131(void) __UNUSED;
++static bool nrf52_errata_132(void) __UNUSED;
++static bool nrf52_errata_133(void) __UNUSED;
++static bool nrf52_errata_134(void) __UNUSED;
++static bool nrf52_errata_135(void) __UNUSED;
++static bool nrf52_errata_136(void) __UNUSED;
++static bool nrf52_errata_138(void) __UNUSED;
++static bool nrf52_errata_140(void) __UNUSED;
++static bool nrf52_errata_141(void) __UNUSED;
++static bool nrf52_errata_142(void) __UNUSED;
++static bool nrf52_errata_143(void) __UNUSED;
++static bool nrf52_errata_144(void) __UNUSED;
++static bool nrf52_errata_145(void) __UNUSED;
++static bool nrf52_errata_146(void) __UNUSED;
++static bool nrf52_errata_147(void) __UNUSED;
++static bool nrf52_errata_149(void) __UNUSED;
++static bool nrf52_errata_150(void) __UNUSED;
++static bool nrf52_errata_151(void) __UNUSED;
++static bool nrf52_errata_153(void) __UNUSED;
++static bool nrf52_errata_154(void) __UNUSED;
++static bool nrf52_errata_155(void) __UNUSED;
++static bool nrf52_errata_156(void) __UNUSED;
++static bool nrf52_errata_158(void) __UNUSED;
++static bool nrf52_errata_160(void) __UNUSED;
++static bool nrf52_errata_162(void) __UNUSED;
++static bool nrf52_errata_163(void) __UNUSED;
++static bool nrf52_errata_164(void) __UNUSED;
++static bool nrf52_errata_166(void) __UNUSED;
++static bool nrf52_errata_170(void) __UNUSED;
++static bool nrf52_errata_171(void) __UNUSED;
++static bool nrf52_errata_172(void) __UNUSED;
++static bool nrf52_errata_173(void) __UNUSED;
++static bool nrf52_errata_174(void) __UNUSED;
++static bool nrf52_errata_176(void) __UNUSED;
++static bool nrf52_errata_178(void) __UNUSED;
++static bool nrf52_errata_179(void) __UNUSED;
++static bool nrf52_errata_180(void) __UNUSED;
++static bool nrf52_errata_181(void) __UNUSED;
++static bool nrf52_errata_182(void) __UNUSED;
++static bool nrf52_errata_183(void) __UNUSED;
++static bool nrf52_errata_184(void) __UNUSED;
++static bool nrf52_errata_186(void) __UNUSED;
++static bool nrf52_errata_187(void) __UNUSED;
++static bool nrf52_errata_189(void) __UNUSED;
++static bool nrf52_errata_190(void) __UNUSED;
++static bool nrf52_errata_191(void) __UNUSED;
++static bool nrf52_errata_192(void) __UNUSED;
++static bool nrf52_errata_193(void) __UNUSED;
++static bool nrf52_errata_194(void) __UNUSED;
++static bool nrf52_errata_195(void) __UNUSED;
++static bool nrf52_errata_196(void) __UNUSED;
++static bool nrf52_errata_197(void) __UNUSED;
++static bool nrf52_errata_198(void) __UNUSED;
++static bool nrf52_errata_199(void) __UNUSED;
++static bool nrf52_errata_200(void) __UNUSED;
++static bool nrf52_errata_201(void) __UNUSED;
++static bool nrf52_errata_202(void) __UNUSED;
++static bool nrf52_errata_204(void) __UNUSED;
++static bool nrf52_errata_208(void) __UNUSED;
++static bool nrf52_errata_209(void) __UNUSED;
++static bool nrf52_errata_210(void) __UNUSED;
++static bool nrf52_errata_211(void) __UNUSED;
++static bool nrf52_errata_212(void) __UNUSED;
++static bool nrf52_errata_213(void) __UNUSED;
++static bool nrf52_errata_214(void) __UNUSED;
++static bool nrf52_errata_215(void) __UNUSED;
++static bool nrf52_errata_216(void) __UNUSED;
++static bool nrf52_errata_217(void) __UNUSED;
++static bool nrf52_errata_218(void) __UNUSED;
++static bool nrf52_errata_219(void) __UNUSED;
++static bool nrf52_errata_220(void) __UNUSED;
++static bool nrf52_errata_223(void) __UNUSED;
++static bool nrf52_errata_225(void) __UNUSED;
++static bool nrf52_errata_228(void) __UNUSED;
++static bool nrf52_errata_230(void) __UNUSED;
++static bool nrf52_errata_231(void) __UNUSED;
++static bool nrf52_errata_232(void) __UNUSED;
++static bool nrf52_errata_233(void) __UNUSED;
++static bool nrf52_errata_236(void) __UNUSED;
++static bool nrf52_errata_237(void) __UNUSED;
++static bool nrf52_errata_242(void) __UNUSED;
++static bool nrf52_errata_243(void) __UNUSED;
++static bool nrf52_errata_244(void) __UNUSED;
++static bool nrf52_errata_245(void) __UNUSED;
++static bool nrf52_errata_246(void) __UNUSED;
++static bool nrf52_errata_248(void) __UNUSED;
++static bool nrf52_errata_249(void) __UNUSED;
++static bool nrf52_errata_250(void) __UNUSED;
++static bool nrf52_errata_254(void) __UNUSED;
++
++/* ========= Errata 1 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_1_PRESENT 1
++#else
++    #define NRF52_ERRATA_1_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_1_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_1_ENABLE_WORKAROUND NRF52_ERRATA_1_PRESENT
++#endif
++
++static bool nrf52_errata_1(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 2 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_2_PRESENT 1
++#else
++    #define NRF52_ERRATA_2_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_2_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_2_ENABLE_WORKAROUND NRF52_ERRATA_2_PRESENT
++#endif
++
++static bool nrf52_errata_2(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 3 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_3_PRESENT 1
++#else
++    #define NRF52_ERRATA_3_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_3_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_3_ENABLE_WORKAROUND NRF52_ERRATA_3_PRESENT
++#endif
++
++static bool nrf52_errata_3(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 4 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_4_PRESENT 1
++#else
++    #define NRF52_ERRATA_4_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_4_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_4_ENABLE_WORKAROUND NRF52_ERRATA_4_PRESENT
++#endif
++
++static bool nrf52_errata_4(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 7 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_7_PRESENT 1
++#else
++    #define NRF52_ERRATA_7_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_7_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_7_ENABLE_WORKAROUND NRF52_ERRATA_7_PRESENT
++#endif
++
++static bool nrf52_errata_7(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 8 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_8_PRESENT 1
++#else
++    #define NRF52_ERRATA_8_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_8_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_8_ENABLE_WORKAROUND NRF52_ERRATA_8_PRESENT
++#endif
++
++static bool nrf52_errata_8(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 9 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_9_PRESENT 1
++#else
++    #define NRF52_ERRATA_9_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_9_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_9_ENABLE_WORKAROUND NRF52_ERRATA_9_PRESENT
++#endif
++
++static bool nrf52_errata_9(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 10 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_10_PRESENT 1
++#else
++    #define NRF52_ERRATA_10_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_10_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_10_ENABLE_WORKAROUND NRF52_ERRATA_10_PRESENT
++#endif
++
++static bool nrf52_errata_10(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 11 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_11_PRESENT 1
++#else
++    #define NRF52_ERRATA_11_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_11_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_11_ENABLE_WORKAROUND NRF52_ERRATA_11_PRESENT
++#endif
++
++static bool nrf52_errata_11(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 12 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_12_PRESENT 1
++#else
++    #define NRF52_ERRATA_12_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_12_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_12_ENABLE_WORKAROUND NRF52_ERRATA_12_PRESENT
++#endif
++
++static bool nrf52_errata_12(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 15 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_15_PRESENT 1
++#else
++    #define NRF52_ERRATA_15_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_15_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_15_ENABLE_WORKAROUND NRF52_ERRATA_15_PRESENT
++#endif
++
++static bool nrf52_errata_15(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 16 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_16_PRESENT 1
++#else
++    #define NRF52_ERRATA_16_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_16_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_16_ENABLE_WORKAROUND NRF52_ERRATA_16_PRESENT
++#endif
++
++static bool nrf52_errata_16(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 17 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_17_PRESENT 1
++#else
++    #define NRF52_ERRATA_17_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_17_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_17_ENABLE_WORKAROUND NRF52_ERRATA_17_PRESENT
++#endif
++
++static bool nrf52_errata_17(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 20 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_20_PRESENT 1
++#else
++    #define NRF52_ERRATA_20_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_20_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_20_ENABLE_WORKAROUND NRF52_ERRATA_20_PRESENT
++#endif
++
++static bool nrf52_errata_20(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 23 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_23_PRESENT 1
++#else
++    #define NRF52_ERRATA_23_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_23_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_23_ENABLE_WORKAROUND NRF52_ERRATA_23_PRESENT
++#endif
++
++static bool nrf52_errata_23(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 24 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_24_PRESENT 1
++#else
++    #define NRF52_ERRATA_24_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_24_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_24_ENABLE_WORKAROUND NRF52_ERRATA_24_PRESENT
++#endif
++
++static bool nrf52_errata_24(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 25 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_25_PRESENT 1
++#else
++    #define NRF52_ERRATA_25_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_25_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_25_ENABLE_WORKAROUND NRF52_ERRATA_25_PRESENT
++#endif
++
++static bool nrf52_errata_25(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 26 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_26_PRESENT 1
++#else
++    #define NRF52_ERRATA_26_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_26_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_26_ENABLE_WORKAROUND NRF52_ERRATA_26_PRESENT
++#endif
++
++static bool nrf52_errata_26(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 27 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_27_PRESENT 1
++#else
++    #define NRF52_ERRATA_27_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_27_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_27_ENABLE_WORKAROUND NRF52_ERRATA_27_PRESENT
++#endif
++
++static bool nrf52_errata_27(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 28 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_28_PRESENT 1
++#else
++    #define NRF52_ERRATA_28_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_28_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_28_ENABLE_WORKAROUND NRF52_ERRATA_28_PRESENT
++#endif
++
++static bool nrf52_errata_28(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 29 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_29_PRESENT 1
++#else
++    #define NRF52_ERRATA_29_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_29_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_29_ENABLE_WORKAROUND NRF52_ERRATA_29_PRESENT
++#endif
++
++static bool nrf52_errata_29(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 30 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_30_PRESENT 1
++#else
++    #define NRF52_ERRATA_30_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_30_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_30_ENABLE_WORKAROUND NRF52_ERRATA_30_PRESENT
++#endif
++
++static bool nrf52_errata_30(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 31 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_31_PRESENT 1
++#else
++    #define NRF52_ERRATA_31_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_31_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_31_ENABLE_WORKAROUND NRF52_ERRATA_31_PRESENT
++#endif
++
++static bool nrf52_errata_31(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 32 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_32_PRESENT 1
++#else
++    #define NRF52_ERRATA_32_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_32_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_32_ENABLE_WORKAROUND NRF52_ERRATA_32_PRESENT
++#endif
++
++static bool nrf52_errata_32(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 33 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_33_PRESENT 1
++#else
++    #define NRF52_ERRATA_33_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_33_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_33_ENABLE_WORKAROUND NRF52_ERRATA_33_PRESENT
++#endif
++
++static bool nrf52_errata_33(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 34 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_34_PRESENT 1
++#else
++    #define NRF52_ERRATA_34_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_34_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_34_ENABLE_WORKAROUND NRF52_ERRATA_34_PRESENT
++#endif
++
++static bool nrf52_errata_34(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 35 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_35_PRESENT 1
++#else
++    #define NRF52_ERRATA_35_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_35_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_35_ENABLE_WORKAROUND NRF52_ERRATA_35_PRESENT
++#endif
++
++static bool nrf52_errata_35(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 36 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_36_PRESENT 1
++#else
++    #define NRF52_ERRATA_36_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_36_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_36_ENABLE_WORKAROUND NRF52_ERRATA_36_PRESENT
++#endif
++
++static bool nrf52_errata_36(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 37 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_37_PRESENT 1
++#else
++    #define NRF52_ERRATA_37_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_37_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_37_ENABLE_WORKAROUND NRF52_ERRATA_37_PRESENT
++#endif
++
++static bool nrf52_errata_37(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 38 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_38_PRESENT 1
++#else
++    #define NRF52_ERRATA_38_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_38_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_38_ENABLE_WORKAROUND NRF52_ERRATA_38_PRESENT
++#endif
++
++static bool nrf52_errata_38(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 39 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_39_PRESENT 1
++#else
++    #define NRF52_ERRATA_39_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_39_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_39_ENABLE_WORKAROUND NRF52_ERRATA_39_PRESENT
++#endif
++
++static bool nrf52_errata_39(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 40 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_40_PRESENT 1
++#else
++    #define NRF52_ERRATA_40_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_40_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_40_ENABLE_WORKAROUND NRF52_ERRATA_40_PRESENT
++#endif
++
++static bool nrf52_errata_40(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 41 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_41_PRESENT 1
++#else
++    #define NRF52_ERRATA_41_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_41_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_41_ENABLE_WORKAROUND NRF52_ERRATA_41_PRESENT
++#endif
++
++static bool nrf52_errata_41(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 42 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_42_PRESENT 1
++#else
++    #define NRF52_ERRATA_42_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_42_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_42_ENABLE_WORKAROUND NRF52_ERRATA_42_PRESENT
++#endif
++
++static bool nrf52_errata_42(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 43 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_43_PRESENT 1
++#else
++    #define NRF52_ERRATA_43_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_43_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_43_ENABLE_WORKAROUND NRF52_ERRATA_43_PRESENT
++#endif
++
++static bool nrf52_errata_43(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 44 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_44_PRESENT 1
++#else
++    #define NRF52_ERRATA_44_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_44_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_44_ENABLE_WORKAROUND NRF52_ERRATA_44_PRESENT
++#endif
++
++static bool nrf52_errata_44(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 46 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_46_PRESENT 1
++#else
++    #define NRF52_ERRATA_46_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_46_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_46_ENABLE_WORKAROUND NRF52_ERRATA_46_PRESENT
++#endif
++
++static bool nrf52_errata_46(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 47 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_47_PRESENT 1
++#else
++    #define NRF52_ERRATA_47_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_47_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_47_ENABLE_WORKAROUND NRF52_ERRATA_47_PRESENT
++#endif
++
++static bool nrf52_errata_47(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 48 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_48_PRESENT 1
++#else
++    #define NRF52_ERRATA_48_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_48_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_48_ENABLE_WORKAROUND NRF52_ERRATA_48_PRESENT
++#endif
++
++static bool nrf52_errata_48(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 49 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_49_PRESENT 1
++#else
++    #define NRF52_ERRATA_49_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_49_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_49_ENABLE_WORKAROUND NRF52_ERRATA_49_PRESENT
++#endif
++
++static bool nrf52_errata_49(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 51 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_51_PRESENT 1
++#else
++    #define NRF52_ERRATA_51_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_51_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_51_ENABLE_WORKAROUND NRF52_ERRATA_51_PRESENT
++#endif
++
++static bool nrf52_errata_51(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 54 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_54_PRESENT 1
++#else
++    #define NRF52_ERRATA_54_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_54_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_54_ENABLE_WORKAROUND NRF52_ERRATA_54_PRESENT
++#endif
++
++static bool nrf52_errata_54(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 55 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_55_PRESENT 1
++#else
++    #define NRF52_ERRATA_55_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_55_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_55_ENABLE_WORKAROUND NRF52_ERRATA_55_PRESENT
++#endif
++
++static bool nrf52_errata_55(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 57 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_57_PRESENT 1
++#else
++    #define NRF52_ERRATA_57_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_57_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_57_ENABLE_WORKAROUND NRF52_ERRATA_57_PRESENT
++#endif
++
++static bool nrf52_errata_57(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 58 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_58_PRESENT 1
++#else
++    #define NRF52_ERRATA_58_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_58_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_58_ENABLE_WORKAROUND NRF52_ERRATA_58_PRESENT
++#endif
++
++static bool nrf52_errata_58(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 62 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_62_PRESENT 1
++#else
++    #define NRF52_ERRATA_62_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_62_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_62_ENABLE_WORKAROUND NRF52_ERRATA_62_PRESENT
++#endif
++
++static bool nrf52_errata_62(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 63 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_63_PRESENT 1
++#else
++    #define NRF52_ERRATA_63_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_63_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_63_ENABLE_WORKAROUND NRF52_ERRATA_63_PRESENT
++#endif
++
++static bool nrf52_errata_63(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 64 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_64_PRESENT 1
++#else
++    #define NRF52_ERRATA_64_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_64_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_64_ENABLE_WORKAROUND NRF52_ERRATA_64_PRESENT
++#endif
++
++static bool nrf52_errata_64(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 65 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_65_PRESENT 1
++#else
++    #define NRF52_ERRATA_65_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_65_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_65_ENABLE_WORKAROUND NRF52_ERRATA_65_PRESENT
++#endif
++
++static bool nrf52_errata_65(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 66 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_66_PRESENT 1
++#else
++    #define NRF52_ERRATA_66_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_66_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_66_ENABLE_WORKAROUND NRF52_ERRATA_66_PRESENT
++#endif
++
++static bool nrf52_errata_66(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 67 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_67_PRESENT 1
++#else
++    #define NRF52_ERRATA_67_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_67_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_67_ENABLE_WORKAROUND NRF52_ERRATA_67_PRESENT
++#endif
++
++static bool nrf52_errata_67(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 68 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_68_PRESENT 1
++#else
++    #define NRF52_ERRATA_68_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_68_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_68_ENABLE_WORKAROUND NRF52_ERRATA_68_PRESENT
++#endif
++
++static bool nrf52_errata_68(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 70 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_70_PRESENT 1
++#else
++    #define NRF52_ERRATA_70_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_70_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_70_ENABLE_WORKAROUND NRF52_ERRATA_70_PRESENT
++#endif
++
++static bool nrf52_errata_70(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 71 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_71_PRESENT 1
++#else
++    #define NRF52_ERRATA_71_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_71_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_71_ENABLE_WORKAROUND NRF52_ERRATA_71_PRESENT
++#endif
++
++static bool nrf52_errata_71(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 72 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_72_PRESENT 1
++#else
++    #define NRF52_ERRATA_72_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_72_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_72_ENABLE_WORKAROUND NRF52_ERRATA_72_PRESENT
++#endif
++
++static bool nrf52_errata_72(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 73 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_73_PRESENT 1
++#else
++    #define NRF52_ERRATA_73_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_73_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_73_ENABLE_WORKAROUND NRF52_ERRATA_73_PRESENT
++#endif
++
++static bool nrf52_errata_73(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 74 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_74_PRESENT 1
++#else
++    #define NRF52_ERRATA_74_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_74_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_74_ENABLE_WORKAROUND NRF52_ERRATA_74_PRESENT
++#endif
++
++static bool nrf52_errata_74(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 75 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_75_PRESENT 1
++#else
++    #define NRF52_ERRATA_75_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_75_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_75_ENABLE_WORKAROUND NRF52_ERRATA_75_PRESENT
++#endif
++
++static bool nrf52_errata_75(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 76 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_76_PRESENT 1
++#else
++    #define NRF52_ERRATA_76_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_76_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_76_ENABLE_WORKAROUND NRF52_ERRATA_76_PRESENT
++#endif
++
++static bool nrf52_errata_76(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 77 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_77_PRESENT 1
++#else
++    #define NRF52_ERRATA_77_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_77_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_77_ENABLE_WORKAROUND NRF52_ERRATA_77_PRESENT
++#endif
++
++static bool nrf52_errata_77(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 78 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_78_PRESENT 1
++#else
++    #define NRF52_ERRATA_78_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_78_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_78_ENABLE_WORKAROUND NRF52_ERRATA_78_PRESENT
++#endif
++
++static bool nrf52_errata_78(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 79 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_79_PRESENT 1
++#else
++    #define NRF52_ERRATA_79_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_79_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_79_ENABLE_WORKAROUND NRF52_ERRATA_79_PRESENT
++#endif
++
++static bool nrf52_errata_79(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 81 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_81_PRESENT 1
++#else
++    #define NRF52_ERRATA_81_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_81_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_81_ENABLE_WORKAROUND NRF52_ERRATA_81_PRESENT
++#endif
++
++static bool nrf52_errata_81(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 83 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_83_PRESENT 1
++#else
++    #define NRF52_ERRATA_83_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_83_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_83_ENABLE_WORKAROUND NRF52_ERRATA_83_PRESENT
++#endif
++
++static bool nrf52_errata_83(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 84 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_84_PRESENT 1
++#else
++    #define NRF52_ERRATA_84_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_84_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_84_ENABLE_WORKAROUND NRF52_ERRATA_84_PRESENT
++#endif
++
++static bool nrf52_errata_84(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 86 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_86_PRESENT 1
++#else
++    #define NRF52_ERRATA_86_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_86_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_86_ENABLE_WORKAROUND NRF52_ERRATA_86_PRESENT
++#endif
++
++static bool nrf52_errata_86(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 87 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_87_PRESENT 1
++#else
++    #define NRF52_ERRATA_87_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_87_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_87_ENABLE_WORKAROUND NRF52_ERRATA_87_PRESENT
++#endif
++
++static bool nrf52_errata_87(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 88 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_88_PRESENT 1
++#else
++    #define NRF52_ERRATA_88_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_88_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_88_ENABLE_WORKAROUND NRF52_ERRATA_88_PRESENT
++#endif
++
++static bool nrf52_errata_88(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 89 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_89_PRESENT 1
++#else
++    #define NRF52_ERRATA_89_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_89_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_89_ENABLE_WORKAROUND NRF52_ERRATA_89_PRESENT
++#endif
++
++static bool nrf52_errata_89(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 91 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_91_PRESENT 1
++#else
++    #define NRF52_ERRATA_91_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_91_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_91_ENABLE_WORKAROUND NRF52_ERRATA_91_PRESENT
++#endif
++
++static bool nrf52_errata_91(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 94 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_94_PRESENT 1
++#else
++    #define NRF52_ERRATA_94_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_94_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_94_ENABLE_WORKAROUND NRF52_ERRATA_94_PRESENT
++#endif
++
++static bool nrf52_errata_94(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 96 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_96_PRESENT 1
++#else
++    #define NRF52_ERRATA_96_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_96_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_96_ENABLE_WORKAROUND NRF52_ERRATA_96_PRESENT
++#endif
++
++static bool nrf52_errata_96(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 97 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_97_PRESENT 1
++#else
++    #define NRF52_ERRATA_97_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_97_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_97_ENABLE_WORKAROUND NRF52_ERRATA_97_PRESENT
++#endif
++
++static bool nrf52_errata_97(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 98 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_98_PRESENT 1
++#else
++    #define NRF52_ERRATA_98_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_98_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_98_ENABLE_WORKAROUND NRF52_ERRATA_98_PRESENT
++#endif
++
++static bool nrf52_errata_98(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 101 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_101_PRESENT 1
++#else
++    #define NRF52_ERRATA_101_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_101_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_101_ENABLE_WORKAROUND NRF52_ERRATA_101_PRESENT
++#endif
++
++static bool nrf52_errata_101(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 102 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_102_PRESENT 1
++#else
++    #define NRF52_ERRATA_102_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_102_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_102_ENABLE_WORKAROUND NRF52_ERRATA_102_PRESENT
++#endif
++
++static bool nrf52_errata_102(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 103 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_103_PRESENT 1
++#else
++    #define NRF52_ERRATA_103_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_103_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_103_ENABLE_WORKAROUND NRF52_ERRATA_103_PRESENT
++#endif
++
++static bool nrf52_errata_103(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 104 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_104_PRESENT 1
++#else
++    #define NRF52_ERRATA_104_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_104_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_104_ENABLE_WORKAROUND NRF52_ERRATA_104_PRESENT
++#endif
++
++static bool nrf52_errata_104(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 106 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_106_PRESENT 1
++#else
++    #define NRF52_ERRATA_106_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_106_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_106_ENABLE_WORKAROUND NRF52_ERRATA_106_PRESENT
++#endif
++
++static bool nrf52_errata_106(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 107 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_107_PRESENT 1
++#else
++    #define NRF52_ERRATA_107_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_107_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_107_ENABLE_WORKAROUND NRF52_ERRATA_107_PRESENT
++#endif
++
++static bool nrf52_errata_107(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 108 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_108_PRESENT 1
++#else
++    #define NRF52_ERRATA_108_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_108_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_108_ENABLE_WORKAROUND NRF52_ERRATA_108_PRESENT
++#endif
++
++static bool nrf52_errata_108(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 109 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_109_PRESENT 1
++#else
++    #define NRF52_ERRATA_109_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_109_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_109_ENABLE_WORKAROUND NRF52_ERRATA_109_PRESENT
++#endif
++
++static bool nrf52_errata_109(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 110 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_110_PRESENT 1
++#else
++    #define NRF52_ERRATA_110_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_110_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_110_ENABLE_WORKAROUND NRF52_ERRATA_110_PRESENT
++#endif
++
++static bool nrf52_errata_110(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 111 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_111_PRESENT 1
++#else
++    #define NRF52_ERRATA_111_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_111_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_111_ENABLE_WORKAROUND NRF52_ERRATA_111_PRESENT
++#endif
++
++static bool nrf52_errata_111(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 112 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_112_PRESENT 1
++#else
++    #define NRF52_ERRATA_112_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_112_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_112_ENABLE_WORKAROUND NRF52_ERRATA_112_PRESENT
++#endif
++
++static bool nrf52_errata_112(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 113 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_113_PRESENT 1
++#else
++    #define NRF52_ERRATA_113_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_113_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_113_ENABLE_WORKAROUND NRF52_ERRATA_113_PRESENT
++#endif
++
++static bool nrf52_errata_113(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 115 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_115_PRESENT 1
++#else
++    #define NRF52_ERRATA_115_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_115_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_115_ENABLE_WORKAROUND NRF52_ERRATA_115_PRESENT
++#endif
++
++static bool nrf52_errata_115(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 116 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_116_PRESENT 1
++#else
++    #define NRF52_ERRATA_116_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_116_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_116_ENABLE_WORKAROUND NRF52_ERRATA_116_PRESENT
++#endif
++
++static bool nrf52_errata_116(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 117 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_117_PRESENT 1
++#else
++    #define NRF52_ERRATA_117_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_117_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_117_ENABLE_WORKAROUND NRF52_ERRATA_117_PRESENT
++#endif
++
++static bool nrf52_errata_117(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 118 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_118_PRESENT 1
++#else
++    #define NRF52_ERRATA_118_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_118_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_118_ENABLE_WORKAROUND NRF52_ERRATA_118_PRESENT
++#endif
++
++static bool nrf52_errata_118(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 119 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_119_PRESENT 1
++#else
++    #define NRF52_ERRATA_119_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_119_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_119_ENABLE_WORKAROUND NRF52_ERRATA_119_PRESENT
++#endif
++
++static bool nrf52_errata_119(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 120 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_120_PRESENT 1
++#else
++    #define NRF52_ERRATA_120_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_120_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_120_ENABLE_WORKAROUND NRF52_ERRATA_120_PRESENT
++#endif
++
++static bool nrf52_errata_120(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 121 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_121_PRESENT 1
++#else
++    #define NRF52_ERRATA_121_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_121_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_121_ENABLE_WORKAROUND NRF52_ERRATA_121_PRESENT
++#endif
++
++static bool nrf52_errata_121(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 122 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_122_PRESENT 1
++#else
++    #define NRF52_ERRATA_122_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_122_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_122_ENABLE_WORKAROUND NRF52_ERRATA_122_PRESENT
++#endif
++
++static bool nrf52_errata_122(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 127 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_127_PRESENT 1
++#else
++    #define NRF52_ERRATA_127_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_127_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_127_ENABLE_WORKAROUND NRF52_ERRATA_127_PRESENT
++#endif
++
++static bool nrf52_errata_127(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 128 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_128_PRESENT 1
++#else
++    #define NRF52_ERRATA_128_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_128_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_128_ENABLE_WORKAROUND NRF52_ERRATA_128_PRESENT
++#endif
++
++static bool nrf52_errata_128(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 131 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_131_PRESENT 1
++#else
++    #define NRF52_ERRATA_131_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_131_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_131_ENABLE_WORKAROUND NRF52_ERRATA_131_PRESENT
++#endif
++
++static bool nrf52_errata_131(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 132 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_132_PRESENT 1
++#else
++    #define NRF52_ERRATA_132_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_132_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_132_ENABLE_WORKAROUND NRF52_ERRATA_132_PRESENT
++#endif
++
++static bool nrf52_errata_132(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 133 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_133_PRESENT 1
++#else
++    #define NRF52_ERRATA_133_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_133_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_133_ENABLE_WORKAROUND NRF52_ERRATA_133_PRESENT
++#endif
++
++static bool nrf52_errata_133(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 134 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_134_PRESENT 1
++#else
++    #define NRF52_ERRATA_134_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_134_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_134_ENABLE_WORKAROUND NRF52_ERRATA_134_PRESENT
++#endif
++
++static bool nrf52_errata_134(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 135 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_135_PRESENT 1
++#else
++    #define NRF52_ERRATA_135_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_135_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_135_ENABLE_WORKAROUND NRF52_ERRATA_135_PRESENT
++#endif
++
++static bool nrf52_errata_135(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 136 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_136_PRESENT 1
++#else
++    #define NRF52_ERRATA_136_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_136_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_136_ENABLE_WORKAROUND NRF52_ERRATA_136_PRESENT
++#endif
++
++static bool nrf52_errata_136(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 138 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_138_PRESENT 1
++#else
++    #define NRF52_ERRATA_138_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_138_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_138_ENABLE_WORKAROUND NRF52_ERRATA_138_PRESENT
++#endif
++
++static bool nrf52_errata_138(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 140 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_140_PRESENT 1
++#else
++    #define NRF52_ERRATA_140_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_140_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_140_ENABLE_WORKAROUND NRF52_ERRATA_140_PRESENT
++#endif
++
++static bool nrf52_errata_140(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 141 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_141_PRESENT 1
++#else
++    #define NRF52_ERRATA_141_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_141_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_141_ENABLE_WORKAROUND NRF52_ERRATA_141_PRESENT
++#endif
++
++static bool nrf52_errata_141(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 142 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_142_PRESENT 1
++#else
++    #define NRF52_ERRATA_142_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_142_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_142_ENABLE_WORKAROUND NRF52_ERRATA_142_PRESENT
++#endif
++
++static bool nrf52_errata_142(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 143 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_143_PRESENT 1
++#else
++    #define NRF52_ERRATA_143_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_143_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_143_ENABLE_WORKAROUND NRF52_ERRATA_143_PRESENT
++#endif
++
++static bool nrf52_errata_143(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 144 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_144_PRESENT 1
++#else
++    #define NRF52_ERRATA_144_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_144_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_144_ENABLE_WORKAROUND NRF52_ERRATA_144_PRESENT
++#endif
++
++static bool nrf52_errata_144(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 145 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_145_PRESENT 1
++#else
++    #define NRF52_ERRATA_145_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_145_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_145_ENABLE_WORKAROUND NRF52_ERRATA_145_PRESENT
++#endif
++
++static bool nrf52_errata_145(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 146 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_146_PRESENT 1
++#else
++    #define NRF52_ERRATA_146_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_146_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_146_ENABLE_WORKAROUND NRF52_ERRATA_146_PRESENT
++#endif
++
++static bool nrf52_errata_146(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 147 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_147_PRESENT 1
++#else
++    #define NRF52_ERRATA_147_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_147_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_147_ENABLE_WORKAROUND NRF52_ERRATA_147_PRESENT
++#endif
++
++static bool nrf52_errata_147(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 149 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_149_PRESENT 1
++#else
++    #define NRF52_ERRATA_149_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_149_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_149_ENABLE_WORKAROUND NRF52_ERRATA_149_PRESENT
++#endif
++
++static bool nrf52_errata_149(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 150 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_150_PRESENT 1
++#else
++    #define NRF52_ERRATA_150_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_150_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_150_ENABLE_WORKAROUND NRF52_ERRATA_150_PRESENT
++#endif
++
++static bool nrf52_errata_150(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 151 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_151_PRESENT 1
++#else
++    #define NRF52_ERRATA_151_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_151_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_151_ENABLE_WORKAROUND NRF52_ERRATA_151_PRESENT
++#endif
++
++static bool nrf52_errata_151(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 153 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_153_PRESENT 1
++#else
++    #define NRF52_ERRATA_153_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_153_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_153_ENABLE_WORKAROUND NRF52_ERRATA_153_PRESENT
++#endif
++
++static bool nrf52_errata_153(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 154 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_154_PRESENT 1
++#else
++    #define NRF52_ERRATA_154_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_154_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_154_ENABLE_WORKAROUND NRF52_ERRATA_154_PRESENT
++#endif
++
++static bool nrf52_errata_154(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 155 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_155_PRESENT 1
++#else
++    #define NRF52_ERRATA_155_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_155_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_155_ENABLE_WORKAROUND NRF52_ERRATA_155_PRESENT
++#endif
++
++static bool nrf52_errata_155(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 156 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_156_PRESENT 1
++#else
++    #define NRF52_ERRATA_156_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_156_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_156_ENABLE_WORKAROUND NRF52_ERRATA_156_PRESENT
++#endif
++
++static bool nrf52_errata_156(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 158 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_158_PRESENT 1
++#else
++    #define NRF52_ERRATA_158_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_158_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_158_ENABLE_WORKAROUND NRF52_ERRATA_158_PRESENT
++#endif
++
++static bool nrf52_errata_158(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 160 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_160_PRESENT 1
++#else
++    #define NRF52_ERRATA_160_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_160_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_160_ENABLE_WORKAROUND NRF52_ERRATA_160_PRESENT
++#endif
++
++static bool nrf52_errata_160(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 162 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_162_PRESENT 1
++#else
++    #define NRF52_ERRATA_162_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_162_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_162_ENABLE_WORKAROUND NRF52_ERRATA_162_PRESENT
++#endif
++
++static bool nrf52_errata_162(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 163 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_163_PRESENT 1
++#else
++    #define NRF52_ERRATA_163_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_163_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_163_ENABLE_WORKAROUND NRF52_ERRATA_163_PRESENT
++#endif
++
++static bool nrf52_errata_163(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 164 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_164_PRESENT 1
++#else
++    #define NRF52_ERRATA_164_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_164_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_164_ENABLE_WORKAROUND NRF52_ERRATA_164_PRESENT
++#endif
++
++static bool nrf52_errata_164(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 166 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_166_PRESENT 1
++#else
++    #define NRF52_ERRATA_166_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_166_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_166_ENABLE_WORKAROUND NRF52_ERRATA_166_PRESENT
++#endif
++
++static bool nrf52_errata_166(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 170 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_170_PRESENT 1
++#else
++    #define NRF52_ERRATA_170_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_170_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_170_ENABLE_WORKAROUND NRF52_ERRATA_170_PRESENT
++#endif
++
++static bool nrf52_errata_170(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 171 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_171_PRESENT 1
++#else
++    #define NRF52_ERRATA_171_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_171_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_171_ENABLE_WORKAROUND NRF52_ERRATA_171_PRESENT
++#endif
++
++static bool nrf52_errata_171(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 172 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_172_PRESENT 1
++#else
++    #define NRF52_ERRATA_172_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_172_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_172_ENABLE_WORKAROUND NRF52_ERRATA_172_PRESENT
++#endif
++
++static bool nrf52_errata_172(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 173 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_173_PRESENT 1
++#else
++    #define NRF52_ERRATA_173_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_173_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_173_ENABLE_WORKAROUND NRF52_ERRATA_173_PRESENT
++#endif
++
++static bool nrf52_errata_173(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 174 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_174_PRESENT 1
++#else
++    #define NRF52_ERRATA_174_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_174_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_174_ENABLE_WORKAROUND NRF52_ERRATA_174_PRESENT
++#endif
++
++static bool nrf52_errata_174(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 176 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_176_PRESENT 1
++#else
++    #define NRF52_ERRATA_176_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_176_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_176_ENABLE_WORKAROUND NRF52_ERRATA_176_PRESENT
++#endif
++
++static bool nrf52_errata_176(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 178 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_178_PRESENT 1
++#else
++    #define NRF52_ERRATA_178_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_178_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_178_ENABLE_WORKAROUND NRF52_ERRATA_178_PRESENT
++#endif
++
++static bool nrf52_errata_178(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 179 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_179_PRESENT 1
++#else
++    #define NRF52_ERRATA_179_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_179_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_179_ENABLE_WORKAROUND NRF52_ERRATA_179_PRESENT
++#endif
++
++static bool nrf52_errata_179(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 180 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_180_PRESENT 1
++#else
++    #define NRF52_ERRATA_180_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_180_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_180_ENABLE_WORKAROUND NRF52_ERRATA_180_PRESENT
++#endif
++
++static bool nrf52_errata_180(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 181 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_181_PRESENT 1
++#else
++    #define NRF52_ERRATA_181_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_181_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_181_ENABLE_WORKAROUND NRF52_ERRATA_181_PRESENT
++#endif
++
++static bool nrf52_errata_181(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 182 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_182_PRESENT 1
++#else
++    #define NRF52_ERRATA_182_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_182_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_182_ENABLE_WORKAROUND NRF52_ERRATA_182_PRESENT
++#endif
++
++static bool nrf52_errata_182(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 183 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_183_PRESENT 1
++#else
++    #define NRF52_ERRATA_183_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_183_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_183_ENABLE_WORKAROUND NRF52_ERRATA_183_PRESENT
++#endif
++
++static bool nrf52_errata_183(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 184 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_184_PRESENT 1
++#else
++    #define NRF52_ERRATA_184_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_184_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_184_ENABLE_WORKAROUND NRF52_ERRATA_184_PRESENT
++#endif
++
++static bool nrf52_errata_184(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 186 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_186_PRESENT 1
++#else
++    #define NRF52_ERRATA_186_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_186_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_186_ENABLE_WORKAROUND NRF52_ERRATA_186_PRESENT
++#endif
++
++static bool nrf52_errata_186(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 187 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_187_PRESENT 1
++#else
++    #define NRF52_ERRATA_187_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_187_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_187_ENABLE_WORKAROUND NRF52_ERRATA_187_PRESENT
++#endif
++
++static bool nrf52_errata_187(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 189 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_189_PRESENT 1
++#else
++    #define NRF52_ERRATA_189_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_189_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_189_ENABLE_WORKAROUND NRF52_ERRATA_189_PRESENT
++#endif
++
++static bool nrf52_errata_189(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 190 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_190_PRESENT 1
++#else
++    #define NRF52_ERRATA_190_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_190_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_190_ENABLE_WORKAROUND NRF52_ERRATA_190_PRESENT
++#endif
++
++static bool nrf52_errata_190(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 191 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_191_PRESENT 1
++#else
++    #define NRF52_ERRATA_191_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_191_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_191_ENABLE_WORKAROUND NRF52_ERRATA_191_PRESENT
++#endif
++
++static bool nrf52_errata_191(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 192 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_192_PRESENT 1
++#else
++    #define NRF52_ERRATA_192_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_192_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_192_ENABLE_WORKAROUND NRF52_ERRATA_192_PRESENT
++#endif
++
++static bool nrf52_errata_192(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 193 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_193_PRESENT 1
++#else
++    #define NRF52_ERRATA_193_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_193_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_193_ENABLE_WORKAROUND NRF52_ERRATA_193_PRESENT
++#endif
++
++static bool nrf52_errata_193(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 194 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_194_PRESENT 1
++#else
++    #define NRF52_ERRATA_194_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_194_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_194_ENABLE_WORKAROUND NRF52_ERRATA_194_PRESENT
++#endif
++
++static bool nrf52_errata_194(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 195 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_195_PRESENT 1
++#else
++    #define NRF52_ERRATA_195_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_195_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_195_ENABLE_WORKAROUND NRF52_ERRATA_195_PRESENT
++#endif
++
++static bool nrf52_errata_195(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 196 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_196_PRESENT 1
++#else
++    #define NRF52_ERRATA_196_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_196_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_196_ENABLE_WORKAROUND NRF52_ERRATA_196_PRESENT
++#endif
++
++static bool nrf52_errata_196(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 197 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_197_PRESENT 1
++#else
++    #define NRF52_ERRATA_197_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_197_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_197_ENABLE_WORKAROUND NRF52_ERRATA_197_PRESENT
++#endif
++
++static bool nrf52_errata_197(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 198 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_198_PRESENT 1
++#else
++    #define NRF52_ERRATA_198_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_198_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_198_ENABLE_WORKAROUND NRF52_ERRATA_198_PRESENT
++#endif
++
++static bool nrf52_errata_198(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 199 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_199_PRESENT 1
++#else
++    #define NRF52_ERRATA_199_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_199_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_199_ENABLE_WORKAROUND NRF52_ERRATA_199_PRESENT
++#endif
++
++static bool nrf52_errata_199(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 200 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_200_PRESENT 1
++#else
++    #define NRF52_ERRATA_200_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_200_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_200_ENABLE_WORKAROUND NRF52_ERRATA_200_PRESENT
++#endif
++
++static bool nrf52_errata_200(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 201 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_201_PRESENT 1
++#else
++    #define NRF52_ERRATA_201_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_201_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_201_ENABLE_WORKAROUND NRF52_ERRATA_201_PRESENT
++#endif
++
++static bool nrf52_errata_201(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 202 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_202_PRESENT 1
++#else
++    #define NRF52_ERRATA_202_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_202_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_202_ENABLE_WORKAROUND NRF52_ERRATA_202_PRESENT
++#endif
++
++static bool nrf52_errata_202(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 204 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_204_PRESENT 1
++#else
++    #define NRF52_ERRATA_204_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_204_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_204_ENABLE_WORKAROUND NRF52_ERRATA_204_PRESENT
++#endif
++
++static bool nrf52_errata_204(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 208 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_208_PRESENT 1
++#else
++    #define NRF52_ERRATA_208_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_208_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_208_ENABLE_WORKAROUND NRF52_ERRATA_208_PRESENT
++#endif
++
++static bool nrf52_errata_208(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 209 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_209_PRESENT 1
++#else
++    #define NRF52_ERRATA_209_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_209_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_209_ENABLE_WORKAROUND NRF52_ERRATA_209_PRESENT
++#endif
++
++static bool nrf52_errata_209(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 210 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_210_PRESENT 1
++#else
++    #define NRF52_ERRATA_210_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_210_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_210_ENABLE_WORKAROUND NRF52_ERRATA_210_PRESENT
++#endif
++
++static bool nrf52_errata_210(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 211 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_211_PRESENT 1
++#else
++    #define NRF52_ERRATA_211_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_211_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_211_ENABLE_WORKAROUND 0
++#endif
++
++static bool nrf52_errata_211(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 212 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_212_PRESENT 1
++#else
++    #define NRF52_ERRATA_212_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_212_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_212_ENABLE_WORKAROUND NRF52_ERRATA_212_PRESENT
++#endif
++
++static bool nrf52_errata_212(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 213 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_213_PRESENT 1
++#else
++    #define NRF52_ERRATA_213_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_213_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_213_ENABLE_WORKAROUND NRF52_ERRATA_213_PRESENT
++#endif
++
++static bool nrf52_errata_213(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 214 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_214_PRESENT 1
++#else
++    #define NRF52_ERRATA_214_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_214_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_214_ENABLE_WORKAROUND NRF52_ERRATA_214_PRESENT
++#endif
++
++static bool nrf52_errata_214(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 215 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_215_PRESENT 1
++#else
++    #define NRF52_ERRATA_215_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_215_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_215_ENABLE_WORKAROUND NRF52_ERRATA_215_PRESENT
++#endif
++
++static bool nrf52_errata_215(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 216 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_216_PRESENT 1
++#else
++    #define NRF52_ERRATA_216_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_216_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_216_ENABLE_WORKAROUND NRF52_ERRATA_216_PRESENT
++#endif
++
++static bool nrf52_errata_216(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 217 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++    #define NRF52_ERRATA_217_PRESENT 1
++#else
++    #define NRF52_ERRATA_217_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_217_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_217_ENABLE_WORKAROUND NRF52_ERRATA_217_PRESENT
++#endif
++
++static bool nrf52_errata_217(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 218 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_218_PRESENT 1
++#else
++    #define NRF52_ERRATA_218_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_218_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_218_ENABLE_WORKAROUND NRF52_ERRATA_218_PRESENT
++#endif
++
++static bool nrf52_errata_218(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 219 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_219_PRESENT 1
++#else
++    #define NRF52_ERRATA_219_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_219_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_219_ENABLE_WORKAROUND NRF52_ERRATA_219_PRESENT
++#endif
++
++static bool nrf52_errata_219(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 220 ========= */
++#if    defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++    #define NRF52_ERRATA_220_PRESENT 1
++#else
++    #define NRF52_ERRATA_220_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_220_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_220_ENABLE_WORKAROUND NRF52_ERRATA_220_PRESENT
++#endif
++
++static bool nrf52_errata_220(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 223 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++    #define NRF52_ERRATA_223_PRESENT 1
++#else
++    #define NRF52_ERRATA_223_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_223_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_223_ENABLE_WORKAROUND NRF52_ERRATA_223_PRESENT
++#endif
++
++static bool nrf52_errata_223(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 225 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++    #define NRF52_ERRATA_225_PRESENT 1
++#else
++    #define NRF52_ERRATA_225_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_225_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_225_ENABLE_WORKAROUND NRF52_ERRATA_225_PRESENT
++#endif
++
++static bool nrf52_errata_225(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 228 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_228_PRESENT 1
++#else
++    #define NRF52_ERRATA_228_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_228_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_228_ENABLE_WORKAROUND NRF52_ERRATA_228_PRESENT
++#endif
++
++static bool nrf52_errata_228(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 230 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++    #define NRF52_ERRATA_230_PRESENT 1
++#else
++    #define NRF52_ERRATA_230_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_230_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_230_ENABLE_WORKAROUND NRF52_ERRATA_230_PRESENT
++#endif
++
++static bool nrf52_errata_230(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 231 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++    #define NRF52_ERRATA_231_PRESENT 1
++#else
++    #define NRF52_ERRATA_231_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_231_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_231_ENABLE_WORKAROUND NRF52_ERRATA_231_PRESENT
++#endif
++
++static bool nrf52_errata_231(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 232 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++    #define NRF52_ERRATA_232_PRESENT 1
++#else
++    #define NRF52_ERRATA_232_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_232_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_232_ENABLE_WORKAROUND NRF52_ERRATA_232_PRESENT
++#endif
++
++static bool nrf52_errata_232(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 233 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_233_PRESENT 1
++#else
++    #define NRF52_ERRATA_233_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_233_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_233_ENABLE_WORKAROUND NRF52_ERRATA_233_PRESENT
++#endif
++
++static bool nrf52_errata_233(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 236 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_236_PRESENT 1
++#else
++    #define NRF52_ERRATA_236_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_236_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_236_ENABLE_WORKAROUND NRF52_ERRATA_236_PRESENT
++#endif
++
++static bool nrf52_errata_236(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 237 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_237_PRESENT 1
++#else
++    #define NRF52_ERRATA_237_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_237_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_237_ENABLE_WORKAROUND NRF52_ERRATA_237_PRESENT
++#endif
++
++static bool nrf52_errata_237(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 242 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_242_PRESENT 1
++#else
++    #define NRF52_ERRATA_242_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_242_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_242_ENABLE_WORKAROUND NRF52_ERRATA_242_PRESENT
++#endif
++
++static bool nrf52_errata_242(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 243 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_243_PRESENT 1
++#else
++    #define NRF52_ERRATA_243_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_243_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_243_ENABLE_WORKAROUND NRF52_ERRATA_243_PRESENT
++#endif
++
++static bool nrf52_errata_243(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 244 ========= */
++#if    defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_244_PRESENT 1
++#else
++    #define NRF52_ERRATA_244_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_244_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_244_ENABLE_WORKAROUND NRF52_ERRATA_244_PRESENT
++#endif
++
++static bool nrf52_errata_244(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 245 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_245_PRESENT 1
++#else
++    #define NRF52_ERRATA_245_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_245_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_245_ENABLE_WORKAROUND 0
++#endif
++
++static bool nrf52_errata_245(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            uint32_t var1;
++            uint32_t var2;
++
++            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
++            {
++                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
++                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
++            }
++            else
++            {
++                var1 = *(uint32_t *)0x10000130ul;
++                var2 = *(uint32_t *)0x10000134ul;
++            }
++        #elif defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    case 0x06ul:
++                        return true;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 246 ========= */
++#if    defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805) \
++    || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_246_PRESENT 1
++#else
++    #define NRF52_ERRATA_246_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_246_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_246_ENABLE_WORKAROUND NRF52_ERRATA_246_PRESENT
++#endif
++
++static bool nrf52_errata_246(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
++         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)
++            if (var1 == 0x0F)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 248 ========= */
++#if    defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810) \
++    || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811) \
++    || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_248_PRESENT 1
++#else
++    #define NRF52_ERRATA_248_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_248_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_248_ENABLE_WORKAROUND NRF52_ERRATA_248_PRESENT
++#endif
++
++static bool nrf52_errata_248(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
++         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
++         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)
++            if (var1 == 0x0A)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)
++            if (var1 == 0x0E)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 249 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833) \
++    || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++    #define NRF52_ERRATA_249_PRESENT 1
++#else
++    #define NRF52_ERRATA_249_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_249_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_249_ENABLE_WORKAROUND NRF52_ERRATA_249_PRESENT
++#endif
++
++static bool nrf52_errata_249(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
++         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
++         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
++            if (var1 == 0x06)
++            {
++                switch(var2)
++                {
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return false;
++                    case 0x05ul:
++                        return false;
++                    case 0x06ul:
++                        return false;
++                    case 0x07ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
++            if (var1 == 0x08)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return false;
++                    case 0x04ul:
++                        return true;
++                    case 0x05ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return false;
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return false;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 250 ========= */
++#if    defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820) \
++    || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++    #define NRF52_ERRATA_250_PRESENT 1
++#else
++    #define NRF52_ERRATA_250_PRESENT 0
++#endif
++
++#ifndef NRF52_ERRATA_250_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_250_ENABLE_WORKAROUND NRF52_ERRATA_250_PRESENT
++#endif
++
++static bool nrf52_errata_250(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
++         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            uint32_t var1 = *(uint32_t *)0x10000130ul;
++            uint32_t var2 = *(uint32_t *)0x10000134ul;
++        #endif
++        #if defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)
++            if (var1 == 0x0D)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)
++            if (var1 == 0x10)
++            {
++                switch(var2)
++                {
++                    case 0x00ul:
++                        return true;
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    case 0x03ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 254 ========= */
++#define NRF52_ERRATA_254_PRESENT 0
++
++#ifndef NRF52_ERRATA_254_ENABLE_WORKAROUND
++    #define NRF52_ERRATA_254_ENABLE_WORKAROUND NRF52_ERRATA_254_PRESENT
++#endif
++
++static bool nrf52_errata_254(void)
++{
++    #ifndef NRF52_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++#endif /* NRF52_ERRATAS_H */
+diff --git a/projects/nrf52840_dk/nrf52_to_nrf52840.h b/projects/nrf52840_dk/nrf52_to_nrf52840.h
+new file mode 100644
+index 00000000..4c577695
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf52_to_nrf52840.h
+@@ -0,0 +1,161 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#ifndef NRF52_TO_NRF52840_H
++#define NRF52_TO_NRF52840_H
++
++/*lint ++flb "Enter library region */
++
++/* This file is given to prevent your SW from not compiling with the name changes between nRF51 or nRF52832 and nRF52840 devices.
++ * It redefines the old nRF51 or nRF52832 names into the new ones as long as the functionality is still supported. If the
++ * functionality is gone, there old names are not defined, so compilation will fail. Note that also includes macros
++ * from the nrf52_namechange.h file. */
++ 
++/* Differences between latest nRF52 headers and nRF52840 headers. */
++
++/* UART */
++/* The registers PSELRTS, PSELTXD, PSELCTS, PSELRXD were restructured into a struct. */
++#ifndef PSELRTS
++    #define PSELRTS       PSEL.RTS
++#endif
++#ifndef PSELTXD    
++    #define PSELTXD       PSEL.TXD
++#endif
++#ifndef PSELCTS
++    #define PSELCTS       PSEL.CTS
++#endif
++#ifndef PSELRXD
++    #define PSELRXD       PSEL.RXD
++#endif
++
++/* TWI */
++/* The registers PSELSCL, PSELSDA were restructured into a struct. */
++#ifndef PSELSCL
++    #define PSELSCL       PSEL.SCL
++#endif
++#ifndef PSELSDA
++    #define PSELSDA       PSEL.SDA
++#endif
++
++
++/* LPCOMP */
++/* The hysteresis control enumerated values has changed name for nRF52840 devices. */
++#ifndef LPCOMP_HYST_HYST_NoHyst
++    #define LPCOMP_HYST_HYST_NoHyst     LPCOMP_HYST_HYST_Disabled
++#endif
++#ifndef LPCOMP_HYST_HYST_Hyst50mV
++    #define LPCOMP_HYST_HYST_Hyst50mV   LPCOMP_HYST_HYST_Enabled
++#endif
++
++
++/* From nrf52_name_change.h. Several macros changed in different versions of nRF52 headers. By defining the following, any code written for any version of nRF52 headers will still compile. */
++
++/* I2S */
++/* Several enumerations changed case. Adding old macros to keep compilation compatibility. */
++#ifndef I2S_ENABLE_ENABLE_DISABLE
++    #define I2S_ENABLE_ENABLE_DISABLE           I2S_ENABLE_ENABLE_Disabled
++#endif
++#ifndef I2S_ENABLE_ENABLE_ENABLE
++    #define I2S_ENABLE_ENABLE_ENABLE            I2S_ENABLE_ENABLE_Enabled
++#endif
++#ifndef I2S_CONFIG_MODE_MODE_MASTER
++    #define I2S_CONFIG_MODE_MODE_MASTER         I2S_CONFIG_MODE_MODE_Master
++#endif
++#ifndef I2S_CONFIG_MODE_MODE_SLAVE
++    #define I2S_CONFIG_MODE_MODE_SLAVE          I2S_CONFIG_MODE_MODE_Slave
++#endif
++#ifndef I2S_CONFIG_RXEN_RXEN_DISABLE
++    #define I2S_CONFIG_RXEN_RXEN_DISABLE        I2S_CONFIG_RXEN_RXEN_Disabled
++#endif
++#ifndef I2S_CONFIG_RXEN_RXEN_ENABLE
++    #define I2S_CONFIG_RXEN_RXEN_ENABLE         I2S_CONFIG_RXEN_RXEN_Enabled
++#endif
++#ifndef I2S_CONFIG_TXEN_TXEN_DISABLE
++    #define I2S_CONFIG_TXEN_TXEN_DISABLE        I2S_CONFIG_TXEN_TXEN_Disabled
++#endif
++#ifndef I2S_CONFIG_TXEN_TXEN_ENABLE
++    #define I2S_CONFIG_TXEN_TXEN_ENABLE         I2S_CONFIG_TXEN_TXEN_Enabled
++#endif
++#ifndef I2S_CONFIG_MCKEN_MCKEN_DISABLE
++    #define I2S_CONFIG_MCKEN_MCKEN_DISABLE      I2S_CONFIG_MCKEN_MCKEN_Disabled
++#endif
++#ifndef I2S_CONFIG_MCKEN_MCKEN_ENABLE
++    #define I2S_CONFIG_MCKEN_MCKEN_ENABLE       I2S_CONFIG_MCKEN_MCKEN_Enabled
++#endif
++#ifndef I2S_CONFIG_SWIDTH_SWIDTH_8BIT
++    #define I2S_CONFIG_SWIDTH_SWIDTH_8BIT       I2S_CONFIG_SWIDTH_SWIDTH_8Bit
++#endif
++#ifndef I2S_CONFIG_SWIDTH_SWIDTH_16BIT
++    #define I2S_CONFIG_SWIDTH_SWIDTH_16BIT      I2S_CONFIG_SWIDTH_SWIDTH_16Bit
++#endif
++#ifndef I2S_CONFIG_SWIDTH_SWIDTH_24BIT
++    #define I2S_CONFIG_SWIDTH_SWIDTH_24BIT      I2S_CONFIG_SWIDTH_SWIDTH_24Bit
++#endif
++#ifndef I2S_CONFIG_ALIGN_ALIGN_LEFT
++    #define I2S_CONFIG_ALIGN_ALIGN_LEFT         I2S_CONFIG_ALIGN_ALIGN_Left
++#endif
++#ifndef I2S_CONFIG_ALIGN_ALIGN_RIGHT
++    #define I2S_CONFIG_ALIGN_ALIGN_RIGHT        I2S_CONFIG_ALIGN_ALIGN_Right
++#endif
++#ifndef I2S_CONFIG_FORMAT_FORMAT_ALIGNED
++    #define I2S_CONFIG_FORMAT_FORMAT_ALIGNED    I2S_CONFIG_FORMAT_FORMAT_Aligned
++#endif
++#ifndef I2S_CONFIG_CHANNELS_CHANNELS_STEREO
++    #define I2S_CONFIG_CHANNELS_CHANNELS_STEREO I2S_CONFIG_CHANNELS_CHANNELS_Stereo
++#endif
++#ifndef I2S_CONFIG_CHANNELS_CHANNELS_LEFT
++    #define I2S_CONFIG_CHANNELS_CHANNELS_LEFT   I2S_CONFIG_CHANNELS_CHANNELS_Left
++#endif
++#ifndef I2S_CONFIG_CHANNELS_CHANNELS_RIGHT
++    #define I2S_CONFIG_CHANNELS_CHANNELS_RIGHT  I2S_CONFIG_CHANNELS_CHANNELS_Right
++#endif
++
++/* LPCOMP */
++/* Corrected typo in RESULT register. */
++#ifndef LPCOMP_RESULT_RESULT_Bellow
++    #define LPCOMP_RESULT_RESULT_Bellow         LPCOMP_RESULT_RESULT_Below
++#endif
++
++
++/*lint --flb "Leave library region" */
++
++#endif /* NRF51_TO_NRF52840_H */
++
+diff --git a/projects/nrf52840_dk/nrf53_erratas.h b/projects/nrf52840_dk/nrf53_erratas.h
+new file mode 100644
+index 00000000..636dc1bf
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf53_erratas.h
+@@ -0,0 +1,4825 @@
++#ifndef NRF53_ERRATAS_H
++#define NRF53_ERRATAS_H
++
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#include <stdint.h>
++#include <stdbool.h>
++#include "compiler_abstraction.h"
++
++static bool nrf53_errata_1(void) __UNUSED;
++static bool nrf53_errata_2(void) __UNUSED;
++static bool nrf53_errata_3(void) __UNUSED;
++static bool nrf53_errata_4(void) __UNUSED;
++static bool nrf53_errata_5(void) __UNUSED;
++static bool nrf53_errata_6(void) __UNUSED;
++static bool nrf53_errata_7(void) __UNUSED;
++static bool nrf53_errata_8(void) __UNUSED;
++static bool nrf53_errata_9(void) __UNUSED;
++static bool nrf53_errata_10(void) __UNUSED;
++static bool nrf53_errata_11(void) __UNUSED;
++static bool nrf53_errata_12(void) __UNUSED;
++static bool nrf53_errata_13(void) __UNUSED;
++static bool nrf53_errata_14(void) __UNUSED;
++static bool nrf53_errata_15(void) __UNUSED;
++static bool nrf53_errata_16(void) __UNUSED;
++static bool nrf53_errata_18(void) __UNUSED;
++static bool nrf53_errata_19(void) __UNUSED;
++static bool nrf53_errata_20(void) __UNUSED;
++static bool nrf53_errata_21(void) __UNUSED;
++static bool nrf53_errata_22(void) __UNUSED;
++static bool nrf53_errata_23(void) __UNUSED;
++static bool nrf53_errata_26(void) __UNUSED;
++static bool nrf53_errata_27(void) __UNUSED;
++static bool nrf53_errata_28(void) __UNUSED;
++static bool nrf53_errata_29(void) __UNUSED;
++static bool nrf53_errata_30(void) __UNUSED;
++static bool nrf53_errata_31(void) __UNUSED;
++static bool nrf53_errata_32(void) __UNUSED;
++static bool nrf53_errata_33(void) __UNUSED;
++static bool nrf53_errata_34(void) __UNUSED;
++static bool nrf53_errata_36(void) __UNUSED;
++static bool nrf53_errata_37(void) __UNUSED;
++static bool nrf53_errata_42(void) __UNUSED;
++static bool nrf53_errata_43(void) __UNUSED;
++static bool nrf53_errata_44(void) __UNUSED;
++static bool nrf53_errata_45(void) __UNUSED;
++static bool nrf53_errata_46(void) __UNUSED;
++static bool nrf53_errata_47(void) __UNUSED;
++static bool nrf53_errata_49(void) __UNUSED;
++static bool nrf53_errata_50(void) __UNUSED;
++static bool nrf53_errata_51(void) __UNUSED;
++static bool nrf53_errata_52(void) __UNUSED;
++static bool nrf53_errata_53(void) __UNUSED;
++static bool nrf53_errata_54(void) __UNUSED;
++static bool nrf53_errata_55(void) __UNUSED;
++static bool nrf53_errata_57(void) __UNUSED;
++static bool nrf53_errata_58(void) __UNUSED;
++static bool nrf53_errata_59(void) __UNUSED;
++static bool nrf53_errata_62(void) __UNUSED;
++static bool nrf53_errata_64(void) __UNUSED;
++static bool nrf53_errata_65(void) __UNUSED;
++static bool nrf53_errata_66(void) __UNUSED;
++static bool nrf53_errata_67(void) __UNUSED;
++static bool nrf53_errata_69(void) __UNUSED;
++static bool nrf53_errata_70(void) __UNUSED;
++static bool nrf53_errata_71(void) __UNUSED;
++static bool nrf53_errata_72(void) __UNUSED;
++static bool nrf53_errata_73(void) __UNUSED;
++static bool nrf53_errata_74(void) __UNUSED;
++static bool nrf53_errata_75(void) __UNUSED;
++static bool nrf53_errata_76(void) __UNUSED;
++static bool nrf53_errata_77(void) __UNUSED;
++static bool nrf53_errata_79(void) __UNUSED;
++static bool nrf53_errata_80(void) __UNUSED;
++static bool nrf53_errata_81(void) __UNUSED;
++static bool nrf53_errata_82(void) __UNUSED;
++static bool nrf53_errata_83(void) __UNUSED;
++static bool nrf53_errata_84(void) __UNUSED;
++static bool nrf53_errata_85(void) __UNUSED;
++static bool nrf53_errata_86(void) __UNUSED;
++static bool nrf53_errata_87(void) __UNUSED;
++static bool nrf53_errata_90(void) __UNUSED;
++static bool nrf53_errata_91(void) __UNUSED;
++static bool nrf53_errata_93(void) __UNUSED;
++static bool nrf53_errata_95(void) __UNUSED;
++static bool nrf53_errata_97(void) __UNUSED;
++static bool nrf53_errata_99(void) __UNUSED;
++static bool nrf53_errata_103(void) __UNUSED;
++static bool nrf53_errata_105(void) __UNUSED;
++static bool nrf53_errata_106(void) __UNUSED;
++static bool nrf53_errata_107(void) __UNUSED;
++static bool nrf53_errata_109(void) __UNUSED;
++static bool nrf53_errata_110(void) __UNUSED;
++static bool nrf53_errata_112(void) __UNUSED;
++static bool nrf53_errata_113(void) __UNUSED;
++static bool nrf53_errata_114(void) __UNUSED;
++static bool nrf53_errata_115(void) __UNUSED;
++static bool nrf53_errata_116(void) __UNUSED;
++static bool nrf53_errata_117(void) __UNUSED;
++static bool nrf53_errata_119(void) __UNUSED;
++static bool nrf53_errata_121(void) __UNUSED;
++static bool nrf53_errata_122(void) __UNUSED;
++
++/* ========= Errata 1 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_1_PRESENT 1
++    #else
++        #define NRF53_ERRATA_1_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_1_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_1_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_1_ENABLE_WORKAROUND NRF53_ERRATA_1_PRESENT
++#endif
++
++static bool nrf53_errata_1(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 2 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_2_PRESENT 1
++    #else
++        #define NRF53_ERRATA_2_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_2_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_2_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_2_ENABLE_WORKAROUND NRF53_ERRATA_2_PRESENT
++#endif
++
++static bool nrf53_errata_2(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 3 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_3_PRESENT 1
++    #else
++        #define NRF53_ERRATA_3_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_3_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_3_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_3_ENABLE_WORKAROUND NRF53_ERRATA_3_PRESENT
++#endif
++
++static bool nrf53_errata_3(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 4 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_4_PRESENT 1
++    #else
++        #define NRF53_ERRATA_4_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_4_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_4_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_4_ENABLE_WORKAROUND NRF53_ERRATA_4_PRESENT
++#endif
++
++static bool nrf53_errata_4(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 5 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_5_PRESENT 1
++    #else
++        #define NRF53_ERRATA_5_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_5_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_5_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_5_ENABLE_WORKAROUND NRF53_ERRATA_5_PRESENT
++#endif
++
++static bool nrf53_errata_5(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 6 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_6_PRESENT 1
++    #else
++        #define NRF53_ERRATA_6_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_6_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_6_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_6_ENABLE_WORKAROUND NRF53_ERRATA_6_PRESENT
++#endif
++
++static bool nrf53_errata_6(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 7 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_7_PRESENT 1
++    #else
++        #define NRF53_ERRATA_7_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_7_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_7_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_7_ENABLE_WORKAROUND NRF53_ERRATA_7_PRESENT
++#endif
++
++static bool nrf53_errata_7(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 8 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_8_PRESENT 1
++    #else
++        #define NRF53_ERRATA_8_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_8_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_8_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_8_ENABLE_WORKAROUND NRF53_ERRATA_8_PRESENT
++#endif
++
++static bool nrf53_errata_8(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 9 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_9_PRESENT 1
++    #else
++        #define NRF53_ERRATA_9_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_9_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_9_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_9_ENABLE_WORKAROUND NRF53_ERRATA_9_PRESENT
++#endif
++
++static bool nrf53_errata_9(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 10 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_10_PRESENT 1
++    #else
++        #define NRF53_ERRATA_10_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_10_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_10_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_10_ENABLE_WORKAROUND NRF53_ERRATA_10_PRESENT
++#endif
++
++static bool nrf53_errata_10(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 11 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_11_PRESENT 1
++    #else
++        #define NRF53_ERRATA_11_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_11_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_11_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_11_ENABLE_WORKAROUND NRF53_ERRATA_11_PRESENT
++#endif
++
++static bool nrf53_errata_11(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 12 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_12_PRESENT 1
++    #else
++        #define NRF53_ERRATA_12_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_12_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_12_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_12_ENABLE_WORKAROUND NRF53_ERRATA_12_PRESENT
++#endif
++
++static bool nrf53_errata_12(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 13 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_13_PRESENT 1
++    #else
++        #define NRF53_ERRATA_13_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_13_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_13_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_13_ENABLE_WORKAROUND NRF53_ERRATA_13_PRESENT
++#endif
++
++static bool nrf53_errata_13(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 14 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_14_PRESENT 1
++    #else
++        #define NRF53_ERRATA_14_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_14_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_14_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_14_ENABLE_WORKAROUND NRF53_ERRATA_14_PRESENT
++#endif
++
++static bool nrf53_errata_14(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 15 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_15_PRESENT 1
++    #else
++        #define NRF53_ERRATA_15_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_15_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_15_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_15_ENABLE_WORKAROUND NRF53_ERRATA_15_PRESENT
++#endif
++
++static bool nrf53_errata_15(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 16 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_16_PRESENT 1
++    #else
++        #define NRF53_ERRATA_16_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_16_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_16_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_16_ENABLE_WORKAROUND NRF53_ERRATA_16_PRESENT
++#endif
++
++static bool nrf53_errata_16(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 18 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_18_PRESENT 1
++    #else
++        #define NRF53_ERRATA_18_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_18_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_18_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_18_ENABLE_WORKAROUND NRF53_ERRATA_18_PRESENT
++#endif
++
++static bool nrf53_errata_18(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 19 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_19_PRESENT 1
++    #else
++        #define NRF53_ERRATA_19_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_19_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_19_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_19_ENABLE_WORKAROUND NRF53_ERRATA_19_PRESENT
++#endif
++
++static bool nrf53_errata_19(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 20 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_20_PRESENT 1
++    #else
++        #define NRF53_ERRATA_20_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_20_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_20_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_20_ENABLE_WORKAROUND NRF53_ERRATA_20_PRESENT
++#endif
++
++static bool nrf53_errata_20(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 21 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_21_PRESENT 1
++    #else
++        #define NRF53_ERRATA_21_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_21_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_21_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_21_ENABLE_WORKAROUND NRF53_ERRATA_21_PRESENT
++#endif
++
++static bool nrf53_errata_21(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 22 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_22_PRESENT 1
++    #else
++        #define NRF53_ERRATA_22_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_22_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_22_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_22_ENABLE_WORKAROUND NRF53_ERRATA_22_PRESENT
++#endif
++
++static bool nrf53_errata_22(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 23 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_23_PRESENT 1
++    #else
++        #define NRF53_ERRATA_23_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_23_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_23_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_23_ENABLE_WORKAROUND NRF53_ERRATA_23_PRESENT
++#endif
++
++static bool nrf53_errata_23(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 26 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_26_PRESENT 1
++    #else
++        #define NRF53_ERRATA_26_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_26_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_26_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_26_ENABLE_WORKAROUND NRF53_ERRATA_26_PRESENT
++#endif
++
++static bool nrf53_errata_26(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 27 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_27_PRESENT 1
++    #else
++        #define NRF53_ERRATA_27_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_27_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_27_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_27_ENABLE_WORKAROUND NRF53_ERRATA_27_PRESENT
++#endif
++
++static bool nrf53_errata_27(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 28 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_28_PRESENT 1
++    #else
++        #define NRF53_ERRATA_28_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_28_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_28_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_28_ENABLE_WORKAROUND NRF53_ERRATA_28_PRESENT
++#endif
++
++static bool nrf53_errata_28(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 29 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_29_PRESENT 1
++    #else
++        #define NRF53_ERRATA_29_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_29_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_29_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_29_ENABLE_WORKAROUND NRF53_ERRATA_29_PRESENT
++#endif
++
++static bool nrf53_errata_29(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 30 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_30_PRESENT 1
++    #else
++        #define NRF53_ERRATA_30_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_30_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_30_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_30_ENABLE_WORKAROUND NRF53_ERRATA_30_PRESENT
++#endif
++
++static bool nrf53_errata_30(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 31 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_31_PRESENT 1
++    #else
++        #define NRF53_ERRATA_31_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_31_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_31_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_31_ENABLE_WORKAROUND NRF53_ERRATA_31_PRESENT
++#endif
++
++static bool nrf53_errata_31(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 32 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_32_PRESENT 1
++    #else
++        #define NRF53_ERRATA_32_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_32_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_32_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_32_ENABLE_WORKAROUND NRF53_ERRATA_32_PRESENT
++#endif
++
++static bool nrf53_errata_32(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 33 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_33_PRESENT 1
++    #else
++        #define NRF53_ERRATA_33_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_33_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_33_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_33_ENABLE_WORKAROUND NRF53_ERRATA_33_PRESENT
++#endif
++
++static bool nrf53_errata_33(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 34 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_34_PRESENT 1
++    #else
++        #define NRF53_ERRATA_34_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_34_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_34_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_34_ENABLE_WORKAROUND NRF53_ERRATA_34_PRESENT
++#endif
++
++static bool nrf53_errata_34(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 36 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_36_PRESENT 1
++    #else
++        #define NRF53_ERRATA_36_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_36_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_36_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_36_ENABLE_WORKAROUND NRF53_ERRATA_36_PRESENT
++#endif
++
++static bool nrf53_errata_36(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 37 ========= */
++#define NRF53_ERRATA_37_PRESENT 0
++
++#ifndef NRF53_ERRATA_37_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_37_ENABLE_WORKAROUND NRF53_ERRATA_37_PRESENT
++#endif
++
++static bool nrf53_errata_37(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 42 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_42_PRESENT 1
++    #else
++        #define NRF53_ERRATA_42_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_42_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_42_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_42_ENABLE_WORKAROUND NRF53_ERRATA_42_PRESENT
++#endif
++
++static bool nrf53_errata_42(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 43 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_43_PRESENT 1
++    #else
++        #define NRF53_ERRATA_43_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_43_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_43_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_43_ENABLE_WORKAROUND NRF53_ERRATA_43_PRESENT
++#endif
++
++static bool nrf53_errata_43(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 44 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_44_PRESENT 1
++    #else
++        #define NRF53_ERRATA_44_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_44_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_44_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_44_ENABLE_WORKAROUND NRF53_ERRATA_44_PRESENT
++#endif
++
++static bool nrf53_errata_44(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 45 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_45_PRESENT 1
++    #else
++        #define NRF53_ERRATA_45_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_45_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_45_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_45_ENABLE_WORKAROUND NRF53_ERRATA_45_PRESENT
++#endif
++
++static bool nrf53_errata_45(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 46 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_46_PRESENT 1
++    #else
++        #define NRF53_ERRATA_46_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_46_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_46_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_46_ENABLE_WORKAROUND NRF53_ERRATA_46_PRESENT
++#endif
++
++static bool nrf53_errata_46(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 47 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_47_PRESENT 1
++    #else
++        #define NRF53_ERRATA_47_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_47_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_47_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_47_ENABLE_WORKAROUND NRF53_ERRATA_47_PRESENT
++#endif
++
++static bool nrf53_errata_47(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 49 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_49_PRESENT 1
++    #else
++        #define NRF53_ERRATA_49_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_49_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_49_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_49_ENABLE_WORKAROUND NRF53_ERRATA_49_PRESENT
++#endif
++
++static bool nrf53_errata_49(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 50 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_50_PRESENT 1
++    #else
++        #define NRF53_ERRATA_50_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_50_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_50_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_50_ENABLE_WORKAROUND NRF53_ERRATA_50_PRESENT
++#endif
++
++static bool nrf53_errata_50(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 51 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_51_PRESENT 1
++    #else
++        #define NRF53_ERRATA_51_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_51_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_51_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_51_ENABLE_WORKAROUND NRF53_ERRATA_51_PRESENT
++#endif
++
++static bool nrf53_errata_51(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 52 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_52_PRESENT 1
++    #else
++        #define NRF53_ERRATA_52_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_52_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_52_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_52_ENABLE_WORKAROUND NRF53_ERRATA_52_PRESENT
++#endif
++
++static bool nrf53_errata_52(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 53 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_53_PRESENT 1
++    #else
++        #define NRF53_ERRATA_53_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_53_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_53_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_53_ENABLE_WORKAROUND NRF53_ERRATA_53_PRESENT
++#endif
++
++static bool nrf53_errata_53(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 54 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_54_PRESENT 1
++    #else
++        #define NRF53_ERRATA_54_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_54_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_54_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_54_ENABLE_WORKAROUND NRF53_ERRATA_54_PRESENT
++#endif
++
++static bool nrf53_errata_54(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 55 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_55_PRESENT 1
++    #else
++        #define NRF53_ERRATA_55_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_55_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_55_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_55_ENABLE_WORKAROUND NRF53_ERRATA_55_PRESENT
++#endif
++
++static bool nrf53_errata_55(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 57 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_57_PRESENT 1
++    #else
++        #define NRF53_ERRATA_57_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_57_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_57_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_57_ENABLE_WORKAROUND NRF53_ERRATA_57_PRESENT
++#endif
++
++static bool nrf53_errata_57(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 58 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_58_PRESENT 1
++    #else
++        #define NRF53_ERRATA_58_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_58_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_58_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_58_ENABLE_WORKAROUND NRF53_ERRATA_58_PRESENT
++#endif
++
++static bool nrf53_errata_58(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 59 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_59_PRESENT 1
++    #else
++        #define NRF53_ERRATA_59_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_59_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_59_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_59_ENABLE_WORKAROUND NRF53_ERRATA_59_PRESENT
++#endif
++
++static bool nrf53_errata_59(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 62 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_62_PRESENT 1
++    #else
++        #define NRF53_ERRATA_62_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_62_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_62_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_62_ENABLE_WORKAROUND NRF53_ERRATA_62_PRESENT
++#endif
++
++static bool nrf53_errata_62(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 64 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_64_PRESENT 1
++    #else
++        #define NRF53_ERRATA_64_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_64_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_64_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_64_ENABLE_WORKAROUND NRF53_ERRATA_64_PRESENT
++#endif
++
++static bool nrf53_errata_64(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 65 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_65_PRESENT 1
++    #else
++        #define NRF53_ERRATA_65_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_65_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_65_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_65_ENABLE_WORKAROUND NRF53_ERRATA_65_PRESENT
++#endif
++
++static bool nrf53_errata_65(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 66 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_66_PRESENT 1
++    #else
++        #define NRF53_ERRATA_66_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_66_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_66_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_66_ENABLE_WORKAROUND NRF53_ERRATA_66_PRESENT
++#endif
++
++static bool nrf53_errata_66(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 67 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_67_PRESENT 1
++    #else
++        #define NRF53_ERRATA_67_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_67_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_67_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_67_ENABLE_WORKAROUND NRF53_ERRATA_67_PRESENT
++#endif
++
++static bool nrf53_errata_67(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 69 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_69_PRESENT 1
++    #else
++        #define NRF53_ERRATA_69_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_69_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_69_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_69_ENABLE_WORKAROUND NRF53_ERRATA_69_PRESENT
++#endif
++
++static bool nrf53_errata_69(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 70 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_70_PRESENT 1
++    #else
++        #define NRF53_ERRATA_70_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_70_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_70_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_70_ENABLE_WORKAROUND NRF53_ERRATA_70_PRESENT
++#endif
++
++static bool nrf53_errata_70(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 71 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_71_PRESENT 1
++    #else
++        #define NRF53_ERRATA_71_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_71_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_71_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_71_ENABLE_WORKAROUND NRF53_ERRATA_71_PRESENT
++#endif
++
++static bool nrf53_errata_71(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 72 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_72_PRESENT 1
++    #else
++        #define NRF53_ERRATA_72_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_72_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_72_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_72_ENABLE_WORKAROUND NRF53_ERRATA_72_PRESENT
++#endif
++
++static bool nrf53_errata_72(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 73 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_73_PRESENT 1
++    #else
++        #define NRF53_ERRATA_73_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_73_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_73_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_73_ENABLE_WORKAROUND NRF53_ERRATA_73_PRESENT
++#endif
++
++static bool nrf53_errata_73(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 74 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_74_PRESENT 1
++    #else
++        #define NRF53_ERRATA_74_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_74_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_74_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_74_ENABLE_WORKAROUND NRF53_ERRATA_74_PRESENT
++#endif
++
++static bool nrf53_errata_74(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 75 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_75_PRESENT 1
++    #else
++        #define NRF53_ERRATA_75_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_75_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_75_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_75_ENABLE_WORKAROUND NRF53_ERRATA_75_PRESENT
++#endif
++
++static bool nrf53_errata_75(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 76 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_76_PRESENT 1
++    #else
++        #define NRF53_ERRATA_76_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_76_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_76_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_76_ENABLE_WORKAROUND NRF53_ERRATA_76_PRESENT
++#endif
++
++static bool nrf53_errata_76(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 77 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_77_PRESENT 1
++    #else
++        #define NRF53_ERRATA_77_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_77_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_77_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_77_ENABLE_WORKAROUND NRF53_ERRATA_77_PRESENT
++#endif
++
++static bool nrf53_errata_77(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 79 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_79_PRESENT 1
++    #else
++        #define NRF53_ERRATA_79_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_79_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_79_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_79_ENABLE_WORKAROUND NRF53_ERRATA_79_PRESENT
++#endif
++
++static bool nrf53_errata_79(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 80 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_80_PRESENT 1
++    #else
++        #define NRF53_ERRATA_80_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_80_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_80_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_80_ENABLE_WORKAROUND NRF53_ERRATA_80_PRESENT
++#endif
++
++static bool nrf53_errata_80(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 81 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_81_PRESENT 1
++    #else
++        #define NRF53_ERRATA_81_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_81_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_81_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_81_ENABLE_WORKAROUND NRF53_ERRATA_81_PRESENT
++#endif
++
++static bool nrf53_errata_81(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 82 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_82_PRESENT 1
++    #else
++        #define NRF53_ERRATA_82_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_82_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_82_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_82_ENABLE_WORKAROUND NRF53_ERRATA_82_PRESENT
++#endif
++
++static bool nrf53_errata_82(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 83 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_83_PRESENT 1
++    #else
++        #define NRF53_ERRATA_83_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_83_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_83_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_83_ENABLE_WORKAROUND NRF53_ERRATA_83_PRESENT
++#endif
++
++static bool nrf53_errata_83(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 84 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_84_PRESENT 1
++    #else
++        #define NRF53_ERRATA_84_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_84_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_84_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_84_ENABLE_WORKAROUND NRF53_ERRATA_84_PRESENT
++#endif
++
++static bool nrf53_errata_84(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 85 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_85_PRESENT 1
++    #else
++        #define NRF53_ERRATA_85_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_85_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_85_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_85_ENABLE_WORKAROUND NRF53_ERRATA_85_PRESENT
++#endif
++
++static bool nrf53_errata_85(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 86 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_86_PRESENT 1
++    #else
++        #define NRF53_ERRATA_86_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_86_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_86_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_86_ENABLE_WORKAROUND NRF53_ERRATA_86_PRESENT
++#endif
++
++static bool nrf53_errata_86(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 87 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_87_PRESENT 1
++    #else
++        #define NRF53_ERRATA_87_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_87_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_87_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_87_ENABLE_WORKAROUND NRF53_ERRATA_87_PRESENT
++#endif
++
++static bool nrf53_errata_87(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 90 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_90_PRESENT 1
++    #else
++        #define NRF53_ERRATA_90_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_90_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_90_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_90_ENABLE_WORKAROUND NRF53_ERRATA_90_PRESENT
++#endif
++
++static bool nrf53_errata_90(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 91 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_91_PRESENT 1
++    #else
++        #define NRF53_ERRATA_91_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_91_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_91_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_91_ENABLE_WORKAROUND NRF53_ERRATA_91_PRESENT
++#endif
++
++static bool nrf53_errata_91(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 93 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_93_PRESENT 1
++    #else
++        #define NRF53_ERRATA_93_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_93_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_93_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_93_ENABLE_WORKAROUND NRF53_ERRATA_93_PRESENT
++#endif
++
++static bool nrf53_errata_93(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 95 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_95_PRESENT 1
++    #else
++        #define NRF53_ERRATA_95_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_95_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_95_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_95_ENABLE_WORKAROUND NRF53_ERRATA_95_PRESENT
++#endif
++
++static bool nrf53_errata_95(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 97 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION) || \
++        defined(NRF_NETWORK)
++        #define NRF53_ERRATA_97_PRESENT 1
++    #else
++        #define NRF53_ERRATA_97_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_97_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_97_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_97_ENABLE_WORKAROUND NRF53_ERRATA_97_PRESENT
++#endif
++
++static bool nrf53_errata_97(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #elif defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)\
++             || defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 99 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_99_PRESENT 1
++    #else
++        #define NRF53_ERRATA_99_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_99_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_99_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_99_ENABLE_WORKAROUND NRF53_ERRATA_99_PRESENT
++#endif
++
++static bool nrf53_errata_99(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return false;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 103 ========= */
++#define NRF53_ERRATA_103_PRESENT 0
++
++#ifndef NRF53_ERRATA_103_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_103_ENABLE_WORKAROUND NRF53_ERRATA_103_PRESENT
++#endif
++
++static bool nrf53_errata_103(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        return false;
++    #endif
++}
++
++/* ========= Errata 105 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_105_PRESENT 1
++    #else
++        #define NRF53_ERRATA_105_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_105_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_105_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_105_ENABLE_WORKAROUND NRF53_ERRATA_105_PRESENT
++#endif
++
++static bool nrf53_errata_105(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 106 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_106_PRESENT 1
++    #else
++        #define NRF53_ERRATA_106_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_106_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_106_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_106_ENABLE_WORKAROUND NRF53_ERRATA_106_PRESENT
++#endif
++
++static bool nrf53_errata_106(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 107 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_107_PRESENT 1
++    #else
++        #define NRF53_ERRATA_107_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_107_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_107_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_107_ENABLE_WORKAROUND NRF53_ERRATA_107_PRESENT
++#endif
++
++static bool nrf53_errata_107(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return false;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 109 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_109_PRESENT 1
++    #else
++        #define NRF53_ERRATA_109_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_109_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_109_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_109_ENABLE_WORKAROUND NRF53_ERRATA_109_PRESENT
++#endif
++
++static bool nrf53_errata_109(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 110 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_110_PRESENT 1
++    #else
++        #define NRF53_ERRATA_110_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_110_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_110_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_110_ENABLE_WORKAROUND NRF53_ERRATA_110_PRESENT
++#endif
++
++static bool nrf53_errata_110(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 112 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_112_PRESENT 1
++    #else
++        #define NRF53_ERRATA_112_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_112_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_112_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_112_ENABLE_WORKAROUND NRF53_ERRATA_112_PRESENT
++#endif
++
++static bool nrf53_errata_112(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return false;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 113 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_113_PRESENT 1
++    #else
++        #define NRF53_ERRATA_113_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_113_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_113_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_113_ENABLE_WORKAROUND NRF53_ERRATA_113_PRESENT
++#endif
++
++static bool nrf53_errata_113(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 114 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_114_PRESENT 1
++    #else
++        #define NRF53_ERRATA_114_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_114_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_114_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_114_ENABLE_WORKAROUND NRF53_ERRATA_114_PRESENT
++#endif
++
++static bool nrf53_errata_114(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 115 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_115_PRESENT 1
++    #else
++        #define NRF53_ERRATA_115_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_115_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_115_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_115_ENABLE_WORKAROUND NRF53_ERRATA_115_PRESENT
++#endif
++
++static bool nrf53_errata_115(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 116 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_116_PRESENT 1
++    #else
++        #define NRF53_ERRATA_116_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_116_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_116_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_116_ENABLE_WORKAROUND NRF53_ERRATA_116_PRESENT
++#endif
++
++static bool nrf53_errata_116(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return false;
++                        case 0x05ul:
++                            return false;
++                        default:
++                            return false;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 117 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_117_PRESENT 1
++    #else
++        #define NRF53_ERRATA_117_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_117_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_117_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_117_ENABLE_WORKAROUND NRF53_ERRATA_117_PRESENT
++#endif
++
++static bool nrf53_errata_117(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 119 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_119_PRESENT 1
++    #else
++        #define NRF53_ERRATA_119_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_119_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_119_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_119_ENABLE_WORKAROUND NRF53_ERRATA_119_PRESENT
++#endif
++
++static bool nrf53_errata_119(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return true;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 121 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_APPLICATION)
++        #define NRF53_ERRATA_121_PRESENT 1
++    #else
++        #define NRF53_ERRATA_121_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_121_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_121_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_121_ENABLE_WORKAROUND NRF53_ERRATA_121_PRESENT
++#endif
++
++static bool nrf53_errata_121(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_APPLICATION)
++                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_APPLICATION)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return false;
++                        case 0x03ul:
++                            return true;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 122 ========= */
++#if    defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++    #if defined(NRF_NETWORK)
++        #define NRF53_ERRATA_122_PRESENT 1
++    #else
++        #define NRF53_ERRATA_122_PRESENT 0
++    #endif
++#else
++    #define NRF53_ERRATA_122_PRESENT 0
++#endif
++
++#ifndef NRF53_ERRATA_122_ENABLE_WORKAROUND
++    #define NRF53_ERRATA_122_ENABLE_WORKAROUND NRF53_ERRATA_122_PRESENT
++#endif
++
++static bool nrf53_errata_122(void)
++{
++    #ifndef NRF53_SERIES
++        return false;
++    #else
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined(NRF_NETWORK)
++                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
++                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
++            #endif
++        #endif
++        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
++            #if defined (NRF_NETWORK)
++                if (var1 == 0x07)
++                {
++                    switch(var2)
++                    {
++                        case 0x02ul:
++                            return false;
++                        case 0x03ul:
++                            return false;
++                        case 0x04ul:
++                            return true;
++                        case 0x05ul:
++                            return true;
++                        default:
++                            return true;
++                    }
++                }
++            #endif
++        #endif
++        return false;
++    #endif
++}
++
++#endif /* NRF53_ERRATAS_H */
+diff --git a/projects/nrf52840_dk/nrf91_erratas.h b/projects/nrf52840_dk/nrf91_erratas.h
+new file mode 100644
+index 00000000..50bf0579
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf91_erratas.h
+@@ -0,0 +1,1025 @@
++#ifndef NRF91_ERRATAS_H
++#define NRF91_ERRATAS_H
++
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#include <stdint.h>
++#include <stdbool.h>
++#include "compiler_abstraction.h"
++
++static bool nrf91_errata_1(void) __UNUSED;
++static bool nrf91_errata_2(void) __UNUSED;
++static bool nrf91_errata_4(void) __UNUSED;
++static bool nrf91_errata_6(void) __UNUSED;
++static bool nrf91_errata_7(void) __UNUSED;
++static bool nrf91_errata_8(void) __UNUSED;
++static bool nrf91_errata_9(void) __UNUSED;
++static bool nrf91_errata_10(void) __UNUSED;
++static bool nrf91_errata_12(void) __UNUSED;
++static bool nrf91_errata_14(void) __UNUSED;
++static bool nrf91_errata_15(void) __UNUSED;
++static bool nrf91_errata_16(void) __UNUSED;
++static bool nrf91_errata_17(void) __UNUSED;
++static bool nrf91_errata_20(void) __UNUSED;
++static bool nrf91_errata_21(void) __UNUSED;
++static bool nrf91_errata_23(void) __UNUSED;
++static bool nrf91_errata_24(void) __UNUSED;
++static bool nrf91_errata_26(void) __UNUSED;
++static bool nrf91_errata_27(void) __UNUSED;
++static bool nrf91_errata_28(void) __UNUSED;
++static bool nrf91_errata_29(void) __UNUSED;
++static bool nrf91_errata_30(void) __UNUSED;
++static bool nrf91_errata_31(void) __UNUSED;
++static bool nrf91_errata_32(void) __UNUSED;
++static bool nrf91_errata_33(void) __UNUSED;
++
++/* ========= Errata 1 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_1_PRESENT 1
++#else
++    #define NRF91_ERRATA_1_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_1_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_1_ENABLE_WORKAROUND NRF91_ERRATA_1_PRESENT
++#endif
++
++static bool nrf91_errata_1(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 2 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_2_PRESENT 1
++#else
++    #define NRF91_ERRATA_2_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_2_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_2_ENABLE_WORKAROUND NRF91_ERRATA_2_PRESENT
++#endif
++
++static bool nrf91_errata_2(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 4 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_4_PRESENT 1
++#else
++    #define NRF91_ERRATA_4_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_4_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_4_ENABLE_WORKAROUND NRF91_ERRATA_4_PRESENT
++#endif
++
++static bool nrf91_errata_4(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 6 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_6_PRESENT 1
++#else
++    #define NRF91_ERRATA_6_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_6_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_6_ENABLE_WORKAROUND NRF91_ERRATA_6_PRESENT
++#endif
++
++static bool nrf91_errata_6(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 7 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_7_PRESENT 1
++#else
++    #define NRF91_ERRATA_7_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_7_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_7_ENABLE_WORKAROUND NRF91_ERRATA_7_PRESENT
++#endif
++
++static bool nrf91_errata_7(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 8 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_8_PRESENT 1
++#else
++    #define NRF91_ERRATA_8_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_8_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_8_ENABLE_WORKAROUND NRF91_ERRATA_8_PRESENT
++#endif
++
++static bool nrf91_errata_8(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 9 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_9_PRESENT 1
++#else
++    #define NRF91_ERRATA_9_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_9_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_9_ENABLE_WORKAROUND NRF91_ERRATA_9_PRESENT
++#endif
++
++static bool nrf91_errata_9(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 10 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_10_PRESENT 1
++#else
++    #define NRF91_ERRATA_10_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_10_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_10_ENABLE_WORKAROUND NRF91_ERRATA_10_PRESENT
++#endif
++
++static bool nrf91_errata_10(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 12 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_12_PRESENT 1
++#else
++    #define NRF91_ERRATA_12_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_12_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_12_ENABLE_WORKAROUND NRF91_ERRATA_12_PRESENT
++#endif
++
++static bool nrf91_errata_12(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 14 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_14_PRESENT 1
++#else
++    #define NRF91_ERRATA_14_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_14_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_14_ENABLE_WORKAROUND NRF91_ERRATA_14_PRESENT
++#endif
++
++static bool nrf91_errata_14(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 15 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_15_PRESENT 1
++#else
++    #define NRF91_ERRATA_15_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_15_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_15_ENABLE_WORKAROUND NRF91_ERRATA_15_PRESENT
++#endif
++
++static bool nrf91_errata_15(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 16 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_16_PRESENT 1
++#else
++    #define NRF91_ERRATA_16_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_16_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_16_ENABLE_WORKAROUND NRF91_ERRATA_16_PRESENT
++#endif
++
++static bool nrf91_errata_16(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 17 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_17_PRESENT 1
++#else
++    #define NRF91_ERRATA_17_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_17_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_17_ENABLE_WORKAROUND NRF91_ERRATA_17_PRESENT
++#endif
++
++static bool nrf91_errata_17(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 20 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_20_PRESENT 1
++#else
++    #define NRF91_ERRATA_20_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_20_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_20_ENABLE_WORKAROUND NRF91_ERRATA_20_PRESENT
++#endif
++
++static bool nrf91_errata_20(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return false;
++                    default:
++                        return false;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 21 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_21_PRESENT 1
++#else
++    #define NRF91_ERRATA_21_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_21_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_21_ENABLE_WORKAROUND NRF91_ERRATA_21_PRESENT
++#endif
++
++static bool nrf91_errata_21(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 23 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_23_PRESENT 1
++#else
++    #define NRF91_ERRATA_23_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_23_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_23_ENABLE_WORKAROUND NRF91_ERRATA_23_PRESENT
++#endif
++
++static bool nrf91_errata_23(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 24 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_24_PRESENT 1
++#else
++    #define NRF91_ERRATA_24_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_24_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_24_ENABLE_WORKAROUND NRF91_ERRATA_24_PRESENT
++#endif
++
++static bool nrf91_errata_24(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 26 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_26_PRESENT 1
++#else
++    #define NRF91_ERRATA_26_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_26_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_26_ENABLE_WORKAROUND NRF91_ERRATA_26_PRESENT
++#endif
++
++static bool nrf91_errata_26(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 27 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_27_PRESENT 1
++#else
++    #define NRF91_ERRATA_27_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_27_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_27_ENABLE_WORKAROUND NRF91_ERRATA_27_PRESENT
++#endif
++
++static bool nrf91_errata_27(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return false;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 28 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_28_PRESENT 1
++#else
++    #define NRF91_ERRATA_28_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_28_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_28_ENABLE_WORKAROUND NRF91_ERRATA_28_PRESENT
++#endif
++
++static bool nrf91_errata_28(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 29 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_29_PRESENT 1
++#else
++    #define NRF91_ERRATA_29_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_29_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_29_ENABLE_WORKAROUND NRF91_ERRATA_29_PRESENT
++#endif
++
++static bool nrf91_errata_29(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 30 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_30_PRESENT 1
++#else
++    #define NRF91_ERRATA_30_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_30_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_30_ENABLE_WORKAROUND NRF91_ERRATA_30_PRESENT
++#endif
++
++static bool nrf91_errata_30(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 31 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_31_PRESENT 1
++#else
++    #define NRF91_ERRATA_31_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_31_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_31_ENABLE_WORKAROUND NRF91_ERRATA_31_PRESENT
++#endif
++
++static bool nrf91_errata_31(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 32 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_32_PRESENT 1
++#else
++    #define NRF91_ERRATA_32_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_32_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_32_ENABLE_WORKAROUND NRF91_ERRATA_32_PRESENT
++#endif
++
++static bool nrf91_errata_32(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++/* ========= Errata 33 ========= */
++#if    defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++    #define NRF91_ERRATA_33_PRESENT 1
++#else
++    #define NRF91_ERRATA_33_PRESENT 0
++#endif
++
++#ifndef NRF91_ERRATA_33_ENABLE_WORKAROUND
++    #define NRF91_ERRATA_33_ENABLE_WORKAROUND NRF91_ERRATA_33_PRESENT
++#endif
++
++static bool nrf91_errata_33(void)
++{
++    #ifndef NRF91_SERIES
++        return false;
++    #else
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            uint32_t var1 = *(uint32_t *)0x00FF0130ul;
++            uint32_t var2 = *(uint32_t *)0x00FF0134ul;
++        #endif
++        #if defined (NRF9160_XXAA) || defined (DEVELOP_IN_NRF9160)
++            if (var1 == 0x09)
++            {
++                switch(var2)
++                {
++                    case 0x01ul:
++                        return true;
++                    case 0x02ul:
++                        return true;
++                    default:
++                        return true;
++                }
++            }
++        #endif
++        return false;
++    #endif
++}
++
++#endif /* NRF91_ERRATAS_H */
+diff --git a/projects/nrf52840_dk/nrf_erratas.h b/projects/nrf52840_dk/nrf_erratas.h
+new file mode 100644
+index 00000000..52bb61f0
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf_erratas.h
+@@ -0,0 +1,59 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#ifndef NRF_ERRATAS_H
++#define NRF_ERRATAS_H
++
++#include "nrf.h"
++
++/* Check MDK version to make sure we have the required macros */
++NRF_MDK_VERSION_ASSERT_AT_LEAST(8,34,0);
++
++/*lint ++flb "Enter library region */
++
++#include "nrf51_erratas.h"
++#include "nrf52_erratas.h"
++#include "nrf53_erratas.h"
++#include "nrf91_erratas.h"
++
++/*lint --flb "Leave library region" */
++
++#endif // NRF_ERRATAS_H
+diff --git a/projects/nrf52840_dk/nrf_peripherals.h b/projects/nrf52840_dk/nrf_peripherals.h
+new file mode 100644
+index 00000000..760838d8
+--- /dev/null
++++ b/projects/nrf52840_dk/nrf_peripherals.h
+@@ -0,0 +1,79 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#ifndef NRF_PERIPHERALS_H__
++#define NRF_PERIPHERALS_H__
++
++/*lint ++flb "Enter library region */
++
++#if defined(NRF51)
++    #include "nrf51_peripherals.h"
++
++#elif defined (NRF52805_XXAA)
++    #include "nrf52805_peripherals.h"
++#elif defined(NRF52810_XXAA)
++    #include "nrf52810_peripherals.h"
++#elif defined(NRF52811_XXAA)
++    #include "nrf52811_peripherals.h"
++#elif defined(NRF52820_XXAA)
++    #include "nrf52820_peripherals.h"
++#elif defined(NRF52832_XXAA) || defined(NRF52832_XXAB)
++    #include "nrf52832_peripherals.h"
++#elif defined (NRF52833_XXAA)
++    #include "nrf52833_peripherals.h"
++#elif defined(NRF52840_XXAA)
++    #include "nrf52840_peripherals.h"
++
++#elif defined (NRF5340_XXAA_APPLICATION)
++    #include "nrf5340_application_peripherals.h"
++#elif defined (NRF5340_XXAA_NETWORK)
++    #include "nrf5340_network_peripherals.h"
++
++#elif defined(NRF9160_XXAA)
++    #include "nrf9160_peripherals.h"
++
++#else
++    #error "Device must be defined. See nrf.h."
++#endif
++
++/*lint --flb "Leave library region" */
++
++#endif // NRF_PERIPHERALS_H__
+diff --git a/projects/nrf52840_dk/opendefs.h b/projects/nrf52840_dk/opendefs.h
+new file mode 100644
+index 00000000..54472199
+--- /dev/null
++++ b/projects/nrf52840_dk/opendefs.h
+@@ -0,0 +1,445 @@
++/**
++\brief General OpenWSN definitions
++
++\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, August 2010
++\author Ankur Mehta <mehtank@eecs.berkeley.edu>, September 2010
++\author Savio Sciancalepore <savio.sciancalepore@poliba.it>, TelematicsLab April 2015
++\author Giuseppe Piro <giuseppe.piro@poliba.it>,
++\author Gennaro Boggia <gennaro.boggia@poliba.it>,
++\author Luigi Alfredo Grieco <alfredo.grieco@poliba.it>
++*/
++
++#ifndef OPENWSN_OPENDEFS_H
++#define OPENWSN_OPENDEFS_H
++
++// general
++#include <stdint.h>               // needed for uin8_t, uint16_t
++#include "config.h"
++#include "toolchain_defs.h"
++#include "board_info.h"
++#include "af.h"
++
++
++//=========================== define ==========================================
++
++static const uint8_t infoStackName[] = "OpenWSN ";
++#define OPENWSN_VERSION_MAJOR     1
++#define OPENWSN_VERSION_MINOR     25
++#define OPENWSN_VERSION_PATCH     0
++
++#ifndef TRUE
++#define TRUE 1
++#endif
++
++#ifndef FALSE
++#define FALSE 0
++#endif
++
++#define LENGTH_ADDR16b   2
++#define LENGTH_ADDR64b   8
++#define LENGTH_ADDR128b  16
++
++#define MAXNUMNEIGHBORS  30
++
++// maximum celllist length
++#define CELLLIST_MAX_LEN 5
++
++// frame sizes
++#define IEEE802154_FRAME_SIZE   127
++
++#if OPENWSN_6LO_FRAGMENTATION_C
++#define IPV6_PACKET_SIZE        MAX_PKTSIZE_SUPPORTED
++#else
++#define IPV6_PACKET_SIZE        IEEE802154_FRAME_SIZE
++#endif
++
++enum {
++    E_SUCCESS = 0,
++    E_FAIL = 1,
++};
++
++// types of addresses
++enum {
++    ADDR_NONE = 0,
++    ADDR_16B = 1,
++    ADDR_64B = 2,
++    ADDR_128B = 3,
++    ADDR_PANID = 4,
++    ADDR_PREFIX = 5,
++    ADDR_ANYCAST = 6,
++};
++
++enum {
++    OW_LITTLE_ENDIAN = TRUE,
++    OW_BIG_ENDIAN = FALSE,
++};
++
++// protocol numbers, as defined by the IANA
++enum {
++    IANA_IPv6HOPOPT = 0x00,
++    IANA_UDP = 0x11,
++    IANA_IPv6ROUTING = 0x03,
++    IANA_IPv6ROUTE = 0x2b,//used for source routing
++    IANA_ICMPv6 = 0x3a,
++    IANA_ICMPv6_ECHO_REQUEST = 128,
++    IANA_ICMPv6_ECHO_REPLY = 129,
++    IANA_ICMPv6_RS = 133,
++    IANA_ICMPv6_RA = 134,
++    IANA_ICMPv6_RA_PREFIX_INFORMATION = 3,
++    IANA_ICMPv6_RPL = 155,
++    IANA_ICMPv6_RPL_DIS = 0x00,
++    IANA_ICMPv6_RPL_DIO = 0x01,
++    IANA_ICMPv6_RPL_DAO = 0x02,
++    IANA_RSVP = 46,
++    IANA_UNDEFINED = 250, //use an unassigned
++};
++
++// well known ports (which we define)
++// warning: first 4 MSB of 2° octet may coincide with previous protocol number
++enum {
++    //UDP
++    WKP_UDP_COAP = OPENWSN_COAP_PORT_DEFAULT,
++    WKP_UDP_ECHO = 7,
++    WKP_UDP_EXPIRATION = 5,
++    WKP_UDP_MONITOR = 3,
++    WKP_UDP_INJECT = 61617,// 0xf0b1
++    WKP_UDP_RINGMASTER = 15000,
++    WKP_UDP_SERIALBRIDGE = 2001,
++};
++
++//status elements
++enum {
++    STATUS_ISSYNC = 0,
++    STATUS_ID = 1,
++    STATUS_DAGRANK = 2,
++    STATUS_OUTBUFFERINDEXES = 3,
++    STATUS_ASN = 4,
++    STATUS_MACSTATS = 5,
++    STATUS_SCHEDULE = 6,
++    STATUS_BACKOFF = 7,
++    STATUS_QUEUE = 8,
++    STATUS_NEIGHBORS = 9,
++    STATUS_KAPERIOD = 10,
++    STATUS_JOINED = 11,
++    STATUS_MSF = 12,
++    STATUS_MAX = 13,
++};
++
++// component identifiers, order is important
++enum {
++   COMPONENT_NULL                      = 0x00,
++   COMPONENT_OPENWSN                   = 0x01,
++   //cross-layers
++   COMPONENT_IDMANAGER                 = 0x02,
++   COMPONENT_OPENQUEUE                 = 0x03,
++   COMPONENT_OPENSERIAL                = 0x04,
++   COMPONENT_PACKETFUNCTIONS           = 0x05,
++   COMPONENT_RANDOM                    = 0x06,
++   //PHY
++   COMPONENT_RADIO                     = 0x07,
++   //MAClow
++   COMPONENT_IEEE802154                = 0x08,
++   COMPONENT_IEEE802154E               = 0x09,
++
++   // all components with higher component id than COMPONENT_IEEE802154E
++   // won't be able to get free packets from the queue
++   // when the mote is not synch
++
++   //MAClow<->MAChigh ("virtual components")
++   COMPONENT_SIXTOP_TO_IEEE802154E     = 0x0a,
++   COMPONENT_IEEE802154E_TO_SIXTOP     = 0x0b,
++   //MAChigh
++   COMPONENT_SIXTOP                    = 0x0c,
++   COMPONENT_NEIGHBORS                 = 0x0d,
++   COMPONENT_SCHEDULE                  = 0x0e,
++   COMPONENT_SIXTOP_RES                = 0x0f,
++   COMPONENT_MSF                       = 0x10,
++   //IPHC
++   COMPONENT_OPENBRIDGE                = 0x11,
++   COMPONENT_IPHC                      = 0x12,
++   COMPONENT_FRAG                      = 0x13,
++   //IPv6
++   COMPONENT_FORWARDING                = 0x14,
++   COMPONENT_ICMPv6                    = 0x15,
++   COMPONENT_ICMPv6ECHO                = 0x16,
++   COMPONENT_ICMPv6ROUTER              = 0x17,
++   COMPONENT_ICMPv6RPL                 = 0x18,
++   //TRAN
++   COMPONENT_UDP                       = 0x19,
++   COMPONENT_SOCK_TO_UDP               = 0x1a,
++   COMPONENT_UDP_TO_SOCK               = 0x1b,
++   COMPONENT_OPENCOAP                  = 0x1c,
++   // secure join
++   COMPONENT_CJOIN                     = 0x1d,
++   COMPONENT_OSCORE                    = 0x1e,
++   // applications
++   COMPONENT_C6T                       = 0x1f,
++   COMPONENT_CEXAMPLE                  = 0x20,
++   COMPONENT_CINFO                     = 0x21,
++   COMPONENT_CLEDS                     = 0x22,
++   COMPONENT_CSENSORS                  = 0x23,
++   COMPONENT_CSTORM                    = 0x24,
++   COMPONENT_CWELLKNOWN                = 0x25,
++   COMPONENT_UECHO                     = 0x26,
++   COMPONENT_UINJECT                   = 0x27,
++   COMPONENT_RRT                       = 0x28,
++   COMPONENT_SECURITY                  = 0x29,
++   COMPONENT_USERIALBRIDGE             = 0x2a,
++   COMPONENT_UEXPIRATION               = 0x2b,
++   COMPONENT_UMONITOR                  = 0x2c,
++   COMPONENT_CINFRARED                 = 0x2d,
++};
++
++/**
++\brief error codes used throughout the OpenWSN stack
++
++\note The comments are used in the Python parsing tool:
++   - {0} refers to the value of the first argument,
++   - {1} refers to the value of the second argument,
++*/
++enum {
++   // l7
++   ERR_JOINED                          = 0x01, // node joined
++   ERR_JOIN_REQUEST                    = 0x02, // sending CJOIN request
++   ERR_SEQUENCE_NUMBER_OVERFLOW        = 0x03, // OSCORE sequence number reached maximum value
++   ERR_REPLAY_FAILED                   = 0x04, // OSCORE replay protection failed
++   ERR_DECRYPTION_FAILED               = 0x05, // OSCORE decryption and tag verification failed
++   ERR_ABORT_JOIN_PROCESS              = 0x06, // Aborted join process (code location {0})
++   // l4
++   ERR_WRONG_TRAN_PROTOCOL             = 0x07, // unknown transport protocol {0} (code location {1})
++   ERR_UNSUPPORTED_PORT_NUMBER         = 0x08, // unsupported port number {0} (code location {1})
++   ERR_INVALID_CHECKSUM                = 0x09, // invalid checksum, expected 0x{:04x}, found 0x{:04x}
++   // l3a/b
++   ERR_RCVD_ECHO_REQUEST               = 0x0a, // received an echo request (length: {0})
++   ERR_RCVD_ECHO_REPLY                 = 0x0b, // received an echo reply
++   ERR_6LORH_DEADLINE_EXPIRED          = 0x0c, // the received packet has expired
++   ERR_6LORH_DEADLINE_DROPPED          = 0x0d, // packet expiry time reached, dropped
++   ERR_UNEXPECTED_DAO                  = 0x0e, // unexpected DAO (code location {0}). A change maybe happened on dagroot node.
++   ERR_UNSUPPORTED_ICMPV6_TYPE         = 0x0f, // unsupported ICMPv6 type {0} (code location {1})
++   ERR_6LOWPAN_UNSUPPORTED             = 0x10, // unsupported 6LoWPAN parameter {1} at location {0}, dropping packet
++   ERR_NO_NEXTHOP                      = 0x11, // no next hop for layer 3 destination {0:x}{1:x}
++   ERR_INVALID_FWDMODE                 = 0x12, // invalid forward mode
++   ERR_LARGE_DAGRANK                   = 0x13, // large DAGrank {0}, set to {1}
++   ERR_HOP_LIMIT_REACHED               = 0x14, // packet discarded hop limit reached
++   ERR_LOOP_DETECTED                   = 0x15, // loop detected due to previous rank {0} lower than current node rank {1}
++   ERR_WRONG_DIRECTION                 = 0x16, // upstream packet set to be downstream, possible loop.
++   ERR_FORWARDING_PACKET_DROPPED       = 0x17, // packet to forward is dropped (code location {0})
++   ERR_FRAG_INVALID_SIZE               = 0x19, // invalid original packet size ({0} > {1})
++   ERR_FRAG_REASSEMBLED                = 0x1a, // reassembled fragments into big packet (size: {0}, tag: {1})
++   ERR_FRAG_FAST_FORWARD               = 0x1b, // fast-forwarded all fragments with tag {0} (total size: {1})
++   ERR_FRAG_STORED                     = 0x1c, // stored a fragment with offset {0} (currently in buffer: {1})
++   ERR_FRAG_REASSEMBLY_OR_VRB_TIMEOUT  = 0x1d, // reassembly or vrb timer expired for fragments with tag {0}
++   ERR_FRAG_FRAGMENTING                = 0x1e, // fragmenting a big packet, original size {0}, number of fragments {1}
++   ERR_BRIDGE_MISMATCH                 = 0x1f, // bridge mismatch (code location {0})
++   // l2b
++   ERR_SCHEDULE_ADD_DUPLICATE_SLOT     = 0x20, // the slot {0} to be added is already in schedule
++   ERR_NEIGHBORS_FULL                  = 0x21, // neighbors table is full (max number of neighbor is {0})
++   ERR_NO_SENT_PACKET                  = 0x22, // there is no sent packet in queue
++   ERR_NO_RECEIVED_PACKET              = 0x23, // there is no received packet in queue
++   ERR_SCHEDULE_OVERFLOWN              = 0x24, // schedule overflown
++   ERR_SIXTOP_RETURNCODE               = 0x25, // sixtop return code {0} at sixtop state {1}
++   ERR_SIXTOP_REQUEST                  = 0x26, // sending a 6top request
++   ERR_SIXTOP_COUNT                    = 0x27, // there are {0} cells to request mote
++   ERR_SIXTOP_LIST                     = 0x28, // the cells reserved to request mote contains slot {0} and slot {1}
++   ERR_UNSUPPORTED_FORMAT              = 0x29, // the received packet format is not supported (code location {0})
++   ERR_UNSUPPORTED_METADATA            = 0x2a, // the metadata type is not suppored
++   ERR_TX_CELL_USAGE                   = 0x2b, // TX cell usage during last period: {}
++   ERR_RX_CELL_USAGE                   = 0x2c, // RX cell usage during last period: {}
++   // l2a
++   ERR_WRONG_CELLTYPE                  = 0x2d, // wrong celltype {0} at slotOffset {1}
++   ERR_IEEE154_UNSUPPORTED             = 0x2e, // unsupported IEEE802.15.4 parameter {1} at location {0}
++   ERR_DESYNCHRONIZED                  = 0x2f, // got desynchronized at slotOffset {0}
++   ERR_SYNCHRONIZED                    = 0x30, // synchronized at slotOffset {0}
++   ERR_LARGE_TIMECORRECTION            = 0x31, // large timeCorr.: {0} ticks (code loc. {1})
++   ERR_WRONG_STATE_IN_ENDFRAME_SYNC    = 0x32, // wrong state {0} in end of frame+sync
++   ERR_WRONG_STATE_IN_STARTSLOT        = 0x33, // wrong state {0} in startSlot, at slotOffset {1}
++   ERR_WRONG_STATE_IN_TIMERFIRES       = 0x34, // wrong state {0} in timer fires, at slotOffset {1}
++   ERR_WRONG_STATE_IN_NEWSLOT          = 0x35, // wrong state {0} in start of frame, at slotOffset {1}
++   ERR_WRONG_STATE_IN_ENDOFFRAME       = 0x36, // wrong state {0} in end of frame, at slotOffset {1}
++   ERR_MAXTXDATAPREPARE_OVERFLOW       = 0x37, // maxTxDataPrepare overflows while at state {0} in slotOffset {1}
++   ERR_MAXRXACKPREPARE_OVERFLOWS       = 0x38, // maxRxAckPrepapare overflows while at state {0} in slotOffset {1}
++   ERR_MAXRXDATAPREPARE_OVERFLOWS      = 0x39, // maxRxDataPrepapre overflows while at state {0} in slotOffset {1}
++   ERR_MAXTXACKPREPARE_OVERFLOWS       = 0x3a, // maxTxAckPrepapre overflows while at state {0} in slotOffset {1}
++   ERR_WDDATADURATION_OVERFLOWS        = 0x3b, // wdDataDuration overflows while at state {0} in slotOffset {1}
++   ERR_WDRADIO_OVERFLOWS               = 0x3c, // wdRadio overflows while at state {0} in slotOffset {1}
++   ERR_WDRADIOTX_OVERFLOWS             = 0x3d, // wdRadioTx overflows while at state {0} in slotOffset {1}
++   ERR_WDACKDURATION_OVERFLOWS         = 0x3e, // wdAckDuration overflows while at state {0} in slotOffset {1}
++   ERR_SECURITY                        = 0x3f, // security error on frameType {0}, code location {1}
++   ERR_INVALID_PACKET_FROM_RADIO       = 0x40, // invalid packet from radio
++   // drivers
++   ERR_GETDATA_ASKS_TOO_FEW_BYTES      = 0x41, // getData asks for too few bytes, maxNumBytes={0}, fill level={1}
++   ERR_WRONG_CRC_INPUT                 = 0x42, // wrong CRC in input Buffer
++   // cross layer
++   ERR_BUFFER_OVERFLOW                 = 0x43, // buffer overflow detected (code location {0})
++   ERR_BUSY_SENDING                    = 0x44, // busy sending
++   ERR_UNEXPECTED_SENDDONE             = 0x45, // sendDone for packet I didn't send
++   ERR_NO_FREE_PACKET_BUFFER           = 0x46, // no free packet buffer (code location {0})
++   ERR_NO_FREE_TIMER_OR_QUEUE_ENTRY    = 0x47, // no free timer or queue entry (code location {0})
++   ERR_FREEING_UNUSED                  = 0x48, // freeing unused memory
++   ERR_FREEING_ERROR                   = 0x49, // freeing memory unsupported memory
++   ERR_MSG_UNKNOWN_TYPE                = 0x4a, // unknown message type {0}
++   ERR_WRONG_ADDR_TYPE                 = 0x4b, // wrong address type {0} (code location {1})
++   ERR_PACKET_TOO_LONG                 = 0x4c, // total packet size is too long, length {0} (adding {1} bytes)
++   ERR_PACKET_TOO_SHORT                = 0x4d, // total packet size is too short, length {0} (removing {1} bytes)
++   ERR_INPUTBUFFER_LENGTH              = 0x4e, // input length problem, length={0}
++   ERR_BOOTED                          = 0x4f, // booted
++   ERR_MAXRETRIES_REACHED              = 0x50, // maxretries reached (counter: {0})
++   ERR_EMPTY_QUEUE_OR_UNKNOWN_TIMER    = 0x51, // empty queue or trying to remove unknown timer id (code location {0})
++   ERR_PUSH_LOWER_LAYER                = 0x52, // failed to push to lower layer
++   ERR_INVALID_PARAM                   = 0x53, // received an invalid parameter
++   ERR_COPY_TO_SPKT                    = 0x54, // copy packet content to small packet (pkt len {} < max len {})
++   ERR_COPY_TO_BPKT                    = 0x55, // copy packet content to big packet (pkt len {} > max len {})
++};
++
++//=========================== typedef =========================================
++
++
++typedef uint16_t errorparameter_t;
++typedef uint16_t dagrank_t;
++typedef uint8_t owerror_t;
++
++BEGIN_PACK
++typedef struct {
++    uint8_t byte4;
++    uint16_t bytes2and3;
++    uint16_t bytes0and1;
++} asn_t;
++END_PACK
++
++typedef asn_t
++macFrameCounter_t;
++
++BEGIN_PACK
++
++typedef struct {
++    bool isUsed;
++    uint16_t slotoffset;
++    uint16_t channeloffset;
++} cellInfo_ht;
++
++typedef struct {  // always written big endian, i.e. MSB in addr[0]
++    uint8_t type;
++    union {
++        uint8_t addr_16b[2];
++        uint8_t addr_64b[8];
++        uint8_t addr_128b[16];
++        uint8_t panid[2];
++        uint8_t prefix[8];
++    };
++} open_addr_t;
++END_PACK
++
++typedef struct {
++   //admin
++   uint8_t       creator;                                       // the component which called getFreePacketBuffer()
++   uint8_t       owner;                                         // the component which currently owns the entry
++   uint8_t*      payload;                                       // pointer to the start of the payload within 'packet'
++   int16_t       length;                                        // length in bytes of the payload
++   //l7
++#if DEADLINE_OPTION
++   uint16_t      max_delay;                                     // Max delay in milliseconds before which the packet should be delivered to the receiver
++   bool          orgination_time_flag;
++   bool          drop_flag;
++#endif
++   bool          is_cjoin_response;
++#if OPENWSN_6LO_FRAGMENTATION_C
++   bool          is_big_packet;
++#endif
++
++   //l4
++   uint8_t       l4_protocol;                                   // l4 protocol to be used
++   bool          l4_protocol_compressed;                        // is the l4 protocol header compressed?
++   uint16_t      l4_sourcePortORicmpv6Type;                     // l4 source port
++   uint16_t      l4_destination_port;                           // l4 destination port
++   uint8_t*      l4_payload;                                    // pointer to the start of the payload of l4 (used for retransmits)
++   uint8_t       l4_length;                                     // length of the payload of l4 (used for retransmits)
++
++   //l3
++   open_addr_t   l3_destinationAdd;                             // 128b IPv6 destination (down stack)
++   open_addr_t   l3_sourceAdd;                                  // 128b IPv6 source address
++   bool          l3_useSourceRouting;                           // TRUE when the packet goes downstream
++
++#if OPENWSN_6LO_FRAGMENTATION_C
++    bool         l3_isFragment;
++#endif
++    //l2
++    owerror_t l2_sendDoneError;                                // outcome of trying to send this packet
++    open_addr_t l2_nextORpreviousHop;                          // 64b IEEE802.15.4 next (down stack) or previous (up) hop address
++    uint8_t l2_frameType;                                      // beacon, data, ack, cmd
++    uint8_t l2_dsn;                                            // sequence number of the received frame
++    uint8_t l2_retriesLeft;                                    // number Tx retries left before packet dropped (dropped when hits 0)
++    uint8_t l2_numTxAttempts;                                  // number Tx attempts
++    asn_t l2_asn;                                              // at what ASN the packet was Tx'ed or Rx'ed
++    uint8_t *l2_payload;                                       // pointer to the start of the payload of l2 (used for MAC to fill in ASN in ADV)
++    cellInfo_ht l2_sixtop_celllist_add[CELLLIST_MAX_LEN];      // record celllist to be added and will be added when 6P response sendDone
++    cellInfo_ht l2_sixtop_celllist_delete[CELLLIST_MAX_LEN];   // record celllist to be removed and will be removed when 6P response sendDone
++    uint16_t l2_sixtop_frameID;                                // frameID in 6P message
++    uint8_t l2_sixtop_messageType;                             // indicating the sixtop message type
++    uint8_t l2_sixtop_command;                                 // command of the received 6p request, recorded in 6p response
++    uint8_t l2_sixtop_cellOptions;                             // celloptions, used when 6p response senddone. (it's the same with cellOptions in 6p request but with TX and RX bits have been flipped)
++    uint8_t l2_sixtop_returnCode;                              // return code in 6P response
++    uint8_t *l2_ASNpayload;                                    // pointer to the ASN in EB
++    uint8_t *l2_nextHop_payload;                               // pointer to the nexthop address in frame
++    uint8_t l2_joinPriority;                                   // the join priority received in EB
++    bool l2_IEListPresent;                                     // did have IE field?
++    bool l2_payloadIEpresent;                                  // did I have payload IE field
++    bool l2_joinPriorityPresent;
++    bool l2_isNegativeACK;                                     // is the negative ACK?
++    int16_t l2_timeCorrection;                                 // record the timeCorrection and print out at endOfslot
++    bool l2_sendOnTxCell;                                      // mark the frame is sent on txCell
++    //layer-2 security
++    uint8_t l2_securityLevel;                                  // the security level specified for the current frame
++    uint8_t l2_keyIdMode;                                      // the key Identifier mode specified for the current frame
++    uint8_t l2_keyIndex;                                       // the key Index specified for the current frame
++    open_addr_t l2_keySource;                                  // the key Source specified for the current frame
++    uint8_t l2_authenticationLength;                           // the length of the authentication field
++    uint8_t commandFrameIdentifier;                            // used in case of Command Frames
++    uint8_t *l2_FrameCounter;                                  // pointer to the FrameCounter in the MAC header
++    //l1 (drivers)
++    uint8_t l1_txPower;                                        // power for packet to Tx at
++    int8_t l1_rssi;                                            // RSSI of received packet
++    uint8_t l1_lqi;                                            // LQI of received packet
++    bool l1_crc;                                               // did received packet pass CRC check?
++    //the packet
++    uint8_t packet[1 + 1 + 125 + 2 + 1];                       // 1B spi address, 1B length, 125B data, 2B CRC, 1B LQI
++} OpenQueueEntry_t;
++
++
++#if OPENWSN_6LO_FRAGMENTATION_C
++typedef struct {
++    OpenQueueEntry_t standard_entry;
++    // 130 bytes alread allocated in the normal OpenQueueEntry
++    uint8_t packet_remainder[IPV6_PACKET_SIZE - 130];
++} OpenQueueBigEntry_t;
++#endif
++
++
++BEGIN_PACK
++typedef struct {
++    bool used;
++    bool insecure;
++    uint8_t parentPreference;
++    bool stableNeighbor;
++    uint8_t switchStabilityCounter;
++    open_addr_t addr_64b;
++    dagrank_t DAGrank;
++    int8_t rssi;
++    uint8_t numRx;
++    uint8_t numTx;
++    uint8_t numTxACK;
++    uint8_t numWraps; // number of times the tx counter wraps. can be removed if memory is a restriction. also check openvisualizer then.
++    asn_t asn;
++    uint8_t joinPrio;
++    bool f6PNORES;
++    uint8_t sequenceNumber;
++    uint8_t backoffExponenton;
++    uint8_t backoff;
++} neighborRow_t;
++END_PACK
++
++
++//=========================== variables =======================================
++
++//=========================== prototypes ======================================
++
++#endif /* OPENWSN_OPENDEFS_H */
+diff --git a/projects/nrf52840_dk/radio.c b/projects/nrf52840_dk/radio.c
+new file mode 100644
+index 00000000..42831fac
+--- /dev/null
++++ b/projects/nrf52840_dk/radio.c
+@@ -0,0 +1,517 @@
++/**
++ * brief Nordic nRF52840-specific definition of the "radio" bsp module. 
++ *
++ * Authors: Tamas Harczos (1, tamas.harczos@imms.de) and Adam Sedmak (2, adam.sedmak@gmail.com)
++ * Company: (1) Institut fuer Mikroelektronik- und Mechatronik-Systeme gemeinnuetzige GmbH (IMMS GmbH)
++ *          (2) Faculty of Electronics and Computing, Zagreb, Croatia
++ *    Date: June 2018
++*/
++
++#include "nrf52840.h"
++#include "nrf52840_bitfields.h"
++#include "board_info.h"
++#include "sctimer.h"
++#include "debugpins.h"
++#include "leds.h"
++#include "radio.h"
++
++
++//=========================== defines =========================================
++
++#define RADIO_POWER_POWER_POS       0
++
++#define STATE_DISABLED              0
++#define STATE_RXRU                  1
++#define STATE_RXIDLE                2
++#define STATE_RX                    3
++#define STATE_RXDISABLE             4
++#define STATE_TXTU                  9
++#define STATE_TXIDLE                10
++#define STATE_TX                    11
++#define STATE_TXDIABLE              12
++
++/* For calculating frequency */
++#define FREQUENCY_OFFSET  10
++#define FREQUENCY_STEP    5
++
++#define SFD_OCTET                 (0xA7)      ///< start of frame delimiter of IEEE 802.15.4
++#define MAX_PACKET_SIZE           (127)       ///< maximal size of radio packet (one more byte at the beginning needed to store the length)
++#define CRC_POLYNOMIAL            (0x11021)   ///< polynomial used for CRC calculation in 802.15.4 frames (x^16 + x^12 + x^5 + 1)
++
++#define WAIT_FOR_RADIO_DISABLE    (0)         ///< whether the driver shall wait until the radio is disabled upon calling radio_rfOff()
++#define WAIT_FOR_RADIO_ENABLE     (1)         ///< whether the driver shall wait until the radio is enabled upon calling radio_txEnable() or radio_rxEnable()
++
++#define RADIO_CRCINIT_24BIT       0x555555
++#define RADIO_CRCPOLY_24BIT       0x0000065B  /// ref: https://devzone.nordicsemi.com/f/nordic-q-a/44111/crc-register-values-for-a-24-bit-crc
++
++#define MAX_PAYLOAD_LENGTH        (127)
++#define INTERFRAM_SPACING         (150)       // in us
++
++#define BLE_ACCESS_ADDR           0x8E89BED6  // the actual address is 0xD6, 0xBE, 0x89, 0x8E
++
++//=========================== variables =======================================
++
++typedef struct {
++    radio_capture_cbt   startFrame_cb;
++    radio_capture_cbt   endFrame_cb;
++    radio_state_t       state; 
++    uint8_t             payload[1+MAX_PACKET_SIZE] __attribute__ ((aligned));
++    int8_t              rssi_sample;
++//  volatile bool event_ready;
++} radio_vars_t;
++
++static radio_vars_t radio_vars;
++
++//=========================== prototypes ======================================
++
++static uint32_t swap_bits(uint32_t inp);
++static uint32_t bytewise_bitswap(uint32_t inp);
++static uint8_t  ble_channel_to_frequency(uint8_t channel);
++
++static void hfclock_start(void);
++static void hfclock_stop(void);
++
++
++//=========================== public ==========================================
++
++
++void radio_init(void) {
++
++    // clear internal variables
++    memset(&radio_vars, 0, sizeof(radio_vars));
++
++    // set radio configuration parameters
++    NRF_RADIO->TXPOWER   = (RADIO_TXPOWER_TXPOWER_Pos4dBm << RADIO_TXPOWER_TXPOWER_Pos);
++
++    // set radio mode to IEEE 802.15.4
++    NRF_RADIO->MODE      = (RADIO_MODE_MODE_Ieee802154_250Kbit << RADIO_MODE_MODE_Pos);
++
++    // set config field length to 8
++    NRF_RADIO->PCNF0 &= (~RADIO_PCNF0_LFLEN_Msk);
++    NRF_RADIO->PCNF0 |= (((uint32_t)8) << RADIO_PCNF0_LFLEN_Pos);
++
++    // set 32-bit zero preamble
++    NRF_RADIO->PCNF0 &= (~RADIO_PCNF0_PLEN_Msk);
++    NRF_RADIO->PCNF0 |= ((uint32_t) RADIO_PCNF0_PLEN_32bitZero << RADIO_PCNF0_PLEN_Pos);
++
++    // set max packet size
++    NRF_RADIO->PCNF1 &= (~RADIO_PCNF1_MAXLEN_Msk);
++    NRF_RADIO->PCNF1 |= ((uint32_t) MAX_PACKET_SIZE << RADIO_PCNF1_MAXLEN_Pos);
++
++    // set start of frame delimiter
++    NRF_RADIO->SFD = (SFD_OCTET << RADIO_SFD_SFD_Pos) & RADIO_SFD_SFD_Msk;
++
++    // set CRC to be included
++    NRF_RADIO->PCNF0 &= (~RADIO_PCNF0_CRCINC_Msk);
++    NRF_RADIO->PCNF0 |= ((uint32_t) RADIO_PCNF0_CRCINC_Include << RADIO_PCNF0_CRCINC_Pos);
++
++    // set CRC length
++    NRF_RADIO->CRCCNF &= (~RADIO_CRCCNF_LEN_Msk);
++    NRF_RADIO->CRCCNF |= ((uint32_t) LENGTH_CRC << RADIO_CRCCNF_LEN_Pos);
++
++    // configure CRC (CRC calculation as per 802.15.4 standard. Starting at first byte after length field.)
++    NRF_RADIO->CRCCNF &= (~RADIO_CRCCNF_SKIPADDR_Msk);
++    NRF_RADIO->CRCCNF |= ((uint32_t) RADIO_CRCCNF_SKIPADDR_Ieee802154 << RADIO_CRCCNF_SKIPADDR_Pos);
++
++    // set CRC polynomial
++    NRF_RADIO->CRCPOLY = (CRC_POLYNOMIAL << RADIO_CRCPOLY_CRCPOLY_Pos);
++    NRF_RADIO->CRCINIT = 0x0UL;
++
++    // set payload pointer
++    NRF_RADIO->PACKETPTR = (uint32_t)(radio_vars.payload);
++
++    // set up interrupts
++    // disable radio interrupt
++    NVIC_DisableIRQ(RADIO_IRQn);
++
++    NRF_RADIO->INTENSET = (RADIO_INTENSET_FRAMESTART_Enabled << RADIO_INTENSET_FRAMESTART_Pos) |
++                          (RADIO_INTENSET_END_Enabled        << RADIO_INTENSET_END_Pos); 
++
++    NVIC_SetPriority(RADIO_IRQn, RADIO_PRIORITY);
++
++    NVIC_ClearPendingIRQ(RADIO_IRQn);
++    NVIC_EnableIRQ(RADIO_IRQn);
++}
++
++void radio_ble_init(void){
++    
++    NRF_RADIO->PCNF0 =   (((1UL) << RADIO_PCNF0_S0LEN_Pos) & RADIO_PCNF0_S0LEN_Msk) | 
++                         (((0UL) << RADIO_PCNF0_S1LEN_Pos) & RADIO_PCNF0_S1LEN_Msk) |
++                         (((8UL) << RADIO_PCNF0_LFLEN_Pos) & RADIO_PCNF0_LFLEN_Msk);
++
++    NRF_RADIO->PCNF1 =   (((RADIO_PCNF1_ENDIAN_Little)    << RADIO_PCNF1_ENDIAN_Pos)  & RADIO_PCNF1_ENDIAN_Msk)  |
++                         (((3UL)                          << RADIO_PCNF1_BALEN_Pos)   & RADIO_PCNF1_BALEN_Msk)   |
++                         (((0UL)                          << RADIO_PCNF1_STATLEN_Pos) & RADIO_PCNF1_STATLEN_Msk) |
++                         ((((uint32_t)MAX_PAYLOAD_LENGTH) << RADIO_PCNF1_MAXLEN_Pos)  & RADIO_PCNF1_MAXLEN_Msk)  |
++                         ((RADIO_PCNF1_WHITEEN_Enabled    << RADIO_PCNF1_WHITEEN_Pos) & RADIO_PCNF1_WHITEEN_Msk);
++    
++    NRF_RADIO->CRCPOLY      = RADIO_CRCPOLY_24BIT;
++    NRF_RADIO->CRCCNF       = (
++                                ((RADIO_CRCCNF_SKIPADDR_Skip) << RADIO_CRCCNF_SKIPADDR_Pos) & RADIO_CRCCNF_SKIPADDR_Msk) |
++                                (((RADIO_CRCCNF_LEN_Three)    << RADIO_CRCCNF_LEN_Pos)      & RADIO_CRCCNF_LEN_Msk
++                              );
++    NRF_RADIO->CRCINIT      = RADIO_CRCINIT_24BIT;
++
++    NRF_RADIO->TXADDRESS    = 0;
++    NRF_RADIO->RXADDRESSES  = 1;
++
++    NRF_RADIO->MODE         = ((RADIO_MODE_MODE_Ble_1Mbit) << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
++    NRF_RADIO->TIFS         = INTERFRAM_SPACING;
++    NRF_RADIO->PREFIX0      = ((BLE_ACCESS_ADDR & 0xff000000) >> 24);
++    NRF_RADIO->BASE0        = ((BLE_ACCESS_ADDR & 0x00ffffff) << 8 );
++}
++
++
++void radio_setStartFrameCb(radio_capture_cbt cb) {
++
++    radio_vars.startFrame_cb  = cb;
++}
++
++
++void radio_setEndFrameCb(radio_capture_cbt cb) {
++
++    radio_vars.endFrame_cb = cb;
++}
++
++
++void radio_reset(void) {
++
++    // reset is implemented by power off and power radio
++    NRF_RADIO->POWER = ((uint32_t)(0)) << RADIO_POWER_POWER_POS;
++    NRF_RADIO->POWER = ((uint32_t)(1)) << RADIO_POWER_POWER_POS;
++
++    radio_vars.state  = RADIOSTATE_STOPPED;
++}
++
++
++void radio_setFrequency(uint8_t frequency, radio_freq_t tx_or_rx) {
++
++    NRF_RADIO->FREQUENCY = FREQUENCY_STEP*(frequency-FREQUENCY_OFFSET);
++
++    radio_vars.state     = RADIOSTATE_FREQUENCY_SET;
++}
++
++void radio_ble_setFrequency(uint8_t channel) {
++
++    NRF_RADIO->FREQUENCY   = ble_channel_to_frequency(channel);
++    NRF_RADIO->DATAWHITEIV = channel; 
++
++    radio_vars.state  = RADIOSTATE_FREQUENCY_SET;
++}
++
++int8_t radio_getFrequencyOffset(void){
++  
++    return 0; 
++}
++
++
++void radio_rfOn(void) {
++    // power on radio
++    NRF_RADIO->POWER = ((uint32_t)(1)) << 0;
++
++    radio_vars.state = RADIOSTATE_STOPPED;
++}
++
++
++void radio_rfOff(void) {
++
++    radio_vars.state  = RADIOSTATE_TURNING_OFF;
++
++    NRF_RADIO->EVENTS_DISABLED = 0;
++
++    // stop radio
++    NRF_RADIO->TASKS_DISABLE = (uint32_t)(1);
++
++    while(NRF_RADIO->EVENTS_DISABLED==0);
++
++    leds_radio_off();
++    debugpins_radio_clr();
++
++    radio_vars.state  = RADIOSTATE_RFOFF;
++}
++
++
++void radio_loadPacket(uint8_t* packet, uint16_t len) {
++
++    radio_vars.state  = RADIOSTATE_LOADING_PACKET;
++
++    ///< note: 1st byte should be the payload size (for Nordic), and
++    ///   the two last bytes are used by the MAC layer for CRC
++    if ((len > 0) && (len <= MAX_PACKET_SIZE)) {
++        radio_vars.payload[0]= len;
++        memcpy(&radio_vars.payload[1], packet, len);
++    }
++
++    // (re)set payload pointer
++    NRF_RADIO->PACKETPTR = (uint32_t)(radio_vars.payload);
++
++    radio_vars.state  = RADIOSTATE_PACKET_LOADED;
++}
++
++void radio_ble_loadPacket(uint8_t* packet, uint16_t len) {
++    radio_vars.state  = RADIOSTATE_LOADING_PACKET;
++
++    ///< note: 1st byte should be the payload size (for Nordic), and
++    ///   the two last bytes are used by the MAC layer for CRC
++    if ((len > 0) && (len <= MAX_PACKET_SIZE)) {
++        memcpy(&radio_vars.payload[0], packet, len);
++    }
++
++    // (re)set payload pointer
++    NRF_RADIO->PACKETPTR = (uint32_t)(radio_vars.payload);
++
++    radio_vars.state  = RADIOSTATE_PACKET_LOADED;
++}
++
++
++void radio_txEnable(void) {
++
++    radio_vars.state  = RADIOSTATE_ENABLING_TX;
++
++    NRF_RADIO->EVENTS_READY = (uint32_t)0;
++
++    NRF_RADIO->TASKS_TXEN = (uint32_t)1;
++    while(NRF_RADIO->EVENTS_READY==0);
++
++    // wiggle debug pin
++    debugpins_radio_set();
++    leds_radio_on();
++
++    radio_vars.state  = RADIOSTATE_TX_ENABLED;
++}
++
++
++void radio_txNow(void) {
++
++    NRF_RADIO->TASKS_START = (uint32_t)1;
++
++    radio_vars.state = RADIOSTATE_TRANSMITTING;
++}
++
++
++void radio_rxEnable(void) {
++
++    radio_vars.state = RADIOSTATE_ENABLING_RX;
++
++    if (NRF_RADIO->STATE != STATE_RX) {
++
++        // turn off radio first
++        radio_rfOff();
++
++        NRF_RADIO->EVENTS_READY = (uint32_t)0;
++
++        NRF_RADIO->TASKS_RXEN  = (uint32_t)1;
++
++        while(NRF_RADIO->EVENTS_READY==0);
++    }
++}
++
++
++void radio_rxNow(void) {
++
++    NRF_RADIO->TASKS_START = (uint32_t)1;
++
++    debugpins_radio_set();
++    leds_radio_on();
++
++    radio_vars.state  = RADIOSTATE_LISTENING;
++}
++
++
++void radio_getReceivedFrame(uint8_t* pBufRead,
++                            uint8_t* pLenRead,
++                            uint8_t  maxBufLen,
++                             int8_t* pRssi,
++                            uint8_t* pLqi,
++                               bool* pCrc)
++{
++    // check for length parameter; if too long, payload won't fit into memory
++    uint8_t len;
++
++    len = radio_vars.payload[0];
++
++    if (len == 0) {
++        return; 
++    }
++
++    if (len > MAX_PACKET_SIZE) { 
++        len = MAX_PACKET_SIZE; 
++    }
++
++    if (len > maxBufLen) { 
++        len = maxBufLen; 
++    }
++
++    // copy payload
++    memcpy(pBufRead, &radio_vars.payload[1], len);
++
++    // store other parameters
++    *pLenRead = len;
++    *pLqi = radio_vars.payload[radio_vars.payload[0]-1];
++
++    *pRssi = (int8_t)(0-NRF_RADIO->RSSISAMPLE);
++
++    *pCrc = (NRF_RADIO->CRCSTATUS == 1U);
++}
++
++void radio_ble_getReceivedFrame(uint8_t* pBufRead,
++                        uint8_t* pLenRead,
++                        uint8_t  maxBufLen,
++                         int8_t* pRssi,
++                        uint8_t* pLqi,
++                           bool* pCrc) 
++{
++    // check for length parameter; if too long, payload won't fit into memory
++    uint8_t len;
++
++    len = radio_vars.payload[1];
++
++    if (len == 0) {
++        return; 
++    }
++
++    if (len > MAX_PACKET_SIZE) {
++        len = MAX_PACKET_SIZE; 
++    }
++
++    if (len > maxBufLen) {
++        len = maxBufLen; 
++    }
++
++    // copy payload
++    memcpy(pBufRead, &radio_vars.payload[0], len+2);
++
++    // store other parameters
++    *pLenRead = len+2;
++
++    *pCrc = (NRF_RADIO->CRCSTATUS == 1U);
++
++}
++
++
++//=========================== private =========================================
++
++static uint32_t swap_bits(uint32_t inp) {
++
++    uint32_t i;
++    uint32_t retval = 0;
++
++    inp = (inp & 0x000000FFUL);
++
++    for (i = 0; i < 8; i++) {
++        retval |= ((inp >> i) & 0x01) << (7 - i);
++    }
++
++    return retval;
++}
++
++
++static uint32_t bytewise_bitswap(uint32_t inp) {
++
++    return (swap_bits(inp >> 24) << 24)
++          | (swap_bits(inp >> 16) << 16)
++          | (swap_bits(inp >> 8) << 8)
++          | (swap_bits(inp));
++}
++
++static uint8_t ble_channel_to_frequency(uint8_t channel) {
++
++    uint8_t frequency;
++    
++    if (channel<=10) {
++
++        frequency = 4+2*channel;
++    } else {
++        if (channel >=11 && channel <=36) {
++            
++            frequency = 28+2*(channel-11);
++        } else {
++            switch(channel){
++                case 37:
++                    frequency = 2;
++                break;
++                case 38:
++                    frequency = 26;
++                break;
++                case 39:
++                    frequency = 80;
++                break;
++                default:
++                    // something goes wrong
++                    frequency = 2;
++
++            }
++        }
++    }
++
++    return frequency;
++}
++
++static void hfclock_start(void) {
++    
++    NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
++    NRF_CLOCK->TASKS_HFCLKSTART    = 1;
++    while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0);
++}
++
++static void hfclock_stop(void) {
++    
++    // check clock source
++    if((NRF_CLOCK->HFCLKSTAT & 0x00000001) != 0) {
++        
++        // clock running?
++        if((NRF_CLOCK->HFCLKSTAT & 0x00010000) != 0) {
++            
++            NRF_CLOCK->TASKS_HFCLKSTOP = 1;
++            while((NRF_CLOCK->HFCLKSTAT & 0x00000001) != 0);
++        }
++    }
++}
++
++//=========================== callbacks =======================================
++
++
++kick_scheduler_t radio_isr(void){
++
++    uint32_t time_stampe;
++
++    time_stampe = NRF_RTC0->COUNTER;
++
++    // start of frame (payload)
++    if (NRF_RADIO->EVENTS_FRAMESTART){
++
++        // start sampling rssi
++        NRF_RADIO->TASKS_RSSISTART = (uint32_t)1;
++
++        if (radio_vars.startFrame_cb!=NULL){
++            radio_vars.startFrame_cb(time_stampe);
++        }
++        
++        NRF_RADIO->EVENTS_FRAMESTART = (uint32_t)0;
++        return KICK_SCHEDULER;
++    }
++
++    // END 
++    if (NRF_RADIO->EVENTS_END) {
++
++        if (radio_vars.endFrame_cb!=NULL){
++            radio_vars.endFrame_cb(time_stampe);
++        }
++        
++        NRF_RADIO->EVENTS_END = (uint32_t)0;
++        return KICK_SCHEDULER;
++    }
++
++    return DO_NOT_KICK_SCHEDULER;
++}
++
++//=========================== interrupt handlers ==============================
++
++void RADIO_IRQHandler(void) {
++
++    debugpins_isr_set();
++
++    radio_isr();
++
++    debugpins_isr_clr();
++}
+diff --git a/projects/nrf52840_dk/sctimer.c b/projects/nrf52840_dk/sctimer.c
+new file mode 100644
+index 00000000..244294b6
+--- /dev/null
++++ b/projects/nrf52840_dk/sctimer.c
+@@ -0,0 +1,164 @@
++/**
++ * brief A timer module with only a single compare value. 
++ *
++ * Authors: Tamas Harczos (1, tamas.harczos@imms.de) and Adam Sedmak (2, adam.sedmak@gmail.com)
++ * Company: (1) Institut fuer Mikroelektronik- und Mechatronik-Systeme gemeinnuetzige GmbH (IMMS GmbH)
++ *          (2) Faculty of Electronics and Computing, Zagreb, Croatia
++ *    Date: May 2018
++ *
++ *    Note: We use RTC0 peripheral with its CC0 register.
++*/
++
++#include "nrf52840.h"
++#include "sctimer.h"
++#include "debugpins.h"
++
++// ========================== define ==========================================
++
++#define LFCLKSRC_SRC_POS      0
++#define LFCLKSRC_BYPASS_POS   16
++#define LFCLKSRC_EXTERNAL_POS 17
++
++#define LFCLKSTAT_SRC_POS     0
++#define LFCLKSTAT_STATE_POS   16
++
++#define MINIMUM_ISR_ADVANCE         5        // nRF52840_PS_v1.7 (page 370)
++#define TIMERLOOP_THRESHOLD         0xffff 
++#define TIMERMASK                   0xffffff
++
++// ========================== variable ========================================
++
++typedef struct {
++    sctimer_cbt         cb;
++    uint8_t             lastFireMode;
++} sctimer_vars_t;
++
++sctimer_vars_t sctimer_vars= {0};
++
++// ========================== prototypes========================================
++
++// ========================== protocol =========================================
++
++/**
++\brief Initialization sctimer.
++*/
++void sctimer_init(void) {
++
++    memset(&sctimer_vars, 0, sizeof(sctimer_vars_t));
++
++    NVIC->IP[RTC0_IRQn]         = (uint8_t)((RTC_PRIORITY << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFF);
++    NVIC->ISER[RTC0_IRQn>>5]    = (uint32_t)(0x1 << (RTC0_IRQn & 0x1f));
++
++    // stop LFCLK
++    NRF_CLOCK->TASKS_LFCLKSTOP     = 1;
++    while((NRF_CLOCK->LFCLKSTAT & (1<<LFCLKSTAT_STATE_POS)) == 1);
++    
++    // configure prescaler
++    NRF_RTC0->PRESCALER         = 0;
++
++    // configure the source
++    NRF_CLOCK->LFCLKSRC = (1<<LFCLKSRC_SRC_POS);
++
++    // start LFCLK
++    NRF_CLOCK->TASKS_LFCLKSTART = (uint32_t)1;
++    while((NRF_CLOCK->LFCLKSTAT & (1<<LFCLKSTAT_STATE_POS)) == 0);
++
++
++    // enable compare 0 1, and 2
++    NRF_RTC0->EVENTS_COMPARE[0] = 0;
++    NRF_RTC0->INTENSET          = 0x1<<16;
++
++    NRF_RTC0->TASKS_START       = 1;
++
++    NVIC->IP[SWI0_EGU0_IRQn]         = (uint8_t)((RTC_PRIORITY << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFF);
++    NVIC->ISER[SWI0_EGU0_IRQn>>5]    = (uint32_t)(0x1 << (SWI0_EGU0_IRQn & 0x1f));
++
++    // configure egu for manually interrupts
++    NRF_EGU0->EVENTS_TRIGGERED[0] = 0;
++    NRF_EGU0->INTENSET            = 1;
++}
++
++void sctimer_set_callback(sctimer_cbt cb) {
++    sctimer_vars.cb= cb;
++}
++
++/**
++\brief set compare interrupt
++*/
++void sctimer_setCompare(PORT_TIMER_WIDTH val) {
++
++    uint32_t counter_current;
++    
++    counter_current = NRF_RTC0->COUNTER;
++
++    if (((counter_current - val) & TIMERMASK) < TIMERLOOP_THRESHOLD) {
++        // the timer is already late, schedule the ISR right now manually 
++        NRF_EGU0->TASKS_TRIGGER[0] = 1;
++        sctimer_vars.lastFireMode  = 1;
++    } else {
++        if (((val - counter_current) & TIMERMASK) < MINIMUM_ISR_ADVANCE)  {
++            // there is hardware limitation to schedule the timer within TIMERTHRESHOLD ticks
++            // schedule ISR right now manually
++            NRF_EGU0->TASKS_TRIGGER[0] = 1;
++            sctimer_vars.lastFireMode  = 2;
++        } else {
++            // schedule the timer at val
++            NRF_RTC0->CC[0] = val;
++            sctimer_vars.lastFireMode = 0;
++        }
++    }
++}
++
++/**
++\brief Return the current value of the timer's counter.
++
++ \returns The current value of the timer's counter.
++*/
++PORT_TIMER_WIDTH sctimer_readCounter(void) {
++
++    return NRF_RTC0->COUNTER;
++}
++
++void sctimer_enable(void) {
++
++    NRF_RTC0->INTENSET = (uint32_t)(1<<16);
++}
++
++void sctimer_disable(void) {
++
++    NRF_RTC0->INTENCLR = (uint32_t)(1<<16);
++}
++
++
++//=========================== interrupt handler ===============================
++
++void RTC0_IRQHandler(void) {
++
++    debugpins_isr_set();
++    
++    if (NRF_RTC0->EVENTS_COMPARE[0] != 0) {
++        NRF_RTC0->EVENTS_COMPARE[0] = 0;
++
++        if (sctimer_vars.cb != NULL) {
++            sctimer_vars.cb();
++        }
++    }
++
++    debugpins_isr_clr();
++}
++
++
++void SWI0_EGU0_IRQHandler(void) {
++
++    debugpins_isr_set();
++    
++    if (NRF_EGU0->EVENTS_TRIGGERED[0] != 0) {
++        NRF_EGU0->EVENTS_TRIGGERED[0] = 0;
++
++        if (sctimer_vars.cb != NULL) {
++            sctimer_vars.cb();
++        }
++    }
++
++    debugpins_isr_clr();
++}
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/sensors.c b/projects/nrf52840_dk/sensors.c
+new file mode 100644
+index 00000000..de8845ad
+--- /dev/null
++++ b/projects/nrf52840_dk/sensors.c
+@@ -0,0 +1,97 @@
++/**
++    \brief Definition of the "sensors" board-specific driver.
++    \author Frank Senf <frank.senf@imms.de>, July 2018.
++*/
++
++#include "config.h"
++
++#if BOARD_SENSORS_ENABLED
++
++#include "adc_sensor.h"
++#include "sensors.h"
++
++
++//=========================== defines =========================================
++
++//=========================== typedef =========================================
++
++//=========================== variables =======================================
++
++sensors_vars_t sensors_vars;
++
++//=========================== prototype =======================================
++
++//=========================== public ==========================================
++
++/**
++   \brief Initialize sensors on the board
++*/
++void sensors_init(void) {
++    memset(&sensors_vars, 0, sizeof(sensors_vars_t));
++
++    if (adc_sens_init()) {
++        sensors_vars.sensorsTypes[SENSOR_ADCBATTERY] = 1;
++        sensors_vars.sensorsTypes[SENSOR_ADCTEMPERATURE] = 1;
++    }
++}
++
++/**
++   \brief Returns a bool value indicating if a given sensor is present
++   \param[in] sensorType sensor type polled.
++   \param[out] returnVal presence of the sensor.
++*/
++bool sensors_is_present(uint8_t sensorType) {
++    return sensors_vars.sensorsTypes[sensorType];
++}
++
++/**
++   \brief Returns the callback for reading data from a given sensor
++   \param[in] sensorType sensor type used to associate the callback.
++   \param[out] callback for reading data.
++*/
++callbackRead_cbt sensors_getCallbackRead(uint8_t sensorType) {
++    switch (sensorType) {
++        case SENSOR_ADCTEMPERATURE:
++            return &adc_sens_read_temperature;
++        case SENSOR_ADCBATTERY:
++            return &adc_sens_read_battery;
++
++        case SENSOR_TEMPERATURE:
++        case SENSOR_HUMIDITY:
++        case SENSOR_LIGHT:
++        case SENSOR_XACCELERATION:
++        case SENSOR_YACCELERATION:
++        case SENSOR_ZACCELERATION:
++
++        default:
++            return NULL;
++    }
++}
++
++/**
++   \brief Returns the callback for converting data from a given sensor
++   \param[in] sensorType sensor type used to associate the callback.
++   \param[out] callback for converting data.
++*/
++callbackConvert_cbt sensors_getCallbackConvert(uint8_t sensorType) {
++    switch (sensorType) {
++        case SENSOR_ADCTEMPERATURE:
++            return &adc_sens_convert_temperature;
++        case SENSOR_ADCBATTERY:
++            return &adc_sens_convert_battery;
++
++        case SENSOR_TEMPERATURE:
++        case SENSOR_HUMIDITY:
++        case SENSOR_LIGHT:
++        case SENSOR_XACCELERATION:
++        case SENSOR_YACCELERATION:
++        case SENSOR_ZACCELERATION:
++
++        default:
++            return NULL;
++    }
++}
++
++//=========================== private =========================================
++
++#endif /* BOARD_SENSORS_ENABLED */
+diff --git a/projects/nrf52840_dk/ses_startup_nrf52840.s b/projects/nrf52840_dk/ses_startup_nrf52840.s
+new file mode 100644
+index 00000000..e895995b
+--- /dev/null
++++ b/projects/nrf52840_dk/ses_startup_nrf52840.s
+@@ -0,0 +1,409 @@
++/***********************************************************************************
++ *                           SEGGER Microcontroller GmbH                           *
++ *                               The Embedded Experts                              *
++ ***********************************************************************************
++ *                                                                                 *
++ *                   (c) 2014 - 2018 SEGGER Microcontroller GmbH                   *
++ *                                                                                 *
++ *                  www.segger.com     Support: support@segger.com                 *
++ *                                                                                 *
++ ***********************************************************************************
++ *                                                                                 *
++ *        All rights reserved.                                                     *
++ *                                                                                 *
++ *        Redistribution and use in source and binary forms, with or               *
++ *        without modification, are permitted provided that the following          *
++ *        conditions are met:                                                      *
++ *                                                                                 *
++ *        - Redistributions of source code must retain the above copyright         *
++ *          notice, this list of conditions and the following disclaimer.          *
++ *                                                                                 *
++ *        - Neither the name of SEGGER Microcontroller GmbH                        *
++ *          nor the names of its contributors may be used to endorse or            *
++ *          promote products derived from this software without specific           *
++ *          prior written permission.                                              *
++ *                                                                                 *
++ *        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND                   *
++ *        CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,              *
++ *        INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF                 *
++ *        MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE                 *
++ *        DISCLAIMED.                                                              *
++ *        IN NO EVENT SHALL SEGGER Microcontroller GmbH BE LIABLE FOR              *
++ *        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR                 *
++ *        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT        *
++ *        OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;          *
++ *        OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF            *
++ *        LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT                *
++ *        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE        *
++ *        USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         *
++ *        DAMAGE.                                                                  *
++ *                                                                                 *
++ ***********************************************************************************/
++
++/************************************************************************************
++ *                         Preprocessor Definitions                                 *
++ *                         ------------------------                                 *
++ * VECTORS_IN_RAM                                                                   *
++ *                                                                                  *
++ *   If defined, an area of RAM will large enough to store the vector table         *
++ *   will be reserved.                                                              *
++ *                                                                                  *
++ ************************************************************************************/
++
++  .syntax unified
++  .code 16
++
++  .section .init, "ax"
++  .align 0
++  
++/************************************************************************************
++ * Default Exception Handlers                                                       *
++ ************************************************************************************/
++
++
++  .thumb_func
++  .weak   NMI_Handler
++NMI_Handler:
++  b     .
++
++  .thumb_func
++  .weak   HardFault_Handler
++HardFault_Handler:
++  b     .
++
++  .thumb_func
++  .weak   MemoryManagement_Handler
++MemoryManagement_Handler:
++  b     .
++
++  .thumb_func
++  .weak   BusFault_Handler
++BusFault_Handler:
++  b     .
++
++  .thumb_func
++  .weak   UsageFault_Handler
++UsageFault_Handler:
++  b     .
++
++  .thumb_func
++  .weak   SVC_Handler
++SVC_Handler:
++  b     .
++
++  .thumb_func
++  .weak   DebugMon_Handler
++DebugMon_Handler:
++  b     .
++
++  .thumb_func
++  .weak   PendSV_Handler
++PendSV_Handler:
++  b     .
++
++  .thumb_func
++  .weak   SysTick_Handler
++SysTick_Handler:
++  b     .
++
++  .thumb_func
++  .weak   Dummy_Handler
++Dummy_Handler:
++  b     .
++
++/************************************************************************************
++ * Default Interrupt Handlers                                                       *
++ ************************************************************************************/
++ 
++.weak POWER_CLOCK_IRQHandler
++.thumb_set POWER_CLOCK_IRQHandler, Dummy_Handler
++
++.weak RADIO_IRQHandler
++.thumb_set RADIO_IRQHandler, Dummy_Handler
++
++.weak UARTE0_UART0_IRQHandler
++.thumb_set UARTE0_UART0_IRQHandler, Dummy_Handler
++
++.weak SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
++.thumb_set SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler, Dummy_Handler
++
++.weak SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
++.thumb_set SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler, Dummy_Handler
++
++.weak NFCT_IRQHandler
++.thumb_set NFCT_IRQHandler, Dummy_Handler
++
++.weak GPIOTE_IRQHandler
++.thumb_set GPIOTE_IRQHandler, Dummy_Handler
++
++.weak SAADC_IRQHandler
++.thumb_set SAADC_IRQHandler, Dummy_Handler
++
++.weak TIMER0_IRQHandler
++.thumb_set TIMER0_IRQHandler, Dummy_Handler
++
++.weak TIMER1_IRQHandler
++.thumb_set TIMER1_IRQHandler, Dummy_Handler
++
++.weak TIMER2_IRQHandler
++.thumb_set TIMER2_IRQHandler, Dummy_Handler
++
++.weak RTC0_IRQHandler
++.thumb_set RTC0_IRQHandler, Dummy_Handler
++
++.weak TEMP_IRQHandler
++.thumb_set TEMP_IRQHandler, Dummy_Handler
++
++.weak RNG_IRQHandler
++.thumb_set RNG_IRQHandler, Dummy_Handler
++
++.weak ECB_IRQHandler
++.thumb_set ECB_IRQHandler, Dummy_Handler
++
++.weak CCM_AAR_IRQHandler
++.thumb_set CCM_AAR_IRQHandler, Dummy_Handler
++
++.weak WDT_IRQHandler
++.thumb_set WDT_IRQHandler, Dummy_Handler
++
++.weak RTC1_IRQHandler
++.thumb_set RTC1_IRQHandler, Dummy_Handler
++
++.weak QDEC_IRQHandler
++.thumb_set QDEC_IRQHandler, Dummy_Handler
++
++.weak COMP_LPCOMP_IRQHandler
++.thumb_set COMP_LPCOMP_IRQHandler, Dummy_Handler
++
++.weak SWI0_EGU0_IRQHandler
++.thumb_set SWI0_EGU0_IRQHandler, Dummy_Handler
++
++.weak SWI1_EGU1_IRQHandler
++.thumb_set SWI1_EGU1_IRQHandler, Dummy_Handler
++
++.weak SWI2_EGU2_IRQHandler
++.thumb_set SWI2_EGU2_IRQHandler, Dummy_Handler
++
++.weak SWI3_EGU3_IRQHandler
++.thumb_set SWI3_EGU3_IRQHandler, Dummy_Handler
++
++.weak SWI4_EGU4_IRQHandler
++.thumb_set SWI4_EGU4_IRQHandler, Dummy_Handler
++
++.weak SWI5_EGU5_IRQHandler
++.thumb_set SWI5_EGU5_IRQHandler, Dummy_Handler
++
++.weak TIMER3_IRQHandler
++.thumb_set TIMER3_IRQHandler, Dummy_Handler
++
++.weak TIMER4_IRQHandler
++.thumb_set TIMER4_IRQHandler, Dummy_Handler
++
++.weak PWM0_IRQHandler
++.thumb_set PWM0_IRQHandler, Dummy_Handler
++
++.weak PDM_IRQHandler
++.thumb_set PDM_IRQHandler, Dummy_Handler
++
++.weak MWU_IRQHandler
++.thumb_set MWU_IRQHandler, Dummy_Handler
++
++.weak PWM1_IRQHandler
++.thumb_set PWM1_IRQHandler, Dummy_Handler
++
++.weak PWM2_IRQHandler
++.thumb_set PWM2_IRQHandler, Dummy_Handler
++
++.weak SPIM2_SPIS2_SPI2_IRQHandler
++.thumb_set SPIM2_SPIS2_SPI2_IRQHandler, Dummy_Handler
++
++.weak RTC2_IRQHandler
++.thumb_set RTC2_IRQHandler, Dummy_Handler
++
++.weak I2S_IRQHandler
++.thumb_set I2S_IRQHandler, Dummy_Handler
++
++.weak FPU_IRQHandler
++.thumb_set FPU_IRQHandler, Dummy_Handler
++
++.weak USBD_IRQHandler
++.thumb_set USBD_IRQHandler, Dummy_Handler
++
++.weak UARTE1_IRQHandler
++.thumb_set UARTE1_IRQHandler, Dummy_Handler
++
++.weak QSPI_IRQHandler
++.thumb_set QSPI_IRQHandler, Dummy_Handler
++
++.weak CRYPTOCELL_IRQHandler
++.thumb_set CRYPTOCELL_IRQHandler, Dummy_Handler
++
++.weak PWM3_IRQHandler
++.thumb_set PWM3_IRQHandler, Dummy_Handler
++
++.weak SPIM3_IRQHandler
++.thumb_set SPIM3_IRQHandler, Dummy_Handler
++
++/************************************************************************************
++ * Reset Handler Extensions                                                         *
++ ************************************************************************************/
++
++  .extern Reset_Handler
++  .global nRFInitialize
++  .extern afterInitialize
++
++  .thumb_func
++nRFInitialize:
++  b afterInitialize
++ 
++ 
++/************************************************************************************
++ * Vector Table                                                                     *
++ ************************************************************************************/
++
++  .section .vectors, "ax"
++  .align 0
++  .global _vectors
++  .extern __stack_end__
++
++_vectors:
++  .word __stack_end__
++  .word Reset_Handler
++  .word NMI_Handler
++  .word HardFault_Handler
++  .word MemoryManagement_Handler
++  .word BusFault_Handler
++  .word UsageFault_Handler
++  .word 0                           /*Reserved */
++  .word 0                           /*Reserved */
++  .word 0                           /*Reserved */
++  .word 0                           /*Reserved */
++  .word SVC_Handler
++  .word DebugMon_Handler
++  .word 0                           /*Reserved */
++  .word PendSV_Handler
++  .word SysTick_Handler
++
++/* External Interrupts */
++  .word   POWER_CLOCK_IRQHandler
++  .word   RADIO_IRQHandler
++  .word   UARTE0_UART0_IRQHandler
++  .word   SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
++  .word   SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
++  .word   NFCT_IRQHandler
++  .word   GPIOTE_IRQHandler
++  .word   SAADC_IRQHandler
++  .word   TIMER0_IRQHandler
++  .word   TIMER1_IRQHandler
++  .word   TIMER2_IRQHandler
++  .word   RTC0_IRQHandler
++  .word   TEMP_IRQHandler
++  .word   RNG_IRQHandler
++  .word   ECB_IRQHandler
++  .word   CCM_AAR_IRQHandler
++  .word   WDT_IRQHandler
++  .word   RTC1_IRQHandler
++  .word   QDEC_IRQHandler
++  .word   COMP_LPCOMP_IRQHandler
++  .word   SWI0_EGU0_IRQHandler
++  .word   SWI1_EGU1_IRQHandler
++  .word   SWI2_EGU2_IRQHandler
++  .word   SWI3_EGU3_IRQHandler
++  .word   SWI4_EGU4_IRQHandler
++  .word   SWI5_EGU5_IRQHandler
++  .word   TIMER3_IRQHandler
++  .word   TIMER4_IRQHandler
++  .word   PWM0_IRQHandler
++  .word   PDM_IRQHandler
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   MWU_IRQHandler
++  .word   PWM1_IRQHandler
++  .word   PWM2_IRQHandler
++  .word   SPIM2_SPIS2_SPI2_IRQHandler
++  .word   RTC2_IRQHandler
++  .word   I2S_IRQHandler
++  .word   FPU_IRQHandler
++  .word   USBD_IRQHandler
++  .word   UARTE1_IRQHandler
++  .word   QSPI_IRQHandler
++  .word   CRYPTOCELL_IRQHandler
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   PWM3_IRQHandler
++  .word   0                           /*Reserved */
++  .word   SPIM3_IRQHandler
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++  .word   0                           /*Reserved */
++_vectors_end:
++
++#ifdef VECTORS_IN_RAM
++  .section .vectors_ram, "ax"
++  .align 0
++  .global _vectors_ram
++
++_vectors_ram:
++  .space _vectors_end - _vectors, 0
++#endif
+diff --git a/projects/nrf52840_dk/ses_startup_nrf_common.s b/projects/nrf52840_dk/ses_startup_nrf_common.s
+new file mode 100644
+index 00000000..f7ede0a0
+--- /dev/null
++++ b/projects/nrf52840_dk/ses_startup_nrf_common.s
+@@ -0,0 +1,193 @@
++/***********************************************************************************
++ *                           SEGGER Microcontroller GmbH                           *
++ *                               The Embedded Experts                              *
++ ***********************************************************************************
++ *                                                                                 *
++ *                   (c) 2014 - 2018 SEGGER Microcontroller GmbH                   *
++ *                                                                                 *
++ *                  www.segger.com     Support: support@segger.com                 *
++ *                                                                                 *
++ ***********************************************************************************
++ *                                                                                 *
++ *        All rights reserved.                                                     *
++ *                                                                                 *
++ *        Redistribution and use in source and binary forms, with or               *
++ *        without modification, are permitted provided that the following          *
++ *        conditions are met:                                                      *
++ *                                                                                 *
++ *        - Redistributions of source code must retain the above copyright         *
++ *          notice, this list of conditions and the following disclaimer.          *
++ *                                                                                 *
++ *        - Neither the name of SEGGER Microcontroller GmbH                        *
++ *          nor the names of its contributors may be used to endorse or            *
++ *          promote products derived from this software without specific           *
++ *          prior written permission.                                              *
++ *                                                                                 *
++ *        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND                   *
++ *        CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,              *
++ *        INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF                 *
++ *        MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE                 *
++ *        DISCLAIMED.                                                              *
++ *        IN NO EVENT SHALL SEGGER Microcontroller GmbH BE LIABLE FOR              *
++ *        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR                 *
++ *        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT        *
++ *        OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;          *
++ *        OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF            *
++ *        LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT                *
++ *        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE        *
++ *        USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH         *
++ *        DAMAGE.                                                                  *
++ *                                                                                 *
++ ***********************************************************************************
++ *                                                                                 *
++ *    This file has been modified by Nordic Semiconductor:                         *
++ *        To separate out device-specific data                                     *
++ *                                                                                 *
++ ***********************************************************************************/
++
++/************************************************************************************
++ *                         Preprocessor Definitions                                 *
++ *                         ------------------------                                 *
++ * NO_FPU_ENABLE                                                                    *
++ *                                                                                  *
++ *   If defined, FPU will not be enabled.                                           *
++ *                                                                                  *
++ * NO_STACK_INIT                                                                    *
++ *                                                                                  *
++ *   If defined, the stack pointer will not be initialised.                         *
++ *                                                                                  *
++ * NO_SYSTEM_INIT                                                                   *
++ *                                                                                  *
++ *   If defined, the SystemInit() function will not be called. By default           *
++ *   SystemInit() is called after reset to enable the clocks and memories to        *
++ *   be initialised prior to any C startup initialisation.                          *
++ *                                                                                  *
++ * NO_VTOR_CONFIG                                                                   *
++ *                                                                                  *
++ *   If defined, the vector table offset register will not be configured.           *
++ *                                                                                  *
++ * MEMORY_INIT                                                                      *
++ *                                                                                  *
++ *   If defined, the MemoryInit() function will be called. By default               *
++ *   MemoryInit() is called after SystemInit() to enable an external memory         *
++ *   controller.                                                                    *
++ *                                                                                  *
++ * STACK_INIT_VAL                                                                   *
++ *                                                                                  *
++ *   If defined, specifies the initial stack pointer value. If undefined,           *
++ *   the stack pointer will be initialised to point to the end of the               *
++ *   RAM segment.                                                                   *
++ *                                                                                  *
++ * VECTORS_IN_RAM                                                                   *
++ *                                                                                  *
++ *   If defined, the exception vectors will be copied from Flash to RAM.            *
++ *                                                                                  *
++ ************************************************************************************/
++
++  .syntax unified
++
++  .global Reset_Handler
++#ifdef INITIALIZE_USER_SECTIONS  
++  .global InitializeUserMemorySections
++#endif
++  .extern _vectors
++  .extern nRFInitialize
++  .global afterInitialize
++
++  .section .init, "ax"
++  .thumb_func
++
++  .equ VTOR_REG, 0xE000ED08
++  .equ FPU_CPACR_REG, 0xE000ED88
++
++#ifndef STACK_INIT_VAL
++#define STACK_INIT_VAL __RAM1_segment_end__
++#endif
++
++Reset_Handler:
++
++  /* Perform prestart tasks. */
++  b nRFInitialize
++
++.thumb_func
++afterInitialize:
++  
++#ifndef NO_STACK_INIT
++  /* Initialise main stack */
++  ldr r0, =STACK_INIT_VAL
++  ldr r1, =0x7
++  bics r0, r1
++  mov sp, r0
++#endif
++
++#ifndef NO_SYSTEM_INIT
++  /* Initialise system */
++  ldr r0, =SystemInit
++  blx r0
++#endif
++
++#ifdef MEMORY_INIT
++  ldr r0, =MemoryInit
++  blx r0
++#endif
++
++#ifdef VECTORS_IN_RAM
++  /* Copy exception vectors into RAM */
++  ldr r0, =__vectors_start__
++  ldr r1, =__vectors_end__
++  ldr r2, =__vectors_ram_start__
++1:
++  cmp r0, r1
++  beq 2f
++  ldr r3, [r0]
++  str r3, [r2]
++  adds r0, r0, #4
++  adds r2, r2, #4
++  b 1b
++2:
++#endif
++
++#ifndef NO_VTOR_CONFIG
++  /* Configure vector table offset register */
++  ldr r0, =VTOR_REG
++#ifdef VECTORS_IN_RAM
++  ldr r1, =_vectors_ram
++#else
++  ldr r1, =_vectors
++#endif
++  str r1, [r0]
++#endif
++
++#if (defined(__ARM_ARCH_FPV4_SP_D16__) || defined(__ARM_ARCH_FPV5_D16__)) && !defined(NO_FPU_ENABLE)
++  /* Enable FPU */
++  ldr r0, =FPU_CPACR_REG
++  ldr r1, [r0]
++  orr r1, r1, #(0xF << 20)
++  str r1, [r0]
++  dsb
++  isb
++#endif
++
++  /* Jump to program start */
++  b _start
++
++#ifdef INITIALIZE_USER_SECTIONS  
++  .thumb_func
++InitializeUserMemorySections:
++  ldr r0, =__start_nrf_sections
++  ldr r1, =__start_nrf_sections_run
++  ldr r2, =__end_nrf_sections_run
++  cmp r0, r1
++  beq 2f
++  subs r2, r2, r1
++  beq 2f
++1:
++  ldrb r3, [r0]
++  adds r0, r0, #1
++  strb r3, [r1]
++  adds r1, r1, #1
++  subs r2, r2, #1
++  bne 1b
++2:
++  bx lr
++#endif
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/spi.c b/projects/nrf52840_dk/spi.c
+new file mode 100644
+index 00000000..61c30e90
+--- /dev/null
++++ b/projects/nrf52840_dk/spi.c
+@@ -0,0 +1,40 @@
++/**
++ * Author: Adam Sedmak (adam.sedmak@gmail.com)
++ * Company: Faculty of Electronics and Computing, Zagreb, Croatia
++ * Date:   Apr 2018
++ * Description: nRF52840-specific definition of the "spi" bsp module.
++ */
++
++#include "board_info.h"
++#include "spi.h"
++
++//=========================== defines =========================================
++
++
++#define SPI_SS_PIN   NRF_GPIO_PIN_MAP(1,1)   ///< P1.01
++#define SPI_MISO_PIN NRF_GPIO_PIN_MAP(1,2)   ///< P1.02
++#define SPI_MOSI_PIN NRF_GPIO_PIN_MAP(1,3)   ///< P1.03
++#define SPI_SCK_PIN  NRF_GPIO_PIN_MAP(1,4)   ///< P1.04
++
++//=========================== variables =======================================
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++void spi_init(void) {
++}
++
++ 
++void    spi_txrx(uint8_t*     bufTx,
++                 uint16_t     lenbufTx,
++                 spi_return_t returnType,
++                 uint8_t*     bufRx,
++                 uint16_t     maxLenBufRx,
++                 spi_first_t  isFirst,
++                 spi_last_t   isLast)
++{
++   
++}
++
++//=========================== private =========================================
+\ No newline at end of file
+diff --git a/projects/nrf52840_dk/system_nrf52.h b/projects/nrf52840_dk/system_nrf52.h
+new file mode 100644
+index 00000000..bd3919cb
+--- /dev/null
++++ b/projects/nrf52840_dk/system_nrf52.h
+@@ -0,0 +1,61 @@
++/*
++
++Copyright (c) 2009-2021 ARM Limited. All rights reserved.
++
++    SPDX-License-Identifier: Apache-2.0
++
++Licensed under the Apache License, Version 2.0 (the License); you may
++not use this file except in compliance with the License.
++You may obtain a copy of the License at
++
++    www.apache.org/licenses/LICENSE-2.0
++
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an AS IS BASIS, WITHOUT
++WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++
++NOTICE: This file has been modified by Nordic Semiconductor ASA.
++
++*/
++
++#ifndef SYSTEM_NRF52_H
++#define SYSTEM_NRF52_H
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#include <stdint.h>
++
++
++extern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
++
++/**
++ * Initialize the system
++ *
++ * @param  none
++ * @return none
++ *
++ * @brief  Setup the microcontroller system.
++ *         Initialize the System and update the SystemCoreClock variable.
++ */
++extern void SystemInit (void);
++
++/**
++ * Update SystemCoreClock variable
++ *
++ * @param  none
++ * @return none
++ *
++ * @brief  Updates the SystemCoreClock with current core Clock
++ *         retrieved from cpu registers.
++ */
++extern void SystemCoreClockUpdate (void);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* SYSTEM_NRF52_H */
+diff --git a/projects/nrf52840_dk/system_nrf52840.c b/projects/nrf52840_dk/system_nrf52840.c
+new file mode 100644
+index 00000000..c3359ee4
+--- /dev/null
++++ b/projects/nrf52840_dk/system_nrf52840.c
+@@ -0,0 +1,42 @@
++/*
++
++Copyright (c) 2010 - 2021, Nordic Semiconductor ASA
++
++All rights reserved.
++
++Redistribution and use in source and binary forms, with or without modification,
++are permitted provided that the following conditions are met:
++
++1. Redistributions of source code must retain the above copyright notice, this
++   list of conditions and the following disclaimer.
++
++2. Redistributions in binary form, except as embedded into a Nordic
++   Semiconductor ASA integrated circuit in a product or a software update for
++   such product, must reproduce the above copyright notice, this list of
++   conditions and the following disclaimer in the documentation and/or other
++   materials provided with the distribution.
++
++3. Neither the name of Nordic Semiconductor ASA nor the names of its
++   contributors may be used to endorse or promote products derived from this
++   software without specific prior written permission.
++
++4. This software, with or without modification, must only be used with a
++   Nordic Semiconductor ASA integrated circuit.
++
++5. Any software provided in binary form under this license must not be reverse
++   engineered, decompiled, modified and/or disassembled.
++
++THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
++OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
++OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
++DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
++LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
++HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
++LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
++OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++
++*/
++
++#include "system_nrf52.c"
+diff --git a/projects/nrf52840_dk/system_nrf52840.h b/projects/nrf52840_dk/system_nrf52840.h
+new file mode 100644
+index 00000000..3df49a46
+--- /dev/null
++++ b/projects/nrf52840_dk/system_nrf52840.h
+@@ -0,0 +1,61 @@
++/*
++
++Copyright (c) 2009-2021 ARM Limited. All rights reserved.
++
++    SPDX-License-Identifier: Apache-2.0
++
++Licensed under the Apache License, Version 2.0 (the License); you may
++not use this file except in compliance with the License.
++You may obtain a copy of the License at
++
++    www.apache.org/licenses/LICENSE-2.0
++
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an AS IS BASIS, WITHOUT
++WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++
++NOTICE: This file has been modified by Nordic Semiconductor ASA.
++
++*/
++
++#ifndef SYSTEM_NRF52840_H
++#define SYSTEM_NRF52840_H
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#include <stdint.h>
++
++
++extern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
++
++/**
++ * Initialize the system
++ *
++ * @param  none
++ * @return none
++ *
++ * @brief  Setup the microcontroller system.
++ *         Initialize the System and update the SystemCoreClock variable.
++ */
++extern void SystemInit (void);
++
++/**
++ * Update SystemCoreClock variable
++ *
++ * @param  none
++ * @return none
++ *
++ * @brief  Updates the SystemCoreClock with current core Clock
++ *         retrieved from cpu registers.
++ */
++extern void SystemCoreClockUpdate (void);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* SYSTEM_NRF52840_H */
+diff --git a/projects/nrf52840_dk/system_nrf52_approtect.h b/projects/nrf52840_dk/system_nrf52_approtect.h
+new file mode 100644
+index 00000000..86a8b65b
+--- /dev/null
++++ b/projects/nrf52840_dk/system_nrf52_approtect.h
+@@ -0,0 +1,65 @@
++/*
++
++Copyright (c) 2009-2021 ARM Limited. All rights reserved.
++
++    SPDX-License-Identifier: Apache-2.0
++
++Licensed under the Apache License, Version 2.0 (the License); you may
++not use this file except in compliance with the License.
++You may obtain a copy of the License at
++
++    www.apache.org/licenses/LICENSE-2.0
++
++Unless required by applicable law or agreed to in writing, software
++distributed under the License is distributed on an AS IS BASIS, WITHOUT
++WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++See the License for the specific language governing permissions and
++limitations under the License.
++
++NOTICE: This file has been modified by Nordic Semiconductor ASA.
++
++*/
++
++#ifndef SYSTEM_NRF52_APPROTECT_H
++#define SYSTEM_NRF52_APPROTECT_H
++
++#include "nrf.h"
++#include "nrf_erratas.h"
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++
++/* Function that handles firmware-driven enabling or disabling of APPROTECT on devices where it is supported.
++        If ENABLE_APPROTECT is defined, the FW will lock the fw branch of the APPROTECT mechanism,
++                            preventing it from being opened.
++        Otherwise, the fw branch state is loaded from UICR, emulating the legacy APPROTECT behavior.
++
++         The same mechanism is implemented for SECURE APPROTECT, with the macros
++         ENABLE_SECURE_APPROTECT and ENABLE_SECURE_APPROTECT_USER_HANDLING. */
++static inline void nrf52_handle_approtect(void)
++{
++    #if NRF52_ERRATA_249_PRESENT
++        #if defined (ENABLE_APPROTECT)
++            if (nrf52_errata_249())
++            {
++                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
++                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
++            }
++        #else
++            if (nrf52_errata_249())
++            {
++                /* Load APPROTECT soft branch from UICR.
++                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
++                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
++            }
++        #endif
++    #endif
++}
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* SYSTEM_NRF52_APPROTECT_H */
+diff --git a/projects/nrf52840_dk/thumb_crt0.s b/projects/nrf52840_dk/thumb_crt0.s
+new file mode 100644
+index 00000000..0370351f
+--- /dev/null
++++ b/projects/nrf52840_dk/thumb_crt0.s
+@@ -0,0 +1,395 @@
++// **********************************************************************
++// *                    SEGGER Microcontroller GmbH                     *
++// *                        The Embedded Experts                        *
++// **********************************************************************
++// *                                                                    *
++// *            (c) 2014 - 2022 SEGGER Microcontroller GmbH             *
++// *            (c) 2001 - 2022 Rowley Associates Limited               *
++// *                                                                    *
++// *           www.segger.com     Support: support@segger.com           *
++// *                                                                    *
++// **********************************************************************
++// *                                                                    *
++// * All rights reserved.                                               *
++// *                                                                    *
++// * Redistribution and use in source and binary forms, with or         *
++// * without modification, are permitted provided that the following    *
++// * condition is met:                                                  *
++// *                                                                    *
++// * - Redistributions of source code must retain the above copyright   *
++// *   notice, this condition and the following disclaimer.             *
++// *                                                                    *
++// * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
++// * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
++// * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
++// * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
++// * DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
++// * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
++// * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
++// * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
++// * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
++// * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
++// * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
++// * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
++// * DAMAGE.                                                            *
++// *                                                                    *
++// **********************************************************************
++//
++//
++//                           Preprocessor Definitions
++//                           ------------------------
++// APP_ENTRY_POINT
++//
++//   Defines the application entry point function, if undefined this setting
++//   defaults to "main".
++//
++// INITIALIZE_STACK
++//
++//   If defined, the contents of the stack will be initialized to a the
++//   value 0xCC.
++//
++// INITIALIZE_SECONDARY_SECTIONS
++//
++//   If defined, the .data2, .text2, .rodata2 and .bss2 sections will be initialized.
++//
++// INITIALIZE_TCM_SECTIONS
++//
++//   If defined, the .data_tcm, .text_tcm, .rodata_tcm and .bss_tcm sections 
++//   will be initialized.
++//
++// INITIALIZE_USER_SECTIONS
++//
++//   If defined, the function InitializeUserMemorySections will be called prior
++//   to entering main in order to allow the user to initialize any user defined
++//   memory sections.
++//
++// FULL_LIBRARY
++//
++//   If defined then 
++//     - argc, argv are setup by the SEGGER_SEMIHOST_GetArgs.
++//     - the exit symbol is defined and executes on return from main.
++//     - the exit symbol calls destructors, atexit functions and then SEGGER_SEMIHOST_Exit.
++//  
++//   If not defined then
++//     - argc and argv are zero.
++//     - the exit symbol is defined, executes on return from main and loops
++//
++// STACK_CHECK
++//
++//   If defined will set the v8m msplim/psplim registers to the start of the stacks
++//
++// RETURN_FROM_CRT0
++//
++//   If defined, carry out a return to link register on application exit.
++//
++
++
++#ifndef APP_ENTRY_POINT
++#define APP_ENTRY_POINT main
++#endif
++
++#ifndef ARGSSPACE
++#define ARGSSPACE 128
++#endif
++  .syntax unified
++
++  .global _start
++  .extern APP_ENTRY_POINT
++  .weak exit
++
++#ifdef INITIALIZE_USER_SECTIONS
++  .extern InitializeUserMemorySections
++#endif
++
++  .section .init, "ax"
++  .code 16
++  .balign 2
++  .thumb_func
++
++_start:
++  /* Set up main stack if size > 0 */
++  ldr r1, =__stack_end__
++  ldr r0, =__stack_start__
++  subs r2, r1, r0
++  beq 1f
++#ifdef __ARM_EABI__
++  movs r2, #0x7
++  bics r1, r2
++#endif
++  mov sp, r1
++#ifdef RETURN_FROM_CRT0
++  push {lr}
++#endif
++#ifdef INITIALIZE_STACK
++  movs r2, #0xCC
++  ldr r0, =__stack_start__
++  bl memory_set
++#endif
++#ifdef STACK_CHECK
++  ldr r0, =__stack_start__
++  msr msplim, r0
++#endif
++1:
++  /* Set up process stack if size > 0 */
++  ldr r1, =__stack_process_end__
++  ldr r0, =__stack_process_start__
++  subs r2, r1, r0
++  beq 1f
++#ifdef __ARM_EABI__
++  movs r2, #0x7
++  bics r1, r2
++#endif
++  msr psp, r1
++  movs r2, #2
++  msr control, r2
++#ifdef INITIALIZE_STACK
++  movs r2, #0xCC
++  bl memory_set
++#endif
++#ifdef STACK_CHECK
++  ldr r0, =__stack_process_start__
++  msr psplim, r0
++#endif
++1:
++
++  /* Copy initialized memory sections into RAM (if necessary). */
++  ldr r0, =__data_load_start__
++  ldr r1, =__data_start__
++  ldr r2, =__data_end__
++  bl memory_copy
++  ldr r0, =__text_load_start__
++  ldr r1, =__text_start__
++  ldr r2, =__text_end__
++  bl memory_copy
++  ldr r0, =__fast_load_start__
++  ldr r1, =__fast_start__
++  ldr r2, =__fast_end__
++  bl memory_copy
++  ldr r0, =__ctors_load_start__
++  ldr r1, =__ctors_start__
++  ldr r2, =__ctors_end__
++  bl memory_copy
++  ldr r0, =__dtors_load_start__
++  ldr r1, =__dtors_start__
++  ldr r2, =__dtors_end__
++  bl memory_copy
++  ldr r0, =__rodata_load_start__
++  ldr r1, =__rodata_start__
++  ldr r2, =__rodata_end__
++  bl memory_copy
++  ldr r0, =__tdata_load_start__
++  ldr r1, =__tdata_start__
++  ldr r2, =__tdata_end__
++  bl memory_copy
++#ifdef INITIALIZE_SECONDARY_SECTIONS
++  ldr r0, =__data2_load_start__
++  ldr r1, =__data2_start__
++  ldr r2, =__data2_end__
++  bl memory_copy
++  ldr r0, =__text2_load_start__
++  ldr r1, =__text2_start__
++  ldr r2, =__text2_end__
++  bl memory_copy
++  ldr r0, =__rodata2_load_start__
++  ldr r1, =__rodata2_start__
++  ldr r2, =__rodata2_end__
++  bl memory_copy
++#endif /* #ifdef INITIALIZE_SECONDARY_SECTIONS */
++#ifdef INITIALIZE_TCM_SECTIONS
++  ldr r0, =__data_tcm_load_start__
++  ldr r1, =__data_tcm_start__
++  ldr r2, =__data_tcm_end__
++  bl memory_copy
++  ldr r0, =__text_tcm_load_start__
++  ldr r1, =__text_tcm_start__
++  ldr r2, =__text_tcm_end__
++  bl memory_copy
++  ldr r0, =__rodata_tcm_load_start__
++  ldr r1, =__rodata_tcm_start__
++  ldr r2, =__rodata_tcm_end__
++  bl memory_copy
++#endif /* #ifdef INITIALIZE_TCM_SECTIONS */
++
++  /* Zero the bss. */
++  ldr r0, =__bss_start__
++  ldr r1, =__bss_end__
++  movs r2, #0
++  bl memory_set
++  ldr r0, =__tbss_start__
++  ldr r1, =__tbss_end__
++  movs r2, #0
++  bl memory_set
++#ifdef INITIALIZE_SECONDARY_SECTIONS
++  ldr r0, =__bss2_start__
++  ldr r1, =__bss2_end__
++  mov r2, #0
++  bl memory_set
++#endif /* #ifdef INITIALIZE_SECONDARY_SECTIONS */
++#ifdef INITIALIZE_TCM_SECTIONS
++  ldr r0, =__bss_tcm_start__
++  ldr r1, =__bss_tcm_end__
++  mov r2, #0
++  bl memory_set
++#endif /* #ifdef INITIALIZE_TCM_SECTIONS */
++
++#if !defined(__HEAP_SIZE__) || (__HEAP_SIZE__)
++  /* Initialize the heap */
++  ldr r0, = __heap_start__
++  ldr r1, = __heap_end__
++  subs r1, r1, r0
++#if defined(__SES_ARM)
++  bl __SEGGER_RTL_init_heap
++#else
++  cmp r1, #8
++  blt 1f
++  movs r2, #0
++  str r2, [r0]
++  str r1, [r0, #4] 
++1:
++#endif
++#endif
++
++#ifdef INITIALIZE_USER_SECTIONS
++  ldr r2, =InitializeUserMemorySections
++  blx r2
++#endif
++
++  .type start, function
++start:
++
++  /* Call constructors */
++  ldr r0, =__ctors_start__
++  ldr r1, =__ctors_end__
++ctor_loop:
++  cmp r0, r1
++  beq ctor_end
++  ldr r2, [r0]
++  adds r0, #4
++  push {r0-r1}  
++  blx r2
++  pop {r0-r1}
++  b ctor_loop
++ctor_end:
++
++  /* Setup initial call frame */
++  movs r0, #0
++  mov lr, r0
++  mov r12, sp
++
++  .type __startup_complete, function
++__startup_complete:
++
++  /* Jump to application entry point */
++#ifdef FULL_LIBRARY
++  movs r0, #ARGSSPACE
++  ldr r1, =args
++  ldr r2, =SEGGER_SEMIHOST_GetArgs
++  blx r2
++  ldr r1, =args
++#else
++  movs r0, #0
++  movs r1, #0
++#endif
++  ldr r2, =APP_ENTRY_POINT
++  blx r2
++
++  .thumb_func
++exit:
++#ifdef FULL_LIBRARY  
++  mov r5, r0 // save the exit parameter/return result
++
++  /* Call destructors */
++  ldr r0, =__dtors_start__
++  ldr r1, =__dtors_end__
++dtor_loop:
++  cmp r0, r1
++  beq dtor_end
++  ldr r2, [r0]
++  adds r0, #4
++  push {r0-r1}
++  blx r2
++  pop {r0-r1}
++  b dtor_loop
++dtor_end:
++
++  /* Call atexit functions */
++  ldr r2, =__SEGGER_RTL_execute_at_exit_fns
++  blx r2
++
++  /* Call SEGGER_SEMIHOST_Exit with return result/exit parameter */
++  mov r0, r5
++  ldr r2, =SEGGER_SEMIHOST_Exit
++  blx r2
++#endif
++
++  /* Returned from application entry point */
++#ifdef RETURN_FROM_CRT0
++  pop {r2}
++  bx r2
++#else
++  /* Loop forever */
++exit_loop:
++  b exit_loop
++#endif
++
++  .thumb_func
++memory_copy:
++  cmp r0, r1
++  beq 2f
++  subs r2, r2, r1
++  beq 2f
++1:
++  ldrb r3, [r0]
++  adds r0, r0, #1
++  strb r3, [r1]
++  adds r1, r1, #1
++  subs r2, r2, #1
++  bne 1b
++2:
++  bx lr
++
++  .thumb_func
++memory_set:
++  cmp r0, r1
++  beq 1f
++  strb r2, [r0]
++  adds r0, r0, #1
++  b memory_set
++1:
++  bx lr
++
++  // default C/C++ library helpers
++
++.macro HELPER helper_name
++  .section .text.\helper_name, "ax", %progbits
++  .balign 2 
++  .weak \helper_name
++  .thumb_func
++\helper_name:
++.endm
++
++HELPER __aeabi_read_tp
++  ldr r0, =__tbss_start__-8
++  bx lr
++HELPER abort
++  b .
++HELPER __assert
++  b .
++HELPER __assert_func
++  b .
++HELPER __aeabi_assert
++  b .
++HELPER __sync_synchronize
++  bx lr
++
++#ifdef FULL_LIBRARY
++  .bss
++args:
++  .space ARGSSPACE
++#endif
++
++  /* Setup attibutes of stack and heap sections so they don't take up room in the elf file */
++  .section .stack, "wa", %nobits
++  .section .stack_process, "wa", %nobits
++  .section .heap, "wa", %nobits
++
+diff --git a/projects/nrf52840_dk/uart.c b/projects/nrf52840_dk/uart.c
+new file mode 100644
+index 00000000..9cb2328b
+--- /dev/null
++++ b/projects/nrf52840_dk/uart.c
+@@ -0,0 +1,180 @@
++ /**
++ * Author: Tamas Harczos (tamas.harczos@imms.de)
++ * Date:   Apr 2018
++ * Description: nRF52840-specific definition of the "uart" bsp module.
++ */
++
++
++#include "nrf52840.h"
++#include "nrf52840_bitfields.h"
++#include "board_info.h"
++
++#include "leds.h"
++#include "debugpins.h"
++#include "uart.h"
++
++//=========================== defines =========================================
++
++#define UART_RX_PIN       NRF_GPIO_PIN_MAP(0,8) // p0.08
++#define UART_TX_PIN       NRF_GPIO_PIN_MAP(0,6) // p0.06
++#define UART_CTS_PIN      NRF_GPIO_PIN_MAP(0,7) // p0.07
++#define UART_RTS_PIN      NRF_GPIO_PIN_MAP(0,5) // p0.05
++
++#define UART_BAUDRATE_115200        0x01D7E000  // Baud 115200
++#define UART_BAUDRATE_1M            0x10000000  // Baud 1M
++
++#define UART_INTEN_RXDRDY_POS       2
++#define UART_INTEN_TXDRDY_POS       7
++
++#define UART_CONFIG_PARITY          0 // excluded
++#define UART_CONFIG_PARITY_POS      1
++#define UART_CONFIG_HWFC            0
++#define UART_CONFIG_HWFC_POS        0
++
++//=========================== variables =======================================
++
++typedef struct
++{
++   uart_tx_cbt txCb;
++   uart_rx_cbt rxCb;
++   bool        fXonXoffEscaping;
++   uint8_t     xonXoffEscapedByte;
++} uart_vars_t;
++
++uart_vars_t uart_vars;
++
++//=========================== prototypes ======================================
++
++//=========================== public ==========================================
++
++void uart_init(void) {
++    // reset local variables
++    memset(&uart_vars,0,sizeof(uart_vars_t));
++
++    NRF_P0->PIN_CNF[UART_TX_PIN] = ((uint32_t)GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos)
++                               | ((uint32_t)GPIO_PIN_CNF_INPUT_Disconnect << GPIO_PIN_CNF_INPUT_Pos)
++                               | ((uint32_t)GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
++                               | ((uint32_t)GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
++                               | ((uint32_t)GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos);
++    NRF_P0->PIN_CNF[UART_RX_PIN] = ((uint32_t)GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos)
++                               | ((uint32_t)GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
++                               | ((uint32_t)GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
++                               | ((uint32_t)GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
++                               | ((uint32_t)GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos);
++    
++    NRF_UART0->PSEL.TXD = UART_TX_PIN;
++    NRF_UART0->PSEL.RXD = UART_RX_PIN;
++
++    // default: stop 1 bit, no parity, no HWFC
++    NRF_UART0->CONFIG   = 0 ;
++    NRF_UART0->BAUDRATE = UART_BAUDRATE_115200;
++
++    NRF_UART0->EVENTS_TXDRDY      = 0;
++    NRF_UART0->EVENTS_RXDRDY      = 0;
++    NRF_UART0->INTENSET = (1 << UART_INTEN_RXDRDY_POS) |\
++                          (1 << UART_INTEN_TXDRDY_POS);
++
++    NVIC->IP[UARTE0_UART0_IRQn]         = (uint8_t)((UART_PRIORITY << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFF);
++    NVIC->ISER[UARTE0_UART0_IRQn>>5]    = (uint32_t)(0x1 << (UARTE0_UART0_IRQn & 0x1f));
++
++    NRF_UART0->ENABLE   = 4;  // set to 4 to enable
++
++    NRF_UART0->TASKS_STARTTX = 1;
++    NRF_UART0->TASKS_STARTRX = 1;
++}
++
++void uart_setCallbacks(uart_tx_cbt txCb, uart_rx_cbt rxCb) {
++    uart_vars.txCb = txCb;
++    uart_vars.rxCb = rxCb;
++}
++
++void    uart_enableInterrupts(void) {
++
++    NRF_UART0->INTENSET = 
++      (uint32_t)(1<<UART_INTEN_RXDRDY_POS)
++    | (uint32_t)(1<<UART_INTEN_TXDRDY_POS);
++}
++
++void    uart_clearRxInterrupts(void) {
++    
++    NRF_UART0->EVENTS_RXDRDY = (uint32_t)0;
++}
++
++void    uart_clearTxInterrupts(void) {
++    
++    NRF_UART0->EVENTS_TXDRDY = (uint32_t)0;
++}
++
++void uart_setCTS(bool state) {
++
++    if (state==0x01) {
++        NRF_UART0->TXD = XON;
++    } else {
++        NRF_UART0->TXD = XOFF;
++    }
++}
++
++void uart_writeByte(uint8_t byteToWrite){
++
++    if (byteToWrite==XON || byteToWrite==XOFF || byteToWrite==XONXOFF_ESCAPE) {
++        uart_vars.fXonXoffEscaping     = 0x01;
++        uart_vars.xonXoffEscapedByte   = byteToWrite;
++        NRF_UART0->TXD = XONXOFF_ESCAPE;
++    } else {
++        NRF_UART0->TXD = byteToWrite;
++    }
++}
++
++uint8_t uart_readByte(void) {
++    
++    return NRF_UART0->RXD;
++}
++
++//=========================== private =========================================
++
++void UARTE0_UART0_IRQHandler(void) {
++
++    debugpins_isr_set();
++
++    if (NRF_UART0->EVENTS_RXDRDY) {
++
++        NRF_UART0->EVENTS_RXDRDY = (uint32_t)0;
++        uart_rx_isr();
++    }
++
++    
++    if (NRF_UART0->EVENTS_TXDRDY) {
++        
++        NRF_UART0->EVENTS_TXDRDY = (uint32_t)0;
++        uart_tx_isr();
++    }
++
++    debugpins_isr_clr();
++}
++
++//=========================== interrupt handlers ==============================
++
++kick_scheduler_t uart_tx_isr(void) {
++    
++    if (uart_vars.fXonXoffEscaping==0x01) {
++        uart_vars.fXonXoffEscaping = 0x00;
++        NRF_UART0->TXD = uart_vars.xonXoffEscapedByte^XONXOFF_MASK;
++    } else {
++        if (uart_vars.txCb != NULL){
++            uart_vars.txCb();
++            return KICK_SCHEDULER;
++        }
++    }
++
++    return DO_NOT_KICK_SCHEDULER;
++}
++
++kick_scheduler_t uart_rx_isr(void) {
++
++    if (uart_vars.rxCb != NULL){
++        uart_vars.rxCb();
++        return KICK_SCHEDULER;
++    }
++
++    return DO_NOT_KICK_SCHEDULER;
++}
+\ No newline at end of file
diff --git a/bsp/boards/nrf52840_dk/radio.c b/bsp/boards/nrf52840_dk/radio.c
index 42831fac..4fa931df 100644
--- a/bsp/boards/nrf52840_dk/radio.c
+++ b/bsp/boards/nrf52840_dk/radio.c
@@ -468,6 +468,27 @@ static void hfclock_stop(void) {
     }
 }
 
+void float_to_char(float number, char *buffer, int decimal_digits) {
+    int whole_part = (int)number; // 整数部分
+    float decimal_part = number - whole_part; // 小数部分
+
+    // 将整数部分转换为char类型的数组
+    sprintf(buffer, "%d", whole_part);
+
+    // 定位到小数点的位置
+    int decimal_position = strlen(buffer);
+    buffer[decimal_position] = '.';
+
+    // 将小数部分转换为char类型的数组
+    for (int i = 1; i <= decimal_digits; i++) {
+        decimal_part *= 10;
+        int digit = (int)decimal_part;
+        buffer[decimal_position + i] = '0' + digit;
+        decimal_part -= digit;
+    }
+
+    buffer[decimal_position + decimal_digits + 1] = '\0'; // 添加字符串结束符
+}
 //=========================== callbacks =======================================
 
 
diff --git a/bsp/boards/nrf52840_dk/uart.c b/bsp/boards/nrf52840_dk/uart.c
index a80a3f20..3e63bece 100644
--- a/bsp/boards/nrf52840_dk/uart.c
+++ b/bsp/boards/nrf52840_dk/uart.c
@@ -12,7 +12,7 @@
 #include "leds.h"
 #include "debugpins.h"
 #include "uart.h"
-
+#include "stdio.h"
 //=========================== defines =========================================
 
 #define UART_RX_PIN       NRF_GPIO_PIN_MAP(0,8) // p0.08
@@ -130,6 +130,20 @@ uint8_t uart_readByte(void) {
     return NRF_UART0->RXD;
 }
 
+void uart_writeFloatByte(float dataToWrite){
+    
+    char buffer[50];  // make sure the buffer is large enough!
+
+    int length = sprintf(buffer, "%f", dataToWrite);  // convert float to string and get length
+
+    // Now, send the string over UART
+    for(int i=0; i<length; i++)
+    {
+        uart_writeByte(buffer[i]);  // assuming UART_send() is your function to send a byte over UART
+    }
+
+}
+
 //=========================== private =========================================
 
 void UARTE0_UART0_IRQHandler(void) {
diff --git a/bsp/boards/radio.h b/bsp/boards/radio.h
index df4333e8..f2196235 100644
--- a/bsp/boards/radio.h
+++ b/bsp/boards/radio.h
@@ -85,7 +85,7 @@ void                radio_getReceivedFrame(uint8_t* bufRead,
                                  int8_t* rssi,
                                 uint8_t* lqi,
                                    bool* crc);
-
+void float_to_char(float number, char *buffer, int decimal_digits);
 // interrupt handlers
 kick_scheduler_t    radio_isr(void);
 
diff --git a/bsp/boards/uart.h b/bsp/boards/uart.h
index 745c42d6..a4d60eb9 100644
--- a/bsp/boards/uart.h
+++ b/bsp/boards/uart.h
@@ -47,6 +47,7 @@ void    uart_clearRxInterrupts(void);
 void    uart_clearTxInterrupts(void);
 void    uart_setCTS(bool state);
 void    uart_writeByte(uint8_t byteToWrite);
+void    uart_writeFloatByte(float dataToWrite);
 #if BOARD_FASTSIM_ENABLED
 void    uart_writeCircularBuffer_FASTSIM(uint8_t* buffer, uint16_t* outputBufIdxR, uint16_t* outputBufIdxW);
 #endif
diff --git a/bsp/chips/bmx388/bmx388.c b/bsp/chips/bmx388/bmx388.c
index 213c9e84..e47fc9a3 100644
--- a/bsp/chips/bmx388/bmx388.c
+++ b/bsp/chips/bmx388/bmx388.c
@@ -145,6 +145,11 @@ void bmx160_read_9dof_data(void) {
     bmx388x_var.fullpres = (bmx388x_var.bmx388x_data.pres[2] << 16) | (bmx388x_var.bmx388x_data.pres[1] << 8) | bmx388x_var.bmx388x_data.pres[0];
 }
 
+float bmx388_read_t_fine(void){
+    
+    return bmx388x_var.t_fine;
+}
+
 
 //int16_t bmx160_read_acc_x(void) {
 
diff --git a/bsp/chips/bmx388/bmx388.h b/bsp/chips/bmx388/bmx388.h
index e3a55bda..b68c9269 100644
--- a/bsp/chips/bmx388/bmx388.h
+++ b/bsp/chips/bmx388/bmx388.h
@@ -92,5 +92,6 @@ void    bmx160_read_9dof_data(void);
 void    bmp388_get_compensation(void);
 
 void bmp388_compensation_temp(void);
+float bmx388_read_t_fine(void);
 
 //=========================== private =========================================
\ No newline at end of file
diff --git a/projects/common/01bsp_bmx388/01bsp_bmx388.c b/projects/common/01bsp_bmx388/01bsp_bmx388.c
index 6b383047..76e9453b 100644
--- a/projects/common/01bsp_bmx388/01bsp_bmx388.c
+++ b/projects/common/01bsp_bmx388/01bsp_bmx388.c
@@ -81,15 +81,15 @@ int mote_main(void) {
     bmx160_power_on();
     app_vars.pwr_status = bmx160_get_pwr_status();
 
-    // should be 0xd8 for bmx160
+    // should be 0x50 for bmx388
     app_vars.who_am_i = bmx388_who_am_i();
         
 
     while (1) {
 
-        //// wait for timer to elapse
-        //while (app_vars.uartSendNow==0);
-        //app_vars.uartSendNow = 0;
+        // wait for timer to elapse
+        while (app_vars.uartSendNow==0);
+        app_vars.uartSendNow = 0;
         //bmx160_set_cmd(BMX160_CMD_PMU_GYR_NORMAL);
 
         bmx160_read_9dof_data();
@@ -99,6 +99,8 @@ int mote_main(void) {
 
         bmp388_get_compensation();
         bmp388_compensation_temp();
+        app_vars.temp_f = bmx388_read_t_fine();
+
 
         //i=0;
         //tmp = bmx160_read_gyr_x();
@@ -116,10 +118,11 @@ int mote_main(void) {
         //app_vars.uartToSend[i++] = '\r';
         //app_vars.uartToSend[i++] = '\n';
 
-        //// send string over UART
-        //app_vars.uartDone              = 0;
-        //app_vars.uart_lastTxByteIndex  = 0;
+        // send string over UART
+        app_vars.uartDone              = 0;
+        app_vars.uart_lastTxByteIndex  = 0;
         //uart_writeByte(app_vars.uartToSend[app_vars.uart_lastTxByteIndex]);
+        //uart_writeFloatByte(app_vars.temp_f);
         //while(app_vars.uartDone==0);
         //app_vars.sensorTime = bmp388_get_sensortime();
     }
diff --git a/projects/common/01bsp_radio/01bsp_radio.c b/projects/common/01bsp_radio/01bsp_radio.c
index 554d7aa0..cb10a006 100644
--- a/projects/common/01bsp_radio/01bsp_radio.c
+++ b/projects/common/01bsp_radio/01bsp_radio.c
@@ -22,6 +22,12 @@ end of frame event), it will turn on its error LED.
 #include "leds.h"
 #include "sctimer.h"
 #include "uart.h"
+#include "i2c.h"
+#include "stdint.h"
+#include "string.h"
+#include "bmx388.h"
+#include "stdio.h"
+#include "math.h"
 
 //=========================== defines =========================================
 
@@ -29,7 +35,7 @@ end of frame event), it will turn on its error LED.
 #define LEN_PKT_TO_SEND 20+LENGTH_CRC
 #define CHANNEL         11             ///< 11=2.405GHz
 #define TIMER_PERIOD    (0xffff>>4)    ///< 0xffff = 2s@32kHz
-#define ID              0x99           ///< byte sent in the packets
+#define ID              0x55           ///< byte sent in the packets
 
 uint8_t stringToSend[]  = "+002 Ptest.24.00.12.-010\n";
 
@@ -69,6 +75,10 @@ typedef struct {
                 int8_t          rxpk_rssi;
                 uint8_t         rxpk_lqi;
                 bool            rxpk_crc;
+
+                uint8_t who_am_i;
+                float   temp_f;
+                char    temp_data[6];
 } app_vars_t;
 
 app_vars_t app_vars;
@@ -106,6 +116,13 @@ int mote_main(void) {
 
     app_vars.uartDone = 1;
 
+    // alway set address first
+    i2c_set_addr(BMX388_ADDR);
+    bmx160_power_on();
+
+    // should be 0x50 for bmx388
+    app_vars.who_am_i = bmx388_who_am_i();
+
     // add callback functions radio
     radio_setStartFrameCb(cb_startFrame);
     radio_setEndFrameCb(cb_endFrame);
@@ -140,6 +157,14 @@ int mote_main(void) {
             board_sleep();
         }
 
+        //read bmx388 data
+        bmx160_read_9dof_data();
+        bmp388_get_compensation();
+        bmp388_compensation_temp();
+        app_vars.temp_f = bmx388_read_t_fine();
+        float_to_char(app_vars.temp_f,app_vars.temp_data,4);
+
+
         // handle and clear every flag
         while (app_vars.flags) {
 
@@ -275,6 +300,8 @@ int mote_main(void) {
                     app_vars.packet[i++] = 's';
                     app_vars.packet[i++] = 't';
                     app_vars.packet[i++] = CHANNEL;
+                    memcpy(&app_vars.packet[i],&app_vars.temp_data[0],6);
+                    i=i+6;
                     while (i<app_vars.packet_len) {
                         app_vars.packet[i++] = ID;
                     }
diff --git a/projects/nrf52840_dk/01bsp_radio_Debug.jlink b/projects/nrf52840_dk/01bsp_radio_Debug.jlink
new file mode 100644
index 00000000..35ce3010
--- /dev/null
+++ b/projects/nrf52840_dk/01bsp_radio_Debug.jlink
@@ -0,0 +1,44 @@
+[BREAKPOINTS]
+ForceImpTypeAny = 0
+ShowInfoWin = 1
+EnableFlashBP = 2
+BPDuringExecution = 0
+[CFI]
+CFISize = 0x00
+CFIAddr = 0x00
+[CPU]
+MonModeVTableAddr = 0xFFFFFFFF
+MonModeDebug = 0
+MaxNumAPs = 0
+LowPowerHandlingMode = 0
+OverrideMemMap = 0
+AllowSimulation = 1
+ScriptFile=""
+[FLASH]
+RMWThreshold = 0x400
+Loaders=""
+EraseType = 0x00
+CacheExcludeSize = 0x00
+CacheExcludeAddr = 0x00
+MinNumBytesFlashDL = 0
+SkipProgOnCRCMatch = 1
+VerifyDownload = 1
+AllowCaching = 1
+EnableFlashDL = 2
+Override = 0
+Device="ARM7"
+[GENERAL]
+WorkRAMSize = 0x00
+WorkRAMAddr = 0x00
+RAMUsageLimit = 0x00
+[SWO]
+SWOLogFile=""
+[MEM]
+RdOverrideOrMask = 0x00
+RdOverrideAndMask = 0xFFFFFFFF
+RdOverrideAddr = 0xFFFFFFFF
+WrOverrideOrMask = 0x00
+WrOverrideAndMask = 0xFFFFFFFF
+WrOverrideAddr = 0xFFFFFFFF
+[RAM]
+VerifyDownload = 0x01
diff --git a/projects/nrf52840_dk/bmx388.c b/projects/nrf52840_dk/bmx388.c
new file mode 100644
index 00000000..e47fc9a3
--- /dev/null
+++ b/projects/nrf52840_dk/bmx388.c
@@ -0,0 +1,242 @@
+/**
+\brief bmx160 driver.
+
+\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
+*/
+
+#include "i2c.h"
+#include "bmx388.h"
+#include "math.h"
+
+//=========================== define ==========================================
+
+typedef struct{
+
+    //int16_t mag_x;
+    //int16_t mag_y;
+    //int16_t mag_z;
+
+    //int16_t rhall;
+
+    //int16_t gyr_x;
+    //int16_t gyr_y;
+    //int16_t gyr_z;
+
+    //int16_t acc_x;
+    //int16_t acc_y;
+    //int16_t acc_z;
+
+    uint8_t pres[3];
+    uint8_t temp[3];
+    
+}bmx388x_data_t;
+
+ //typedef struct bmp388_handle_s
+ //{                                                                  
+ //    uint16_t t1;                                                                        
+ //    uint16_t t2;                                                                        
+ //    int8_t t3;                                                                          
+ //    int16_t p1;                                                                         
+ //    int16_t p2;                                                                         
+ //    int8_t p3;                                                                          
+ //    int8_t p4;                                                                          
+ //    uint16_t p5;                                                                        
+ //    uint16_t p6;                                                                        
+ //    int8_t p7;                                                                          
+ //    int8_t p8;                                                                          
+ //    int16_t p9;                                                                         
+ //    int8_t p10;                                                                         
+ //    int8_t p11;                                                                         
+ //    int64_t t_fine;                                                                     
+ //} bmp388x_compensation_t;
+
+typedef struct {
+    
+    bmx388x_data_t bmx388x_data;
+        uint32_t fullpres;
+        uint32_t fulltemp;
+        uint32_t sen_time;
+        uint8_t res[21];
+        double  PAR_T[3];//3个温度修正系数
+	double  PAR_P[11];//11个气压修正系数
+        float   t_fine;
+
+}bmx388x_var_t;
+
+//=========================== variables =======================================
+
+bmx388x_var_t bmx388x_var;
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+// admin
+uint8_t bmx388_who_am_i(void) {
+
+    uint8_t chipid;
+    i2c_read_bytes(BMX160_REG_ADDR_CHIPID, &chipid, 1);
+    return chipid;
+}
+
+//void bmx160_config_wakeup(void) {
+    
+//}
+
+uint8_t bmx160_power_on(void) {
+    uint8_t pwr_cmd;
+    pwr_cmd = BMX160_CMD_PWR_CTRL;
+    i2c_write_bytes(BMX160_REG_ADDR_PWR_CTRL, &pwr_cmd,1);
+}
+
+uint8_t bmx160_get_pmu_status(void) {
+
+    uint8_t pmu_status;
+    i2c_read_bytes(BMX160_REG_ADDR_PMU_STATUS, &pmu_status, 1);
+    return pmu_status;
+}
+
+uint8_t bmx160_get_pwr_status(void) {
+
+    uint8_t pwr_status;
+    i2c_read_bytes(BMX160_REG_ADDR_PWR_CTRL, &pwr_status, 1);
+    return pwr_status;
+}
+
+
+void bmx160_set_cmd(uint8_t cmd) {
+    i2c_write_bytes(BMX160_REG_ADDR_PWR_CTRL, &cmd, 1);
+}
+
+//// configuration
+
+//void    bmx160_acc_config(uint8_t config) {
+//    i2c_write_bytes(BMX160_REG_ADDR_ACC_CONF, &config, 1);
+//}
+
+//void    bmx160_gyr_config(uint8_t config) {
+//    i2c_write_bytes(BMX160_REG_ADDR_GYR_CONF, &config, 1);
+//}
+
+//void    bmx160_mag_config(uint8_t config) {
+//    i2c_write_bytes(BMX160_REG_ADDR_MAG_CONF, &config, 1);
+//}
+
+//// range & interface
+
+//void    bmx160_acc_range(uint8_t range) {
+//    i2c_write_bytes(BMX160_REG_ADDR_ACC_RANGE, &range, 1);
+//}
+
+//void    bmx160_gyr_range(uint8_t range) {
+//    i2c_write_bytes(BMX160_REG_ADDR_GYR_RANGE, &range, 1);
+//}
+
+//void    bmx160_mag_if(uint8_t interface) {
+//    i2c_write_bytes(BMX160_REG_ADDR_MAG_IF, &interface, 1);
+//}
+
+
+// read
+void bmx160_read_9dof_data(void) {
+    i2c_read_bytes(BMX160_REG_ADDR_DATA, (uint8_t*)(&bmx388x_var.bmx388x_data), sizeof(bmx388x_data_t));
+    //i2c_read_bytes(BMX160_REG_ADDR_DATA, (uint8_t*)(&bmx388x_var.bmx388x_data), 1);
+    bmx388x_var.fulltemp = (bmx388x_var.bmx388x_data.temp[2] << 16) | (bmx388x_var.bmx388x_data.temp[1] << 8) | bmx388x_var.bmx388x_data.temp[0];
+    bmx388x_var.fullpres = (bmx388x_var.bmx388x_data.pres[2] << 16) | (bmx388x_var.bmx388x_data.pres[1] << 8) | bmx388x_var.bmx388x_data.pres[0];
+}
+
+float bmx388_read_t_fine(void){
+    
+    return bmx388x_var.t_fine;
+}
+
+
+//int16_t bmx160_read_acc_x(void) {
+
+//    return bmx160x_var.bmx160x_data.acc_x;
+//}
+//int16_t bmx160_read_acc_y(void) {
+    
+//    return bmx160x_var.bmx160x_data.acc_y;
+//}
+//int16_t bmx160_read_acc_z(void) {
+    
+//    return bmx160x_var.bmx160x_data.acc_z;
+//}
+
+//int16_t bmx160_read_mag_x(void) {
+    
+//    return bmx160x_var.bmx160x_data.mag_x;
+//}
+//int16_t bmx160_read_mag_y(void) {
+    
+//    return bmx160x_var.bmx160x_data.mag_y;
+//}
+//int16_t bmx160_read_mag_z(void) {
+    
+//    return bmx160x_var.bmx160x_data.mag_z;
+//}
+
+//int16_t bmx160_read_gyr_x(void) {
+    
+//    return bmx160x_var.bmx160x_data.gyr_x;
+//}
+//int16_t bmx160_read_gyr_y(void) {
+    
+//    return bmx160x_var.bmx160x_data.gyr_y;
+//}
+//int16_t bmx160_read_gyr_z(void) {
+    
+//    return bmx160x_var.bmx160x_data.gyr_z;
+//}
+
+ uint8_t bmp388_get_sensortime(void)
+ {
+     
+     i2c_read_bytes(BMX160_REG_ADDR_SENSORTIME, (uint8_t*)(&bmx388x_var.sen_time), sizeof(bmx388x_var.sen_time));
+
+     return 0;                                                                              /* success return 0 */
+ }
+ void bmp388_get_compensation(void)
+ {
+     i2c_read_bytes(BMX160_REG_ADDR_COMP,(uint8_t*)(&bmx388x_var.res[0]),sizeof(bmx388x_var.res));
+     bmx388x_var.PAR_T[0]=((bmx388x_var.res[1]<<8)|bmx388x_var.res[0])/pow(2,-8);
+     bmx388x_var.PAR_T[1]=((bmx388x_var.res[3]<<8)|bmx388x_var.res[2])/pow(2,30);
+     bmx388x_var.PAR_T[2]=(int8_t)bmx388x_var.res[4]/pow(2,48);//计算3个温度修正系数
+
+     bmx388x_var.PAR_P[0]=(((int16_t)((bmx388x_var.res[6]<<8)|bmx388x_var.res[5]))-pow(2,14))/pow(2,20);
+     bmx388x_var.PAR_P[1]=(((int16_t)((bmx388x_var.res[8]<<8)|bmx388x_var.res[7]))-pow(2,14))/pow(2,29);
+     bmx388x_var.PAR_P[2]=(int8_t)bmx388x_var.res[9]/pow(2,32);
+     bmx388x_var.PAR_P[3]=(int8_t)bmx388x_var.res[10]/pow(2,37);
+     bmx388x_var.PAR_P[4]=((bmx388x_var.res[12]<<8)|bmx388x_var.res[11])/pow(2,-3);
+     bmx388x_var.PAR_P[5]=((bmx388x_var.res[14]<<8)|bmx388x_var.res[13])/pow(2,6);
+     bmx388x_var.PAR_P[6]=(int8_t)bmx388x_var.res[15]/pow(2,8);
+     bmx388x_var.PAR_P[7]=(int8_t)bmx388x_var.res[16]/pow(2,15);
+     bmx388x_var.PAR_P[8]=(int16_t)((bmx388x_var.res[18]<<8)|bmx388x_var.res[17])/pow(2,48);
+     bmx388x_var.PAR_P[9]=(int8_t)bmx388x_var.res[19]/pow(2,48);
+     bmx388x_var.PAR_P[10]=(int8_t)bmx388x_var.res[20]/pow(2,65);//计算11个温度修正系数
+}
+
+void bmp388_compensation_temp(void)
+{
+    float partial_data1;
+    float partial_data2;
+
+    partial_data1 = (float)(bmx388x_var.fulltemp-bmx388x_var.PAR_T[0]);
+    partial_data2 = (float)(partial_data1*bmx388x_var.PAR_T[1]);
+
+    bmx388x_var.t_fine = partial_data2+(partial_data1*partial_data1)*bmx388x_var.PAR_T[2];
+
+}
+
+////=========================== helper ==========================================
+
+//float bmx160_from_lsb_to_celsius(int16_t lsb) {
+
+//}
+
+//float bmx160_from_fs8_lp1_to_mg(int16_t lsb) {
+
+//}
+
+////=========================== private =========================================
\ No newline at end of file
diff --git a/projects/nrf52840_dk/bmx388.h b/projects/nrf52840_dk/bmx388.h
new file mode 100644
index 00000000..b68c9269
--- /dev/null
+++ b/projects/nrf52840_dk/bmx388.h
@@ -0,0 +1,97 @@
+/**
+\brief registers address mapping of bmx160 sensor.
+
+\author Tengfei Chang <tengfei.chang@gmail.com>, Nov 2021.
+*/
+
+#include "stdint.h"
+
+//=========================== define ==========================================
+
+#define BMX388_ADDR 0x76
+
+//---- register addresses
+
+#define BMX160_REG_ADDR_CHIPID      0x00
+#define BMX160_REG_ADDR_ERR_REG     0x02
+#define BMX160_REG_ADDR_PMU_STATUS  0x03
+
+// sensor data
+
+#define BMX160_REG_ADDR_DATA        0x04
+#define BMX160_REG_ADDR_PRESURE     0x04
+#define BMX160_REG_ADDR_TEMPATURE   0x07
+#define BMX160_REG_ADDR_SENSORTIME  0x0C
+#define BMX160_REG_ADDR_EVENT       0x10
+#define BMX160_REG_ADDR_INT_STATUS  0x11
+#define BMX160_REG_ADDR_FIFO_LENGTH 0x12
+#define BMX160_REG_ADDR_FIFO_DATA   0x14
+#define BMX160_REG_ADDR_FIFO_WTM    0x15
+#define BMX160_REG_ADDR_FIFO_CONFIG1 0x17
+#define BMX160_REG_ADDR_FIFO_CONFIG2 0x18
+#define BMX160_REG_ADDR_INT_CTRL    0x19
+#define BMX160_REG_ADDR_INT_CONF    0x1A
+#define BMX160_REG_ADDR_PWR_CTRL    0x1B
+#define BMX160_REG_ADDR_OSR         0x1C
+#define BMX160_REG_ADDR_ODR         0x1D
+#define BMX160_REG_ADDR_COMP        0x31
+
+//---- register values
+
+//#define BMX160_CMD_PMU_ACC_SUSPEND        0x10
+//#define BMX160_CMD_PMU_ACC_NORMAL         0x11
+//#define BMX160_CMD_PMU_ACC_LOW_POWER      0x12
+
+//#define BMX160_CMD_PMU_GYR_SUSPEND        0x14
+//#define BMX160_CMD_PMU_GYR_NORMAL         0x15
+//#define BMX160_CMD_PMU_GYR_FSU            0x17
+
+//#define BMX160_CMD_PMU_MAG_IF_SUSPEND     0x18
+//#define BMX160_CMD_PMU_MAG_IF_NORMAL      0x19
+//#define BMX160_CMD_PMU_MAG_IF_LOW_POWER   0x1A
+#define BMX160_CMD_PWR_CTRL 0x33
+
+//=========================== variables =======================================
+
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+
+// admin
+uint8_t bmx388_who_am_i(void);
+uint8_t bmx160_power_on(void);
+uint8_t bmx160_get_pmu_status(void);
+uint8_t bmx160_get_pwr_status(void);
+uint8_t bmp388_get_sensortime(void);
+
+void    bmx160_set_cmd(uint8_t cmd);
+void    bmx160_acc_config(uint8_t config);
+void    bmx160_gyr_config(uint8_t config);
+void    bmx160_mag_config(uint8_t config);
+
+void    bmx160_acc_range(uint8_t range);
+void    bmx160_gyr_range(uint8_t range);
+void    bmx160_mag_if(uint8_t interface);
+
+// read
+int16_t bmx160_read_temperature(void);
+
+int16_t bmx160_read_acc_x(void);
+int16_t bmx160_read_acc_y(void);
+int16_t bmx160_read_acc_z(void);
+
+int16_t bmx160_read_mag_x(void);
+int16_t bmx160_read_mag_y(void);
+int16_t bmx160_read_mag_z(void);
+
+int16_t bmx160_read_gyr_x(void);
+int16_t bmx160_read_gyr_y(void);
+int16_t bmx160_read_gyr_z(void);
+
+void    bmx160_read_9dof_data(void);
+void    bmp388_get_compensation(void);
+
+void bmp388_compensation_temp(void);
+float bmx388_read_t_fine(void);
+
+//=========================== private =========================================
\ No newline at end of file
diff --git a/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz-3.emSession b/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz-3.emSession
new file mode 100644
index 00000000..a44e46f7
--- /dev/null
+++ b/projects/nrf52840_dk/nrf52840_dk-Imon_hkustgz-3.emSession
@@ -0,0 +1,136 @@
+<!DOCTYPE CrossStudio_Session_File>
+<session>
+ <Bookmarks/>
+ <Breakpoints groups="Breakpoints" active_group="Breakpoints">
+  <BreakpointListItem trigger="" line="102" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_bmx388/01bsp_bmx388.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="98" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_bmx388/01bsp_bmx388.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="48" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_sctimer/01bsp_sctimer.c" useHWbreakpoint="false"/>
+  <Exceptions set="MemManage;UsageFault_Coprocessor;UsageFault_CheckingError;UsageFault_StateError;BusFault;ExceptionEntryReturnFault;HardFault"/>
+ </Breakpoints>
+ <ExecutionProfileWindow/>
+ <FrameBuffer>
+  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_leds_Debug" addressText="" accessByDisplayWidth="0"/>
+  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_sctimer_Debug" addressText="" accessByDisplayWidth="0"/>
+  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_uart_Debug" addressText="" accessByDisplayWidth="0"/>
+  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_bmx160_Debug" addressText="" accessByDisplayWidth="0"/>
+  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_i2c_Debug" addressText="" accessByDisplayWidth="0"/>
+  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_bmx388_Debug" addressText="" accessByDisplayWidth="0"/>
+ </FrameBuffer>
+ <Memory1>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+ </Memory1>
+ <Memory2>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+ </Memory2>
+ <Memory3>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+ </Memory3>
+ <Memory4>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_sctimer_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_uart_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+ </Memory4>
+ <Project>
+  <ProjectSessionItem path="nrf52840-dk"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;application"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp;sdk"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;chips"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;application"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;bsp"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;bsp;sdk"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;chips"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;inc"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_eui64"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_eui64;application"/>
+ </Project>
+ <Register1>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+ </Register1>
+ <Register2>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+ </Register2>
+ <Register3>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+ </Register3>
+ <Register4>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_sctimer_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_uart_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+ </Register4>
+ <Threads>
+  <ThreadsWindow showLists=""/>
+ </Threads>
+ <TraceWindow>
+  <Trace enabled="Yes"/>
+ </TraceWindow>
+ <Watch1>
+  <Watches active="1" update="Never">
+   <Watchpoint expression="counter_current" name="counter_current" radix="16" linenumber="149" filename="../common/01bsp_leds/01bsp_leds.c"/>
+   <Watchpoint expression="timerflag" name="timerflag" radix="-1" linenumber="63" filename="../common/01bsp_leds/01bsp_leds.c"/>
+   <Watchpoint expression="app_vars" name="app_vars" radix="-1" linenumber="43" filename="../common/01bsp_i2c/01bsp_i2c.c"/>
+   <Watchpoint expression="stasus" name="stasus" radix="-1" linenumber="100" filename="../common/01bsp_bmx388/01bsp_bmx388.c"/>
+   <Watchpoint expression="bmx388x_var" name="bmx388x_var" radix="-1" linenumber="139" filename="../../bsp/chips/bmx388/bmx388.c"/>
+   <Watchpoint expression="pwr_status" name="pwr_status" radix="-1" linenumber="83" filename="../common/01bsp_bmx388/01bsp_bmx388.c"/>
+  </Watches>
+ </Watch1>
+ <Watch2>
+  <Watches active="0" update="Never"/>
+ </Watch2>
+ <Watch3>
+  <Watches active="0" update="Never"/>
+ </Watch3>
+ <Watch4>
+  <Watches active="0" update="Never"/>
+ </Watch4>
+ <Files>
+  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="147" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/common/01bsp_bmx388/01bsp_bmx388.c" path="../../bsp/chips/bmx388/bmx388.c" left="0" top="127" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="24" y="94" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/common/01bsp_bmx388/01bsp_bmx388.c" path="../../bsp/chips/bmx388/bmx388.h" left="0" top="78" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="28" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/board.c" left="0" selected="1" top="81" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="127" useTextEdit="1" path="../common/01bsp_bmx388/01bsp_bmx388.c" left="0" top="104" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="29" y="146" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/bsp/chips/bmx388/bmx388.c" path="../../bsp/boards/nrf52840_dk/i2c.c" left="0" top="130" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="71" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/sdk/ses_startup_nrf52840.s" left="0" top="54" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="18" y="14" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/uart.c" left="0" top="14" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="8" y="49" useTextEdit="1" path="../../bsp/boards/uart.h" left="0" top="27" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="292" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/sdk/thumb_crt0.s" left="0" top="277" codecName="Default"/>
+ </Files>
+ <EMStudioWindow activeProject="01bsp_bmx388" fileDialogDefaultFilter="*.emProject" autoConnectTarget="J-Link" buildConfiguration="Debug" sessionSettings="" debugSearchFileMap="" fileDialogInitialDirectory="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/nrf52840_dk" debugSearchPath="" autoConnectCapabilities="3711"/>
+</session>
diff --git a/projects/nrf52840_dk/nrf52840_dk.emProject b/projects/nrf52840_dk/nrf52840_dk.emProject
index 131c2023..519bd786 100644
--- a/projects/nrf52840_dk/nrf52840_dk.emProject
+++ b/projects/nrf52840_dk/nrf52840_dk.emProject
@@ -404,6 +404,10 @@
       macros=""
       project_directory=""
       project_type="Executable" />
+    <configuration
+      Name="Debug"
+      c_include_files=""
+      c_user_include_directories="../../bsp/chips/bmx388" />
     <folder
       Name="application"
       exclude=""
@@ -416,6 +420,12 @@
       filter="*.s;*.c;*.h"
       path="../../bsp/boards/nrf52840_dk"
       recurse="Yes" />
+    <folder
+      Name="chip"
+      exclude=""
+      filter=""
+      path="D:\Courses\HKUSTgz\23FALL\IOTA5109\openwsn-IOTA5109\bsp\chips\bmx388"
+      recurse="No" />
     <folder
       Name="inc"
       exclude=""
diff --git a/projects/nrf52840_dk/nrf52840_dk.emSession b/projects/nrf52840_dk/nrf52840_dk.emSession
index f7947fa0..eb324159 100644
--- a/projects/nrf52840_dk/nrf52840_dk.emSession
+++ b/projects/nrf52840_dk/nrf52840_dk.emSession
@@ -2,10 +2,15 @@
 <session>
  <Bookmarks/>
  <Breakpoints groups="Breakpoints" active_group="Breakpoints">
-  <BreakpointListItem trigger="" line="101" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_bmx388/01bsp_bmx388.c" useHWbreakpoint="false"/>
-  <BreakpointListItem trigger="" line="98" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_bmx388/01bsp_bmx388.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="88" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_bmx388/01bsp_bmx388.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="169" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_radio/01bsp_radio.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="209" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_radio/01bsp_radio.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="232" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_radio/01bsp_radio.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="237" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_radio/01bsp_radio.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="242" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_radio/01bsp_radio.c" useHWbreakpoint="false"/>
+  <BreakpointListItem trigger="" line="253" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="2" filename="../common/01bsp_radio/01bsp_radio.c" useHWbreakpoint="false"/>
   <BreakpointListItem trigger="" line="48" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../common/01bsp_sctimer/01bsp_sctimer.c" useHWbreakpoint="false"/>
-  <Exceptions set="MemManage;UsageFault_Coprocessor;UsageFault_CheckingError;UsageFault_StateError;BusFault;ExceptionEntryReturnFault;HardFault"/>
+  <BreakpointListItem trigger="" line="192" counter="0" hardwareBreakpoint="" isFunctionBreakpoint="false" action="" expression="" group="Breakpoints" type="Breakpoint" state="4" filename="../../bsp/chips/bmx388/bmx388.c" useHWbreakpoint="false"/>
  </Breakpoints>
  <ExecutionProfileWindow/>
  <FrameBuffer>
@@ -15,6 +20,7 @@
   <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_bmx160_Debug" addressText="" accessByDisplayWidth="0"/>
   <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_i2c_Debug" addressText="" accessByDisplayWidth="0"/>
   <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_bmx388_Debug" addressText="" accessByDisplayWidth="0"/>
+  <FrameBufferWindow width="16843009" keepAspectRatio="0" zoomToFitWindow="0" addressSpace="" format="0" height="16843009" autoEvaluate="0" scaleFactor="1" refreshPeriod="0" name="01bsp_radio_Debug" addressText="" accessByDisplayWidth="0"/>
  </FrameBuffer>
  <Memory1>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
@@ -23,6 +29,7 @@
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_radio_Debug" sizeText="" addressText=""/>
  </Memory1>
  <Memory2>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
@@ -31,6 +38,7 @@
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_radio_Debug" sizeText="" addressText=""/>
  </Memory2>
  <Memory3>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
@@ -39,6 +47,7 @@
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_radio_Debug" sizeText="" addressText=""/>
  </Memory3>
  <Memory4>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_leds_Debug" sizeText="" addressText=""/>
@@ -47,22 +56,21 @@
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx160_Debug" sizeText="" addressText=""/>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_i2c_Debug" sizeText="" addressText=""/>
   <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_bmx388_Debug" sizeText="" addressText=""/>
+  <MemoryWindow addressSpace="" dataSize="1" autoEvaluate="0" viewMode="0" viewType="4" addressOrder="0" columnsText="" refreshPeriod="0" name="01bsp_radio_Debug" sizeText="" addressText=""/>
  </Memory4>
  <Project>
   <ProjectSessionItem path="nrf52840-dk"/>
-  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160"/>
-  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;application"/>
-  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp"/>
-  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;bsp;sdk"/>
-  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx160;chips"/>
   <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388"/>
   <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;application"/>
   <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;bsp"/>
-  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;bsp;sdk"/>
   <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;chips"/>
-  <ProjectSessionItem path="nrf52840-dk;01bsp_bmx388;inc"/>
   <ProjectSessionItem path="nrf52840-dk;01bsp_eui64"/>
   <ProjectSessionItem path="nrf52840-dk;01bsp_eui64;application"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_radio"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_radio;application"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_radio;bsp"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_radio;chip"/>
+  <ProjectSessionItem path="nrf52840-dk;01bsp_radio;inc"/>
  </Project>
  <Register1>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
@@ -71,6 +79,7 @@
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_radio_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
  </Register1>
  <Register2>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
@@ -79,6 +88,7 @@
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_radio_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
  </Register2>
  <Register3>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
@@ -87,6 +97,7 @@
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_radio_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
  </Register3>
  <Register4>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_leds_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
@@ -95,6 +106,7 @@
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx160_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_i2c_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
   <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_bmx388_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
+  <RegisterWindow visibleNodes="CPU - Current Context/r0;CPU - Current Context/r1;CPU - Current Context/r2;CPU - Current Context/r3;CPU - Current Context/r4;CPU - Current Context/r5;CPU - Current Context/r6;CPU - Current Context/r7;CPU - Current Context/r8;CPU - Current Context/r9;CPU - Current Context/r10;CPU - Current Context/r11;CPU - Current Context/r12;CPU - Current Context/sp(r13);CPU - Current Context/lr(r14);CPU - Current Context/pc(r15);CPU - Current Context/apsr;CPU/r0;CPU/r1;CPU/r2;CPU/r3;CPU/r4;CPU/r5;CPU/r6;CPU/r7;CPU/r8;CPU/r9;CPU/r10;CPU/r11;CPU/r12;CPU/sp(r13);CPU/lr(r14);CPU/pc(r15);CPU/xpsr;CPU/MSP;CPU/PSP;CPU/PRIMASK;CPU/BASEPRI;CPU/FAULTMASK;CPU/CONTROL;CPU/internal" binaryNodes="" asciiNodes="" openNodes="CPU - Current Context" name="01bsp_radio_Debug" decimalNodes="" octalNodes="" unsignedNodes=""/>
  </Register4>
  <Threads>
   <ThreadsWindow showLists=""/>
@@ -107,9 +119,12 @@
    <Watchpoint expression="counter_current" name="counter_current" radix="16" linenumber="149" filename="../common/01bsp_leds/01bsp_leds.c"/>
    <Watchpoint expression="timerflag" name="timerflag" radix="-1" linenumber="63" filename="../common/01bsp_leds/01bsp_leds.c"/>
    <Watchpoint expression="app_vars" name="app_vars" radix="-1" linenumber="43" filename="../common/01bsp_i2c/01bsp_i2c.c"/>
-   <Watchpoint expression="stasus" name="stasus" radix="-1" linenumber="100" filename="../common/01bsp_bmx388/01bsp_bmx388.c"/>
-   <Watchpoint expression="bmx388x_var" name="bmx388x_var" radix="-1" linenumber="139" filename="../../bsp/chips/bmx388/bmx388.c"/>
-   <Watchpoint expression="pwr_status" name="pwr_status" radix="-1" linenumber="83" filename="../common/01bsp_bmx388/01bsp_bmx388.c"/>
+   <Watchpoint expression="stasus" name="stasus" radix="-1" linenumber="101" filename="../common/01bsp_bmx388/01bsp_bmx388.c"/>
+   <Watchpoint expression="bmx388x_var" name="bmx388x_var" radix="-1" linenumber="143" filename="../../bsp/chips/bmx388/bmx388.c"/>
+   <Watchpoint expression="pwr_status" name="pwr_status" radix="-1" linenumber="82" filename="../common/01bsp_bmx388/01bsp_bmx388.c"/>
+   <Watchpoint expression="stringToSend" name="stringToSend" radix="-1" linenumber="254" filename="../common/01bsp_radio/01bsp_radio.c"/>
+   <Watchpoint expression="str" name="str" radix="-1" linenumber="167" filename="../common/01bsp_radio/01bsp_radio.c"/>
+   <Watchpoint expression="buffer" name="buffer" radix="-1" linenumber="168" filename="../common/01bsp_radio/01bsp_radio.c"/>
   </Watches>
  </Watch1>
  <Watch2>
@@ -122,12 +137,11 @@
   <Watches active="0" update="Never"/>
  </Watch4>
  <Files>
-  <SessionOpenFile windowGroup="DockEditLeft" x="80" y="222" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/common/01bsp_bmx388/01bsp_bmx388.c" path="../../bsp/chips/bmx388/bmx388.c" left="0" top="213" codecName="Default"/>
-  <SessionOpenFile windowGroup="DockEditLeft" x="27" y="51" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/common/01bsp_bmx388/01bsp_bmx388.c" path="../../bsp/chips/bmx388/bmx388.h" left="0" top="29" codecName="Default"/>
-  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="29" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/board.c" left="0" top="12" codecName="Default"/>
-  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="97" useTextEdit="1" path="../common/01bsp_bmx388/01bsp_bmx388.c" left="0" selected="1" top="90" codecName="Default"/>
-  <SessionOpenFile windowGroup="DockEditLeft" x="29" y="146" useTextEdit="1" openedFrom="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/bsp/chips/bmx388/bmx388.c" path="../../bsp/boards/nrf52840_dk/i2c.c" left="0" top="130" codecName="Default"/>
-  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="71" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/sdk/ses_startup_nrf52840.s" left="0" top="54" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="41" y="66" useTextEdit="1" folds0="49,54" path="../common/01bsp_radio/01bsp_radio.c" left="0" selected="1" top="19" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="29" useTextEdit="1" path="../../bsp/boards/nrf52840_dk/board.c" left="0" top="17" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="67" y="87" useTextEdit="1" openedFrom="D:/OneDrive - HKUST (Guangzhou)/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/bsp/boards/nrf52840_dk/radio.c" path="../../bsp/boards/radio.h" left="0" top="33" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="470" useTextEdit="1" openedFrom="D:/OneDrive - HKUST (Guangzhou)/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/common/01bsp_radio/01bsp_radio.c" path="../../bsp/boards/nrf52840_dk/radio.c" left="0" top="446" codecName="Default"/>
+  <SessionOpenFile windowGroup="DockEditLeft" x="0" y="0" useTextEdit="1" path="../../bsp/chips/bmx388/bmx388.h" left="0" top="0" codecName="Default"/>
  </Files>
- <EMStudioWindow activeProject="01bsp_bmx388" fileDialogDefaultFilter="*.emProject" autoConnectTarget="J-Link" buildConfiguration="Debug" sessionSettings="" debugSearchFileMap="" fileDialogInitialDirectory="D:/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/projects/nrf52840_dk" debugSearchPath="" autoConnectCapabilities="3711"/>
+ <EMStudioWindow activeProject="01bsp_radio" fileDialogDefaultFilter="*.c;*.h" autoConnectTarget="J-Link" buildConfiguration="Debug" sessionSettings="" debugSearchFileMap="" fileDialogInitialDirectory="D:/OneDrive - HKUST (Guangzhou)/Courses/HKUSTgz/23FALL/IOTA5109/openwsn-IOTA5109/bsp/chips/bmx388" debugSearchPath="" autoConnectCapabilities="3711"/>
 </session>
